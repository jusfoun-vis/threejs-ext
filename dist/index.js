/*!
 * The three.js expansion library v0.92.0
 * Collected by Jusfoun Visualization Department
 * Contact: 
 *   vis@jusfoun.com
 *   http://vis.jusfoun.com
 *   http://jusfoun-vis.github.io
 * 
 * Copyright (c) 2018, Jusfoun Big Data Group Inc.
 * All rights reserved.
 * 
 * LICENSE
 * http://www.jusfoun.com/software/LICENSE.txt
 * 
 * The three.js LICENSE
 * http://threejs.org/license
 */
(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 27);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("three");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @author alteredq / http://alteredqualia.com/
 */
var Pass = function Pass() {

  // if set to true, the pass is processed by the composer
  this.enabled = true;

  // if set to true, the pass indicates to swap read and write buffer after rendering
  this.needsSwap = true;

  // if set to true, the pass clears its buffer before rendering
  this.clear = false;

  // if set to true, the result of the pass is rendered to screen
  this.renderToScreen = false;
};

Object.assign(Pass.prototype, {

  setSize: function setSize(width, height) {},

  render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

    console.error('THREE.Pass: .render() must be implemented in derived pass.');
  }

});

exports.default = Pass;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Full-screen textured quad shader
 */

var CopyShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"opacity": { value: 1.0 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "gl_FragColor = opacity * texel;", "}"].join("\n")

};

exports.default = CopyShader;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _Pass = __webpack_require__(1);

var _Pass2 = _interopRequireDefault(_Pass);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author alteredq / http://alteredqualia.com/
 */

var ShaderPass = function ShaderPass(shader, textureID) {

	_Pass2.default.call(this);

	this.textureID = textureID !== undefined ? textureID : "tDiffuse";

	if (shader instanceof THREE.ShaderMaterial) {

		this.uniforms = shader.uniforms;

		this.material = shader;
	} else if (shader) {

		this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);

		this.material = new THREE.ShaderMaterial({

			defines: Object.assign({}, shader.defines),
			uniforms: this.uniforms,
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader

		});
	}

	this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
	this.scene = new THREE.Scene();

	this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
	this.quad.frustumCulled = false; // Avoid getting clipped
	this.scene.add(this.quad);
};

ShaderPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {

	constructor: ShaderPass,

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		if (this.uniforms[this.textureID]) {

			this.uniforms[this.textureID].value = readBuffer.texture;
		}

		this.quad.material = this.material;

		if (this.renderToScreen) {

			renderer.render(this.scene, this.camera);
		} else {

			renderer.render(this.scene, this.camera, writeBuffer, this.clear);
		}
	}

});

exports.default = ShaderPass;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
   true ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.MMDParser = global.MMDParser || {})));
}(this, (function (exports) { 'use strict';

/**
 * @author Takahiro / https://github.com/takahirox
 *
 * Simple CharsetEncoder.
 */

function CharsetEncoder() {
}

/*
 * Converts from Shift_JIS Uint8Array data to Unicode strings.
 */
CharsetEncoder.prototype.s2u = function(uint8Array) {
  var t = this.s2uTable;
  var str = '';
  var p = 0;

  while(p < uint8Array.length) {
    var key = uint8Array[p++];

    if(! ((key >= 0x00 && key <= 0x7e) ||
          (key >= 0xa1 && key <= 0xdf)) &&
       p < uint8Array.length) {
      key = (key << 8) | uint8Array[p++];
    }

    if(t[key] === undefined) {
      throw 'unknown char code ' + key + '.';
    }

    str += String.fromCharCode(t[key]);
  }

  return str;
};

CharsetEncoder.prototype.s2uTable = {
0:0,
1:1,
2:2,
3:3,
4:4,
5:5,
6:6,
7:7,
8:8,
9:9,
10:10,
11:11,
12:12,
13:13,
14:14,
15:15,
16:16,
17:17,
18:18,
19:19,
20:20,
21:21,
22:22,
23:23,
24:24,
25:25,
26:26,
27:27,
28:28,
29:29,
30:30,
31:31,
32:32,
33:33,
34:34,
35:35,
36:36,
37:37,
38:38,
39:39,
40:40,
41:41,
42:42,
43:43,
44:44,
45:45,
46:46,
47:47,
48:48,
49:49,
50:50,
51:51,
52:52,
53:53,
54:54,
55:55,
56:56,
57:57,
58:58,
59:59,
60:60,
61:61,
62:62,
63:63,
64:64,
65:65,
66:66,
67:67,
68:68,
69:69,
70:70,
71:71,
72:72,
73:73,
74:74,
75:75,
76:76,
77:77,
78:78,
79:79,
80:80,
81:81,
82:82,
83:83,
84:84,
85:85,
86:86,
87:87,
88:88,
89:89,
90:90,
91:91,
92:92,
93:93,
94:94,
95:95,
96:96,
97:97,
98:98,
99:99,
100:100,
101:101,
102:102,
103:103,
104:104,
105:105,
106:106,
107:107,
108:108,
109:109,
110:110,
111:111,
112:112,
113:113,
114:114,
115:115,
116:116,
117:117,
118:118,
119:119,
120:120,
121:121,
122:122,
123:123,
124:124,
125:125,
126:126,
161:65377,
162:65378,
163:65379,
164:65380,
165:65381,
166:65382,
167:65383,
168:65384,
169:65385,
170:65386,
171:65387,
172:65388,
173:65389,
174:65390,
175:65391,
176:65392,
177:65393,
178:65394,
179:65395,
180:65396,
181:65397,
182:65398,
183:65399,
184:65400,
185:65401,
186:65402,
187:65403,
188:65404,
189:65405,
190:65406,
191:65407,
192:65408,
193:65409,
194:65410,
195:65411,
196:65412,
197:65413,
198:65414,
199:65415,
200:65416,
201:65417,
202:65418,
203:65419,
204:65420,
205:65421,
206:65422,
207:65423,
208:65424,
209:65425,
210:65426,
211:65427,
212:65428,
213:65429,
214:65430,
215:65431,
216:65432,
217:65433,
218:65434,
219:65435,
220:65436,
221:65437,
222:65438,
223:65439,
33088:12288,
33089:12289,
33090:12290,
33091:65292,
33092:65294,
33093:12539,
33094:65306,
33095:65307,
33096:65311,
33097:65281,
33098:12443,
33099:12444,
33100:180,
33101:65344,
33102:168,
33103:65342,
33104:65507,
33105:65343,
33106:12541,
33107:12542,
33108:12445,
33109:12446,
33110:12291,
33111:20189,
33112:12293,
33113:12294,
33114:12295,
33115:12540,
33116:8213,
33117:8208,
33118:65295,
33119:65340,
33120:65374,
33121:8741,
33122:65372,
33123:8230,
33124:8229,
33125:8216,
33126:8217,
33127:8220,
33128:8221,
33129:65288,
33130:65289,
33131:12308,
33132:12309,
33133:65339,
33134:65341,
33135:65371,
33136:65373,
33137:12296,
33138:12297,
33139:12298,
33140:12299,
33141:12300,
33142:12301,
33143:12302,
33144:12303,
33145:12304,
33146:12305,
33147:65291,
33148:65293,
33149:177,
33150:215,
33152:247,
33153:65309,
33154:8800,
33155:65308,
33156:65310,
33157:8806,
33158:8807,
33159:8734,
33160:8756,
33161:9794,
33162:9792,
33163:176,
33164:8242,
33165:8243,
33166:8451,
33167:65509,
33168:65284,
33169:65504,
33170:65505,
33171:65285,
33172:65283,
33173:65286,
33174:65290,
33175:65312,
33176:167,
33177:9734,
33178:9733,
33179:9675,
33180:9679,
33181:9678,
33182:9671,
33183:9670,
33184:9633,
33185:9632,
33186:9651,
33187:9650,
33188:9661,
33189:9660,
33190:8251,
33191:12306,
33192:8594,
33193:8592,
33194:8593,
33195:8595,
33196:12307,
33208:8712,
33209:8715,
33210:8838,
33211:8839,
33212:8834,
33213:8835,
33214:8746,
33215:8745,
33224:8743,
33225:8744,
33226:65506,
33227:8658,
33228:8660,
33229:8704,
33230:8707,
33242:8736,
33243:8869,
33244:8978,
33245:8706,
33246:8711,
33247:8801,
33248:8786,
33249:8810,
33250:8811,
33251:8730,
33252:8765,
33253:8733,
33254:8757,
33255:8747,
33256:8748,
33264:8491,
33265:8240,
33266:9839,
33267:9837,
33268:9834,
33269:8224,
33270:8225,
33271:182,
33276:9711,
33359:65296,
33360:65297,
33361:65298,
33362:65299,
33363:65300,
33364:65301,
33365:65302,
33366:65303,
33367:65304,
33368:65305,
33376:65313,
33377:65314,
33378:65315,
33379:65316,
33380:65317,
33381:65318,
33382:65319,
33383:65320,
33384:65321,
33385:65322,
33386:65323,
33387:65324,
33388:65325,
33389:65326,
33390:65327,
33391:65328,
33392:65329,
33393:65330,
33394:65331,
33395:65332,
33396:65333,
33397:65334,
33398:65335,
33399:65336,
33400:65337,
33401:65338,
33409:65345,
33410:65346,
33411:65347,
33412:65348,
33413:65349,
33414:65350,
33415:65351,
33416:65352,
33417:65353,
33418:65354,
33419:65355,
33420:65356,
33421:65357,
33422:65358,
33423:65359,
33424:65360,
33425:65361,
33426:65362,
33427:65363,
33428:65364,
33429:65365,
33430:65366,
33431:65367,
33432:65368,
33433:65369,
33434:65370,
33439:12353,
33440:12354,
33441:12355,
33442:12356,
33443:12357,
33444:12358,
33445:12359,
33446:12360,
33447:12361,
33448:12362,
33449:12363,
33450:12364,
33451:12365,
33452:12366,
33453:12367,
33454:12368,
33455:12369,
33456:12370,
33457:12371,
33458:12372,
33459:12373,
33460:12374,
33461:12375,
33462:12376,
33463:12377,
33464:12378,
33465:12379,
33466:12380,
33467:12381,
33468:12382,
33469:12383,
33470:12384,
33471:12385,
33472:12386,
33473:12387,
33474:12388,
33475:12389,
33476:12390,
33477:12391,
33478:12392,
33479:12393,
33480:12394,
33481:12395,
33482:12396,
33483:12397,
33484:12398,
33485:12399,
33486:12400,
33487:12401,
33488:12402,
33489:12403,
33490:12404,
33491:12405,
33492:12406,
33493:12407,
33494:12408,
33495:12409,
33496:12410,
33497:12411,
33498:12412,
33499:12413,
33500:12414,
33501:12415,
33502:12416,
33503:12417,
33504:12418,
33505:12419,
33506:12420,
33507:12421,
33508:12422,
33509:12423,
33510:12424,
33511:12425,
33512:12426,
33513:12427,
33514:12428,
33515:12429,
33516:12430,
33517:12431,
33518:12432,
33519:12433,
33520:12434,
33521:12435,
33600:12449,
33601:12450,
33602:12451,
33603:12452,
33604:12453,
33605:12454,
33606:12455,
33607:12456,
33608:12457,
33609:12458,
33610:12459,
33611:12460,
33612:12461,
33613:12462,
33614:12463,
33615:12464,
33616:12465,
33617:12466,
33618:12467,
33619:12468,
33620:12469,
33621:12470,
33622:12471,
33623:12472,
33624:12473,
33625:12474,
33626:12475,
33627:12476,
33628:12477,
33629:12478,
33630:12479,
33631:12480,
33632:12481,
33633:12482,
33634:12483,
33635:12484,
33636:12485,
33637:12486,
33638:12487,
33639:12488,
33640:12489,
33641:12490,
33642:12491,
33643:12492,
33644:12493,
33645:12494,
33646:12495,
33647:12496,
33648:12497,
33649:12498,
33650:12499,
33651:12500,
33652:12501,
33653:12502,
33654:12503,
33655:12504,
33656:12505,
33657:12506,
33658:12507,
33659:12508,
33660:12509,
33661:12510,
33662:12511,
33664:12512,
33665:12513,
33666:12514,
33667:12515,
33668:12516,
33669:12517,
33670:12518,
33671:12519,
33672:12520,
33673:12521,
33674:12522,
33675:12523,
33676:12524,
33677:12525,
33678:12526,
33679:12527,
33680:12528,
33681:12529,
33682:12530,
33683:12531,
33684:12532,
33685:12533,
33686:12534,
33695:913,
33696:914,
33697:915,
33698:916,
33699:917,
33700:918,
33701:919,
33702:920,
33703:921,
33704:922,
33705:923,
33706:924,
33707:925,
33708:926,
33709:927,
33710:928,
33711:929,
33712:931,
33713:932,
33714:933,
33715:934,
33716:935,
33717:936,
33718:937,
33727:945,
33728:946,
33729:947,
33730:948,
33731:949,
33732:950,
33733:951,
33734:952,
33735:953,
33736:954,
33737:955,
33738:956,
33739:957,
33740:958,
33741:959,
33742:960,
33743:961,
33744:963,
33745:964,
33746:965,
33747:966,
33748:967,
33749:968,
33750:969,
33856:1040,
33857:1041,
33858:1042,
33859:1043,
33860:1044,
33861:1045,
33862:1025,
33863:1046,
33864:1047,
33865:1048,
33866:1049,
33867:1050,
33868:1051,
33869:1052,
33870:1053,
33871:1054,
33872:1055,
33873:1056,
33874:1057,
33875:1058,
33876:1059,
33877:1060,
33878:1061,
33879:1062,
33880:1063,
33881:1064,
33882:1065,
33883:1066,
33884:1067,
33885:1068,
33886:1069,
33887:1070,
33888:1071,
33904:1072,
33905:1073,
33906:1074,
33907:1075,
33908:1076,
33909:1077,
33910:1105,
33911:1078,
33912:1079,
33913:1080,
33914:1081,
33915:1082,
33916:1083,
33917:1084,
33918:1085,
33920:1086,
33921:1087,
33922:1088,
33923:1089,
33924:1090,
33925:1091,
33926:1092,
33927:1093,
33928:1094,
33929:1095,
33930:1096,
33931:1097,
33932:1098,
33933:1099,
33934:1100,
33935:1101,
33936:1102,
33937:1103,
33951:9472,
33952:9474,
33953:9484,
33954:9488,
33955:9496,
33956:9492,
33957:9500,
33958:9516,
33959:9508,
33960:9524,
33961:9532,
33962:9473,
33963:9475,
33964:9487,
33965:9491,
33966:9499,
33967:9495,
33968:9507,
33969:9523,
33970:9515,
33971:9531,
33972:9547,
33973:9504,
33974:9519,
33975:9512,
33976:9527,
33977:9535,
33978:9501,
33979:9520,
33980:9509,
33981:9528,
33982:9538,
34624:9312,
34625:9313,
34626:9314,
34627:9315,
34628:9316,
34629:9317,
34630:9318,
34631:9319,
34632:9320,
34633:9321,
34634:9322,
34635:9323,
34636:9324,
34637:9325,
34638:9326,
34639:9327,
34640:9328,
34641:9329,
34642:9330,
34643:9331,
34644:8544,
34645:8545,
34646:8546,
34647:8547,
34648:8548,
34649:8549,
34650:8550,
34651:8551,
34652:8552,
34653:8553,
34655:13129,
34656:13076,
34657:13090,
34658:13133,
34659:13080,
34660:13095,
34661:13059,
34662:13110,
34663:13137,
34664:13143,
34665:13069,
34666:13094,
34667:13091,
34668:13099,
34669:13130,
34670:13115,
34671:13212,
34672:13213,
34673:13214,
34674:13198,
34675:13199,
34676:13252,
34677:13217,
34686:13179,
34688:12317,
34689:12319,
34690:8470,
34691:13261,
34692:8481,
34693:12964,
34694:12965,
34695:12966,
34696:12967,
34697:12968,
34698:12849,
34699:12850,
34700:12857,
34701:13182,
34702:13181,
34703:13180,
34704:8786,
34705:8801,
34706:8747,
34707:8750,
34708:8721,
34709:8730,
34710:8869,
34711:8736,
34712:8735,
34713:8895,
34714:8757,
34715:8745,
34716:8746,
34975:20124,
34976:21782,
34977:23043,
34978:38463,
34979:21696,
34980:24859,
34981:25384,
34982:23030,
34983:36898,
34984:33909,
34985:33564,
34986:31312,
34987:24746,
34988:25569,
34989:28197,
34990:26093,
34991:33894,
34992:33446,
34993:39925,
34994:26771,
34995:22311,
34996:26017,
34997:25201,
34998:23451,
34999:22992,
35000:34427,
35001:39156,
35002:32098,
35003:32190,
35004:39822,
35005:25110,
35006:31903,
35007:34999,
35008:23433,
35009:24245,
35010:25353,
35011:26263,
35012:26696,
35013:38343,
35014:38797,
35015:26447,
35016:20197,
35017:20234,
35018:20301,
35019:20381,
35020:20553,
35021:22258,
35022:22839,
35023:22996,
35024:23041,
35025:23561,
35026:24799,
35027:24847,
35028:24944,
35029:26131,
35030:26885,
35031:28858,
35032:30031,
35033:30064,
35034:31227,
35035:32173,
35036:32239,
35037:32963,
35038:33806,
35039:34915,
35040:35586,
35041:36949,
35042:36986,
35043:21307,
35044:20117,
35045:20133,
35046:22495,
35047:32946,
35048:37057,
35049:30959,
35050:19968,
35051:22769,
35052:28322,
35053:36920,
35054:31282,
35055:33576,
35056:33419,
35057:39983,
35058:20801,
35059:21360,
35060:21693,
35061:21729,
35062:22240,
35063:23035,
35064:24341,
35065:39154,
35066:28139,
35067:32996,
35068:34093,
35136:38498,
35137:38512,
35138:38560,
35139:38907,
35140:21515,
35141:21491,
35142:23431,
35143:28879,
35144:32701,
35145:36802,
35146:38632,
35147:21359,
35148:40284,
35149:31418,
35150:19985,
35151:30867,
35152:33276,
35153:28198,
35154:22040,
35155:21764,
35156:27421,
35157:34074,
35158:39995,
35159:23013,
35160:21417,
35161:28006,
35162:29916,
35163:38287,
35164:22082,
35165:20113,
35166:36939,
35167:38642,
35168:33615,
35169:39180,
35170:21473,
35171:21942,
35172:23344,
35173:24433,
35174:26144,
35175:26355,
35176:26628,
35177:27704,
35178:27891,
35179:27945,
35180:29787,
35181:30408,
35182:31310,
35183:38964,
35184:33521,
35185:34907,
35186:35424,
35187:37613,
35188:28082,
35189:30123,
35190:30410,
35191:39365,
35192:24742,
35193:35585,
35194:36234,
35195:38322,
35196:27022,
35197:21421,
35198:20870,
35200:22290,
35201:22576,
35202:22852,
35203:23476,
35204:24310,
35205:24616,
35206:25513,
35207:25588,
35208:27839,
35209:28436,
35210:28814,
35211:28948,
35212:29017,
35213:29141,
35214:29503,
35215:32257,
35216:33398,
35217:33489,
35218:34199,
35219:36960,
35220:37467,
35221:40219,
35222:22633,
35223:26044,
35224:27738,
35225:29989,
35226:20985,
35227:22830,
35228:22885,
35229:24448,
35230:24540,
35231:25276,
35232:26106,
35233:27178,
35234:27431,
35235:27572,
35236:29579,
35237:32705,
35238:35158,
35239:40236,
35240:40206,
35241:40644,
35242:23713,
35243:27798,
35244:33659,
35245:20740,
35246:23627,
35247:25014,
35248:33222,
35249:26742,
35250:29281,
35251:20057,
35252:20474,
35253:21368,
35254:24681,
35255:28201,
35256:31311,
35257:38899,
35258:19979,
35259:21270,
35260:20206,
35261:20309,
35262:20285,
35263:20385,
35264:20339,
35265:21152,
35266:21487,
35267:22025,
35268:22799,
35269:23233,
35270:23478,
35271:23521,
35272:31185,
35273:26247,
35274:26524,
35275:26550,
35276:27468,
35277:27827,
35278:28779,
35279:29634,
35280:31117,
35281:31166,
35282:31292,
35283:31623,
35284:33457,
35285:33499,
35286:33540,
35287:33655,
35288:33775,
35289:33747,
35290:34662,
35291:35506,
35292:22057,
35293:36008,
35294:36838,
35295:36942,
35296:38686,
35297:34442,
35298:20420,
35299:23784,
35300:25105,
35301:29273,
35302:30011,
35303:33253,
35304:33469,
35305:34558,
35306:36032,
35307:38597,
35308:39187,
35309:39381,
35310:20171,
35311:20250,
35312:35299,
35313:22238,
35314:22602,
35315:22730,
35316:24315,
35317:24555,
35318:24618,
35319:24724,
35320:24674,
35321:25040,
35322:25106,
35323:25296,
35324:25913,
35392:39745,
35393:26214,
35394:26800,
35395:28023,
35396:28784,
35397:30028,
35398:30342,
35399:32117,
35400:33445,
35401:34809,
35402:38283,
35403:38542,
35404:35997,
35405:20977,
35406:21182,
35407:22806,
35408:21683,
35409:23475,
35410:23830,
35411:24936,
35412:27010,
35413:28079,
35414:30861,
35415:33995,
35416:34903,
35417:35442,
35418:37799,
35419:39608,
35420:28012,
35421:39336,
35422:34521,
35423:22435,
35424:26623,
35425:34510,
35426:37390,
35427:21123,
35428:22151,
35429:21508,
35430:24275,
35431:25313,
35432:25785,
35433:26684,
35434:26680,
35435:27579,
35436:29554,
35437:30906,
35438:31339,
35439:35226,
35440:35282,
35441:36203,
35442:36611,
35443:37101,
35444:38307,
35445:38548,
35446:38761,
35447:23398,
35448:23731,
35449:27005,
35450:38989,
35451:38990,
35452:25499,
35453:31520,
35454:27179,
35456:27263,
35457:26806,
35458:39949,
35459:28511,
35460:21106,
35461:21917,
35462:24688,
35463:25324,
35464:27963,
35465:28167,
35466:28369,
35467:33883,
35468:35088,
35469:36676,
35470:19988,
35471:39993,
35472:21494,
35473:26907,
35474:27194,
35475:38788,
35476:26666,
35477:20828,
35478:31427,
35479:33970,
35480:37340,
35481:37772,
35482:22107,
35483:40232,
35484:26658,
35485:33541,
35486:33841,
35487:31909,
35488:21000,
35489:33477,
35490:29926,
35491:20094,
35492:20355,
35493:20896,
35494:23506,
35495:21002,
35496:21208,
35497:21223,
35498:24059,
35499:21914,
35500:22570,
35501:23014,
35502:23436,
35503:23448,
35504:23515,
35505:24178,
35506:24185,
35507:24739,
35508:24863,
35509:24931,
35510:25022,
35511:25563,
35512:25954,
35513:26577,
35514:26707,
35515:26874,
35516:27454,
35517:27475,
35518:27735,
35519:28450,
35520:28567,
35521:28485,
35522:29872,
35523:29976,
35524:30435,
35525:30475,
35526:31487,
35527:31649,
35528:31777,
35529:32233,
35530:32566,
35531:32752,
35532:32925,
35533:33382,
35534:33694,
35535:35251,
35536:35532,
35537:36011,
35538:36996,
35539:37969,
35540:38291,
35541:38289,
35542:38306,
35543:38501,
35544:38867,
35545:39208,
35546:33304,
35547:20024,
35548:21547,
35549:23736,
35550:24012,
35551:29609,
35552:30284,
35553:30524,
35554:23721,
35555:32747,
35556:36107,
35557:38593,
35558:38929,
35559:38996,
35560:39000,
35561:20225,
35562:20238,
35563:21361,
35564:21916,
35565:22120,
35566:22522,
35567:22855,
35568:23305,
35569:23492,
35570:23696,
35571:24076,
35572:24190,
35573:24524,
35574:25582,
35575:26426,
35576:26071,
35577:26082,
35578:26399,
35579:26827,
35580:26820,
35648:27231,
35649:24112,
35650:27589,
35651:27671,
35652:27773,
35653:30079,
35654:31048,
35655:23395,
35656:31232,
35657:32000,
35658:24509,
35659:35215,
35660:35352,
35661:36020,
35662:36215,
35663:36556,
35664:36637,
35665:39138,
35666:39438,
35667:39740,
35668:20096,
35669:20605,
35670:20736,
35671:22931,
35672:23452,
35673:25135,
35674:25216,
35675:25836,
35676:27450,
35677:29344,
35678:30097,
35679:31047,
35680:32681,
35681:34811,
35682:35516,
35683:35696,
35684:25516,
35685:33738,
35686:38816,
35687:21513,
35688:21507,
35689:21931,
35690:26708,
35691:27224,
35692:35440,
35693:30759,
35694:26485,
35695:40653,
35696:21364,
35697:23458,
35698:33050,
35699:34384,
35700:36870,
35701:19992,
35702:20037,
35703:20167,
35704:20241,
35705:21450,
35706:21560,
35707:23470,
35708:24339,
35709:24613,
35710:25937,
35712:26429,
35713:27714,
35714:27762,
35715:27875,
35716:28792,
35717:29699,
35718:31350,
35719:31406,
35720:31496,
35721:32026,
35722:31998,
35723:32102,
35724:26087,
35725:29275,
35726:21435,
35727:23621,
35728:24040,
35729:25298,
35730:25312,
35731:25369,
35732:28192,
35733:34394,
35734:35377,
35735:36317,
35736:37624,
35737:28417,
35738:31142,
35739:39770,
35740:20136,
35741:20139,
35742:20140,
35743:20379,
35744:20384,
35745:20689,
35746:20807,
35747:31478,
35748:20849,
35749:20982,
35750:21332,
35751:21281,
35752:21375,
35753:21483,
35754:21932,
35755:22659,
35756:23777,
35757:24375,
35758:24394,
35759:24623,
35760:24656,
35761:24685,
35762:25375,
35763:25945,
35764:27211,
35765:27841,
35766:29378,
35767:29421,
35768:30703,
35769:33016,
35770:33029,
35771:33288,
35772:34126,
35773:37111,
35774:37857,
35775:38911,
35776:39255,
35777:39514,
35778:20208,
35779:20957,
35780:23597,
35781:26241,
35782:26989,
35783:23616,
35784:26354,
35785:26997,
35786:29577,
35787:26704,
35788:31873,
35789:20677,
35790:21220,
35791:22343,
35792:24062,
35793:37670,
35794:26020,
35795:27427,
35796:27453,
35797:29748,
35798:31105,
35799:31165,
35800:31563,
35801:32202,
35802:33465,
35803:33740,
35804:34943,
35805:35167,
35806:35641,
35807:36817,
35808:37329,
35809:21535,
35810:37504,
35811:20061,
35812:20534,
35813:21477,
35814:21306,
35815:29399,
35816:29590,
35817:30697,
35818:33510,
35819:36527,
35820:39366,
35821:39368,
35822:39378,
35823:20855,
35824:24858,
35825:34398,
35826:21936,
35827:31354,
35828:20598,
35829:23507,
35830:36935,
35831:38533,
35832:20018,
35833:27355,
35834:37351,
35835:23633,
35836:23624,
35904:25496,
35905:31391,
35906:27795,
35907:38772,
35908:36705,
35909:31402,
35910:29066,
35911:38536,
35912:31874,
35913:26647,
35914:32368,
35915:26705,
35916:37740,
35917:21234,
35918:21531,
35919:34219,
35920:35347,
35921:32676,
35922:36557,
35923:37089,
35924:21350,
35925:34952,
35926:31041,
35927:20418,
35928:20670,
35929:21009,
35930:20804,
35931:21843,
35932:22317,
35933:29674,
35934:22411,
35935:22865,
35936:24418,
35937:24452,
35938:24693,
35939:24950,
35940:24935,
35941:25001,
35942:25522,
35943:25658,
35944:25964,
35945:26223,
35946:26690,
35947:28179,
35948:30054,
35949:31293,
35950:31995,
35951:32076,
35952:32153,
35953:32331,
35954:32619,
35955:33550,
35956:33610,
35957:34509,
35958:35336,
35959:35427,
35960:35686,
35961:36605,
35962:38938,
35963:40335,
35964:33464,
35965:36814,
35966:39912,
35968:21127,
35969:25119,
35970:25731,
35971:28608,
35972:38553,
35973:26689,
35974:20625,
35975:27424,
35976:27770,
35977:28500,
35978:31348,
35979:32080,
35980:34880,
35981:35363,
35982:26376,
35983:20214,
35984:20537,
35985:20518,
35986:20581,
35987:20860,
35988:21048,
35989:21091,
35990:21927,
35991:22287,
35992:22533,
35993:23244,
35994:24314,
35995:25010,
35996:25080,
35997:25331,
35998:25458,
35999:26908,
36000:27177,
36001:29309,
36002:29356,
36003:29486,
36004:30740,
36005:30831,
36006:32121,
36007:30476,
36008:32937,
36009:35211,
36010:35609,
36011:36066,
36012:36562,
36013:36963,
36014:37749,
36015:38522,
36016:38997,
36017:39443,
36018:40568,
36019:20803,
36020:21407,
36021:21427,
36022:24187,
36023:24358,
36024:28187,
36025:28304,
36026:29572,
36027:29694,
36028:32067,
36029:33335,
36030:35328,
36031:35578,
36032:38480,
36033:20046,
36034:20491,
36035:21476,
36036:21628,
36037:22266,
36038:22993,
36039:23396,
36040:24049,
36041:24235,
36042:24359,
36043:25144,
36044:25925,
36045:26543,
36046:28246,
36047:29392,
36048:31946,
36049:34996,
36050:32929,
36051:32993,
36052:33776,
36053:34382,
36054:35463,
36055:36328,
36056:37431,
36057:38599,
36058:39015,
36059:40723,
36060:20116,
36061:20114,
36062:20237,
36063:21320,
36064:21577,
36065:21566,
36066:23087,
36067:24460,
36068:24481,
36069:24735,
36070:26791,
36071:27278,
36072:29786,
36073:30849,
36074:35486,
36075:35492,
36076:35703,
36077:37264,
36078:20062,
36079:39881,
36080:20132,
36081:20348,
36082:20399,
36083:20505,
36084:20502,
36085:20809,
36086:20844,
36087:21151,
36088:21177,
36089:21246,
36090:21402,
36091:21475,
36092:21521,
36160:21518,
36161:21897,
36162:22353,
36163:22434,
36164:22909,
36165:23380,
36166:23389,
36167:23439,
36168:24037,
36169:24039,
36170:24055,
36171:24184,
36172:24195,
36173:24218,
36174:24247,
36175:24344,
36176:24658,
36177:24908,
36178:25239,
36179:25304,
36180:25511,
36181:25915,
36182:26114,
36183:26179,
36184:26356,
36185:26477,
36186:26657,
36187:26775,
36188:27083,
36189:27743,
36190:27946,
36191:28009,
36192:28207,
36193:28317,
36194:30002,
36195:30343,
36196:30828,
36197:31295,
36198:31968,
36199:32005,
36200:32024,
36201:32094,
36202:32177,
36203:32789,
36204:32771,
36205:32943,
36206:32945,
36207:33108,
36208:33167,
36209:33322,
36210:33618,
36211:34892,
36212:34913,
36213:35611,
36214:36002,
36215:36092,
36216:37066,
36217:37237,
36218:37489,
36219:30783,
36220:37628,
36221:38308,
36222:38477,
36224:38917,
36225:39321,
36226:39640,
36227:40251,
36228:21083,
36229:21163,
36230:21495,
36231:21512,
36232:22741,
36233:25335,
36234:28640,
36235:35946,
36236:36703,
36237:40633,
36238:20811,
36239:21051,
36240:21578,
36241:22269,
36242:31296,
36243:37239,
36244:40288,
36245:40658,
36246:29508,
36247:28425,
36248:33136,
36249:29969,
36250:24573,
36251:24794,
36252:39592,
36253:29403,
36254:36796,
36255:27492,
36256:38915,
36257:20170,
36258:22256,
36259:22372,
36260:22718,
36261:23130,
36262:24680,
36263:25031,
36264:26127,
36265:26118,
36266:26681,
36267:26801,
36268:28151,
36269:30165,
36270:32058,
36271:33390,
36272:39746,
36273:20123,
36274:20304,
36275:21449,
36276:21766,
36277:23919,
36278:24038,
36279:24046,
36280:26619,
36281:27801,
36282:29811,
36283:30722,
36284:35408,
36285:37782,
36286:35039,
36287:22352,
36288:24231,
36289:25387,
36290:20661,
36291:20652,
36292:20877,
36293:26368,
36294:21705,
36295:22622,
36296:22971,
36297:23472,
36298:24425,
36299:25165,
36300:25505,
36301:26685,
36302:27507,
36303:28168,
36304:28797,
36305:37319,
36306:29312,
36307:30741,
36308:30758,
36309:31085,
36310:25998,
36311:32048,
36312:33756,
36313:35009,
36314:36617,
36315:38555,
36316:21092,
36317:22312,
36318:26448,
36319:32618,
36320:36001,
36321:20916,
36322:22338,
36323:38442,
36324:22586,
36325:27018,
36326:32948,
36327:21682,
36328:23822,
36329:22524,
36330:30869,
36331:40442,
36332:20316,
36333:21066,
36334:21643,
36335:25662,
36336:26152,
36337:26388,
36338:26613,
36339:31364,
36340:31574,
36341:32034,
36342:37679,
36343:26716,
36344:39853,
36345:31545,
36346:21273,
36347:20874,
36348:21047,
36416:23519,
36417:25334,
36418:25774,
36419:25830,
36420:26413,
36421:27578,
36422:34217,
36423:38609,
36424:30352,
36425:39894,
36426:25420,
36427:37638,
36428:39851,
36429:30399,
36430:26194,
36431:19977,
36432:20632,
36433:21442,
36434:23665,
36435:24808,
36436:25746,
36437:25955,
36438:26719,
36439:29158,
36440:29642,
36441:29987,
36442:31639,
36443:32386,
36444:34453,
36445:35715,
36446:36059,
36447:37240,
36448:39184,
36449:26028,
36450:26283,
36451:27531,
36452:20181,
36453:20180,
36454:20282,
36455:20351,
36456:21050,
36457:21496,
36458:21490,
36459:21987,
36460:22235,
36461:22763,
36462:22987,
36463:22985,
36464:23039,
36465:23376,
36466:23629,
36467:24066,
36468:24107,
36469:24535,
36470:24605,
36471:25351,
36472:25903,
36473:23388,
36474:26031,
36475:26045,
36476:26088,
36477:26525,
36478:27490,
36480:27515,
36481:27663,
36482:29509,
36483:31049,
36484:31169,
36485:31992,
36486:32025,
36487:32043,
36488:32930,
36489:33026,
36490:33267,
36491:35222,
36492:35422,
36493:35433,
36494:35430,
36495:35468,
36496:35566,
36497:36039,
36498:36060,
36499:38604,
36500:39164,
36501:27503,
36502:20107,
36503:20284,
36504:20365,
36505:20816,
36506:23383,
36507:23546,
36508:24904,
36509:25345,
36510:26178,
36511:27425,
36512:28363,
36513:27835,
36514:29246,
36515:29885,
36516:30164,
36517:30913,
36518:31034,
36519:32780,
36520:32819,
36521:33258,
36522:33940,
36523:36766,
36524:27728,
36525:40575,
36526:24335,
36527:35672,
36528:40235,
36529:31482,
36530:36600,
36531:23437,
36532:38635,
36533:19971,
36534:21489,
36535:22519,
36536:22833,
36537:23241,
36538:23460,
36539:24713,
36540:28287,
36541:28422,
36542:30142,
36543:36074,
36544:23455,
36545:34048,
36546:31712,
36547:20594,
36548:26612,
36549:33437,
36550:23649,
36551:34122,
36552:32286,
36553:33294,
36554:20889,
36555:23556,
36556:25448,
36557:36198,
36558:26012,
36559:29038,
36560:31038,
36561:32023,
36562:32773,
36563:35613,
36564:36554,
36565:36974,
36566:34503,
36567:37034,
36568:20511,
36569:21242,
36570:23610,
36571:26451,
36572:28796,
36573:29237,
36574:37196,
36575:37320,
36576:37675,
36577:33509,
36578:23490,
36579:24369,
36580:24825,
36581:20027,
36582:21462,
36583:23432,
36584:25163,
36585:26417,
36586:27530,
36587:29417,
36588:29664,
36589:31278,
36590:33131,
36591:36259,
36592:37202,
36593:39318,
36594:20754,
36595:21463,
36596:21610,
36597:23551,
36598:25480,
36599:27193,
36600:32172,
36601:38656,
36602:22234,
36603:21454,
36604:21608,
36672:23447,
36673:23601,
36674:24030,
36675:20462,
36676:24833,
36677:25342,
36678:27954,
36679:31168,
36680:31179,
36681:32066,
36682:32333,
36683:32722,
36684:33261,
36685:33311,
36686:33936,
36687:34886,
36688:35186,
36689:35728,
36690:36468,
36691:36655,
36692:36913,
36693:37195,
36694:37228,
36695:38598,
36696:37276,
36697:20160,
36698:20303,
36699:20805,
36700:21313,
36701:24467,
36702:25102,
36703:26580,
36704:27713,
36705:28171,
36706:29539,
36707:32294,
36708:37325,
36709:37507,
36710:21460,
36711:22809,
36712:23487,
36713:28113,
36714:31069,
36715:32302,
36716:31899,
36717:22654,
36718:29087,
36719:20986,
36720:34899,
36721:36848,
36722:20426,
36723:23803,
36724:26149,
36725:30636,
36726:31459,
36727:33308,
36728:39423,
36729:20934,
36730:24490,
36731:26092,
36732:26991,
36733:27529,
36734:28147,
36736:28310,
36737:28516,
36738:30462,
36739:32020,
36740:24033,
36741:36981,
36742:37255,
36743:38918,
36744:20966,
36745:21021,
36746:25152,
36747:26257,
36748:26329,
36749:28186,
36750:24246,
36751:32210,
36752:32626,
36753:26360,
36754:34223,
36755:34295,
36756:35576,
36757:21161,
36758:21465,
36759:22899,
36760:24207,
36761:24464,
36762:24661,
36763:37604,
36764:38500,
36765:20663,
36766:20767,
36767:21213,
36768:21280,
36769:21319,
36770:21484,
36771:21736,
36772:21830,
36773:21809,
36774:22039,
36775:22888,
36776:22974,
36777:23100,
36778:23477,
36779:23558,
36780:23567,
36781:23569,
36782:23578,
36783:24196,
36784:24202,
36785:24288,
36786:24432,
36787:25215,
36788:25220,
36789:25307,
36790:25484,
36791:25463,
36792:26119,
36793:26124,
36794:26157,
36795:26230,
36796:26494,
36797:26786,
36798:27167,
36799:27189,
36800:27836,
36801:28040,
36802:28169,
36803:28248,
36804:28988,
36805:28966,
36806:29031,
36807:30151,
36808:30465,
36809:30813,
36810:30977,
36811:31077,
36812:31216,
36813:31456,
36814:31505,
36815:31911,
36816:32057,
36817:32918,
36818:33750,
36819:33931,
36820:34121,
36821:34909,
36822:35059,
36823:35359,
36824:35388,
36825:35412,
36826:35443,
36827:35937,
36828:36062,
36829:37284,
36830:37478,
36831:37758,
36832:37912,
36833:38556,
36834:38808,
36835:19978,
36836:19976,
36837:19998,
36838:20055,
36839:20887,
36840:21104,
36841:22478,
36842:22580,
36843:22732,
36844:23330,
36845:24120,
36846:24773,
36847:25854,
36848:26465,
36849:26454,
36850:27972,
36851:29366,
36852:30067,
36853:31331,
36854:33976,
36855:35698,
36856:37304,
36857:37664,
36858:22065,
36859:22516,
36860:39166,
36928:25325,
36929:26893,
36930:27542,
36931:29165,
36932:32340,
36933:32887,
36934:33394,
36935:35302,
36936:39135,
36937:34645,
36938:36785,
36939:23611,
36940:20280,
36941:20449,
36942:20405,
36943:21767,
36944:23072,
36945:23517,
36946:23529,
36947:24515,
36948:24910,
36949:25391,
36950:26032,
36951:26187,
36952:26862,
36953:27035,
36954:28024,
36955:28145,
36956:30003,
36957:30137,
36958:30495,
36959:31070,
36960:31206,
36961:32051,
36962:33251,
36963:33455,
36964:34218,
36965:35242,
36966:35386,
36967:36523,
36968:36763,
36969:36914,
36970:37341,
36971:38663,
36972:20154,
36973:20161,
36974:20995,
36975:22645,
36976:22764,
36977:23563,
36978:29978,
36979:23613,
36980:33102,
36981:35338,
36982:36805,
36983:38499,
36984:38765,
36985:31525,
36986:35535,
36987:38920,
36988:37218,
36989:22259,
36990:21416,
36992:36887,
36993:21561,
36994:22402,
36995:24101,
36996:25512,
36997:27700,
36998:28810,
36999:30561,
37000:31883,
37001:32736,
37002:34928,
37003:36930,
37004:37204,
37005:37648,
37006:37656,
37007:38543,
37008:29790,
37009:39620,
37010:23815,
37011:23913,
37012:25968,
37013:26530,
37014:36264,
37015:38619,
37016:25454,
37017:26441,
37018:26905,
37019:33733,
37020:38935,
37021:38592,
37022:35070,
37023:28548,
37024:25722,
37025:23544,
37026:19990,
37027:28716,
37028:30045,
37029:26159,
37030:20932,
37031:21046,
37032:21218,
37033:22995,
37034:24449,
37035:24615,
37036:25104,
37037:25919,
37038:25972,
37039:26143,
37040:26228,
37041:26866,
37042:26646,
37043:27491,
37044:28165,
37045:29298,
37046:29983,
37047:30427,
37048:31934,
37049:32854,
37050:22768,
37051:35069,
37052:35199,
37053:35488,
37054:35475,
37055:35531,
37056:36893,
37057:37266,
37058:38738,
37059:38745,
37060:25993,
37061:31246,
37062:33030,
37063:38587,
37064:24109,
37065:24796,
37066:25114,
37067:26021,
37068:26132,
37069:26512,
37070:30707,
37071:31309,
37072:31821,
37073:32318,
37074:33034,
37075:36012,
37076:36196,
37077:36321,
37078:36447,
37079:30889,
37080:20999,
37081:25305,
37082:25509,
37083:25666,
37084:25240,
37085:35373,
37086:31363,
37087:31680,
37088:35500,
37089:38634,
37090:32118,
37091:33292,
37092:34633,
37093:20185,
37094:20808,
37095:21315,
37096:21344,
37097:23459,
37098:23554,
37099:23574,
37100:24029,
37101:25126,
37102:25159,
37103:25776,
37104:26643,
37105:26676,
37106:27849,
37107:27973,
37108:27927,
37109:26579,
37110:28508,
37111:29006,
37112:29053,
37113:26059,
37114:31359,
37115:31661,
37116:32218,
37184:32330,
37185:32680,
37186:33146,
37187:33307,
37188:33337,
37189:34214,
37190:35438,
37191:36046,
37192:36341,
37193:36984,
37194:36983,
37195:37549,
37196:37521,
37197:38275,
37198:39854,
37199:21069,
37200:21892,
37201:28472,
37202:28982,
37203:20840,
37204:31109,
37205:32341,
37206:33203,
37207:31950,
37208:22092,
37209:22609,
37210:23720,
37211:25514,
37212:26366,
37213:26365,
37214:26970,
37215:29401,
37216:30095,
37217:30094,
37218:30990,
37219:31062,
37220:31199,
37221:31895,
37222:32032,
37223:32068,
37224:34311,
37225:35380,
37226:38459,
37227:36961,
37228:40736,
37229:20711,
37230:21109,
37231:21452,
37232:21474,
37233:20489,
37234:21930,
37235:22766,
37236:22863,
37237:29245,
37238:23435,
37239:23652,
37240:21277,
37241:24803,
37242:24819,
37243:25436,
37244:25475,
37245:25407,
37246:25531,
37248:25805,
37249:26089,
37250:26361,
37251:24035,
37252:27085,
37253:27133,
37254:28437,
37255:29157,
37256:20105,
37257:30185,
37258:30456,
37259:31379,
37260:31967,
37261:32207,
37262:32156,
37263:32865,
37264:33609,
37265:33624,
37266:33900,
37267:33980,
37268:34299,
37269:35013,
37270:36208,
37271:36865,
37272:36973,
37273:37783,
37274:38684,
37275:39442,
37276:20687,
37277:22679,
37278:24974,
37279:33235,
37280:34101,
37281:36104,
37282:36896,
37283:20419,
37284:20596,
37285:21063,
37286:21363,
37287:24687,
37288:25417,
37289:26463,
37290:28204,
37291:36275,
37292:36895,
37293:20439,
37294:23646,
37295:36042,
37296:26063,
37297:32154,
37298:21330,
37299:34966,
37300:20854,
37301:25539,
37302:23384,
37303:23403,
37304:23562,
37305:25613,
37306:26449,
37307:36956,
37308:20182,
37309:22810,
37310:22826,
37311:27760,
37312:35409,
37313:21822,
37314:22549,
37315:22949,
37316:24816,
37317:25171,
37318:26561,
37319:33333,
37320:26965,
37321:38464,
37322:39364,
37323:39464,
37324:20307,
37325:22534,
37326:23550,
37327:32784,
37328:23729,
37329:24111,
37330:24453,
37331:24608,
37332:24907,
37333:25140,
37334:26367,
37335:27888,
37336:28382,
37337:32974,
37338:33151,
37339:33492,
37340:34955,
37341:36024,
37342:36864,
37343:36910,
37344:38538,
37345:40667,
37346:39899,
37347:20195,
37348:21488,
37349:22823,
37350:31532,
37351:37261,
37352:38988,
37353:40441,
37354:28381,
37355:28711,
37356:21331,
37357:21828,
37358:23429,
37359:25176,
37360:25246,
37361:25299,
37362:27810,
37363:28655,
37364:29730,
37365:35351,
37366:37944,
37367:28609,
37368:35582,
37369:33592,
37370:20967,
37371:34552,
37372:21482,
37440:21481,
37441:20294,
37442:36948,
37443:36784,
37444:22890,
37445:33073,
37446:24061,
37447:31466,
37448:36799,
37449:26842,
37450:35895,
37451:29432,
37452:40008,
37453:27197,
37454:35504,
37455:20025,
37456:21336,
37457:22022,
37458:22374,
37459:25285,
37460:25506,
37461:26086,
37462:27470,
37463:28129,
37464:28251,
37465:28845,
37466:30701,
37467:31471,
37468:31658,
37469:32187,
37470:32829,
37471:32966,
37472:34507,
37473:35477,
37474:37723,
37475:22243,
37476:22727,
37477:24382,
37478:26029,
37479:26262,
37480:27264,
37481:27573,
37482:30007,
37483:35527,
37484:20516,
37485:30693,
37486:22320,
37487:24347,
37488:24677,
37489:26234,
37490:27744,
37491:30196,
37492:31258,
37493:32622,
37494:33268,
37495:34584,
37496:36933,
37497:39347,
37498:31689,
37499:30044,
37500:31481,
37501:31569,
37502:33988,
37504:36880,
37505:31209,
37506:31378,
37507:33590,
37508:23265,
37509:30528,
37510:20013,
37511:20210,
37512:23449,
37513:24544,
37514:25277,
37515:26172,
37516:26609,
37517:27880,
37518:34411,
37519:34935,
37520:35387,
37521:37198,
37522:37619,
37523:39376,
37524:27159,
37525:28710,
37526:29482,
37527:33511,
37528:33879,
37529:36015,
37530:19969,
37531:20806,
37532:20939,
37533:21899,
37534:23541,
37535:24086,
37536:24115,
37537:24193,
37538:24340,
37539:24373,
37540:24427,
37541:24500,
37542:25074,
37543:25361,
37544:26274,
37545:26397,
37546:28526,
37547:29266,
37548:30010,
37549:30522,
37550:32884,
37551:33081,
37552:33144,
37553:34678,
37554:35519,
37555:35548,
37556:36229,
37557:36339,
37558:37530,
37559:38263,
37560:38914,
37561:40165,
37562:21189,
37563:25431,
37564:30452,
37565:26389,
37566:27784,
37567:29645,
37568:36035,
37569:37806,
37570:38515,
37571:27941,
37572:22684,
37573:26894,
37574:27084,
37575:36861,
37576:37786,
37577:30171,
37578:36890,
37579:22618,
37580:26626,
37581:25524,
37582:27131,
37583:20291,
37584:28460,
37585:26584,
37586:36795,
37587:34086,
37588:32180,
37589:37716,
37590:26943,
37591:28528,
37592:22378,
37593:22775,
37594:23340,
37595:32044,
37596:29226,
37597:21514,
37598:37347,
37599:40372,
37600:20141,
37601:20302,
37602:20572,
37603:20597,
37604:21059,
37605:35998,
37606:21576,
37607:22564,
37608:23450,
37609:24093,
37610:24213,
37611:24237,
37612:24311,
37613:24351,
37614:24716,
37615:25269,
37616:25402,
37617:25552,
37618:26799,
37619:27712,
37620:30855,
37621:31118,
37622:31243,
37623:32224,
37624:33351,
37625:35330,
37626:35558,
37627:36420,
37628:36883,
37696:37048,
37697:37165,
37698:37336,
37699:40718,
37700:27877,
37701:25688,
37702:25826,
37703:25973,
37704:28404,
37705:30340,
37706:31515,
37707:36969,
37708:37841,
37709:28346,
37710:21746,
37711:24505,
37712:25764,
37713:36685,
37714:36845,
37715:37444,
37716:20856,
37717:22635,
37718:22825,
37719:23637,
37720:24215,
37721:28155,
37722:32399,
37723:29980,
37724:36028,
37725:36578,
37726:39003,
37727:28857,
37728:20253,
37729:27583,
37730:28593,
37731:30000,
37732:38651,
37733:20814,
37734:21520,
37735:22581,
37736:22615,
37737:22956,
37738:23648,
37739:24466,
37740:26007,
37741:26460,
37742:28193,
37743:30331,
37744:33759,
37745:36077,
37746:36884,
37747:37117,
37748:37709,
37749:30757,
37750:30778,
37751:21162,
37752:24230,
37753:22303,
37754:22900,
37755:24594,
37756:20498,
37757:20826,
37758:20908,
37760:20941,
37761:20992,
37762:21776,
37763:22612,
37764:22616,
37765:22871,
37766:23445,
37767:23798,
37768:23947,
37769:24764,
37770:25237,
37771:25645,
37772:26481,
37773:26691,
37774:26812,
37775:26847,
37776:30423,
37777:28120,
37778:28271,
37779:28059,
37780:28783,
37781:29128,
37782:24403,
37783:30168,
37784:31095,
37785:31561,
37786:31572,
37787:31570,
37788:31958,
37789:32113,
37790:21040,
37791:33891,
37792:34153,
37793:34276,
37794:35342,
37795:35588,
37796:35910,
37797:36367,
37798:36867,
37799:36879,
37800:37913,
37801:38518,
37802:38957,
37803:39472,
37804:38360,
37805:20685,
37806:21205,
37807:21516,
37808:22530,
37809:23566,
37810:24999,
37811:25758,
37812:27934,
37813:30643,
37814:31461,
37815:33012,
37816:33796,
37817:36947,
37818:37509,
37819:23776,
37820:40199,
37821:21311,
37822:24471,
37823:24499,
37824:28060,
37825:29305,
37826:30563,
37827:31167,
37828:31716,
37829:27602,
37830:29420,
37831:35501,
37832:26627,
37833:27233,
37834:20984,
37835:31361,
37836:26932,
37837:23626,
37838:40182,
37839:33515,
37840:23493,
37841:37193,
37842:28702,
37843:22136,
37844:23663,
37845:24775,
37846:25958,
37847:27788,
37848:35930,
37849:36929,
37850:38931,
37851:21585,
37852:26311,
37853:37389,
37854:22856,
37855:37027,
37856:20869,
37857:20045,
37858:20970,
37859:34201,
37860:35598,
37861:28760,
37862:25466,
37863:37707,
37864:26978,
37865:39348,
37866:32260,
37867:30071,
37868:21335,
37869:26976,
37870:36575,
37871:38627,
37872:27741,
37873:20108,
37874:23612,
37875:24336,
37876:36841,
37877:21250,
37878:36049,
37879:32905,
37880:34425,
37881:24319,
37882:26085,
37883:20083,
37884:20837,
37952:22914,
37953:23615,
37954:38894,
37955:20219,
37956:22922,
37957:24525,
37958:35469,
37959:28641,
37960:31152,
37961:31074,
37962:23527,
37963:33905,
37964:29483,
37965:29105,
37966:24180,
37967:24565,
37968:25467,
37969:25754,
37970:29123,
37971:31896,
37972:20035,
37973:24316,
37974:20043,
37975:22492,
37976:22178,
37977:24745,
37978:28611,
37979:32013,
37980:33021,
37981:33075,
37982:33215,
37983:36786,
37984:35223,
37985:34468,
37986:24052,
37987:25226,
37988:25773,
37989:35207,
37990:26487,
37991:27874,
37992:27966,
37993:29750,
37994:30772,
37995:23110,
37996:32629,
37997:33453,
37998:39340,
37999:20467,
38000:24259,
38001:25309,
38002:25490,
38003:25943,
38004:26479,
38005:30403,
38006:29260,
38007:32972,
38008:32954,
38009:36649,
38010:37197,
38011:20493,
38012:22521,
38013:23186,
38014:26757,
38016:26995,
38017:29028,
38018:29437,
38019:36023,
38020:22770,
38021:36064,
38022:38506,
38023:36889,
38024:34687,
38025:31204,
38026:30695,
38027:33833,
38028:20271,
38029:21093,
38030:21338,
38031:25293,
38032:26575,
38033:27850,
38034:30333,
38035:31636,
38036:31893,
38037:33334,
38038:34180,
38039:36843,
38040:26333,
38041:28448,
38042:29190,
38043:32283,
38044:33707,
38045:39361,
38046:40614,
38047:20989,
38048:31665,
38049:30834,
38050:31672,
38051:32903,
38052:31560,
38053:27368,
38054:24161,
38055:32908,
38056:30033,
38057:30048,
38058:20843,
38059:37474,
38060:28300,
38061:30330,
38062:37271,
38063:39658,
38064:20240,
38065:32624,
38066:25244,
38067:31567,
38068:38309,
38069:40169,
38070:22138,
38071:22617,
38072:34532,
38073:38588,
38074:20276,
38075:21028,
38076:21322,
38077:21453,
38078:21467,
38079:24070,
38080:25644,
38081:26001,
38082:26495,
38083:27710,
38084:27726,
38085:29256,
38086:29359,
38087:29677,
38088:30036,
38089:32321,
38090:33324,
38091:34281,
38092:36009,
38093:31684,
38094:37318,
38095:29033,
38096:38930,
38097:39151,
38098:25405,
38099:26217,
38100:30058,
38101:30436,
38102:30928,
38103:34115,
38104:34542,
38105:21290,
38106:21329,
38107:21542,
38108:22915,
38109:24199,
38110:24444,
38111:24754,
38112:25161,
38113:25209,
38114:25259,
38115:26000,
38116:27604,
38117:27852,
38118:30130,
38119:30382,
38120:30865,
38121:31192,
38122:32203,
38123:32631,
38124:32933,
38125:34987,
38126:35513,
38127:36027,
38128:36991,
38129:38750,
38130:39131,
38131:27147,
38132:31800,
38133:20633,
38134:23614,
38135:24494,
38136:26503,
38137:27608,
38138:29749,
38139:30473,
38140:32654,
38208:40763,
38209:26570,
38210:31255,
38211:21305,
38212:30091,
38213:39661,
38214:24422,
38215:33181,
38216:33777,
38217:32920,
38218:24380,
38219:24517,
38220:30050,
38221:31558,
38222:36924,
38223:26727,
38224:23019,
38225:23195,
38226:32016,
38227:30334,
38228:35628,
38229:20469,
38230:24426,
38231:27161,
38232:27703,
38233:28418,
38234:29922,
38235:31080,
38236:34920,
38237:35413,
38238:35961,
38239:24287,
38240:25551,
38241:30149,
38242:31186,
38243:33495,
38244:37672,
38245:37618,
38246:33948,
38247:34541,
38248:39981,
38249:21697,
38250:24428,
38251:25996,
38252:27996,
38253:28693,
38254:36007,
38255:36051,
38256:38971,
38257:25935,
38258:29942,
38259:19981,
38260:20184,
38261:22496,
38262:22827,
38263:23142,
38264:23500,
38265:20904,
38266:24067,
38267:24220,
38268:24598,
38269:25206,
38270:25975,
38272:26023,
38273:26222,
38274:28014,
38275:29238,
38276:31526,
38277:33104,
38278:33178,
38279:33433,
38280:35676,
38281:36000,
38282:36070,
38283:36212,
38284:38428,
38285:38468,
38286:20398,
38287:25771,
38288:27494,
38289:33310,
38290:33889,
38291:34154,
38292:37096,
38293:23553,
38294:26963,
38295:39080,
38296:33914,
38297:34135,
38298:20239,
38299:21103,
38300:24489,
38301:24133,
38302:26381,
38303:31119,
38304:33145,
38305:35079,
38306:35206,
38307:28149,
38308:24343,
38309:25173,
38310:27832,
38311:20175,
38312:29289,
38313:39826,
38314:20998,
38315:21563,
38316:22132,
38317:22707,
38318:24996,
38319:25198,
38320:28954,
38321:22894,
38322:31881,
38323:31966,
38324:32027,
38325:38640,
38326:25991,
38327:32862,
38328:19993,
38329:20341,
38330:20853,
38331:22592,
38332:24163,
38333:24179,
38334:24330,
38335:26564,
38336:20006,
38337:34109,
38338:38281,
38339:38491,
38340:31859,
38341:38913,
38342:20731,
38343:22721,
38344:30294,
38345:30887,
38346:21029,
38347:30629,
38348:34065,
38349:31622,
38350:20559,
38351:22793,
38352:29255,
38353:31687,
38354:32232,
38355:36794,
38356:36820,
38357:36941,
38358:20415,
38359:21193,
38360:23081,
38361:24321,
38362:38829,
38363:20445,
38364:33303,
38365:37610,
38366:22275,
38367:25429,
38368:27497,
38369:29995,
38370:35036,
38371:36628,
38372:31298,
38373:21215,
38374:22675,
38375:24917,
38376:25098,
38377:26286,
38378:27597,
38379:31807,
38380:33769,
38381:20515,
38382:20472,
38383:21253,
38384:21574,
38385:22577,
38386:22857,
38387:23453,
38388:23792,
38389:23791,
38390:23849,
38391:24214,
38392:25265,
38393:25447,
38394:25918,
38395:26041,
38396:26379,
38464:27861,
38465:27873,
38466:28921,
38467:30770,
38468:32299,
38469:32990,
38470:33459,
38471:33804,
38472:34028,
38473:34562,
38474:35090,
38475:35370,
38476:35914,
38477:37030,
38478:37586,
38479:39165,
38480:40179,
38481:40300,
38482:20047,
38483:20129,
38484:20621,
38485:21078,
38486:22346,
38487:22952,
38488:24125,
38489:24536,
38490:24537,
38491:25151,
38492:26292,
38493:26395,
38494:26576,
38495:26834,
38496:20882,
38497:32033,
38498:32938,
38499:33192,
38500:35584,
38501:35980,
38502:36031,
38503:37502,
38504:38450,
38505:21536,
38506:38956,
38507:21271,
38508:20693,
38509:21340,
38510:22696,
38511:25778,
38512:26420,
38513:29287,
38514:30566,
38515:31302,
38516:37350,
38517:21187,
38518:27809,
38519:27526,
38520:22528,
38521:24140,
38522:22868,
38523:26412,
38524:32763,
38525:20961,
38526:30406,
38528:25705,
38529:30952,
38530:39764,
38531:40635,
38532:22475,
38533:22969,
38534:26151,
38535:26522,
38536:27598,
38537:21737,
38538:27097,
38539:24149,
38540:33180,
38541:26517,
38542:39850,
38543:26622,
38544:40018,
38545:26717,
38546:20134,
38547:20451,
38548:21448,
38549:25273,
38550:26411,
38551:27819,
38552:36804,
38553:20397,
38554:32365,
38555:40639,
38556:19975,
38557:24930,
38558:28288,
38559:28459,
38560:34067,
38561:21619,
38562:26410,
38563:39749,
38564:24051,
38565:31637,
38566:23724,
38567:23494,
38568:34588,
38569:28234,
38570:34001,
38571:31252,
38572:33032,
38573:22937,
38574:31885,
38575:27665,
38576:30496,
38577:21209,
38578:22818,
38579:28961,
38580:29279,
38581:30683,
38582:38695,
38583:40289,
38584:26891,
38585:23167,
38586:23064,
38587:20901,
38588:21517,
38589:21629,
38590:26126,
38591:30431,
38592:36855,
38593:37528,
38594:40180,
38595:23018,
38596:29277,
38597:28357,
38598:20813,
38599:26825,
38600:32191,
38601:32236,
38602:38754,
38603:40634,
38604:25720,
38605:27169,
38606:33538,
38607:22916,
38608:23391,
38609:27611,
38610:29467,
38611:30450,
38612:32178,
38613:32791,
38614:33945,
38615:20786,
38616:26408,
38617:40665,
38618:30446,
38619:26466,
38620:21247,
38621:39173,
38622:23588,
38623:25147,
38624:31870,
38625:36016,
38626:21839,
38627:24758,
38628:32011,
38629:38272,
38630:21249,
38631:20063,
38632:20918,
38633:22812,
38634:29242,
38635:32822,
38636:37326,
38637:24357,
38638:30690,
38639:21380,
38640:24441,
38641:32004,
38642:34220,
38643:35379,
38644:36493,
38645:38742,
38646:26611,
38647:34222,
38648:37971,
38649:24841,
38650:24840,
38651:27833,
38652:30290,
38720:35565,
38721:36664,
38722:21807,
38723:20305,
38724:20778,
38725:21191,
38726:21451,
38727:23461,
38728:24189,
38729:24736,
38730:24962,
38731:25558,
38732:26377,
38733:26586,
38734:28263,
38735:28044,
38736:29494,
38737:29495,
38738:30001,
38739:31056,
38740:35029,
38741:35480,
38742:36938,
38743:37009,
38744:37109,
38745:38596,
38746:34701,
38747:22805,
38748:20104,
38749:20313,
38750:19982,
38751:35465,
38752:36671,
38753:38928,
38754:20653,
38755:24188,
38756:22934,
38757:23481,
38758:24248,
38759:25562,
38760:25594,
38761:25793,
38762:26332,
38763:26954,
38764:27096,
38765:27915,
38766:28342,
38767:29076,
38768:29992,
38769:31407,
38770:32650,
38771:32768,
38772:33865,
38773:33993,
38774:35201,
38775:35617,
38776:36362,
38777:36965,
38778:38525,
38779:39178,
38780:24958,
38781:25233,
38782:27442,
38784:27779,
38785:28020,
38786:32716,
38787:32764,
38788:28096,
38789:32645,
38790:34746,
38791:35064,
38792:26469,
38793:33713,
38794:38972,
38795:38647,
38796:27931,
38797:32097,
38798:33853,
38799:37226,
38800:20081,
38801:21365,
38802:23888,
38803:27396,
38804:28651,
38805:34253,
38806:34349,
38807:35239,
38808:21033,
38809:21519,
38810:23653,
38811:26446,
38812:26792,
38813:29702,
38814:29827,
38815:30178,
38816:35023,
38817:35041,
38818:37324,
38819:38626,
38820:38520,
38821:24459,
38822:29575,
38823:31435,
38824:33870,
38825:25504,
38826:30053,
38827:21129,
38828:27969,
38829:28316,
38830:29705,
38831:30041,
38832:30827,
38833:31890,
38834:38534,
38835:31452,
38836:40845,
38837:20406,
38838:24942,
38839:26053,
38840:34396,
38841:20102,
38842:20142,
38843:20698,
38844:20001,
38845:20940,
38846:23534,
38847:26009,
38848:26753,
38849:28092,
38850:29471,
38851:30274,
38852:30637,
38853:31260,
38854:31975,
38855:33391,
38856:35538,
38857:36988,
38858:37327,
38859:38517,
38860:38936,
38861:21147,
38862:32209,
38863:20523,
38864:21400,
38865:26519,
38866:28107,
38867:29136,
38868:29747,
38869:33256,
38870:36650,
38871:38563,
38872:40023,
38873:40607,
38874:29792,
38875:22593,
38876:28057,
38877:32047,
38878:39006,
38879:20196,
38880:20278,
38881:20363,
38882:20919,
38883:21169,
38884:23994,
38885:24604,
38886:29618,
38887:31036,
38888:33491,
38889:37428,
38890:38583,
38891:38646,
38892:38666,
38893:40599,
38894:40802,
38895:26278,
38896:27508,
38897:21015,
38898:21155,
38899:28872,
38900:35010,
38901:24265,
38902:24651,
38903:24976,
38904:28451,
38905:29001,
38906:31806,
38907:32244,
38908:32879,
38976:34030,
38977:36899,
38978:37676,
38979:21570,
38980:39791,
38981:27347,
38982:28809,
38983:36034,
38984:36335,
38985:38706,
38986:21172,
38987:23105,
38988:24266,
38989:24324,
38990:26391,
38991:27004,
38992:27028,
38993:28010,
38994:28431,
38995:29282,
38996:29436,
38997:31725,
38998:32769,
38999:32894,
39000:34635,
39001:37070,
39002:20845,
39003:40595,
39004:31108,
39005:32907,
39006:37682,
39007:35542,
39008:20525,
39009:21644,
39010:35441,
39011:27498,
39012:36036,
39013:33031,
39014:24785,
39015:26528,
39016:40434,
39017:20121,
39018:20120,
39019:39952,
39020:35435,
39021:34241,
39022:34152,
39023:26880,
39024:28286,
39025:30871,
39026:33109,
39071:24332,
39072:19984,
39073:19989,
39074:20010,
39075:20017,
39076:20022,
39077:20028,
39078:20031,
39079:20034,
39080:20054,
39081:20056,
39082:20098,
39083:20101,
39084:35947,
39085:20106,
39086:33298,
39087:24333,
39088:20110,
39089:20126,
39090:20127,
39091:20128,
39092:20130,
39093:20144,
39094:20147,
39095:20150,
39096:20174,
39097:20173,
39098:20164,
39099:20166,
39100:20162,
39101:20183,
39102:20190,
39103:20205,
39104:20191,
39105:20215,
39106:20233,
39107:20314,
39108:20272,
39109:20315,
39110:20317,
39111:20311,
39112:20295,
39113:20342,
39114:20360,
39115:20367,
39116:20376,
39117:20347,
39118:20329,
39119:20336,
39120:20369,
39121:20335,
39122:20358,
39123:20374,
39124:20760,
39125:20436,
39126:20447,
39127:20430,
39128:20440,
39129:20443,
39130:20433,
39131:20442,
39132:20432,
39133:20452,
39134:20453,
39135:20506,
39136:20520,
39137:20500,
39138:20522,
39139:20517,
39140:20485,
39141:20252,
39142:20470,
39143:20513,
39144:20521,
39145:20524,
39146:20478,
39147:20463,
39148:20497,
39149:20486,
39150:20547,
39151:20551,
39152:26371,
39153:20565,
39154:20560,
39155:20552,
39156:20570,
39157:20566,
39158:20588,
39159:20600,
39160:20608,
39161:20634,
39162:20613,
39163:20660,
39164:20658,
39232:20681,
39233:20682,
39234:20659,
39235:20674,
39236:20694,
39237:20702,
39238:20709,
39239:20717,
39240:20707,
39241:20718,
39242:20729,
39243:20725,
39244:20745,
39245:20737,
39246:20738,
39247:20758,
39248:20757,
39249:20756,
39250:20762,
39251:20769,
39252:20794,
39253:20791,
39254:20796,
39255:20795,
39256:20799,
39257:20800,
39258:20818,
39259:20812,
39260:20820,
39261:20834,
39262:31480,
39263:20841,
39264:20842,
39265:20846,
39266:20864,
39267:20866,
39268:22232,
39269:20876,
39270:20873,
39271:20879,
39272:20881,
39273:20883,
39274:20885,
39275:20886,
39276:20900,
39277:20902,
39278:20898,
39279:20905,
39280:20906,
39281:20907,
39282:20915,
39283:20913,
39284:20914,
39285:20912,
39286:20917,
39287:20925,
39288:20933,
39289:20937,
39290:20955,
39291:20960,
39292:34389,
39293:20969,
39294:20973,
39296:20976,
39297:20981,
39298:20990,
39299:20996,
39300:21003,
39301:21012,
39302:21006,
39303:21031,
39304:21034,
39305:21038,
39306:21043,
39307:21049,
39308:21071,
39309:21060,
39310:21067,
39311:21068,
39312:21086,
39313:21076,
39314:21098,
39315:21108,
39316:21097,
39317:21107,
39318:21119,
39319:21117,
39320:21133,
39321:21140,
39322:21138,
39323:21105,
39324:21128,
39325:21137,
39326:36776,
39327:36775,
39328:21164,
39329:21165,
39330:21180,
39331:21173,
39332:21185,
39333:21197,
39334:21207,
39335:21214,
39336:21219,
39337:21222,
39338:39149,
39339:21216,
39340:21235,
39341:21237,
39342:21240,
39343:21241,
39344:21254,
39345:21256,
39346:30008,
39347:21261,
39348:21264,
39349:21263,
39350:21269,
39351:21274,
39352:21283,
39353:21295,
39354:21297,
39355:21299,
39356:21304,
39357:21312,
39358:21318,
39359:21317,
39360:19991,
39361:21321,
39362:21325,
39363:20950,
39364:21342,
39365:21353,
39366:21358,
39367:22808,
39368:21371,
39369:21367,
39370:21378,
39371:21398,
39372:21408,
39373:21414,
39374:21413,
39375:21422,
39376:21424,
39377:21430,
39378:21443,
39379:31762,
39380:38617,
39381:21471,
39382:26364,
39383:29166,
39384:21486,
39385:21480,
39386:21485,
39387:21498,
39388:21505,
39389:21565,
39390:21568,
39391:21548,
39392:21549,
39393:21564,
39394:21550,
39395:21558,
39396:21545,
39397:21533,
39398:21582,
39399:21647,
39400:21621,
39401:21646,
39402:21599,
39403:21617,
39404:21623,
39405:21616,
39406:21650,
39407:21627,
39408:21632,
39409:21622,
39410:21636,
39411:21648,
39412:21638,
39413:21703,
39414:21666,
39415:21688,
39416:21669,
39417:21676,
39418:21700,
39419:21704,
39420:21672,
39488:21675,
39489:21698,
39490:21668,
39491:21694,
39492:21692,
39493:21720,
39494:21733,
39495:21734,
39496:21775,
39497:21780,
39498:21757,
39499:21742,
39500:21741,
39501:21754,
39502:21730,
39503:21817,
39504:21824,
39505:21859,
39506:21836,
39507:21806,
39508:21852,
39509:21829,
39510:21846,
39511:21847,
39512:21816,
39513:21811,
39514:21853,
39515:21913,
39516:21888,
39517:21679,
39518:21898,
39519:21919,
39520:21883,
39521:21886,
39522:21912,
39523:21918,
39524:21934,
39525:21884,
39526:21891,
39527:21929,
39528:21895,
39529:21928,
39530:21978,
39531:21957,
39532:21983,
39533:21956,
39534:21980,
39535:21988,
39536:21972,
39537:22036,
39538:22007,
39539:22038,
39540:22014,
39541:22013,
39542:22043,
39543:22009,
39544:22094,
39545:22096,
39546:29151,
39547:22068,
39548:22070,
39549:22066,
39550:22072,
39552:22123,
39553:22116,
39554:22063,
39555:22124,
39556:22122,
39557:22150,
39558:22144,
39559:22154,
39560:22176,
39561:22164,
39562:22159,
39563:22181,
39564:22190,
39565:22198,
39566:22196,
39567:22210,
39568:22204,
39569:22209,
39570:22211,
39571:22208,
39572:22216,
39573:22222,
39574:22225,
39575:22227,
39576:22231,
39577:22254,
39578:22265,
39579:22272,
39580:22271,
39581:22276,
39582:22281,
39583:22280,
39584:22283,
39585:22285,
39586:22291,
39587:22296,
39588:22294,
39589:21959,
39590:22300,
39591:22310,
39592:22327,
39593:22328,
39594:22350,
39595:22331,
39596:22336,
39597:22351,
39598:22377,
39599:22464,
39600:22408,
39601:22369,
39602:22399,
39603:22409,
39604:22419,
39605:22432,
39606:22451,
39607:22436,
39608:22442,
39609:22448,
39610:22467,
39611:22470,
39612:22484,
39613:22482,
39614:22483,
39615:22538,
39616:22486,
39617:22499,
39618:22539,
39619:22553,
39620:22557,
39621:22642,
39622:22561,
39623:22626,
39624:22603,
39625:22640,
39626:27584,
39627:22610,
39628:22589,
39629:22649,
39630:22661,
39631:22713,
39632:22687,
39633:22699,
39634:22714,
39635:22750,
39636:22715,
39637:22712,
39638:22702,
39639:22725,
39640:22739,
39641:22737,
39642:22743,
39643:22745,
39644:22744,
39645:22757,
39646:22748,
39647:22756,
39648:22751,
39649:22767,
39650:22778,
39651:22777,
39652:22779,
39653:22780,
39654:22781,
39655:22786,
39656:22794,
39657:22800,
39658:22811,
39659:26790,
39660:22821,
39661:22828,
39662:22829,
39663:22834,
39664:22840,
39665:22846,
39666:31442,
39667:22869,
39668:22864,
39669:22862,
39670:22874,
39671:22872,
39672:22882,
39673:22880,
39674:22887,
39675:22892,
39676:22889,
39744:22904,
39745:22913,
39746:22941,
39747:20318,
39748:20395,
39749:22947,
39750:22962,
39751:22982,
39752:23016,
39753:23004,
39754:22925,
39755:23001,
39756:23002,
39757:23077,
39758:23071,
39759:23057,
39760:23068,
39761:23049,
39762:23066,
39763:23104,
39764:23148,
39765:23113,
39766:23093,
39767:23094,
39768:23138,
39769:23146,
39770:23194,
39771:23228,
39772:23230,
39773:23243,
39774:23234,
39775:23229,
39776:23267,
39777:23255,
39778:23270,
39779:23273,
39780:23254,
39781:23290,
39782:23291,
39783:23308,
39784:23307,
39785:23318,
39786:23346,
39787:23248,
39788:23338,
39789:23350,
39790:23358,
39791:23363,
39792:23365,
39793:23360,
39794:23377,
39795:23381,
39796:23386,
39797:23387,
39798:23397,
39799:23401,
39800:23408,
39801:23411,
39802:23413,
39803:23416,
39804:25992,
39805:23418,
39806:23424,
39808:23427,
39809:23462,
39810:23480,
39811:23491,
39812:23495,
39813:23497,
39814:23508,
39815:23504,
39816:23524,
39817:23526,
39818:23522,
39819:23518,
39820:23525,
39821:23531,
39822:23536,
39823:23542,
39824:23539,
39825:23557,
39826:23559,
39827:23560,
39828:23565,
39829:23571,
39830:23584,
39831:23586,
39832:23592,
39833:23608,
39834:23609,
39835:23617,
39836:23622,
39837:23630,
39838:23635,
39839:23632,
39840:23631,
39841:23409,
39842:23660,
39843:23662,
39844:20066,
39845:23670,
39846:23673,
39847:23692,
39848:23697,
39849:23700,
39850:22939,
39851:23723,
39852:23739,
39853:23734,
39854:23740,
39855:23735,
39856:23749,
39857:23742,
39858:23751,
39859:23769,
39860:23785,
39861:23805,
39862:23802,
39863:23789,
39864:23948,
39865:23786,
39866:23819,
39867:23829,
39868:23831,
39869:23900,
39870:23839,
39871:23835,
39872:23825,
39873:23828,
39874:23842,
39875:23834,
39876:23833,
39877:23832,
39878:23884,
39879:23890,
39880:23886,
39881:23883,
39882:23916,
39883:23923,
39884:23926,
39885:23943,
39886:23940,
39887:23938,
39888:23970,
39889:23965,
39890:23980,
39891:23982,
39892:23997,
39893:23952,
39894:23991,
39895:23996,
39896:24009,
39897:24013,
39898:24019,
39899:24018,
39900:24022,
39901:24027,
39902:24043,
39903:24050,
39904:24053,
39905:24075,
39906:24090,
39907:24089,
39908:24081,
39909:24091,
39910:24118,
39911:24119,
39912:24132,
39913:24131,
39914:24128,
39915:24142,
39916:24151,
39917:24148,
39918:24159,
39919:24162,
39920:24164,
39921:24135,
39922:24181,
39923:24182,
39924:24186,
39925:40636,
39926:24191,
39927:24224,
39928:24257,
39929:24258,
39930:24264,
39931:24272,
39932:24271,
40000:24278,
40001:24291,
40002:24285,
40003:24282,
40004:24283,
40005:24290,
40006:24289,
40007:24296,
40008:24297,
40009:24300,
40010:24305,
40011:24307,
40012:24304,
40013:24308,
40014:24312,
40015:24318,
40016:24323,
40017:24329,
40018:24413,
40019:24412,
40020:24331,
40021:24337,
40022:24342,
40023:24361,
40024:24365,
40025:24376,
40026:24385,
40027:24392,
40028:24396,
40029:24398,
40030:24367,
40031:24401,
40032:24406,
40033:24407,
40034:24409,
40035:24417,
40036:24429,
40037:24435,
40038:24439,
40039:24451,
40040:24450,
40041:24447,
40042:24458,
40043:24456,
40044:24465,
40045:24455,
40046:24478,
40047:24473,
40048:24472,
40049:24480,
40050:24488,
40051:24493,
40052:24508,
40053:24534,
40054:24571,
40055:24548,
40056:24568,
40057:24561,
40058:24541,
40059:24755,
40060:24575,
40061:24609,
40062:24672,
40064:24601,
40065:24592,
40066:24617,
40067:24590,
40068:24625,
40069:24603,
40070:24597,
40071:24619,
40072:24614,
40073:24591,
40074:24634,
40075:24666,
40076:24641,
40077:24682,
40078:24695,
40079:24671,
40080:24650,
40081:24646,
40082:24653,
40083:24675,
40084:24643,
40085:24676,
40086:24642,
40087:24684,
40088:24683,
40089:24665,
40090:24705,
40091:24717,
40092:24807,
40093:24707,
40094:24730,
40095:24708,
40096:24731,
40097:24726,
40098:24727,
40099:24722,
40100:24743,
40101:24715,
40102:24801,
40103:24760,
40104:24800,
40105:24787,
40106:24756,
40107:24560,
40108:24765,
40109:24774,
40110:24757,
40111:24792,
40112:24909,
40113:24853,
40114:24838,
40115:24822,
40116:24823,
40117:24832,
40118:24820,
40119:24826,
40120:24835,
40121:24865,
40122:24827,
40123:24817,
40124:24845,
40125:24846,
40126:24903,
40127:24894,
40128:24872,
40129:24871,
40130:24906,
40131:24895,
40132:24892,
40133:24876,
40134:24884,
40135:24893,
40136:24898,
40137:24900,
40138:24947,
40139:24951,
40140:24920,
40141:24921,
40142:24922,
40143:24939,
40144:24948,
40145:24943,
40146:24933,
40147:24945,
40148:24927,
40149:24925,
40150:24915,
40151:24949,
40152:24985,
40153:24982,
40154:24967,
40155:25004,
40156:24980,
40157:24986,
40158:24970,
40159:24977,
40160:25003,
40161:25006,
40162:25036,
40163:25034,
40164:25033,
40165:25079,
40166:25032,
40167:25027,
40168:25030,
40169:25018,
40170:25035,
40171:32633,
40172:25037,
40173:25062,
40174:25059,
40175:25078,
40176:25082,
40177:25076,
40178:25087,
40179:25085,
40180:25084,
40181:25086,
40182:25088,
40183:25096,
40184:25097,
40185:25101,
40186:25100,
40187:25108,
40188:25115,
40256:25118,
40257:25121,
40258:25130,
40259:25134,
40260:25136,
40261:25138,
40262:25139,
40263:25153,
40264:25166,
40265:25182,
40266:25187,
40267:25179,
40268:25184,
40269:25192,
40270:25212,
40271:25218,
40272:25225,
40273:25214,
40274:25234,
40275:25235,
40276:25238,
40277:25300,
40278:25219,
40279:25236,
40280:25303,
40281:25297,
40282:25275,
40283:25295,
40284:25343,
40285:25286,
40286:25812,
40287:25288,
40288:25308,
40289:25292,
40290:25290,
40291:25282,
40292:25287,
40293:25243,
40294:25289,
40295:25356,
40296:25326,
40297:25329,
40298:25383,
40299:25346,
40300:25352,
40301:25327,
40302:25333,
40303:25424,
40304:25406,
40305:25421,
40306:25628,
40307:25423,
40308:25494,
40309:25486,
40310:25472,
40311:25515,
40312:25462,
40313:25507,
40314:25487,
40315:25481,
40316:25503,
40317:25525,
40318:25451,
40320:25449,
40321:25534,
40322:25577,
40323:25536,
40324:25542,
40325:25571,
40326:25545,
40327:25554,
40328:25590,
40329:25540,
40330:25622,
40331:25652,
40332:25606,
40333:25619,
40334:25638,
40335:25654,
40336:25885,
40337:25623,
40338:25640,
40339:25615,
40340:25703,
40341:25711,
40342:25718,
40343:25678,
40344:25898,
40345:25749,
40346:25747,
40347:25765,
40348:25769,
40349:25736,
40350:25788,
40351:25818,
40352:25810,
40353:25797,
40354:25799,
40355:25787,
40356:25816,
40357:25794,
40358:25841,
40359:25831,
40360:33289,
40361:25824,
40362:25825,
40363:25260,
40364:25827,
40365:25839,
40366:25900,
40367:25846,
40368:25844,
40369:25842,
40370:25850,
40371:25856,
40372:25853,
40373:25880,
40374:25884,
40375:25861,
40376:25892,
40377:25891,
40378:25899,
40379:25908,
40380:25909,
40381:25911,
40382:25910,
40383:25912,
40384:30027,
40385:25928,
40386:25942,
40387:25941,
40388:25933,
40389:25944,
40390:25950,
40391:25949,
40392:25970,
40393:25976,
40394:25986,
40395:25987,
40396:35722,
40397:26011,
40398:26015,
40399:26027,
40400:26039,
40401:26051,
40402:26054,
40403:26049,
40404:26052,
40405:26060,
40406:26066,
40407:26075,
40408:26073,
40409:26080,
40410:26081,
40411:26097,
40412:26482,
40413:26122,
40414:26115,
40415:26107,
40416:26483,
40417:26165,
40418:26166,
40419:26164,
40420:26140,
40421:26191,
40422:26180,
40423:26185,
40424:26177,
40425:26206,
40426:26205,
40427:26212,
40428:26215,
40429:26216,
40430:26207,
40431:26210,
40432:26224,
40433:26243,
40434:26248,
40435:26254,
40436:26249,
40437:26244,
40438:26264,
40439:26269,
40440:26305,
40441:26297,
40442:26313,
40443:26302,
40444:26300,
40512:26308,
40513:26296,
40514:26326,
40515:26330,
40516:26336,
40517:26175,
40518:26342,
40519:26345,
40520:26352,
40521:26357,
40522:26359,
40523:26383,
40524:26390,
40525:26398,
40526:26406,
40527:26407,
40528:38712,
40529:26414,
40530:26431,
40531:26422,
40532:26433,
40533:26424,
40534:26423,
40535:26438,
40536:26462,
40537:26464,
40538:26457,
40539:26467,
40540:26468,
40541:26505,
40542:26480,
40543:26537,
40544:26492,
40545:26474,
40546:26508,
40547:26507,
40548:26534,
40549:26529,
40550:26501,
40551:26551,
40552:26607,
40553:26548,
40554:26604,
40555:26547,
40556:26601,
40557:26552,
40558:26596,
40559:26590,
40560:26589,
40561:26594,
40562:26606,
40563:26553,
40564:26574,
40565:26566,
40566:26599,
40567:27292,
40568:26654,
40569:26694,
40570:26665,
40571:26688,
40572:26701,
40573:26674,
40574:26702,
40576:26803,
40577:26667,
40578:26713,
40579:26723,
40580:26743,
40581:26751,
40582:26783,
40583:26767,
40584:26797,
40585:26772,
40586:26781,
40587:26779,
40588:26755,
40589:27310,
40590:26809,
40591:26740,
40592:26805,
40593:26784,
40594:26810,
40595:26895,
40596:26765,
40597:26750,
40598:26881,
40599:26826,
40600:26888,
40601:26840,
40602:26914,
40603:26918,
40604:26849,
40605:26892,
40606:26829,
40607:26836,
40608:26855,
40609:26837,
40610:26934,
40611:26898,
40612:26884,
40613:26839,
40614:26851,
40615:26917,
40616:26873,
40617:26848,
40618:26863,
40619:26920,
40620:26922,
40621:26906,
40622:26915,
40623:26913,
40624:26822,
40625:27001,
40626:26999,
40627:26972,
40628:27000,
40629:26987,
40630:26964,
40631:27006,
40632:26990,
40633:26937,
40634:26996,
40635:26941,
40636:26969,
40637:26928,
40638:26977,
40639:26974,
40640:26973,
40641:27009,
40642:26986,
40643:27058,
40644:27054,
40645:27088,
40646:27071,
40647:27073,
40648:27091,
40649:27070,
40650:27086,
40651:23528,
40652:27082,
40653:27101,
40654:27067,
40655:27075,
40656:27047,
40657:27182,
40658:27025,
40659:27040,
40660:27036,
40661:27029,
40662:27060,
40663:27102,
40664:27112,
40665:27138,
40666:27163,
40667:27135,
40668:27402,
40669:27129,
40670:27122,
40671:27111,
40672:27141,
40673:27057,
40674:27166,
40675:27117,
40676:27156,
40677:27115,
40678:27146,
40679:27154,
40680:27329,
40681:27171,
40682:27155,
40683:27204,
40684:27148,
40685:27250,
40686:27190,
40687:27256,
40688:27207,
40689:27234,
40690:27225,
40691:27238,
40692:27208,
40693:27192,
40694:27170,
40695:27280,
40696:27277,
40697:27296,
40698:27268,
40699:27298,
40700:27299,
40768:27287,
40769:34327,
40770:27323,
40771:27331,
40772:27330,
40773:27320,
40774:27315,
40775:27308,
40776:27358,
40777:27345,
40778:27359,
40779:27306,
40780:27354,
40781:27370,
40782:27387,
40783:27397,
40784:34326,
40785:27386,
40786:27410,
40787:27414,
40788:39729,
40789:27423,
40790:27448,
40791:27447,
40792:30428,
40793:27449,
40794:39150,
40795:27463,
40796:27459,
40797:27465,
40798:27472,
40799:27481,
40800:27476,
40801:27483,
40802:27487,
40803:27489,
40804:27512,
40805:27513,
40806:27519,
40807:27520,
40808:27524,
40809:27523,
40810:27533,
40811:27544,
40812:27541,
40813:27550,
40814:27556,
40815:27562,
40816:27563,
40817:27567,
40818:27570,
40819:27569,
40820:27571,
40821:27575,
40822:27580,
40823:27590,
40824:27595,
40825:27603,
40826:27615,
40827:27628,
40828:27627,
40829:27635,
40830:27631,
40832:40638,
40833:27656,
40834:27667,
40835:27668,
40836:27675,
40837:27684,
40838:27683,
40839:27742,
40840:27733,
40841:27746,
40842:27754,
40843:27778,
40844:27789,
40845:27802,
40846:27777,
40847:27803,
40848:27774,
40849:27752,
40850:27763,
40851:27794,
40852:27792,
40853:27844,
40854:27889,
40855:27859,
40856:27837,
40857:27863,
40858:27845,
40859:27869,
40860:27822,
40861:27825,
40862:27838,
40863:27834,
40864:27867,
40865:27887,
40866:27865,
40867:27882,
40868:27935,
40869:34893,
40870:27958,
40871:27947,
40872:27965,
40873:27960,
40874:27929,
40875:27957,
40876:27955,
40877:27922,
40878:27916,
40879:28003,
40880:28051,
40881:28004,
40882:27994,
40883:28025,
40884:27993,
40885:28046,
40886:28053,
40887:28644,
40888:28037,
40889:28153,
40890:28181,
40891:28170,
40892:28085,
40893:28103,
40894:28134,
40895:28088,
40896:28102,
40897:28140,
40898:28126,
40899:28108,
40900:28136,
40901:28114,
40902:28101,
40903:28154,
40904:28121,
40905:28132,
40906:28117,
40907:28138,
40908:28142,
40909:28205,
40910:28270,
40911:28206,
40912:28185,
40913:28274,
40914:28255,
40915:28222,
40916:28195,
40917:28267,
40918:28203,
40919:28278,
40920:28237,
40921:28191,
40922:28227,
40923:28218,
40924:28238,
40925:28196,
40926:28415,
40927:28189,
40928:28216,
40929:28290,
40930:28330,
40931:28312,
40932:28361,
40933:28343,
40934:28371,
40935:28349,
40936:28335,
40937:28356,
40938:28338,
40939:28372,
40940:28373,
40941:28303,
40942:28325,
40943:28354,
40944:28319,
40945:28481,
40946:28433,
40947:28748,
40948:28396,
40949:28408,
40950:28414,
40951:28479,
40952:28402,
40953:28465,
40954:28399,
40955:28466,
40956:28364,
57408:28478,
57409:28435,
57410:28407,
57411:28550,
57412:28538,
57413:28536,
57414:28545,
57415:28544,
57416:28527,
57417:28507,
57418:28659,
57419:28525,
57420:28546,
57421:28540,
57422:28504,
57423:28558,
57424:28561,
57425:28610,
57426:28518,
57427:28595,
57428:28579,
57429:28577,
57430:28580,
57431:28601,
57432:28614,
57433:28586,
57434:28639,
57435:28629,
57436:28652,
57437:28628,
57438:28632,
57439:28657,
57440:28654,
57441:28635,
57442:28681,
57443:28683,
57444:28666,
57445:28689,
57446:28673,
57447:28687,
57448:28670,
57449:28699,
57450:28698,
57451:28532,
57452:28701,
57453:28696,
57454:28703,
57455:28720,
57456:28734,
57457:28722,
57458:28753,
57459:28771,
57460:28825,
57461:28818,
57462:28847,
57463:28913,
57464:28844,
57465:28856,
57466:28851,
57467:28846,
57468:28895,
57469:28875,
57470:28893,
57472:28889,
57473:28937,
57474:28925,
57475:28956,
57476:28953,
57477:29029,
57478:29013,
57479:29064,
57480:29030,
57481:29026,
57482:29004,
57483:29014,
57484:29036,
57485:29071,
57486:29179,
57487:29060,
57488:29077,
57489:29096,
57490:29100,
57491:29143,
57492:29113,
57493:29118,
57494:29138,
57495:29129,
57496:29140,
57497:29134,
57498:29152,
57499:29164,
57500:29159,
57501:29173,
57502:29180,
57503:29177,
57504:29183,
57505:29197,
57506:29200,
57507:29211,
57508:29224,
57509:29229,
57510:29228,
57511:29232,
57512:29234,
57513:29243,
57514:29244,
57515:29247,
57516:29248,
57517:29254,
57518:29259,
57519:29272,
57520:29300,
57521:29310,
57522:29314,
57523:29313,
57524:29319,
57525:29330,
57526:29334,
57527:29346,
57528:29351,
57529:29369,
57530:29362,
57531:29379,
57532:29382,
57533:29380,
57534:29390,
57535:29394,
57536:29410,
57537:29408,
57538:29409,
57539:29433,
57540:29431,
57541:20495,
57542:29463,
57543:29450,
57544:29468,
57545:29462,
57546:29469,
57547:29492,
57548:29487,
57549:29481,
57550:29477,
57551:29502,
57552:29518,
57553:29519,
57554:40664,
57555:29527,
57556:29546,
57557:29544,
57558:29552,
57559:29560,
57560:29557,
57561:29563,
57562:29562,
57563:29640,
57564:29619,
57565:29646,
57566:29627,
57567:29632,
57568:29669,
57569:29678,
57570:29662,
57571:29858,
57572:29701,
57573:29807,
57574:29733,
57575:29688,
57576:29746,
57577:29754,
57578:29781,
57579:29759,
57580:29791,
57581:29785,
57582:29761,
57583:29788,
57584:29801,
57585:29808,
57586:29795,
57587:29802,
57588:29814,
57589:29822,
57590:29835,
57591:29854,
57592:29863,
57593:29898,
57594:29903,
57595:29908,
57596:29681,
57664:29920,
57665:29923,
57666:29927,
57667:29929,
57668:29934,
57669:29938,
57670:29936,
57671:29937,
57672:29944,
57673:29943,
57674:29956,
57675:29955,
57676:29957,
57677:29964,
57678:29966,
57679:29965,
57680:29973,
57681:29971,
57682:29982,
57683:29990,
57684:29996,
57685:30012,
57686:30020,
57687:30029,
57688:30026,
57689:30025,
57690:30043,
57691:30022,
57692:30042,
57693:30057,
57694:30052,
57695:30055,
57696:30059,
57697:30061,
57698:30072,
57699:30070,
57700:30086,
57701:30087,
57702:30068,
57703:30090,
57704:30089,
57705:30082,
57706:30100,
57707:30106,
57708:30109,
57709:30117,
57710:30115,
57711:30146,
57712:30131,
57713:30147,
57714:30133,
57715:30141,
57716:30136,
57717:30140,
57718:30129,
57719:30157,
57720:30154,
57721:30162,
57722:30169,
57723:30179,
57724:30174,
57725:30206,
57726:30207,
57728:30204,
57729:30209,
57730:30192,
57731:30202,
57732:30194,
57733:30195,
57734:30219,
57735:30221,
57736:30217,
57737:30239,
57738:30247,
57739:30240,
57740:30241,
57741:30242,
57742:30244,
57743:30260,
57744:30256,
57745:30267,
57746:30279,
57747:30280,
57748:30278,
57749:30300,
57750:30296,
57751:30305,
57752:30306,
57753:30312,
57754:30313,
57755:30314,
57756:30311,
57757:30316,
57758:30320,
57759:30322,
57760:30326,
57761:30328,
57762:30332,
57763:30336,
57764:30339,
57765:30344,
57766:30347,
57767:30350,
57768:30358,
57769:30355,
57770:30361,
57771:30362,
57772:30384,
57773:30388,
57774:30392,
57775:30393,
57776:30394,
57777:30402,
57778:30413,
57779:30422,
57780:30418,
57781:30430,
57782:30433,
57783:30437,
57784:30439,
57785:30442,
57786:34351,
57787:30459,
57788:30472,
57789:30471,
57790:30468,
57791:30505,
57792:30500,
57793:30494,
57794:30501,
57795:30502,
57796:30491,
57797:30519,
57798:30520,
57799:30535,
57800:30554,
57801:30568,
57802:30571,
57803:30555,
57804:30565,
57805:30591,
57806:30590,
57807:30585,
57808:30606,
57809:30603,
57810:30609,
57811:30624,
57812:30622,
57813:30640,
57814:30646,
57815:30649,
57816:30655,
57817:30652,
57818:30653,
57819:30651,
57820:30663,
57821:30669,
57822:30679,
57823:30682,
57824:30684,
57825:30691,
57826:30702,
57827:30716,
57828:30732,
57829:30738,
57830:31014,
57831:30752,
57832:31018,
57833:30789,
57834:30862,
57835:30836,
57836:30854,
57837:30844,
57838:30874,
57839:30860,
57840:30883,
57841:30901,
57842:30890,
57843:30895,
57844:30929,
57845:30918,
57846:30923,
57847:30932,
57848:30910,
57849:30908,
57850:30917,
57851:30922,
57852:30956,
57920:30951,
57921:30938,
57922:30973,
57923:30964,
57924:30983,
57925:30994,
57926:30993,
57927:31001,
57928:31020,
57929:31019,
57930:31040,
57931:31072,
57932:31063,
57933:31071,
57934:31066,
57935:31061,
57936:31059,
57937:31098,
57938:31103,
57939:31114,
57940:31133,
57941:31143,
57942:40779,
57943:31146,
57944:31150,
57945:31155,
57946:31161,
57947:31162,
57948:31177,
57949:31189,
57950:31207,
57951:31212,
57952:31201,
57953:31203,
57954:31240,
57955:31245,
57956:31256,
57957:31257,
57958:31264,
57959:31263,
57960:31104,
57961:31281,
57962:31291,
57963:31294,
57964:31287,
57965:31299,
57966:31319,
57967:31305,
57968:31329,
57969:31330,
57970:31337,
57971:40861,
57972:31344,
57973:31353,
57974:31357,
57975:31368,
57976:31383,
57977:31381,
57978:31384,
57979:31382,
57980:31401,
57981:31432,
57982:31408,
57984:31414,
57985:31429,
57986:31428,
57987:31423,
57988:36995,
57989:31431,
57990:31434,
57991:31437,
57992:31439,
57993:31445,
57994:31443,
57995:31449,
57996:31450,
57997:31453,
57998:31457,
57999:31458,
58000:31462,
58001:31469,
58002:31472,
58003:31490,
58004:31503,
58005:31498,
58006:31494,
58007:31539,
58008:31512,
58009:31513,
58010:31518,
58011:31541,
58012:31528,
58013:31542,
58014:31568,
58015:31610,
58016:31492,
58017:31565,
58018:31499,
58019:31564,
58020:31557,
58021:31605,
58022:31589,
58023:31604,
58024:31591,
58025:31600,
58026:31601,
58027:31596,
58028:31598,
58029:31645,
58030:31640,
58031:31647,
58032:31629,
58033:31644,
58034:31642,
58035:31627,
58036:31634,
58037:31631,
58038:31581,
58039:31641,
58040:31691,
58041:31681,
58042:31692,
58043:31695,
58044:31668,
58045:31686,
58046:31709,
58047:31721,
58048:31761,
58049:31764,
58050:31718,
58051:31717,
58052:31840,
58053:31744,
58054:31751,
58055:31763,
58056:31731,
58057:31735,
58058:31767,
58059:31757,
58060:31734,
58061:31779,
58062:31783,
58063:31786,
58064:31775,
58065:31799,
58066:31787,
58067:31805,
58068:31820,
58069:31811,
58070:31828,
58071:31823,
58072:31808,
58073:31824,
58074:31832,
58075:31839,
58076:31844,
58077:31830,
58078:31845,
58079:31852,
58080:31861,
58081:31875,
58082:31888,
58083:31908,
58084:31917,
58085:31906,
58086:31915,
58087:31905,
58088:31912,
58089:31923,
58090:31922,
58091:31921,
58092:31918,
58093:31929,
58094:31933,
58095:31936,
58096:31941,
58097:31938,
58098:31960,
58099:31954,
58100:31964,
58101:31970,
58102:39739,
58103:31983,
58104:31986,
58105:31988,
58106:31990,
58107:31994,
58108:32006,
58176:32002,
58177:32028,
58178:32021,
58179:32010,
58180:32069,
58181:32075,
58182:32046,
58183:32050,
58184:32063,
58185:32053,
58186:32070,
58187:32115,
58188:32086,
58189:32078,
58190:32114,
58191:32104,
58192:32110,
58193:32079,
58194:32099,
58195:32147,
58196:32137,
58197:32091,
58198:32143,
58199:32125,
58200:32155,
58201:32186,
58202:32174,
58203:32163,
58204:32181,
58205:32199,
58206:32189,
58207:32171,
58208:32317,
58209:32162,
58210:32175,
58211:32220,
58212:32184,
58213:32159,
58214:32176,
58215:32216,
58216:32221,
58217:32228,
58218:32222,
58219:32251,
58220:32242,
58221:32225,
58222:32261,
58223:32266,
58224:32291,
58225:32289,
58226:32274,
58227:32305,
58228:32287,
58229:32265,
58230:32267,
58231:32290,
58232:32326,
58233:32358,
58234:32315,
58235:32309,
58236:32313,
58237:32323,
58238:32311,
58240:32306,
58241:32314,
58242:32359,
58243:32349,
58244:32342,
58245:32350,
58246:32345,
58247:32346,
58248:32377,
58249:32362,
58250:32361,
58251:32380,
58252:32379,
58253:32387,
58254:32213,
58255:32381,
58256:36782,
58257:32383,
58258:32392,
58259:32393,
58260:32396,
58261:32402,
58262:32400,
58263:32403,
58264:32404,
58265:32406,
58266:32398,
58267:32411,
58268:32412,
58269:32568,
58270:32570,
58271:32581,
58272:32588,
58273:32589,
58274:32590,
58275:32592,
58276:32593,
58277:32597,
58278:32596,
58279:32600,
58280:32607,
58281:32608,
58282:32616,
58283:32617,
58284:32615,
58285:32632,
58286:32642,
58287:32646,
58288:32643,
58289:32648,
58290:32647,
58291:32652,
58292:32660,
58293:32670,
58294:32669,
58295:32666,
58296:32675,
58297:32687,
58298:32690,
58299:32697,
58300:32686,
58301:32694,
58302:32696,
58303:35697,
58304:32709,
58305:32710,
58306:32714,
58307:32725,
58308:32724,
58309:32737,
58310:32742,
58311:32745,
58312:32755,
58313:32761,
58314:39132,
58315:32774,
58316:32772,
58317:32779,
58318:32786,
58319:32792,
58320:32793,
58321:32796,
58322:32801,
58323:32808,
58324:32831,
58325:32827,
58326:32842,
58327:32838,
58328:32850,
58329:32856,
58330:32858,
58331:32863,
58332:32866,
58333:32872,
58334:32883,
58335:32882,
58336:32880,
58337:32886,
58338:32889,
58339:32893,
58340:32895,
58341:32900,
58342:32902,
58343:32901,
58344:32923,
58345:32915,
58346:32922,
58347:32941,
58348:20880,
58349:32940,
58350:32987,
58351:32997,
58352:32985,
58353:32989,
58354:32964,
58355:32986,
58356:32982,
58357:33033,
58358:33007,
58359:33009,
58360:33051,
58361:33065,
58362:33059,
58363:33071,
58364:33099,
58432:38539,
58433:33094,
58434:33086,
58435:33107,
58436:33105,
58437:33020,
58438:33137,
58439:33134,
58440:33125,
58441:33126,
58442:33140,
58443:33155,
58444:33160,
58445:33162,
58446:33152,
58447:33154,
58448:33184,
58449:33173,
58450:33188,
58451:33187,
58452:33119,
58453:33171,
58454:33193,
58455:33200,
58456:33205,
58457:33214,
58458:33208,
58459:33213,
58460:33216,
58461:33218,
58462:33210,
58463:33225,
58464:33229,
58465:33233,
58466:33241,
58467:33240,
58468:33224,
58469:33242,
58470:33247,
58471:33248,
58472:33255,
58473:33274,
58474:33275,
58475:33278,
58476:33281,
58477:33282,
58478:33285,
58479:33287,
58480:33290,
58481:33293,
58482:33296,
58483:33302,
58484:33321,
58485:33323,
58486:33336,
58487:33331,
58488:33344,
58489:33369,
58490:33368,
58491:33373,
58492:33370,
58493:33375,
58494:33380,
58496:33378,
58497:33384,
58498:33386,
58499:33387,
58500:33326,
58501:33393,
58502:33399,
58503:33400,
58504:33406,
58505:33421,
58506:33426,
58507:33451,
58508:33439,
58509:33467,
58510:33452,
58511:33505,
58512:33507,
58513:33503,
58514:33490,
58515:33524,
58516:33523,
58517:33530,
58518:33683,
58519:33539,
58520:33531,
58521:33529,
58522:33502,
58523:33542,
58524:33500,
58525:33545,
58526:33497,
58527:33589,
58528:33588,
58529:33558,
58530:33586,
58531:33585,
58532:33600,
58533:33593,
58534:33616,
58535:33605,
58536:33583,
58537:33579,
58538:33559,
58539:33560,
58540:33669,
58541:33690,
58542:33706,
58543:33695,
58544:33698,
58545:33686,
58546:33571,
58547:33678,
58548:33671,
58549:33674,
58550:33660,
58551:33717,
58552:33651,
58553:33653,
58554:33696,
58555:33673,
58556:33704,
58557:33780,
58558:33811,
58559:33771,
58560:33742,
58561:33789,
58562:33795,
58563:33752,
58564:33803,
58565:33729,
58566:33783,
58567:33799,
58568:33760,
58569:33778,
58570:33805,
58571:33826,
58572:33824,
58573:33725,
58574:33848,
58575:34054,
58576:33787,
58577:33901,
58578:33834,
58579:33852,
58580:34138,
58581:33924,
58582:33911,
58583:33899,
58584:33965,
58585:33902,
58586:33922,
58587:33897,
58588:33862,
58589:33836,
58590:33903,
58591:33913,
58592:33845,
58593:33994,
58594:33890,
58595:33977,
58596:33983,
58597:33951,
58598:34009,
58599:33997,
58600:33979,
58601:34010,
58602:34000,
58603:33985,
58604:33990,
58605:34006,
58606:33953,
58607:34081,
58608:34047,
58609:34036,
58610:34071,
58611:34072,
58612:34092,
58613:34079,
58614:34069,
58615:34068,
58616:34044,
58617:34112,
58618:34147,
58619:34136,
58620:34120,
58688:34113,
58689:34306,
58690:34123,
58691:34133,
58692:34176,
58693:34212,
58694:34184,
58695:34193,
58696:34186,
58697:34216,
58698:34157,
58699:34196,
58700:34203,
58701:34282,
58702:34183,
58703:34204,
58704:34167,
58705:34174,
58706:34192,
58707:34249,
58708:34234,
58709:34255,
58710:34233,
58711:34256,
58712:34261,
58713:34269,
58714:34277,
58715:34268,
58716:34297,
58717:34314,
58718:34323,
58719:34315,
58720:34302,
58721:34298,
58722:34310,
58723:34338,
58724:34330,
58725:34352,
58726:34367,
58727:34381,
58728:20053,
58729:34388,
58730:34399,
58731:34407,
58732:34417,
58733:34451,
58734:34467,
58735:34473,
58736:34474,
58737:34443,
58738:34444,
58739:34486,
58740:34479,
58741:34500,
58742:34502,
58743:34480,
58744:34505,
58745:34851,
58746:34475,
58747:34516,
58748:34526,
58749:34537,
58750:34540,
58752:34527,
58753:34523,
58754:34543,
58755:34578,
58756:34566,
58757:34568,
58758:34560,
58759:34563,
58760:34555,
58761:34577,
58762:34569,
58763:34573,
58764:34553,
58765:34570,
58766:34612,
58767:34623,
58768:34615,
58769:34619,
58770:34597,
58771:34601,
58772:34586,
58773:34656,
58774:34655,
58775:34680,
58776:34636,
58777:34638,
58778:34676,
58779:34647,
58780:34664,
58781:34670,
58782:34649,
58783:34643,
58784:34659,
58785:34666,
58786:34821,
58787:34722,
58788:34719,
58789:34690,
58790:34735,
58791:34763,
58792:34749,
58793:34752,
58794:34768,
58795:38614,
58796:34731,
58797:34756,
58798:34739,
58799:34759,
58800:34758,
58801:34747,
58802:34799,
58803:34802,
58804:34784,
58805:34831,
58806:34829,
58807:34814,
58808:34806,
58809:34807,
58810:34830,
58811:34770,
58812:34833,
58813:34838,
58814:34837,
58815:34850,
58816:34849,
58817:34865,
58818:34870,
58819:34873,
58820:34855,
58821:34875,
58822:34884,
58823:34882,
58824:34898,
58825:34905,
58826:34910,
58827:34914,
58828:34923,
58829:34945,
58830:34942,
58831:34974,
58832:34933,
58833:34941,
58834:34997,
58835:34930,
58836:34946,
58837:34967,
58838:34962,
58839:34990,
58840:34969,
58841:34978,
58842:34957,
58843:34980,
58844:34992,
58845:35007,
58846:34993,
58847:35011,
58848:35012,
58849:35028,
58850:35032,
58851:35033,
58852:35037,
58853:35065,
58854:35074,
58855:35068,
58856:35060,
58857:35048,
58858:35058,
58859:35076,
58860:35084,
58861:35082,
58862:35091,
58863:35139,
58864:35102,
58865:35109,
58866:35114,
58867:35115,
58868:35137,
58869:35140,
58870:35131,
58871:35126,
58872:35128,
58873:35148,
58874:35101,
58875:35168,
58876:35166,
58944:35174,
58945:35172,
58946:35181,
58947:35178,
58948:35183,
58949:35188,
58950:35191,
58951:35198,
58952:35203,
58953:35208,
58954:35210,
58955:35219,
58956:35224,
58957:35233,
58958:35241,
58959:35238,
58960:35244,
58961:35247,
58962:35250,
58963:35258,
58964:35261,
58965:35263,
58966:35264,
58967:35290,
58968:35292,
58969:35293,
58970:35303,
58971:35316,
58972:35320,
58973:35331,
58974:35350,
58975:35344,
58976:35340,
58977:35355,
58978:35357,
58979:35365,
58980:35382,
58981:35393,
58982:35419,
58983:35410,
58984:35398,
58985:35400,
58986:35452,
58987:35437,
58988:35436,
58989:35426,
58990:35461,
58991:35458,
58992:35460,
58993:35496,
58994:35489,
58995:35473,
58996:35493,
58997:35494,
58998:35482,
58999:35491,
59000:35524,
59001:35533,
59002:35522,
59003:35546,
59004:35563,
59005:35571,
59006:35559,
59008:35556,
59009:35569,
59010:35604,
59011:35552,
59012:35554,
59013:35575,
59014:35550,
59015:35547,
59016:35596,
59017:35591,
59018:35610,
59019:35553,
59020:35606,
59021:35600,
59022:35607,
59023:35616,
59024:35635,
59025:38827,
59026:35622,
59027:35627,
59028:35646,
59029:35624,
59030:35649,
59031:35660,
59032:35663,
59033:35662,
59034:35657,
59035:35670,
59036:35675,
59037:35674,
59038:35691,
59039:35679,
59040:35692,
59041:35695,
59042:35700,
59043:35709,
59044:35712,
59045:35724,
59046:35726,
59047:35730,
59048:35731,
59049:35734,
59050:35737,
59051:35738,
59052:35898,
59053:35905,
59054:35903,
59055:35912,
59056:35916,
59057:35918,
59058:35920,
59059:35925,
59060:35938,
59061:35948,
59062:35960,
59063:35962,
59064:35970,
59065:35977,
59066:35973,
59067:35978,
59068:35981,
59069:35982,
59070:35988,
59071:35964,
59072:35992,
59073:25117,
59074:36013,
59075:36010,
59076:36029,
59077:36018,
59078:36019,
59079:36014,
59080:36022,
59081:36040,
59082:36033,
59083:36068,
59084:36067,
59085:36058,
59086:36093,
59087:36090,
59088:36091,
59089:36100,
59090:36101,
59091:36106,
59092:36103,
59093:36111,
59094:36109,
59095:36112,
59096:40782,
59097:36115,
59098:36045,
59099:36116,
59100:36118,
59101:36199,
59102:36205,
59103:36209,
59104:36211,
59105:36225,
59106:36249,
59107:36290,
59108:36286,
59109:36282,
59110:36303,
59111:36314,
59112:36310,
59113:36300,
59114:36315,
59115:36299,
59116:36330,
59117:36331,
59118:36319,
59119:36323,
59120:36348,
59121:36360,
59122:36361,
59123:36351,
59124:36381,
59125:36382,
59126:36368,
59127:36383,
59128:36418,
59129:36405,
59130:36400,
59131:36404,
59132:36426,
59200:36423,
59201:36425,
59202:36428,
59203:36432,
59204:36424,
59205:36441,
59206:36452,
59207:36448,
59208:36394,
59209:36451,
59210:36437,
59211:36470,
59212:36466,
59213:36476,
59214:36481,
59215:36487,
59216:36485,
59217:36484,
59218:36491,
59219:36490,
59220:36499,
59221:36497,
59222:36500,
59223:36505,
59224:36522,
59225:36513,
59226:36524,
59227:36528,
59228:36550,
59229:36529,
59230:36542,
59231:36549,
59232:36552,
59233:36555,
59234:36571,
59235:36579,
59236:36604,
59237:36603,
59238:36587,
59239:36606,
59240:36618,
59241:36613,
59242:36629,
59243:36626,
59244:36633,
59245:36627,
59246:36636,
59247:36639,
59248:36635,
59249:36620,
59250:36646,
59251:36659,
59252:36667,
59253:36665,
59254:36677,
59255:36674,
59256:36670,
59257:36684,
59258:36681,
59259:36678,
59260:36686,
59261:36695,
59262:36700,
59264:36706,
59265:36707,
59266:36708,
59267:36764,
59268:36767,
59269:36771,
59270:36781,
59271:36783,
59272:36791,
59273:36826,
59274:36837,
59275:36834,
59276:36842,
59277:36847,
59278:36999,
59279:36852,
59280:36869,
59281:36857,
59282:36858,
59283:36881,
59284:36885,
59285:36897,
59286:36877,
59287:36894,
59288:36886,
59289:36875,
59290:36903,
59291:36918,
59292:36917,
59293:36921,
59294:36856,
59295:36943,
59296:36944,
59297:36945,
59298:36946,
59299:36878,
59300:36937,
59301:36926,
59302:36950,
59303:36952,
59304:36958,
59305:36968,
59306:36975,
59307:36982,
59308:38568,
59309:36978,
59310:36994,
59311:36989,
59312:36993,
59313:36992,
59314:37002,
59315:37001,
59316:37007,
59317:37032,
59318:37039,
59319:37041,
59320:37045,
59321:37090,
59322:37092,
59323:25160,
59324:37083,
59325:37122,
59326:37138,
59327:37145,
59328:37170,
59329:37168,
59330:37194,
59331:37206,
59332:37208,
59333:37219,
59334:37221,
59335:37225,
59336:37235,
59337:37234,
59338:37259,
59339:37257,
59340:37250,
59341:37282,
59342:37291,
59343:37295,
59344:37290,
59345:37301,
59346:37300,
59347:37306,
59348:37312,
59349:37313,
59350:37321,
59351:37323,
59352:37328,
59353:37334,
59354:37343,
59355:37345,
59356:37339,
59357:37372,
59358:37365,
59359:37366,
59360:37406,
59361:37375,
59362:37396,
59363:37420,
59364:37397,
59365:37393,
59366:37470,
59367:37463,
59368:37445,
59369:37449,
59370:37476,
59371:37448,
59372:37525,
59373:37439,
59374:37451,
59375:37456,
59376:37532,
59377:37526,
59378:37523,
59379:37531,
59380:37466,
59381:37583,
59382:37561,
59383:37559,
59384:37609,
59385:37647,
59386:37626,
59387:37700,
59388:37678,
59456:37657,
59457:37666,
59458:37658,
59459:37667,
59460:37690,
59461:37685,
59462:37691,
59463:37724,
59464:37728,
59465:37756,
59466:37742,
59467:37718,
59468:37808,
59469:37804,
59470:37805,
59471:37780,
59472:37817,
59473:37846,
59474:37847,
59475:37864,
59476:37861,
59477:37848,
59478:37827,
59479:37853,
59480:37840,
59481:37832,
59482:37860,
59483:37914,
59484:37908,
59485:37907,
59486:37891,
59487:37895,
59488:37904,
59489:37942,
59490:37931,
59491:37941,
59492:37921,
59493:37946,
59494:37953,
59495:37970,
59496:37956,
59497:37979,
59498:37984,
59499:37986,
59500:37982,
59501:37994,
59502:37417,
59503:38000,
59504:38005,
59505:38007,
59506:38013,
59507:37978,
59508:38012,
59509:38014,
59510:38017,
59511:38015,
59512:38274,
59513:38279,
59514:38282,
59515:38292,
59516:38294,
59517:38296,
59518:38297,
59520:38304,
59521:38312,
59522:38311,
59523:38317,
59524:38332,
59525:38331,
59526:38329,
59527:38334,
59528:38346,
59529:28662,
59530:38339,
59531:38349,
59532:38348,
59533:38357,
59534:38356,
59535:38358,
59536:38364,
59537:38369,
59538:38373,
59539:38370,
59540:38433,
59541:38440,
59542:38446,
59543:38447,
59544:38466,
59545:38476,
59546:38479,
59547:38475,
59548:38519,
59549:38492,
59550:38494,
59551:38493,
59552:38495,
59553:38502,
59554:38514,
59555:38508,
59556:38541,
59557:38552,
59558:38549,
59559:38551,
59560:38570,
59561:38567,
59562:38577,
59563:38578,
59564:38576,
59565:38580,
59566:38582,
59567:38584,
59568:38585,
59569:38606,
59570:38603,
59571:38601,
59572:38605,
59573:35149,
59574:38620,
59575:38669,
59576:38613,
59577:38649,
59578:38660,
59579:38662,
59580:38664,
59581:38675,
59582:38670,
59583:38673,
59584:38671,
59585:38678,
59586:38681,
59587:38692,
59588:38698,
59589:38704,
59590:38713,
59591:38717,
59592:38718,
59593:38724,
59594:38726,
59595:38728,
59596:38722,
59597:38729,
59598:38748,
59599:38752,
59600:38756,
59601:38758,
59602:38760,
59603:21202,
59604:38763,
59605:38769,
59606:38777,
59607:38789,
59608:38780,
59609:38785,
59610:38778,
59611:38790,
59612:38795,
59613:38799,
59614:38800,
59615:38812,
59616:38824,
59617:38822,
59618:38819,
59619:38835,
59620:38836,
59621:38851,
59622:38854,
59623:38856,
59624:38859,
59625:38876,
59626:38893,
59627:40783,
59628:38898,
59629:31455,
59630:38902,
59631:38901,
59632:38927,
59633:38924,
59634:38968,
59635:38948,
59636:38945,
59637:38967,
59638:38973,
59639:38982,
59640:38991,
59641:38987,
59642:39019,
59643:39023,
59644:39024,
59712:39025,
59713:39028,
59714:39027,
59715:39082,
59716:39087,
59717:39089,
59718:39094,
59719:39108,
59720:39107,
59721:39110,
59722:39145,
59723:39147,
59724:39171,
59725:39177,
59726:39186,
59727:39188,
59728:39192,
59729:39201,
59730:39197,
59731:39198,
59732:39204,
59733:39200,
59734:39212,
59735:39214,
59736:39229,
59737:39230,
59738:39234,
59739:39241,
59740:39237,
59741:39248,
59742:39243,
59743:39249,
59744:39250,
59745:39244,
59746:39253,
59747:39319,
59748:39320,
59749:39333,
59750:39341,
59751:39342,
59752:39356,
59753:39391,
59754:39387,
59755:39389,
59756:39384,
59757:39377,
59758:39405,
59759:39406,
59760:39409,
59761:39410,
59762:39419,
59763:39416,
59764:39425,
59765:39439,
59766:39429,
59767:39394,
59768:39449,
59769:39467,
59770:39479,
59771:39493,
59772:39490,
59773:39488,
59774:39491,
59776:39486,
59777:39509,
59778:39501,
59779:39515,
59780:39511,
59781:39519,
59782:39522,
59783:39525,
59784:39524,
59785:39529,
59786:39531,
59787:39530,
59788:39597,
59789:39600,
59790:39612,
59791:39616,
59792:39631,
59793:39633,
59794:39635,
59795:39636,
59796:39646,
59797:39647,
59798:39650,
59799:39651,
59800:39654,
59801:39663,
59802:39659,
59803:39662,
59804:39668,
59805:39665,
59806:39671,
59807:39675,
59808:39686,
59809:39704,
59810:39706,
59811:39711,
59812:39714,
59813:39715,
59814:39717,
59815:39719,
59816:39720,
59817:39721,
59818:39722,
59819:39726,
59820:39727,
59821:39730,
59822:39748,
59823:39747,
59824:39759,
59825:39757,
59826:39758,
59827:39761,
59828:39768,
59829:39796,
59830:39827,
59831:39811,
59832:39825,
59833:39830,
59834:39831,
59835:39839,
59836:39840,
59837:39848,
59838:39860,
59839:39872,
59840:39882,
59841:39865,
59842:39878,
59843:39887,
59844:39889,
59845:39890,
59846:39907,
59847:39906,
59848:39908,
59849:39892,
59850:39905,
59851:39994,
59852:39922,
59853:39921,
59854:39920,
59855:39957,
59856:39956,
59857:39945,
59858:39955,
59859:39948,
59860:39942,
59861:39944,
59862:39954,
59863:39946,
59864:39940,
59865:39982,
59866:39963,
59867:39973,
59868:39972,
59869:39969,
59870:39984,
59871:40007,
59872:39986,
59873:40006,
59874:39998,
59875:40026,
59876:40032,
59877:40039,
59878:40054,
59879:40056,
59880:40167,
59881:40172,
59882:40176,
59883:40201,
59884:40200,
59885:40171,
59886:40195,
59887:40198,
59888:40234,
59889:40230,
59890:40367,
59891:40227,
59892:40223,
59893:40260,
59894:40213,
59895:40210,
59896:40257,
59897:40255,
59898:40254,
59899:40262,
59900:40264,
59968:40285,
59969:40286,
59970:40292,
59971:40273,
59972:40272,
59973:40281,
59974:40306,
59975:40329,
59976:40327,
59977:40363,
59978:40303,
59979:40314,
59980:40346,
59981:40356,
59982:40361,
59983:40370,
59984:40388,
59985:40385,
59986:40379,
59987:40376,
59988:40378,
59989:40390,
59990:40399,
59991:40386,
59992:40409,
59993:40403,
59994:40440,
59995:40422,
59996:40429,
59997:40431,
59998:40445,
59999:40474,
60000:40475,
60001:40478,
60002:40565,
60003:40569,
60004:40573,
60005:40577,
60006:40584,
60007:40587,
60008:40588,
60009:40594,
60010:40597,
60011:40593,
60012:40605,
60013:40613,
60014:40617,
60015:40632,
60016:40618,
60017:40621,
60018:38753,
60019:40652,
60020:40654,
60021:40655,
60022:40656,
60023:40660,
60024:40668,
60025:40670,
60026:40669,
60027:40672,
60028:40677,
60029:40680,
60030:40687,
60032:40692,
60033:40694,
60034:40695,
60035:40697,
60036:40699,
60037:40700,
60038:40701,
60039:40711,
60040:40712,
60041:30391,
60042:40725,
60043:40737,
60044:40748,
60045:40766,
60046:40778,
60047:40786,
60048:40788,
60049:40803,
60050:40799,
60051:40800,
60052:40801,
60053:40806,
60054:40807,
60055:40812,
60056:40810,
60057:40823,
60058:40818,
60059:40822,
60060:40853,
60061:40860,
60062:40864,
60063:22575,
60064:27079,
60065:36953,
60066:29796,
60067:20956,
60068:29081,
60736:32394,
60737:35100,
60738:37704,
60739:37512,
60740:34012,
60741:20425,
60742:28859,
60743:26161,
60744:26824,
60745:37625,
60746:26363,
60747:24389,
60748:20008,
60749:20193,
60750:20220,
60751:20224,
60752:20227,
60753:20281,
60754:20310,
60755:20370,
60756:20362,
60757:20378,
60758:20372,
60759:20429,
60760:20544,
60761:20514,
60762:20479,
60763:20510,
60764:20550,
60765:20592,
60766:20546,
60767:20628,
60768:20724,
60769:20696,
60770:20810,
60771:20836,
60772:20893,
60773:20926,
60774:20972,
60775:21013,
60776:21148,
60777:21158,
60778:21184,
60779:21211,
60780:21248,
60781:21255,
60782:21284,
60783:21362,
60784:21395,
60785:21426,
60786:21469,
60787:64014,
60788:21660,
60789:21642,
60790:21673,
60791:21759,
60792:21894,
60793:22361,
60794:22373,
60795:22444,
60796:22472,
60797:22471,
60798:64015,
60800:64016,
60801:22686,
60802:22706,
60803:22795,
60804:22867,
60805:22875,
60806:22877,
60807:22883,
60808:22948,
60809:22970,
60810:23382,
60811:23488,
60812:29999,
60813:23512,
60814:23532,
60815:23582,
60816:23718,
60817:23738,
60818:23797,
60819:23847,
60820:23891,
60821:64017,
60822:23874,
60823:23917,
60824:23992,
60825:23993,
60826:24016,
60827:24353,
60828:24372,
60829:24423,
60830:24503,
60831:24542,
60832:24669,
60833:24709,
60834:24714,
60835:24798,
60836:24789,
60837:24864,
60838:24818,
60839:24849,
60840:24887,
60841:24880,
60842:24984,
60843:25107,
60844:25254,
60845:25589,
60846:25696,
60847:25757,
60848:25806,
60849:25934,
60850:26112,
60851:26133,
60852:26171,
60853:26121,
60854:26158,
60855:26142,
60856:26148,
60857:26213,
60858:26199,
60859:26201,
60860:64018,
60861:26227,
60862:26265,
60863:26272,
60864:26290,
60865:26303,
60866:26362,
60867:26382,
60868:63785,
60869:26470,
60870:26555,
60871:26706,
60872:26560,
60873:26625,
60874:26692,
60875:26831,
60876:64019,
60877:26984,
60878:64020,
60879:27032,
60880:27106,
60881:27184,
60882:27243,
60883:27206,
60884:27251,
60885:27262,
60886:27362,
60887:27364,
60888:27606,
60889:27711,
60890:27740,
60891:27782,
60892:27759,
60893:27866,
60894:27908,
60895:28039,
60896:28015,
60897:28054,
60898:28076,
60899:28111,
60900:28152,
60901:28146,
60902:28156,
60903:28217,
60904:28252,
60905:28199,
60906:28220,
60907:28351,
60908:28552,
60909:28597,
60910:28661,
60911:28677,
60912:28679,
60913:28712,
60914:28805,
60915:28843,
60916:28943,
60917:28932,
60918:29020,
60919:28998,
60920:28999,
60921:64021,
60922:29121,
60923:29182,
60924:29361,
60992:29374,
60993:29476,
60994:64022,
60995:29559,
60996:29629,
60997:29641,
60998:29654,
60999:29667,
61000:29650,
61001:29703,
61002:29685,
61003:29734,
61004:29738,
61005:29737,
61006:29742,
61007:29794,
61008:29833,
61009:29855,
61010:29953,
61011:30063,
61012:30338,
61013:30364,
61014:30366,
61015:30363,
61016:30374,
61017:64023,
61018:30534,
61019:21167,
61020:30753,
61021:30798,
61022:30820,
61023:30842,
61024:31024,
61025:64024,
61026:64025,
61027:64026,
61028:31124,
61029:64027,
61030:31131,
61031:31441,
61032:31463,
61033:64028,
61034:31467,
61035:31646,
61036:64029,
61037:32072,
61038:32092,
61039:32183,
61040:32160,
61041:32214,
61042:32338,
61043:32583,
61044:32673,
61045:64030,
61046:33537,
61047:33634,
61048:33663,
61049:33735,
61050:33782,
61051:33864,
61052:33972,
61053:34131,
61054:34137,
61056:34155,
61057:64031,
61058:34224,
61059:64032,
61060:64033,
61061:34823,
61062:35061,
61063:35346,
61064:35383,
61065:35449,
61066:35495,
61067:35518,
61068:35551,
61069:64034,
61070:35574,
61071:35667,
61072:35711,
61073:36080,
61074:36084,
61075:36114,
61076:36214,
61077:64035,
61078:36559,
61079:64036,
61080:64037,
61081:36967,
61082:37086,
61083:64038,
61084:37141,
61085:37159,
61086:37338,
61087:37335,
61088:37342,
61089:37357,
61090:37358,
61091:37348,
61092:37349,
61093:37382,
61094:37392,
61095:37386,
61096:37434,
61097:37440,
61098:37436,
61099:37454,
61100:37465,
61101:37457,
61102:37433,
61103:37479,
61104:37543,
61105:37495,
61106:37496,
61107:37607,
61108:37591,
61109:37593,
61110:37584,
61111:64039,
61112:37589,
61113:37600,
61114:37587,
61115:37669,
61116:37665,
61117:37627,
61118:64040,
61119:37662,
61120:37631,
61121:37661,
61122:37634,
61123:37744,
61124:37719,
61125:37796,
61126:37830,
61127:37854,
61128:37880,
61129:37937,
61130:37957,
61131:37960,
61132:38290,
61133:63964,
61134:64041,
61135:38557,
61136:38575,
61137:38707,
61138:38715,
61139:38723,
61140:38733,
61141:38735,
61142:38737,
61143:38741,
61144:38999,
61145:39013,
61146:64042,
61147:64043,
61148:39207,
61149:64044,
61150:39326,
61151:39502,
61152:39641,
61153:39644,
61154:39797,
61155:39794,
61156:39823,
61157:39857,
61158:39867,
61159:39936,
61160:40304,
61161:40299,
61162:64045,
61163:40473,
61164:40657,
61167:8560,
61168:8561,
61169:8562,
61170:8563,
61171:8564,
61172:8565,
61173:8566,
61174:8567,
61175:8568,
61176:8569,
61177:65506,
61178:65508,
61179:65287,
61180:65282,
61504:57344,
61505:57345,
61506:57346,
61507:57347,
61508:57348,
61509:57349,
61510:57350,
61511:57351,
61512:57352,
61513:57353,
61514:57354,
61515:57355,
61516:57356,
61517:57357,
61518:57358,
61519:57359,
61520:57360,
61521:57361,
61522:57362,
61523:57363,
61524:57364,
61525:57365,
61526:57366,
61527:57367,
61528:57368,
61529:57369,
61530:57370,
61531:57371,
61532:57372,
61533:57373,
61534:57374,
61535:57375,
61536:57376,
61537:57377,
61538:57378,
61539:57379,
61540:57380,
61541:57381,
61542:57382,
61543:57383,
61544:57384,
61545:57385,
61546:57386,
61547:57387,
61548:57388,
61549:57389,
61550:57390,
61551:57391,
61552:57392,
61553:57393,
61554:57394,
61555:57395,
61556:57396,
61557:57397,
61558:57398,
61559:57399,
61560:57400,
61561:57401,
61562:57402,
61563:57403,
61564:57404,
61565:57405,
61566:57406,
61568:57407,
61569:57408,
61570:57409,
61571:57410,
61572:57411,
61573:57412,
61574:57413,
61575:57414,
61576:57415,
61577:57416,
61578:57417,
61579:57418,
61580:57419,
61581:57420,
61582:57421,
61583:57422,
61584:57423,
61585:57424,
61586:57425,
61587:57426,
61588:57427,
61589:57428,
61590:57429,
61591:57430,
61592:57431,
61593:57432,
61594:57433,
61595:57434,
61596:57435,
61597:57436,
61598:57437,
61599:57438,
61600:57439,
61601:57440,
61602:57441,
61603:57442,
61604:57443,
61605:57444,
61606:57445,
61607:57446,
61608:57447,
61609:57448,
61610:57449,
61611:57450,
61612:57451,
61613:57452,
61614:57453,
61615:57454,
61616:57455,
61617:57456,
61618:57457,
61619:57458,
61620:57459,
61621:57460,
61622:57461,
61623:57462,
61624:57463,
61625:57464,
61626:57465,
61627:57466,
61628:57467,
61629:57468,
61630:57469,
61631:57470,
61632:57471,
61633:57472,
61634:57473,
61635:57474,
61636:57475,
61637:57476,
61638:57477,
61639:57478,
61640:57479,
61641:57480,
61642:57481,
61643:57482,
61644:57483,
61645:57484,
61646:57485,
61647:57486,
61648:57487,
61649:57488,
61650:57489,
61651:57490,
61652:57491,
61653:57492,
61654:57493,
61655:57494,
61656:57495,
61657:57496,
61658:57497,
61659:57498,
61660:57499,
61661:57500,
61662:57501,
61663:57502,
61664:57503,
61665:57504,
61666:57505,
61667:57506,
61668:57507,
61669:57508,
61670:57509,
61671:57510,
61672:57511,
61673:57512,
61674:57513,
61675:57514,
61676:57515,
61677:57516,
61678:57517,
61679:57518,
61680:57519,
61681:57520,
61682:57521,
61683:57522,
61684:57523,
61685:57524,
61686:57525,
61687:57526,
61688:57527,
61689:57528,
61690:57529,
61691:57530,
61692:57531,
61760:57532,
61761:57533,
61762:57534,
61763:57535,
61764:57536,
61765:57537,
61766:57538,
61767:57539,
61768:57540,
61769:57541,
61770:57542,
61771:57543,
61772:57544,
61773:57545,
61774:57546,
61775:57547,
61776:57548,
61777:57549,
61778:57550,
61779:57551,
61780:57552,
61781:57553,
61782:57554,
61783:57555,
61784:57556,
61785:57557,
61786:57558,
61787:57559,
61788:57560,
61789:57561,
61790:57562,
61791:57563,
61792:57564,
61793:57565,
61794:57566,
61795:57567,
61796:57568,
61797:57569,
61798:57570,
61799:57571,
61800:57572,
61801:57573,
61802:57574,
61803:57575,
61804:57576,
61805:57577,
61806:57578,
61807:57579,
61808:57580,
61809:57581,
61810:57582,
61811:57583,
61812:57584,
61813:57585,
61814:57586,
61815:57587,
61816:57588,
61817:57589,
61818:57590,
61819:57591,
61820:57592,
61821:57593,
61822:57594,
61824:57595,
61825:57596,
61826:57597,
61827:57598,
61828:57599,
61829:57600,
61830:57601,
61831:57602,
61832:57603,
61833:57604,
61834:57605,
61835:57606,
61836:57607,
61837:57608,
61838:57609,
61839:57610,
61840:57611,
61841:57612,
61842:57613,
61843:57614,
61844:57615,
61845:57616,
61846:57617,
61847:57618,
61848:57619,
61849:57620,
61850:57621,
61851:57622,
61852:57623,
61853:57624,
61854:57625,
61855:57626,
61856:57627,
61857:57628,
61858:57629,
61859:57630,
61860:57631,
61861:57632,
61862:57633,
61863:57634,
61864:57635,
61865:57636,
61866:57637,
61867:57638,
61868:57639,
61869:57640,
61870:57641,
61871:57642,
61872:57643,
61873:57644,
61874:57645,
61875:57646,
61876:57647,
61877:57648,
61878:57649,
61879:57650,
61880:57651,
61881:57652,
61882:57653,
61883:57654,
61884:57655,
61885:57656,
61886:57657,
61887:57658,
61888:57659,
61889:57660,
61890:57661,
61891:57662,
61892:57663,
61893:57664,
61894:57665,
61895:57666,
61896:57667,
61897:57668,
61898:57669,
61899:57670,
61900:57671,
61901:57672,
61902:57673,
61903:57674,
61904:57675,
61905:57676,
61906:57677,
61907:57678,
61908:57679,
61909:57680,
61910:57681,
61911:57682,
61912:57683,
61913:57684,
61914:57685,
61915:57686,
61916:57687,
61917:57688,
61918:57689,
61919:57690,
61920:57691,
61921:57692,
61922:57693,
61923:57694,
61924:57695,
61925:57696,
61926:57697,
61927:57698,
61928:57699,
61929:57700,
61930:57701,
61931:57702,
61932:57703,
61933:57704,
61934:57705,
61935:57706,
61936:57707,
61937:57708,
61938:57709,
61939:57710,
61940:57711,
61941:57712,
61942:57713,
61943:57714,
61944:57715,
61945:57716,
61946:57717,
61947:57718,
61948:57719,
62016:57720,
62017:57721,
62018:57722,
62019:57723,
62020:57724,
62021:57725,
62022:57726,
62023:57727,
62024:57728,
62025:57729,
62026:57730,
62027:57731,
62028:57732,
62029:57733,
62030:57734,
62031:57735,
62032:57736,
62033:57737,
62034:57738,
62035:57739,
62036:57740,
62037:57741,
62038:57742,
62039:57743,
62040:57744,
62041:57745,
62042:57746,
62043:57747,
62044:57748,
62045:57749,
62046:57750,
62047:57751,
62048:57752,
62049:57753,
62050:57754,
62051:57755,
62052:57756,
62053:57757,
62054:57758,
62055:57759,
62056:57760,
62057:57761,
62058:57762,
62059:57763,
62060:57764,
62061:57765,
62062:57766,
62063:57767,
62064:57768,
62065:57769,
62066:57770,
62067:57771,
62068:57772,
62069:57773,
62070:57774,
62071:57775,
62072:57776,
62073:57777,
62074:57778,
62075:57779,
62076:57780,
62077:57781,
62078:57782,
62080:57783,
62081:57784,
62082:57785,
62083:57786,
62084:57787,
62085:57788,
62086:57789,
62087:57790,
62088:57791,
62089:57792,
62090:57793,
62091:57794,
62092:57795,
62093:57796,
62094:57797,
62095:57798,
62096:57799,
62097:57800,
62098:57801,
62099:57802,
62100:57803,
62101:57804,
62102:57805,
62103:57806,
62104:57807,
62105:57808,
62106:57809,
62107:57810,
62108:57811,
62109:57812,
62110:57813,
62111:57814,
62112:57815,
62113:57816,
62114:57817,
62115:57818,
62116:57819,
62117:57820,
62118:57821,
62119:57822,
62120:57823,
62121:57824,
62122:57825,
62123:57826,
62124:57827,
62125:57828,
62126:57829,
62127:57830,
62128:57831,
62129:57832,
62130:57833,
62131:57834,
62132:57835,
62133:57836,
62134:57837,
62135:57838,
62136:57839,
62137:57840,
62138:57841,
62139:57842,
62140:57843,
62141:57844,
62142:57845,
62143:57846,
62144:57847,
62145:57848,
62146:57849,
62147:57850,
62148:57851,
62149:57852,
62150:57853,
62151:57854,
62152:57855,
62153:57856,
62154:57857,
62155:57858,
62156:57859,
62157:57860,
62158:57861,
62159:57862,
62160:57863,
62161:57864,
62162:57865,
62163:57866,
62164:57867,
62165:57868,
62166:57869,
62167:57870,
62168:57871,
62169:57872,
62170:57873,
62171:57874,
62172:57875,
62173:57876,
62174:57877,
62175:57878,
62176:57879,
62177:57880,
62178:57881,
62179:57882,
62180:57883,
62181:57884,
62182:57885,
62183:57886,
62184:57887,
62185:57888,
62186:57889,
62187:57890,
62188:57891,
62189:57892,
62190:57893,
62191:57894,
62192:57895,
62193:57896,
62194:57897,
62195:57898,
62196:57899,
62197:57900,
62198:57901,
62199:57902,
62200:57903,
62201:57904,
62202:57905,
62203:57906,
62204:57907,
62272:57908,
62273:57909,
62274:57910,
62275:57911,
62276:57912,
62277:57913,
62278:57914,
62279:57915,
62280:57916,
62281:57917,
62282:57918,
62283:57919,
62284:57920,
62285:57921,
62286:57922,
62287:57923,
62288:57924,
62289:57925,
62290:57926,
62291:57927,
62292:57928,
62293:57929,
62294:57930,
62295:57931,
62296:57932,
62297:57933,
62298:57934,
62299:57935,
62300:57936,
62301:57937,
62302:57938,
62303:57939,
62304:57940,
62305:57941,
62306:57942,
62307:57943,
62308:57944,
62309:57945,
62310:57946,
62311:57947,
62312:57948,
62313:57949,
62314:57950,
62315:57951,
62316:57952,
62317:57953,
62318:57954,
62319:57955,
62320:57956,
62321:57957,
62322:57958,
62323:57959,
62324:57960,
62325:57961,
62326:57962,
62327:57963,
62328:57964,
62329:57965,
62330:57966,
62331:57967,
62332:57968,
62333:57969,
62334:57970,
62336:57971,
62337:57972,
62338:57973,
62339:57974,
62340:57975,
62341:57976,
62342:57977,
62343:57978,
62344:57979,
62345:57980,
62346:57981,
62347:57982,
62348:57983,
62349:57984,
62350:57985,
62351:57986,
62352:57987,
62353:57988,
62354:57989,
62355:57990,
62356:57991,
62357:57992,
62358:57993,
62359:57994,
62360:57995,
62361:57996,
62362:57997,
62363:57998,
62364:57999,
62365:58000,
62366:58001,
62367:58002,
62368:58003,
62369:58004,
62370:58005,
62371:58006,
62372:58007,
62373:58008,
62374:58009,
62375:58010,
62376:58011,
62377:58012,
62378:58013,
62379:58014,
62380:58015,
62381:58016,
62382:58017,
62383:58018,
62384:58019,
62385:58020,
62386:58021,
62387:58022,
62388:58023,
62389:58024,
62390:58025,
62391:58026,
62392:58027,
62393:58028,
62394:58029,
62395:58030,
62396:58031,
62397:58032,
62398:58033,
62399:58034,
62400:58035,
62401:58036,
62402:58037,
62403:58038,
62404:58039,
62405:58040,
62406:58041,
62407:58042,
62408:58043,
62409:58044,
62410:58045,
62411:58046,
62412:58047,
62413:58048,
62414:58049,
62415:58050,
62416:58051,
62417:58052,
62418:58053,
62419:58054,
62420:58055,
62421:58056,
62422:58057,
62423:58058,
62424:58059,
62425:58060,
62426:58061,
62427:58062,
62428:58063,
62429:58064,
62430:58065,
62431:58066,
62432:58067,
62433:58068,
62434:58069,
62435:58070,
62436:58071,
62437:58072,
62438:58073,
62439:58074,
62440:58075,
62441:58076,
62442:58077,
62443:58078,
62444:58079,
62445:58080,
62446:58081,
62447:58082,
62448:58083,
62449:58084,
62450:58085,
62451:58086,
62452:58087,
62453:58088,
62454:58089,
62455:58090,
62456:58091,
62457:58092,
62458:58093,
62459:58094,
62460:58095,
62528:58096,
62529:58097,
62530:58098,
62531:58099,
62532:58100,
62533:58101,
62534:58102,
62535:58103,
62536:58104,
62537:58105,
62538:58106,
62539:58107,
62540:58108,
62541:58109,
62542:58110,
62543:58111,
62544:58112,
62545:58113,
62546:58114,
62547:58115,
62548:58116,
62549:58117,
62550:58118,
62551:58119,
62552:58120,
62553:58121,
62554:58122,
62555:58123,
62556:58124,
62557:58125,
62558:58126,
62559:58127,
62560:58128,
62561:58129,
62562:58130,
62563:58131,
62564:58132,
62565:58133,
62566:58134,
62567:58135,
62568:58136,
62569:58137,
62570:58138,
62571:58139,
62572:58140,
62573:58141,
62574:58142,
62575:58143,
62576:58144,
62577:58145,
62578:58146,
62579:58147,
62580:58148,
62581:58149,
62582:58150,
62583:58151,
62584:58152,
62585:58153,
62586:58154,
62587:58155,
62588:58156,
62589:58157,
62590:58158,
62592:58159,
62593:58160,
62594:58161,
62595:58162,
62596:58163,
62597:58164,
62598:58165,
62599:58166,
62600:58167,
62601:58168,
62602:58169,
62603:58170,
62604:58171,
62605:58172,
62606:58173,
62607:58174,
62608:58175,
62609:58176,
62610:58177,
62611:58178,
62612:58179,
62613:58180,
62614:58181,
62615:58182,
62616:58183,
62617:58184,
62618:58185,
62619:58186,
62620:58187,
62621:58188,
62622:58189,
62623:58190,
62624:58191,
62625:58192,
62626:58193,
62627:58194,
62628:58195,
62629:58196,
62630:58197,
62631:58198,
62632:58199,
62633:58200,
62634:58201,
62635:58202,
62636:58203,
62637:58204,
62638:58205,
62639:58206,
62640:58207,
62641:58208,
62642:58209,
62643:58210,
62644:58211,
62645:58212,
62646:58213,
62647:58214,
62648:58215,
62649:58216,
62650:58217,
62651:58218,
62652:58219,
62653:58220,
62654:58221,
62655:58222,
62656:58223,
62657:58224,
62658:58225,
62659:58226,
62660:58227,
62661:58228,
62662:58229,
62663:58230,
62664:58231,
62665:58232,
62666:58233,
62667:58234,
62668:58235,
62669:58236,
62670:58237,
62671:58238,
62672:58239,
62673:58240,
62674:58241,
62675:58242,
62676:58243,
62677:58244,
62678:58245,
62679:58246,
62680:58247,
62681:58248,
62682:58249,
62683:58250,
62684:58251,
62685:58252,
62686:58253,
62687:58254,
62688:58255,
62689:58256,
62690:58257,
62691:58258,
62692:58259,
62693:58260,
62694:58261,
62695:58262,
62696:58263,
62697:58264,
62698:58265,
62699:58266,
62700:58267,
62701:58268,
62702:58269,
62703:58270,
62704:58271,
62705:58272,
62706:58273,
62707:58274,
62708:58275,
62709:58276,
62710:58277,
62711:58278,
62712:58279,
62713:58280,
62714:58281,
62715:58282,
62716:58283,
62784:58284,
62785:58285,
62786:58286,
62787:58287,
62788:58288,
62789:58289,
62790:58290,
62791:58291,
62792:58292,
62793:58293,
62794:58294,
62795:58295,
62796:58296,
62797:58297,
62798:58298,
62799:58299,
62800:58300,
62801:58301,
62802:58302,
62803:58303,
62804:58304,
62805:58305,
62806:58306,
62807:58307,
62808:58308,
62809:58309,
62810:58310,
62811:58311,
62812:58312,
62813:58313,
62814:58314,
62815:58315,
62816:58316,
62817:58317,
62818:58318,
62819:58319,
62820:58320,
62821:58321,
62822:58322,
62823:58323,
62824:58324,
62825:58325,
62826:58326,
62827:58327,
62828:58328,
62829:58329,
62830:58330,
62831:58331,
62832:58332,
62833:58333,
62834:58334,
62835:58335,
62836:58336,
62837:58337,
62838:58338,
62839:58339,
62840:58340,
62841:58341,
62842:58342,
62843:58343,
62844:58344,
62845:58345,
62846:58346,
62848:58347,
62849:58348,
62850:58349,
62851:58350,
62852:58351,
62853:58352,
62854:58353,
62855:58354,
62856:58355,
62857:58356,
62858:58357,
62859:58358,
62860:58359,
62861:58360,
62862:58361,
62863:58362,
62864:58363,
62865:58364,
62866:58365,
62867:58366,
62868:58367,
62869:58368,
62870:58369,
62871:58370,
62872:58371,
62873:58372,
62874:58373,
62875:58374,
62876:58375,
62877:58376,
62878:58377,
62879:58378,
62880:58379,
62881:58380,
62882:58381,
62883:58382,
62884:58383,
62885:58384,
62886:58385,
62887:58386,
62888:58387,
62889:58388,
62890:58389,
62891:58390,
62892:58391,
62893:58392,
62894:58393,
62895:58394,
62896:58395,
62897:58396,
62898:58397,
62899:58398,
62900:58399,
62901:58400,
62902:58401,
62903:58402,
62904:58403,
62905:58404,
62906:58405,
62907:58406,
62908:58407,
62909:58408,
62910:58409,
62911:58410,
62912:58411,
62913:58412,
62914:58413,
62915:58414,
62916:58415,
62917:58416,
62918:58417,
62919:58418,
62920:58419,
62921:58420,
62922:58421,
62923:58422,
62924:58423,
62925:58424,
62926:58425,
62927:58426,
62928:58427,
62929:58428,
62930:58429,
62931:58430,
62932:58431,
62933:58432,
62934:58433,
62935:58434,
62936:58435,
62937:58436,
62938:58437,
62939:58438,
62940:58439,
62941:58440,
62942:58441,
62943:58442,
62944:58443,
62945:58444,
62946:58445,
62947:58446,
62948:58447,
62949:58448,
62950:58449,
62951:58450,
62952:58451,
62953:58452,
62954:58453,
62955:58454,
62956:58455,
62957:58456,
62958:58457,
62959:58458,
62960:58459,
62961:58460,
62962:58461,
62963:58462,
62964:58463,
62965:58464,
62966:58465,
62967:58466,
62968:58467,
62969:58468,
62970:58469,
62971:58470,
62972:58471,
63040:58472,
63041:58473,
63042:58474,
63043:58475,
63044:58476,
63045:58477,
63046:58478,
63047:58479,
63048:58480,
63049:58481,
63050:58482,
63051:58483,
63052:58484,
63053:58485,
63054:58486,
63055:58487,
63056:58488,
63057:58489,
63058:58490,
63059:58491,
63060:58492,
63061:58493,
63062:58494,
63063:58495,
63064:58496,
63065:58497,
63066:58498,
63067:58499,
63068:58500,
63069:58501,
63070:58502,
63071:58503,
63072:58504,
63073:58505,
63074:58506,
63075:58507,
63076:58508,
63077:58509,
63078:58510,
63079:58511,
63080:58512,
63081:58513,
63082:58514,
63083:58515,
63084:58516,
63085:58517,
63086:58518,
63087:58519,
63088:58520,
63089:58521,
63090:58522,
63091:58523,
63092:58524,
63093:58525,
63094:58526,
63095:58527,
63096:58528,
63097:58529,
63098:58530,
63099:58531,
63100:58532,
63101:58533,
63102:58534,
63104:58535,
63105:58536,
63106:58537,
63107:58538,
63108:58539,
63109:58540,
63110:58541,
63111:58542,
63112:58543,
63113:58544,
63114:58545,
63115:58546,
63116:58547,
63117:58548,
63118:58549,
63119:58550,
63120:58551,
63121:58552,
63122:58553,
63123:58554,
63124:58555,
63125:58556,
63126:58557,
63127:58558,
63128:58559,
63129:58560,
63130:58561,
63131:58562,
63132:58563,
63133:58564,
63134:58565,
63135:58566,
63136:58567,
63137:58568,
63138:58569,
63139:58570,
63140:58571,
63141:58572,
63142:58573,
63143:58574,
63144:58575,
63145:58576,
63146:58577,
63147:58578,
63148:58579,
63149:58580,
63150:58581,
63151:58582,
63152:58583,
63153:58584,
63154:58585,
63155:58586,
63156:58587,
63157:58588,
63158:58589,
63159:58590,
63160:58591,
63161:58592,
63162:58593,
63163:58594,
63164:58595,
63165:58596,
63166:58597,
63167:58598,
63168:58599,
63169:58600,
63170:58601,
63171:58602,
63172:58603,
63173:58604,
63174:58605,
63175:58606,
63176:58607,
63177:58608,
63178:58609,
63179:58610,
63180:58611,
63181:58612,
63182:58613,
63183:58614,
63184:58615,
63185:58616,
63186:58617,
63187:58618,
63188:58619,
63189:58620,
63190:58621,
63191:58622,
63192:58623,
63193:58624,
63194:58625,
63195:58626,
63196:58627,
63197:58628,
63198:58629,
63199:58630,
63200:58631,
63201:58632,
63202:58633,
63203:58634,
63204:58635,
63205:58636,
63206:58637,
63207:58638,
63208:58639,
63209:58640,
63210:58641,
63211:58642,
63212:58643,
63213:58644,
63214:58645,
63215:58646,
63216:58647,
63217:58648,
63218:58649,
63219:58650,
63220:58651,
63221:58652,
63222:58653,
63223:58654,
63224:58655,
63225:58656,
63226:58657,
63227:58658,
63228:58659,
63296:58660,
63297:58661,
63298:58662,
63299:58663,
63300:58664,
63301:58665,
63302:58666,
63303:58667,
63304:58668,
63305:58669,
63306:58670,
63307:58671,
63308:58672,
63309:58673,
63310:58674,
63311:58675,
63312:58676,
63313:58677,
63314:58678,
63315:58679,
63316:58680,
63317:58681,
63318:58682,
63319:58683,
63320:58684,
63321:58685,
63322:58686,
63323:58687,
63324:58688,
63325:58689,
63326:58690,
63327:58691,
63328:58692,
63329:58693,
63330:58694,
63331:58695,
63332:58696,
63333:58697,
63334:58698,
63335:58699,
63336:58700,
63337:58701,
63338:58702,
63339:58703,
63340:58704,
63341:58705,
63342:58706,
63343:58707,
63344:58708,
63345:58709,
63346:58710,
63347:58711,
63348:58712,
63349:58713,
63350:58714,
63351:58715,
63352:58716,
63353:58717,
63354:58718,
63355:58719,
63356:58720,
63357:58721,
63358:58722,
63360:58723,
63361:58724,
63362:58725,
63363:58726,
63364:58727,
63365:58728,
63366:58729,
63367:58730,
63368:58731,
63369:58732,
63370:58733,
63371:58734,
63372:58735,
63373:58736,
63374:58737,
63375:58738,
63376:58739,
63377:58740,
63378:58741,
63379:58742,
63380:58743,
63381:58744,
63382:58745,
63383:58746,
63384:58747,
63385:58748,
63386:58749,
63387:58750,
63388:58751,
63389:58752,
63390:58753,
63391:58754,
63392:58755,
63393:58756,
63394:58757,
63395:58758,
63396:58759,
63397:58760,
63398:58761,
63399:58762,
63400:58763,
63401:58764,
63402:58765,
63403:58766,
63404:58767,
63405:58768,
63406:58769,
63407:58770,
63408:58771,
63409:58772,
63410:58773,
63411:58774,
63412:58775,
63413:58776,
63414:58777,
63415:58778,
63416:58779,
63417:58780,
63418:58781,
63419:58782,
63420:58783,
63421:58784,
63422:58785,
63423:58786,
63424:58787,
63425:58788,
63426:58789,
63427:58790,
63428:58791,
63429:58792,
63430:58793,
63431:58794,
63432:58795,
63433:58796,
63434:58797,
63435:58798,
63436:58799,
63437:58800,
63438:58801,
63439:58802,
63440:58803,
63441:58804,
63442:58805,
63443:58806,
63444:58807,
63445:58808,
63446:58809,
63447:58810,
63448:58811,
63449:58812,
63450:58813,
63451:58814,
63452:58815,
63453:58816,
63454:58817,
63455:58818,
63456:58819,
63457:58820,
63458:58821,
63459:58822,
63460:58823,
63461:58824,
63462:58825,
63463:58826,
63464:58827,
63465:58828,
63466:58829,
63467:58830,
63468:58831,
63469:58832,
63470:58833,
63471:58834,
63472:58835,
63473:58836,
63474:58837,
63475:58838,
63476:58839,
63477:58840,
63478:58841,
63479:58842,
63480:58843,
63481:58844,
63482:58845,
63483:58846,
63484:58847,
63552:58848,
63553:58849,
63554:58850,
63555:58851,
63556:58852,
63557:58853,
63558:58854,
63559:58855,
63560:58856,
63561:58857,
63562:58858,
63563:58859,
63564:58860,
63565:58861,
63566:58862,
63567:58863,
63568:58864,
63569:58865,
63570:58866,
63571:58867,
63572:58868,
63573:58869,
63574:58870,
63575:58871,
63576:58872,
63577:58873,
63578:58874,
63579:58875,
63580:58876,
63581:58877,
63582:58878,
63583:58879,
63584:58880,
63585:58881,
63586:58882,
63587:58883,
63588:58884,
63589:58885,
63590:58886,
63591:58887,
63592:58888,
63593:58889,
63594:58890,
63595:58891,
63596:58892,
63597:58893,
63598:58894,
63599:58895,
63600:58896,
63601:58897,
63602:58898,
63603:58899,
63604:58900,
63605:58901,
63606:58902,
63607:58903,
63608:58904,
63609:58905,
63610:58906,
63611:58907,
63612:58908,
63613:58909,
63614:58910,
63616:58911,
63617:58912,
63618:58913,
63619:58914,
63620:58915,
63621:58916,
63622:58917,
63623:58918,
63624:58919,
63625:58920,
63626:58921,
63627:58922,
63628:58923,
63629:58924,
63630:58925,
63631:58926,
63632:58927,
63633:58928,
63634:58929,
63635:58930,
63636:58931,
63637:58932,
63638:58933,
63639:58934,
63640:58935,
63641:58936,
63642:58937,
63643:58938,
63644:58939,
63645:58940,
63646:58941,
63647:58942,
63648:58943,
63649:58944,
63650:58945,
63651:58946,
63652:58947,
63653:58948,
63654:58949,
63655:58950,
63656:58951,
63657:58952,
63658:58953,
63659:58954,
63660:58955,
63661:58956,
63662:58957,
63663:58958,
63664:58959,
63665:58960,
63666:58961,
63667:58962,
63668:58963,
63669:58964,
63670:58965,
63671:58966,
63672:58967,
63673:58968,
63674:58969,
63675:58970,
63676:58971,
63677:58972,
63678:58973,
63679:58974,
63680:58975,
63681:58976,
63682:58977,
63683:58978,
63684:58979,
63685:58980,
63686:58981,
63687:58982,
63688:58983,
63689:58984,
63690:58985,
63691:58986,
63692:58987,
63693:58988,
63694:58989,
63695:58990,
63696:58991,
63697:58992,
63698:58993,
63699:58994,
63700:58995,
63701:58996,
63702:58997,
63703:58998,
63704:58999,
63705:59000,
63706:59001,
63707:59002,
63708:59003,
63709:59004,
63710:59005,
63711:59006,
63712:59007,
63713:59008,
63714:59009,
63715:59010,
63716:59011,
63717:59012,
63718:59013,
63719:59014,
63720:59015,
63721:59016,
63722:59017,
63723:59018,
63724:59019,
63725:59020,
63726:59021,
63727:59022,
63728:59023,
63729:59024,
63730:59025,
63731:59026,
63732:59027,
63733:59028,
63734:59029,
63735:59030,
63736:59031,
63737:59032,
63738:59033,
63739:59034,
63740:59035,
64064:8560,
64065:8561,
64066:8562,
64067:8563,
64068:8564,
64069:8565,
64070:8566,
64071:8567,
64072:8568,
64073:8569,
64074:8544,
64075:8545,
64076:8546,
64077:8547,
64078:8548,
64079:8549,
64080:8550,
64081:8551,
64082:8552,
64083:8553,
64084:65506,
64085:65508,
64086:65287,
64087:65282,
64088:12849,
64089:8470,
64090:8481,
64091:8757,
64092:32394,
64093:35100,
64094:37704,
64095:37512,
64096:34012,
64097:20425,
64098:28859,
64099:26161,
64100:26824,
64101:37625,
64102:26363,
64103:24389,
64104:20008,
64105:20193,
64106:20220,
64107:20224,
64108:20227,
64109:20281,
64110:20310,
64111:20370,
64112:20362,
64113:20378,
64114:20372,
64115:20429,
64116:20544,
64117:20514,
64118:20479,
64119:20510,
64120:20550,
64121:20592,
64122:20546,
64123:20628,
64124:20724,
64125:20696,
64126:20810,
64128:20836,
64129:20893,
64130:20926,
64131:20972,
64132:21013,
64133:21148,
64134:21158,
64135:21184,
64136:21211,
64137:21248,
64138:21255,
64139:21284,
64140:21362,
64141:21395,
64142:21426,
64143:21469,
64144:64014,
64145:21660,
64146:21642,
64147:21673,
64148:21759,
64149:21894,
64150:22361,
64151:22373,
64152:22444,
64153:22472,
64154:22471,
64155:64015,
64156:64016,
64157:22686,
64158:22706,
64159:22795,
64160:22867,
64161:22875,
64162:22877,
64163:22883,
64164:22948,
64165:22970,
64166:23382,
64167:23488,
64168:29999,
64169:23512,
64170:23532,
64171:23582,
64172:23718,
64173:23738,
64174:23797,
64175:23847,
64176:23891,
64177:64017,
64178:23874,
64179:23917,
64180:23992,
64181:23993,
64182:24016,
64183:24353,
64184:24372,
64185:24423,
64186:24503,
64187:24542,
64188:24669,
64189:24709,
64190:24714,
64191:24798,
64192:24789,
64193:24864,
64194:24818,
64195:24849,
64196:24887,
64197:24880,
64198:24984,
64199:25107,
64200:25254,
64201:25589,
64202:25696,
64203:25757,
64204:25806,
64205:25934,
64206:26112,
64207:26133,
64208:26171,
64209:26121,
64210:26158,
64211:26142,
64212:26148,
64213:26213,
64214:26199,
64215:26201,
64216:64018,
64217:26227,
64218:26265,
64219:26272,
64220:26290,
64221:26303,
64222:26362,
64223:26382,
64224:63785,
64225:26470,
64226:26555,
64227:26706,
64228:26560,
64229:26625,
64230:26692,
64231:26831,
64232:64019,
64233:26984,
64234:64020,
64235:27032,
64236:27106,
64237:27184,
64238:27243,
64239:27206,
64240:27251,
64241:27262,
64242:27362,
64243:27364,
64244:27606,
64245:27711,
64246:27740,
64247:27782,
64248:27759,
64249:27866,
64250:27908,
64251:28039,
64252:28015,
64320:28054,
64321:28076,
64322:28111,
64323:28152,
64324:28146,
64325:28156,
64326:28217,
64327:28252,
64328:28199,
64329:28220,
64330:28351,
64331:28552,
64332:28597,
64333:28661,
64334:28677,
64335:28679,
64336:28712,
64337:28805,
64338:28843,
64339:28943,
64340:28932,
64341:29020,
64342:28998,
64343:28999,
64344:64021,
64345:29121,
64346:29182,
64347:29361,
64348:29374,
64349:29476,
64350:64022,
64351:29559,
64352:29629,
64353:29641,
64354:29654,
64355:29667,
64356:29650,
64357:29703,
64358:29685,
64359:29734,
64360:29738,
64361:29737,
64362:29742,
64363:29794,
64364:29833,
64365:29855,
64366:29953,
64367:30063,
64368:30338,
64369:30364,
64370:30366,
64371:30363,
64372:30374,
64373:64023,
64374:30534,
64375:21167,
64376:30753,
64377:30798,
64378:30820,
64379:30842,
64380:31024,
64381:64024,
64382:64025,
64384:64026,
64385:31124,
64386:64027,
64387:31131,
64388:31441,
64389:31463,
64390:64028,
64391:31467,
64392:31646,
64393:64029,
64394:32072,
64395:32092,
64396:32183,
64397:32160,
64398:32214,
64399:32338,
64400:32583,
64401:32673,
64402:64030,
64403:33537,
64404:33634,
64405:33663,
64406:33735,
64407:33782,
64408:33864,
64409:33972,
64410:34131,
64411:34137,
64412:34155,
64413:64031,
64414:34224,
64415:64032,
64416:64033,
64417:34823,
64418:35061,
64419:35346,
64420:35383,
64421:35449,
64422:35495,
64423:35518,
64424:35551,
64425:64034,
64426:35574,
64427:35667,
64428:35711,
64429:36080,
64430:36084,
64431:36114,
64432:36214,
64433:64035,
64434:36559,
64435:64036,
64436:64037,
64437:36967,
64438:37086,
64439:64038,
64440:37141,
64441:37159,
64442:37338,
64443:37335,
64444:37342,
64445:37357,
64446:37358,
64447:37348,
64448:37349,
64449:37382,
64450:37392,
64451:37386,
64452:37434,
64453:37440,
64454:37436,
64455:37454,
64456:37465,
64457:37457,
64458:37433,
64459:37479,
64460:37543,
64461:37495,
64462:37496,
64463:37607,
64464:37591,
64465:37593,
64466:37584,
64467:64039,
64468:37589,
64469:37600,
64470:37587,
64471:37669,
64472:37665,
64473:37627,
64474:64040,
64475:37662,
64476:37631,
64477:37661,
64478:37634,
64479:37744,
64480:37719,
64481:37796,
64482:37830,
64483:37854,
64484:37880,
64485:37937,
64486:37957,
64487:37960,
64488:38290,
64489:63964,
64490:64041,
64491:38557,
64492:38575,
64493:38707,
64494:38715,
64495:38723,
64496:38733,
64497:38735,
64498:38737,
64499:38741,
64500:38999,
64501:39013,
64502:64042,
64503:64043,
64504:39207,
64505:64044,
64506:39326,
64507:39502,
64508:39641,
64576:39644,
64577:39797,
64578:39794,
64579:39823,
64580:39857,
64581:39867,
64582:39936,
64583:40304,
64584:40299,
64585:64045,
64586:40473,
64587:40657
};

/**
 * @author takahiro / https://github.com/takahirox
 */

function DataViewEx ( buffer, littleEndian ) {

	this.dv = new DataView( buffer );
	this.offset = 0;
	this.littleEndian = ( littleEndian !== undefined ) ? littleEndian : true;
	this.encoder = new CharsetEncoder();

}

DataViewEx.prototype = {

	constructor: DataViewEx,

	getInt8: function () {

		var value = this.dv.getInt8( this.offset );
		this.offset += 1;
		return value;

	},

	getInt8Array: function ( size ) {

		var a = [];

		for ( var i = 0; i < size; i++ ) {

			a.push( this.getInt8() );

		}

		return a;

	},

	getUint8: function () {

		var value = this.dv.getUint8( this.offset );
		this.offset += 1;
		return value;

	},

	getUint8Array: function ( size ) {

		var a = [];

		for ( var i = 0; i < size; i++ ) {

			a.push( this.getUint8() );

		}

		return a;

	},


	getInt16: function () {

		var value = this.dv.getInt16( this.offset, this.littleEndian );
		this.offset += 2;
		return value;

	},

	getInt16Array: function ( size ) {

		var a = [];

		for ( var i = 0; i < size; i++ ) {

			a.push( this.getInt16() );

		}

		return a;

	},

	getUint16: function () {

		var value = this.dv.getUint16( this.offset, this.littleEndian );
		this.offset += 2;
		return value;

	},

	getUint16Array: function ( size ) {

		var a = [];

		for ( var i = 0; i < size; i++ ) {

			a.push( this.getUint16() );

		}

		return a;

	},

	getInt32: function () {

		var value = this.dv.getInt32( this.offset, this.littleEndian );
		this.offset += 4;
		return value;

	},

	getInt32Array: function ( size ) {

		var a = [];

		for ( var i = 0; i < size; i++ ) {

			a.push( this.getInt32() );

		}

		return a;

	},

	getUint32: function () {

		var value = this.dv.getUint32( this.offset, this.littleEndian );
		this.offset += 4;
		return value;

	},

	getUint32Array: function ( size ) {

		var a = [];

		for ( var i = 0; i < size; i++ ) {

			a.push( this.getUint32() );

		}

		return a;

	},

	getFloat32: function () {

		var value = this.dv.getFloat32( this.offset, this.littleEndian );
		this.offset += 4;
		return value;

	},

	getFloat32Array: function( size ) {

		var a = [];

		for ( var i = 0; i < size; i++ ) {

			a.push( this.getFloat32() );

		}

		return a;

	},

	getFloat64: function () {

		var value = this.dv.getFloat64( this.offset, this.littleEndian );
		this.offset += 8;
		return value;

	},

	getFloat64Array: function( size ) {

		var a = [];

		for ( var i = 0; i < size; i++ ) {

			a.push( this.getFloat64() );

		}

		return a;

	},

	getIndex: function ( type, isUnsigned ) {

		switch ( type ) {

			case 1:
				return ( isUnsigned === true ) ? this.getUint8() : this.getInt8();

			case 2:
				return ( isUnsigned === true ) ? this.getUint16() : this.getInt16();

			case 4:
				return this.getInt32(); // No Uint32

			default:
				throw 'unknown number type ' + type + ' exception.';

		}

	},

	getIndexArray: function ( type, size, isUnsigned ) {

		var a = [];

		for ( var i = 0; i < size; i++ ) {

			a.push( this.getIndex( type, isUnsigned ) );

		}

		return a;

	},

	getChars: function ( size ) {

		var str = '';

		while ( size > 0 ) {

			var value = this.getUint8();
			size--;

			if ( value === 0 ) {

				break;

			}

			str += String.fromCharCode( value );

		}

		while ( size > 0 ) {

			this.getUint8();
			size--;

		}

		return str;

	},

	getSjisStringsAsUnicode: function ( size ) {

		var a = [];

		while ( size > 0 ) {

			var value = this.getUint8();
			size--;

			if ( value === 0 ) {

				break;

			}

			a.push( value );

		}

		while ( size > 0 ) {

			this.getUint8();
			size--;

		}

		return this.encoder.s2u( new Uint8Array( a ) );

	},

	getUnicodeStrings: function ( size ) {

		var str = '';

		while ( size > 0 ) {

			var value = this.getUint16();
			size -= 2;

			if ( value === 0 ) {

				break;

			}

			str += String.fromCharCode( value );

		}

		while ( size > 0 ) {

			this.getUint8();
			size--;

		}

		return str;

	},

	getTextBuffer: function () {

		var size = this.getUint32();
		return this.getUnicodeStrings( size );

	}

};

/**
 * @author takahiro / https://github.com/takahirox
 */

function DataCreationHelper () {
}

DataCreationHelper.prototype = {

	constructor: DataCreationHelper,

	leftToRightVector3: function ( v ) {

		v[ 2 ] = -v[ 2 ];

	},

	leftToRightQuaternion: function ( q ) {

		q[ 0 ] = -q[ 0 ];
		q[ 1 ] = -q[ 1 ];

	},

	leftToRightEuler: function ( r ) {

		r[ 0 ] = -r[ 0 ];
		r[ 1 ] = -r[ 1 ];

	},

	leftToRightIndexOrder: function ( p ) {

		var tmp = p[ 2 ];
		p[ 2 ] = p[ 0 ];
		p[ 0 ] = tmp;

	},

	leftToRightVector3Range: function ( v1, v2 ) {

		var tmp = -v2[ 2 ];
		v2[ 2 ] = -v1[ 2 ];
		v1[ 2 ] = tmp;

	},

	leftToRightEulerRange: function ( r1, r2 ) {

		var tmp1 = -r2[ 0 ];
		var tmp2 = -r2[ 1 ];
		r2[ 0 ] = -r1[ 0 ];
		r2[ 1 ] = -r1[ 1 ];
		r1[ 0 ] = tmp1;
		r1[ 1 ] = tmp2;

	}

};

/**
 * @author takahiro / https://github.com/takahirox
 */

function Parser() {
}

Parser.prototype.parsePmd = function ( buffer, leftToRight ) {

	var pmd = {};
	var dv = new DataViewEx( buffer );

	pmd.metadata = {};
	pmd.metadata.format = 'pmd';
	pmd.metadata.coordinateSystem = 'left';

	var parseHeader = function () {

		var metadata = pmd.metadata;
		metadata.magic = dv.getChars( 3 );

		if ( metadata.magic !== 'Pmd' ) {

			throw 'PMD file magic is not Pmd, but ' + metadata.magic;

		}

		metadata.version = dv.getFloat32();
		metadata.modelName = dv.getSjisStringsAsUnicode( 20 );
		metadata.comment = dv.getSjisStringsAsUnicode( 256 );

	};

	var parseVertices = function () {

		var parseVertex = function () {

			var p = {};
			p.position = dv.getFloat32Array( 3 );
			p.normal = dv.getFloat32Array( 3 );
			p.uv = dv.getFloat32Array( 2 );
			p.skinIndices = dv.getUint16Array( 2 );
			p.skinWeights = [ dv.getUint8() / 100 ];
			p.skinWeights.push( 1.0 - p.skinWeights[ 0 ] );
			p.edgeFlag = dv.getUint8();
			return p;

		};

		var metadata = pmd.metadata;
		metadata.vertexCount = dv.getUint32();

		pmd.vertices = [];

		for ( var i = 0; i < metadata.vertexCount; i++ ) {

			pmd.vertices.push( parseVertex() );

		}

	};

	var parseFaces = function () {

		var parseFace = function () {

			var p = {};
			p.indices = dv.getUint16Array( 3 );
			return p;

		};

		var metadata = pmd.metadata;
		metadata.faceCount = dv.getUint32() / 3;

		pmd.faces = [];

		for ( var i = 0; i < metadata.faceCount; i++ ) {

			pmd.faces.push( parseFace() );

		}

	};

	var parseMaterials = function () {

		var parseMaterial = function () {

			var p = {};
			p.diffuse = dv.getFloat32Array( 4 );
			p.shininess = dv.getFloat32();
			p.specular = dv.getFloat32Array( 3 );
			p.ambient = dv.getFloat32Array( 3 );
			p.toonIndex = dv.getInt8();
			p.edgeFlag = dv.getUint8();
			p.faceCount = dv.getUint32() / 3;
			p.fileName = dv.getSjisStringsAsUnicode( 20 );
			return p;

		};

		var metadata = pmd.metadata;
		metadata.materialCount = dv.getUint32();

		pmd.materials = [];

		for ( var i = 0; i < metadata.materialCount; i++ ) {

			pmd.materials.push( parseMaterial() );

		}

	};

	var parseBones = function () {

		var parseBone = function () {

			var p = {};
			p.name = dv.getSjisStringsAsUnicode( 20 );
			p.parentIndex = dv.getInt16();
			p.tailIndex = dv.getInt16();
			p.type = dv.getUint8();
			p.ikIndex = dv.getInt16();
			p.position = dv.getFloat32Array( 3 );
			return p;

		};

		var metadata = pmd.metadata;
		metadata.boneCount = dv.getUint16();

		pmd.bones = [];

		for ( var i = 0; i < metadata.boneCount; i++ ) {

			pmd.bones.push( parseBone() );

		}

	};

	var parseIks = function () {

		var parseIk = function () {

			var p = {};
			p.target = dv.getUint16();
			p.effector = dv.getUint16();
			p.linkCount = dv.getUint8();
			p.iteration = dv.getUint16();
			p.maxAngle = dv.getFloat32();

			p.links = [];
			for ( var i = 0; i < p.linkCount; i++ ) {

				var link = {};
				link.index = dv.getUint16();
				p.links.push( link );

			}

			return p;

		};

		var metadata = pmd.metadata;
		metadata.ikCount = dv.getUint16();

		pmd.iks = [];

		for ( var i = 0; i < metadata.ikCount; i++ ) {

			pmd.iks.push( parseIk() );

		}

	};

	var parseMorphs = function () {

		var parseMorph = function () {

			var p = {};
			p.name = dv.getSjisStringsAsUnicode( 20 );
			p.elementCount = dv.getUint32();
			p.type = dv.getUint8();

			p.elements = [];
			for ( var i = 0; i < p.elementCount; i++ ) {

				p.elements.push( {
					index: dv.getUint32(),
					position: dv.getFloat32Array( 3 )
				} ) ;

			}

			return p;

		};

		var metadata = pmd.metadata;
		metadata.morphCount = dv.getUint16();

		pmd.morphs = [];

		for ( var i = 0; i < metadata.morphCount; i++ ) {

			pmd.morphs.push( parseMorph() );

		}


	};

	var parseMorphFrames = function () {

		var parseMorphFrame = function () {

			var p = {};
			p.index = dv.getUint16();
			return p;

		};

		var metadata = pmd.metadata;
		metadata.morphFrameCount = dv.getUint8();

		pmd.morphFrames = [];

		for ( var i = 0; i < metadata.morphFrameCount; i++ ) {

			pmd.morphFrames.push( parseMorphFrame() );

		}

	};

	var parseBoneFrameNames = function () {

		var parseBoneFrameName = function () {

			var p = {};
			p.name = dv.getSjisStringsAsUnicode( 50 );
			return p;

		};

		var metadata = pmd.metadata;
		metadata.boneFrameNameCount = dv.getUint8();

		pmd.boneFrameNames = [];

		for ( var i = 0; i < metadata.boneFrameNameCount; i++ ) {

			pmd.boneFrameNames.push( parseBoneFrameName() );

		}

	};

	var parseBoneFrames = function () {

		var parseBoneFrame = function () {

			var p = {};
			p.boneIndex = dv.getInt16();
			p.frameIndex = dv.getUint8();
			return p;

		};

		var metadata = pmd.metadata;
		metadata.boneFrameCount = dv.getUint32();

		pmd.boneFrames = [];

		for ( var i = 0; i < metadata.boneFrameCount; i++ ) {

			pmd.boneFrames.push( parseBoneFrame() );

		}

	};

	var parseEnglishHeader = function () {

		var metadata = pmd.metadata;
		metadata.englishCompatibility = dv.getUint8();

		if ( metadata.englishCompatibility > 0 ) {

			metadata.englishModelName = dv.getSjisStringsAsUnicode( 20 );
			metadata.englishComment = dv.getSjisStringsAsUnicode( 256 );

		}

	};

	var parseEnglishBoneNames = function () {

		var parseEnglishBoneName = function () {

			var p = {};
			p.name = dv.getSjisStringsAsUnicode( 20 );
			return p;

		};

		var metadata = pmd.metadata;

		if ( metadata.englishCompatibility === 0 ) {

			return;

		}

		pmd.englishBoneNames = [];

		for ( var i = 0; i < metadata.boneCount; i++ ) {

			pmd.englishBoneNames.push( parseEnglishBoneName() );

		}

	};

	var parseEnglishMorphNames = function () {

		var parseEnglishMorphName = function () {

			var p = {};
			p.name = dv.getSjisStringsAsUnicode( 20 );
			return p;

		};

		var metadata = pmd.metadata;

		if ( metadata.englishCompatibility === 0 ) {

			return;

		}

		pmd.englishMorphNames = [];

		for ( var i = 0; i < metadata.morphCount - 1; i++ ) {

			pmd.englishMorphNames.push( parseEnglishMorphName() );

		}

	};

	var parseEnglishBoneFrameNames = function () {

		var parseEnglishBoneFrameName = function () {

			var p = {};
			p.name = dv.getSjisStringsAsUnicode( 50 );
			return p;

		};

		var metadata = pmd.metadata;

		if ( metadata.englishCompatibility === 0 ) {

			return;

		}

		pmd.englishBoneFrameNames = [];

		for ( var i = 0; i < metadata.boneFrameNameCount; i++ ) {

			pmd.englishBoneFrameNames.push( parseEnglishBoneFrameName() );

		}

	};

	var parseToonTextures = function () {

		var parseToonTexture = function () {

			var p = {};
			p.fileName = dv.getSjisStringsAsUnicode( 100 );
			return p;

		};

		pmd.toonTextures = [];

		for ( var i = 0; i < 10; i++ ) {

			pmd.toonTextures.push( parseToonTexture() );

		}

	};

	var parseRigidBodies = function () {

		var parseRigidBody = function () {

			var p = {};
			p.name = dv.getSjisStringsAsUnicode( 20 );
			p.boneIndex = dv.getInt16();
			p.groupIndex = dv.getUint8();
			p.groupTarget = dv.getUint16();
			p.shapeType = dv.getUint8();
			p.width = dv.getFloat32();
			p.height = dv.getFloat32();
			p.depth = dv.getFloat32();
			p.position = dv.getFloat32Array( 3 );
			p.rotation = dv.getFloat32Array( 3 );
			p.weight = dv.getFloat32();
			p.positionDamping = dv.getFloat32();
			p.rotationDamping = dv.getFloat32();
			p.restitution = dv.getFloat32();
			p.friction = dv.getFloat32();
			p.type = dv.getUint8();
			return p;

		};

		var metadata = pmd.metadata;
		metadata.rigidBodyCount = dv.getUint32();

		pmd.rigidBodies = [];

		for ( var i = 0; i < metadata.rigidBodyCount; i++ ) {

			pmd.rigidBodies.push( parseRigidBody() );

		}

	};

	var parseConstraints = function () {

		var parseConstraint = function () {

			var p = {};
			p.name = dv.getSjisStringsAsUnicode( 20 );
			p.rigidBodyIndex1 = dv.getUint32();
			p.rigidBodyIndex2 = dv.getUint32();
			p.position = dv.getFloat32Array( 3 );
			p.rotation = dv.getFloat32Array( 3 );
			p.translationLimitation1 = dv.getFloat32Array( 3 );
			p.translationLimitation2 = dv.getFloat32Array( 3 );
			p.rotationLimitation1 = dv.getFloat32Array( 3 );
			p.rotationLimitation2 = dv.getFloat32Array( 3 );
			p.springPosition = dv.getFloat32Array( 3 );
			p.springRotation = dv.getFloat32Array( 3 );
			return p;

		};

		var metadata = pmd.metadata;
		metadata.constraintCount = dv.getUint32();

		pmd.constraints = [];

		for ( var i = 0; i < metadata.constraintCount; i++ ) {

			pmd.constraints.push( parseConstraint() );

		}

	};

	parseHeader();
	parseVertices();
	parseFaces();
	parseMaterials();
	parseBones();
	parseIks();
	parseMorphs();
	parseMorphFrames();
	parseBoneFrameNames();
	parseBoneFrames();
	parseEnglishHeader();
	parseEnglishBoneNames();
	parseEnglishMorphNames();
	parseEnglishBoneFrameNames();
	parseToonTextures();
	parseRigidBodies();
	parseConstraints();

	if ( leftToRight === true ) this.leftToRightModel( pmd );

	// console.log( pmd ); // for console debug

	return pmd;

};

Parser.prototype.parsePmx = function ( buffer, leftToRight ) {

	var pmx = {};
	var dv = new DataViewEx( buffer );

	pmx.metadata = {};
	pmx.metadata.format = 'pmx';
	pmx.metadata.coordinateSystem = 'left';

	var parseHeader = function () {

		var metadata = pmx.metadata;
		metadata.magic = dv.getChars( 4 );

		// Note: don't remove the last blank space.
		if ( metadata.magic !== 'PMX ' ) {

			throw 'PMX file magic is not PMX , but ' + metadata.magic;

		}

		metadata.version = dv.getFloat32();

		if ( metadata.version !== 2.0 && metadata.version !== 2.1 ) {

			throw 'PMX version ' + metadata.version + ' is not supported.';

		}

		metadata.headerSize = dv.getUint8();
		metadata.encoding = dv.getUint8();
		metadata.additionalUvNum = dv.getUint8();
		metadata.vertexIndexSize = dv.getUint8();
		metadata.textureIndexSize = dv.getUint8();
		metadata.materialIndexSize = dv.getUint8();
		metadata.boneIndexSize = dv.getUint8();
		metadata.morphIndexSize = dv.getUint8();
		metadata.rigidBodyIndexSize = dv.getUint8();
		metadata.modelName = dv.getTextBuffer();
		metadata.englishModelName = dv.getTextBuffer();
		metadata.comment = dv.getTextBuffer();
		metadata.englishComment = dv.getTextBuffer();

	};

	var parseVertices = function () {

		var parseVertex = function () {

			var p = {};
			p.position = dv.getFloat32Array( 3 );
			p.normal = dv.getFloat32Array( 3 );
			p.uv = dv.getFloat32Array( 2 );

			p.auvs = [];

			for ( var i = 0; i < pmx.metadata.additionalUvNum; i++ ) {

				p.auvs.push( dv.getFloat32Array( 4 ) );

			}

			p.type = dv.getUint8();

			var indexSize = metadata.boneIndexSize;

			if ( p.type === 0 ) {  // BDEF1

				p.skinIndices = dv.getIndexArray( indexSize, 1 );
				p.skinWeights = [ 1.0 ];

			} else if ( p.type === 1 ) {  // BDEF2

				p.skinIndices = dv.getIndexArray( indexSize, 2 );
				p.skinWeights = dv.getFloat32Array( 1 );
				p.skinWeights.push( 1.0 - p.skinWeights[ 0 ] );

			} else if ( p.type === 2 ) {  // BDEF4

				p.skinIndices = dv.getIndexArray( indexSize, 4 );
				p.skinWeights = dv.getFloat32Array( 4 );

			} else if ( p.type === 3 ) {  // SDEF

				p.skinIndices = dv.getIndexArray( indexSize, 2 );
				p.skinWeights = dv.getFloat32Array( 1 );
				p.skinWeights.push( 1.0 - p.skinWeights[ 0 ] );

				p.skinC = dv.getFloat32Array( 3 );
				p.skinR0 = dv.getFloat32Array( 3 );
				p.skinR1 = dv.getFloat32Array( 3 );

				// SDEF is not supported yet and is handled as BDEF2 so far.
				// TODO: SDEF support
				p.type = 1;

			} else {

				throw 'unsupport bone type ' + p.type + ' exception.';

			}

			p.edgeRatio = dv.getFloat32();
			return p;

		};

		var metadata = pmx.metadata;
		metadata.vertexCount = dv.getUint32();

		pmx.vertices = [];

		for ( var i = 0; i < metadata.vertexCount; i++ ) {

			pmx.vertices.push( parseVertex() );

		}

	};

	var parseFaces = function () {

		var parseFace = function () {

			var p = {};
			p.indices = dv.getIndexArray( metadata.vertexIndexSize, 3, true );
			return p;

		};

		var metadata = pmx.metadata;
		metadata.faceCount = dv.getUint32() / 3;

		pmx.faces = [];

		for ( var i = 0; i < metadata.faceCount; i++ ) {

			pmx.faces.push( parseFace() );

		}

	};

	var parseTextures = function () {

		var parseTexture = function () {

			return dv.getTextBuffer();

		};

		var metadata = pmx.metadata;
		metadata.textureCount = dv.getUint32();

		pmx.textures = [];

		for ( var i = 0; i < metadata.textureCount; i++ ) {

			pmx.textures.push( parseTexture() );

		}

	};

	var parseMaterials = function () {

		var parseMaterial = function () {

			var p = {};
			p.name = dv.getTextBuffer();
			p.englishName = dv.getTextBuffer();
			p.diffuse = dv.getFloat32Array( 4 );
			p.specular = dv.getFloat32Array( 3 );
			p.shininess = dv.getFloat32();
			p.ambient = dv.getFloat32Array( 3 );
			p.flag = dv.getUint8();
			p.edgeColor = dv.getFloat32Array( 4 );
			p.edgeSize = dv.getFloat32();
			p.textureIndex = dv.getIndex( pmx.metadata.textureIndexSize );
			p.envTextureIndex = dv.getIndex( pmx.metadata.textureIndexSize );
			p.envFlag = dv.getUint8();
			p.toonFlag = dv.getUint8();

			if ( p.toonFlag === 0 ) {

				p.toonIndex = dv.getIndex( pmx.metadata.textureIndexSize );

			} else if ( p.toonFlag === 1 ) {

				p.toonIndex = dv.getInt8();

			} else {

				throw 'unknown toon flag ' + p.toonFlag + ' exception.';

			}

			p.comment = dv.getTextBuffer();
			p.faceCount = dv.getUint32() / 3;
			return p;

		};

		var metadata = pmx.metadata;
		metadata.materialCount = dv.getUint32();

		pmx.materials = [];

		for ( var i = 0; i < metadata.materialCount; i++ ) {

			pmx.materials.push( parseMaterial() );

		}

	};

	var parseBones = function () {

		var parseBone = function () {

			var p = {};
			p.name = dv.getTextBuffer();
			p.englishName = dv.getTextBuffer();
			p.position = dv.getFloat32Array( 3 );
			p.parentIndex = dv.getIndex( pmx.metadata.boneIndexSize );
			p.transformationClass = dv.getUint32();
			p.flag = dv.getUint16();

			if ( p.flag & 0x1 ) {

				p.connectIndex = dv.getIndex( pmx.metadata.boneIndexSize );

			} else {

				p.offsetPosition = dv.getFloat32Array( 3 );

			}

			if ( p.flag & 0x100 || p.flag & 0x200 ) {

				// Note: I don't think Grant is an appropriate name
				//       but I found that some English translated MMD tools use this term
				//       so I've named it Grant so far.
				//       I'd rename to more appropriate name from Grant later.
				var grant = {};

				grant.isLocal = ( p.flag & 0x80 ) !== 0 ? true : false;
				grant.affectRotation = ( p.flag & 0x100 ) !== 0 ? true : false;
				grant.affectPosition = ( p.flag & 0x200 ) !== 0 ? true : false;
				grant.parentIndex = dv.getIndex( pmx.metadata.boneIndexSize );
				grant.ratio = dv.getFloat32();

				p.grant = grant;

			}

			if ( p.flag & 0x400 ) {

				p.fixAxis = dv.getFloat32Array( 3 );

			}

			if ( p.flag & 0x800 ) {

				p.localXVector = dv.getFloat32Array( 3 );
				p.localZVector = dv.getFloat32Array( 3 );

			}

			if ( p.flag & 0x2000 ) {

				p.key = dv.getUint32();

			}

			if ( p.flag & 0x20 ) {

				var ik = {};

				ik.effector = dv.getIndex( pmx.metadata.boneIndexSize );
				ik.target = null;
				ik.iteration = dv.getUint32();
				ik.maxAngle = dv.getFloat32();
				ik.linkCount = dv.getUint32();
				ik.links = [];

				for ( var i = 0; i < ik.linkCount; i++ ) {

					var link = {};
					link.index = dv.getIndex( pmx.metadata.boneIndexSize );
					link.angleLimitation = dv.getUint8();

					if ( link.angleLimitation === 1 ) {

						link.lowerLimitationAngle = dv.getFloat32Array( 3 );
						link.upperLimitationAngle = dv.getFloat32Array( 3 );

					}

					ik.links.push( link );

				}

				p.ik = ik;
			}

			return p;

		};

		var metadata = pmx.metadata;
		metadata.boneCount = dv.getUint32();

		pmx.bones = [];

		for ( var i = 0; i < metadata.boneCount; i++ ) {

			pmx.bones.push( parseBone() );

		}

	};

	var parseMorphs = function () {

		var parseMorph = function () {

			var p = {};
			p.name = dv.getTextBuffer();
			p.englishName = dv.getTextBuffer();
			p.panel = dv.getUint8();
			p.type = dv.getUint8();
			p.elementCount = dv.getUint32();
			p.elements = [];

			for ( var i = 0; i < p.elementCount; i++ ) {

				if ( p.type === 0 ) {  // group morph

					var m = {};
					m.index = dv.getIndex( pmx.metadata.morphIndexSize );
					m.ratio = dv.getFloat32();
					p.elements.push( m );

				} else if ( p.type === 1 ) {  // vertex morph

					var m = {};
					m.index = dv.getIndex( pmx.metadata.vertexIndexSize, true );
					m.position = dv.getFloat32Array( 3 );
					p.elements.push( m );

				} else if ( p.type === 2 ) {  // bone morph

					var m = {};
					m.index = dv.getIndex( pmx.metadata.boneIndexSize );
					m.position = dv.getFloat32Array( 3 );
					m.rotation = dv.getFloat32Array( 4 );
					p.elements.push( m );

				} else if ( p.type === 3 ) {  // uv morph

					var m = {};
					m.index = dv.getIndex( pmx.metadata.vertexIndexSize, true );
					m.uv = dv.getFloat32Array( 4 );
					p.elements.push( m );

				} else if ( p.type === 4 ) {  // additional uv1

					// TODO: implement

				} else if ( p.type === 5 ) {  // additional uv2

					// TODO: implement

				} else if ( p.type === 6 ) {  // additional uv3

					// TODO: implement

				} else if ( p.type === 7 ) {  // additional uv4

					// TODO: implement

				} else if ( p.type === 8 ) {  // material morph

					var m = {};
					m.index = dv.getIndex( pmx.metadata.materialIndexSize );
					m.type = dv.getUint8();
					m.diffuse = dv.getFloat32Array( 4 );
					m.specular = dv.getFloat32Array( 3 );
					m.shininess = dv.getFloat32();
					m.ambient = dv.getFloat32Array( 3 );
					m.edgeColor = dv.getFloat32Array( 4 );
					m.edgeSize = dv.getFloat32();
					m.textureColor = dv.getFloat32Array( 4 );
					m.sphereTextureColor = dv.getFloat32Array( 4 );
					m.toonColor = dv.getFloat32Array( 4 );
					p.elements.push( m );

				}

			}

			return p;

		};

		var metadata = pmx.metadata;
		metadata.morphCount = dv.getUint32();

		pmx.morphs = [];

		for ( var i = 0; i < metadata.morphCount; i++ ) {

			pmx.morphs.push( parseMorph() );

		}

	};

	var parseFrames = function () {

		var parseFrame = function () {

			var p = {};
			p.name = dv.getTextBuffer();
			p.englishName = dv.getTextBuffer();
			p.type = dv.getUint8();
			p.elementCount = dv.getUint32();
			p.elements = [];

			for ( var i = 0; i < p.elementCount; i++ ) {

				var e = {};
				e.target = dv.getUint8();
				e.index = ( e.target === 0 ) ? dv.getIndex( pmx.metadata.boneIndexSize ) : dv.getIndex( pmx.metadata.morphIndexSize );
				p.elements.push( e );

			}

			return p;

		};

		var metadata = pmx.metadata;
		metadata.frameCount = dv.getUint32();

		pmx.frames = [];

		for ( var i = 0; i < metadata.frameCount; i++ ) {

			pmx.frames.push( parseFrame() );

		}

	};

	var parseRigidBodies = function () {

		var parseRigidBody = function () {

			var p = {};
			p.name = dv.getTextBuffer();
			p.englishName = dv.getTextBuffer();
			p.boneIndex = dv.getIndex( pmx.metadata.boneIndexSize );
			p.groupIndex = dv.getUint8();
			p.groupTarget = dv.getUint16();
			p.shapeType = dv.getUint8();
			p.width = dv.getFloat32();
			p.height = dv.getFloat32();
			p.depth = dv.getFloat32();
			p.position = dv.getFloat32Array( 3 );
			p.rotation = dv.getFloat32Array( 3 );
			p.weight = dv.getFloat32();
			p.positionDamping = dv.getFloat32();
			p.rotationDamping = dv.getFloat32();
			p.restitution = dv.getFloat32();
			p.friction = dv.getFloat32();
			p.type = dv.getUint8();
			return p;

		};

		var metadata = pmx.metadata;
		metadata.rigidBodyCount = dv.getUint32();

		pmx.rigidBodies = [];

		for ( var i = 0; i < metadata.rigidBodyCount; i++ ) {

			pmx.rigidBodies.push( parseRigidBody() );

		}

	};

	var parseConstraints = function () {

		var parseConstraint = function () {

			var p = {};
			p.name = dv.getTextBuffer();
			p.englishName = dv.getTextBuffer();
			p.type = dv.getUint8();
			p.rigidBodyIndex1 = dv.getIndex( pmx.metadata.rigidBodyIndexSize );
			p.rigidBodyIndex2 = dv.getIndex( pmx.metadata.rigidBodyIndexSize );
			p.position = dv.getFloat32Array( 3 );
			p.rotation = dv.getFloat32Array( 3 );
			p.translationLimitation1 = dv.getFloat32Array( 3 );
			p.translationLimitation2 = dv.getFloat32Array( 3 );
			p.rotationLimitation1 = dv.getFloat32Array( 3 );
			p.rotationLimitation2 = dv.getFloat32Array( 3 );
			p.springPosition = dv.getFloat32Array( 3 );
			p.springRotation = dv.getFloat32Array( 3 );
			return p;

		};

		var metadata = pmx.metadata;
		metadata.constraintCount = dv.getUint32();

		pmx.constraints = [];

		for ( var i = 0; i < metadata.constraintCount; i++ ) {

			pmx.constraints.push( parseConstraint() );

		}

	};

	parseHeader();
	parseVertices();
	parseFaces();
	parseTextures();
	parseMaterials();
	parseBones();
	parseMorphs();
	parseFrames();
	parseRigidBodies();
	parseConstraints();

	if ( leftToRight === true ) this.leftToRightModel( pmx );

	// console.log( pmx ); // for console debug

	return pmx;

};

Parser.prototype.parseVmd = function ( buffer, leftToRight ) {

	var vmd = {};
	var dv = new DataViewEx( buffer );

	vmd.metadata = {};
	vmd.metadata.coordinateSystem = 'left';

	var parseHeader = function () {

		var metadata = vmd.metadata;
		metadata.magic = dv.getChars( 30 );

		if ( metadata.magic !== 'Vocaloid Motion Data 0002' ) {

			throw 'VMD file magic is not Vocaloid Motion Data 0002, but ' + metadata.magic;

		}

		metadata.name = dv.getSjisStringsAsUnicode( 20 );

	};

	var parseMotions = function () {

		var parseMotion = function () {

			var p = {};
			p.boneName = dv.getSjisStringsAsUnicode( 15 );
			p.frameNum = dv.getUint32();
			p.position = dv.getFloat32Array( 3 );
			p.rotation = dv.getFloat32Array( 4 );
			p.interpolation = dv.getUint8Array( 64 );
			return p;

		};

		var metadata = vmd.metadata;
		metadata.motionCount = dv.getUint32();

		vmd.motions = [];
		for ( var i = 0; i < metadata.motionCount; i++ ) {

			vmd.motions.push( parseMotion() );

		}

	};

	var parseMorphs = function () {

		var parseMorph = function () {

			var p = {};
			p.morphName = dv.getSjisStringsAsUnicode( 15 );
			p.frameNum = dv.getUint32();
			p.weight = dv.getFloat32();
			return p;

		};

		var metadata = vmd.metadata;
		metadata.morphCount = dv.getUint32();

		vmd.morphs = [];
		for ( var i = 0; i < metadata.morphCount; i++ ) {

			vmd.morphs.push( parseMorph() );

		}

	};

	var parseCameras = function () {

		var parseCamera = function () {

			var p = {};
			p.frameNum = dv.getUint32();
			p.distance = dv.getFloat32();
			p.position = dv.getFloat32Array( 3 );
			p.rotation = dv.getFloat32Array( 3 );
			p.interpolation = dv.getUint8Array( 24 );
			p.fov = dv.getUint32();
			p.perspective = dv.getUint8();
			return p;

		};

		var metadata = vmd.metadata;
		metadata.cameraCount = dv.getUint32();

		vmd.cameras = [];
		for ( var i = 0; i < metadata.cameraCount; i++ ) {

			vmd.cameras.push( parseCamera() );

		}

	};

	parseHeader();
	parseMotions();
	parseMorphs();
	parseCameras();

	if ( leftToRight === true ) this.leftToRightVmd( vmd );

	// console.log( vmd ); // for console debug

	return vmd;

};

Parser.prototype.parseVpd = function ( text, leftToRight ) {

	var vpd = {};

	vpd.metadata = {};
	vpd.metadata.coordinateSystem = 'left';

	vpd.bones = [];

	var commentPatternG = /\/\/\w*(\r|\n|\r\n)/g;
	var newlinePattern = /\r|\n|\r\n/;

	var lines = text.replace( commentPatternG, '' ).split( newlinePattern );

	function throwError () {

		throw 'the file seems not vpd file.';

	}

	function checkMagic () {

		if ( lines[ 0 ] !== 'Vocaloid Pose Data file' ) {

			throwError();

		}

	}

	function parseHeader () {

		if ( lines.length < 4 ) {

			throwError();

		}

		vpd.metadata.parentFile = lines[ 2 ];
		vpd.metadata.boneCount = parseInt( lines[ 3 ] );

	}

	function parseBones () {

		var boneHeaderPattern = /^\s*(Bone[0-9]+)\s*\{\s*(.*)$/;
		var boneVectorPattern = /^\s*(-?[0-9]+\.[0-9]+)\s*,\s*(-?[0-9]+\.[0-9]+)\s*,\s*(-?[0-9]+\.[0-9]+)\s*;/;
		var boneQuaternionPattern = /^\s*(-?[0-9]+\.[0-9]+)\s*,\s*(-?[0-9]+\.[0-9]+)\s*,\s*(-?[0-9]+\.[0-9]+)\s*,\s*(-?[0-9]+\.[0-9]+)\s*;/;
		var boneFooterPattern = /^\s*}/;

		var bones = vpd.bones;
		var n = null;
		var v = null;
		var q = null;

		for ( var i = 4; i < lines.length; i++ ) {

			var line = lines[ i ];

			var result;

			result = line.match( boneHeaderPattern );

			if ( result !== null ) {

				if ( n !== null ) {

					throwError();

				}

				n = result[ 2 ];

			}

			result = line.match( boneVectorPattern );

			if ( result !== null ) {

				if ( v !== null ) {

					throwError();

				}

				v = [

					parseFloat( result[ 1 ] ),
					parseFloat( result[ 2 ] ),
					parseFloat( result[ 3 ] )

				];

			}

			result = line.match( boneQuaternionPattern );

			if ( result !== null ) {

				if ( q !== null ) {

					throwError();

				}

				q = [

					parseFloat( result[ 1 ] ),
					parseFloat( result[ 2 ] ),
					parseFloat( result[ 3 ] ),
					parseFloat( result[ 4 ] )

				];


			}

			result = line.match( boneFooterPattern );

			if ( result !== null ) {

				if ( n === null || v === null || q === null ) {

					throwError();

				}

				bones.push( {

					name: n,
					translation: v,
					quaternion: q

				} );

				n = null;
				v = null;
				q = null;

			}

		}

		if ( n !== null || v !== null || q !== null ) {

			throwError();

		}

	}

	checkMagic();
	parseHeader();
	parseBones();

	if ( leftToRight === true ) this.leftToRightVpd( vpd );

	// console.log( vpd );  // for console debug

	return vpd;

};

Parser.prototype.mergeVmds = function ( vmds ) {

	var v = {};
	v.metadata = {};
	v.metadata.name = vmds[ 0 ].metadata.name;
	v.metadata.coordinateSystem = vmds[ 0 ].metadata.coordinateSystem;
	v.metadata.motionCount = 0;
	v.metadata.morphCount = 0;
	v.metadata.cameraCount = 0;
	v.motions = [];
	v.morphs = [];
	v.cameras = [];

	for ( var i = 0; i < vmds.length; i++ ) {

		var v2 = vmds[ i ];

		v.metadata.motionCount += v2.metadata.motionCount;
		v.metadata.morphCount += v2.metadata.morphCount;
		v.metadata.cameraCount += v2.metadata.cameraCount;

		for ( var j = 0; j < v2.metadata.motionCount; j++ ) {

			v.motions.push( v2.motions[ j ] );

		}

		for ( var j = 0; j < v2.metadata.morphCount; j++ ) {

			v.morphs.push( v2.morphs[ j ] );

		}

		for ( var j = 0; j < v2.metadata.cameraCount; j++ ) {

			v.cameras.push( v2.cameras[ j ] );

		}

	}

	return v;

};

Parser.prototype.leftToRightModel = function ( model ) {

	if ( model.metadata.coordinateSystem === 'right' ) {

		return;

	}

	model.metadata.coordinateSystem = 'right';

	var helper = new DataCreationHelper();

	for ( var i = 0; i < model.metadata.vertexCount; i++ ) {

		helper.leftToRightVector3( model.vertices[ i ].position );
		helper.leftToRightVector3( model.vertices[ i ].normal );

	}

	for ( var i = 0; i < model.metadata.faceCount; i++ ) {

		helper.leftToRightIndexOrder( model.faces[ i ].indices );

	}

	for ( var i = 0; i < model.metadata.boneCount; i++ ) {

		helper.leftToRightVector3( model.bones[ i ].position );

	}

	// TODO: support other morph for PMX
	for ( var i = 0; i < model.metadata.morphCount; i++ ) {

		var m = model.morphs[ i ];

		if ( model.metadata.format === 'pmx' && m.type !== 1 ) {

			// TODO: implement
			continue;

		}

		for ( var j = 0; j < m.elements.length; j++ ) {

			helper.leftToRightVector3( m.elements[ j ].position );

		}

	}

	for ( var i = 0; i < model.metadata.rigidBodyCount; i++ ) {

		helper.leftToRightVector3( model.rigidBodies[ i ].position );
		helper.leftToRightEuler( model.rigidBodies[ i ].rotation );

	}

	for ( var i = 0; i < model.metadata.constraintCount; i++ ) {

		helper.leftToRightVector3( model.constraints[ i ].position );
		helper.leftToRightEuler( model.constraints[ i ].rotation );
		helper.leftToRightVector3Range( model.constraints[ i ].translationLimitation1, model.constraints[ i ].translationLimitation2 );
		helper.leftToRightEulerRange( model.constraints[ i ].rotationLimitation1, model.constraints[ i ].rotationLimitation2 );

	}

};

Parser.prototype.leftToRightVmd = function ( vmd ) {

	if ( vmd.metadata.coordinateSystem === 'right' ) {

		return;

	}

	vmd.metadata.coordinateSystem = 'right';

	var helper = new DataCreationHelper();

	for ( var i = 0; i < vmd.metadata.motionCount; i++ ) {

		helper.leftToRightVector3( vmd.motions[ i ].position );
		helper.leftToRightQuaternion( vmd.motions[ i ].rotation );

	}

	for ( var i = 0; i < vmd.metadata.cameraCount; i++ ) {

		helper.leftToRightVector3( vmd.cameras[ i ].position );
		helper.leftToRightEuler( vmd.cameras[ i ].rotation );

	}

};

Parser.prototype.leftToRightVpd = function ( vpd ) {

	if ( vpd.metadata.coordinateSystem === 'right' ) {

		return;

	}

	vpd.metadata.coordinateSystem = 'right';

	var helper = new DataCreationHelper();

	for ( var i = 0; i < vpd.bones.length; i++ ) {

		helper.leftToRightVector3( vpd.bones[ i ].translation );
		helper.leftToRightQuaternion( vpd.bones[ i ].quaternion );

	}

};

exports.CharsetEncoder = CharsetEncoder;
exports.Parser = Parser;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author Rich Tibbett / https://github.com/richtr
 * @author mrdoob / http://mrdoob.com/
 * @author Tony Parisi / http://www.tonyparisi.com/
 * @author Takahiro / https://github.com/takahirox
 * @author Don McCurdy / https://www.donmccurdy.com
 */

var GLTFLoader = function () {

	function GLTFLoader(manager) {

		this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
		this.dracoLoader = null;
	}

	GLTFLoader.prototype = {

		constructor: GLTFLoader,

		crossOrigin: 'Anonymous',

		load: function load(url, onLoad, onProgress, onError) {

			var scope = this;

			var path = this.path !== undefined ? this.path : THREE.LoaderUtils.extractUrlBase(url);

			var loader = new THREE.FileLoader(scope.manager);

			loader.setResponseType('arraybuffer');

			loader.load(url, function (data) {

				try {

					scope.parse(data, path, onLoad, onError);
				} catch (e) {

					if (onError !== undefined) {

						onError(e);
					} else {

						throw e;
					}
				}
			}, onProgress, onError);
		},

		setCrossOrigin: function setCrossOrigin(value) {

			this.crossOrigin = value;
			return this;
		},

		setPath: function setPath(value) {

			this.path = value;
			return this;
		},

		setDRACOLoader: function setDRACOLoader(dracoLoader) {

			this.dracoLoader = dracoLoader;
			return this;
		},

		parse: function parse(data, path, onLoad, onError) {

			var content;
			var extensions = {};

			if (typeof data === 'string') {

				content = data;
			} else {

				var magic = THREE.LoaderUtils.decodeText(new Uint8Array(data, 0, 4));

				if (magic === BINARY_EXTENSION_HEADER_MAGIC) {

					try {

						extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
					} catch (error) {

						if (onError) onError(error);
						return;
					}

					content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;
				} else {

					content = THREE.LoaderUtils.decodeText(new Uint8Array(data));
				}
			}

			var json = JSON.parse(content);

			if (json.asset === undefined || json.asset.version[0] < 2) {

				if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported. Use LegacyGLTFLoader instead.'));
				return;
			}

			if (json.extensionsUsed) {

				if (json.extensionsUsed.indexOf(EXTENSIONS.KHR_LIGHTS) >= 0) {

					extensions[EXTENSIONS.KHR_LIGHTS] = new GLTFLightsExtension(json);
				}

				if (json.extensionsUsed.indexOf(EXTENSIONS.KHR_MATERIALS_UNLIT) >= 0) {

					extensions[EXTENSIONS.KHR_MATERIALS_UNLIT] = new GLTFMaterialsUnlitExtension(json);
				}

				if (json.extensionsUsed.indexOf(EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS) >= 0) {

					extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS] = new GLTFMaterialsPbrSpecularGlossinessExtension();
				}

				if (json.extensionsUsed.indexOf(EXTENSIONS.KHR_DRACO_MESH_COMPRESSION) >= 0) {

					extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION] = new GLTFDracoMeshCompressionExtension(this.dracoLoader);
				}

				if (json.extensionsUsed.indexOf(EXTENSIONS.MSFT_TEXTURE_DDS) >= 0) {

					extensions[EXTENSIONS.MSFT_TEXTURE_DDS] = new GLTFTextureDDSExtension();
				}
			}

			var parser = new GLTFParser(json, extensions, {

				path: path || this.path || '',
				crossOrigin: this.crossOrigin,
				manager: this.manager

			});

			parser.parse(function (scene, scenes, cameras, animations, asset) {

				var glTF = {
					scene: scene,
					scenes: scenes,
					cameras: cameras,
					animations: animations,
					asset: asset
				};

				onLoad(glTF);
			}, onError);
		}

	};

	/* GLTFREGISTRY */

	function GLTFRegistry() {

		var objects = {};

		return {

			get: function get(key) {

				return objects[key];
			},

			add: function add(key, object) {

				objects[key] = object;
			},

			remove: function remove(key) {

				delete objects[key];
			},

			removeAll: function removeAll() {

				objects = {};
			}

		};
	}

	/*********************************/
	/********** EXTENSIONS ***********/
	/*********************************/

	var EXTENSIONS = {
		KHR_BINARY_GLTF: 'KHR_binary_glTF',
		KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
		KHR_LIGHTS: 'KHR_lights',
		KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
		KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
		MSFT_TEXTURE_DDS: 'MSFT_texture_dds'
	};

	/**
  * DDS Texture Extension
  *
  * Specification:
  * https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds
  *
  */
	function GLTFTextureDDSExtension() {

		if (!THREE.DDSLoader) {

			throw new Error('THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader');
		}

		this.name = EXTENSIONS.MSFT_TEXTURE_DDS;
		this.ddsLoader = new THREE.DDSLoader();
	}

	/**
  * Lights Extension
  *
  * Specification: PENDING
  */
	function GLTFLightsExtension(json) {

		this.name = EXTENSIONS.KHR_LIGHTS;

		this.lights = {};

		var extension = json.extensions && json.extensions[EXTENSIONS.KHR_LIGHTS] || {};
		var lights = extension.lights || {};

		for (var lightId in lights) {

			var light = lights[lightId];
			var lightNode;

			var color = new THREE.Color().fromArray(light.color);

			switch (light.type) {

				case 'directional':
					lightNode = new THREE.DirectionalLight(color);
					lightNode.target.position.set(0, 0, 1);
					lightNode.add(lightNode.target);
					break;

				case 'point':
					lightNode = new THREE.PointLight(color);
					break;

				case 'spot':
					lightNode = new THREE.SpotLight(color);
					// Handle spotlight properties.
					light.spot = light.spot || {};
					light.spot.innerConeAngle = light.spot.innerConeAngle !== undefined ? light.spot.innerConeAngle : 0;
					light.spot.outerConeAngle = light.spot.outerConeAngle !== undefined ? light.spot.outerConeAngle : Math.PI / 4.0;
					lightNode.angle = light.spot.outerConeAngle;
					lightNode.penumbra = 1.0 - light.spot.innerConeAngle / light.spot.outerConeAngle;
					lightNode.target.position.set(0, 0, 1);
					lightNode.add(lightNode.target);
					break;

				case 'ambient':
					lightNode = new THREE.AmbientLight(color);
					break;

			}

			if (lightNode) {

				lightNode.decay = 2;

				if (light.intensity !== undefined) {

					lightNode.intensity = light.intensity;
				}

				lightNode.name = light.name || 'light_' + lightId;
				this.lights[lightId] = lightNode;
			}
		}
	}

	/**
  * Unlit Materials Extension (pending)
  *
  * PR: https://github.com/KhronosGroup/glTF/pull/1163
  */
	function GLTFMaterialsUnlitExtension(json) {

		this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
	}

	GLTFMaterialsUnlitExtension.prototype.getMaterialType = function (material) {

		return THREE.MeshBasicMaterial;
	};

	GLTFMaterialsUnlitExtension.prototype.extendParams = function (materialParams, material, parser) {

		var pending = [];

		materialParams.color = new THREE.Color(1.0, 1.0, 1.0);
		materialParams.opacity = 1.0;

		var metallicRoughness = material.pbrMetallicRoughness;

		if (metallicRoughness) {

			if (Array.isArray(metallicRoughness.baseColorFactor)) {

				var array = metallicRoughness.baseColorFactor;

				materialParams.color.fromArray(array);
				materialParams.opacity = array[3];
			}

			if (metallicRoughness.baseColorTexture !== undefined) {

				pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture.index));
			}
		}

		return Promise.all(pending);
	};

	/* BINARY EXTENSION */

	var BINARY_EXTENSION_BUFFER_NAME = 'binary_glTF';
	var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
	var BINARY_EXTENSION_HEADER_LENGTH = 12;
	var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };

	function GLTFBinaryExtension(data) {

		this.name = EXTENSIONS.KHR_BINARY_GLTF;
		this.content = null;
		this.body = null;

		var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);

		this.header = {
			magic: THREE.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
			version: headerView.getUint32(4, true),
			length: headerView.getUint32(8, true)
		};

		if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {

			throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');
		} else if (this.header.version < 2.0) {

			throw new Error('THREE.GLTFLoader: Legacy binary file detected. Use LegacyGLTFLoader instead.');
		}

		var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
		var chunkIndex = 0;

		while (chunkIndex < chunkView.byteLength) {

			var chunkLength = chunkView.getUint32(chunkIndex, true);
			chunkIndex += 4;

			var chunkType = chunkView.getUint32(chunkIndex, true);
			chunkIndex += 4;

			if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {

				var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
				this.content = THREE.LoaderUtils.decodeText(contentArray);
			} else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {

				var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
				this.body = data.slice(byteOffset, byteOffset + chunkLength);
			}

			// Clients must ignore chunks with unknown types.

			chunkIndex += chunkLength;
		}

		if (this.content === null) {

			throw new Error('THREE.GLTFLoader: JSON content not found.');
		}
	}

	/**
  * DRACO Mesh Compression Extension
  *
  * Specification: https://github.com/KhronosGroup/glTF/pull/874
  */
	function GLTFDracoMeshCompressionExtension(dracoLoader) {

		if (!dracoLoader) {

			throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');
		}

		this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
		this.dracoLoader = dracoLoader;
	}

	GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function (primitive, parser) {

		var dracoLoader = this.dracoLoader;
		var bufferViewIndex = primitive.extensions[this.name].bufferView;
		var gltfAttributeMap = primitive.extensions[this.name].attributes;
		var threeAttributeMap = {};

		for (var attributeName in gltfAttributeMap) {

			if (!(attributeName in ATTRIBUTES)) continue;

			threeAttributeMap[ATTRIBUTES[attributeName]] = gltfAttributeMap[attributeName];
		}

		return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {

			return new Promise(function (resolve) {

				dracoLoader.decodeDracoFile(bufferView, resolve, threeAttributeMap);
			});
		});
	};

	/**
  * Specular-Glossiness Extension
  *
  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
  */
	function GLTFMaterialsPbrSpecularGlossinessExtension() {

		return {

			name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,

			specularGlossinessParams: ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'],

			getMaterialType: function getMaterialType() {

				return THREE.ShaderMaterial;
			},

			extendParams: function extendParams(params, material, parser) {

				var pbrSpecularGlossiness = material.extensions[this.name];

				var shader = THREE.ShaderLib['standard'];

				var uniforms = THREE.UniformsUtils.clone(shader.uniforms);

				var specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '	uniform sampler2D specularMap;', '#endif'].join('\n');

				var glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '	uniform sampler2D glossinessMap;', '#endif'].join('\n');

				var specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '	vec4 texelSpecular = texture2D( specularMap, vUv );', '	texelSpecular = sRGBToLinear( texelSpecular );', '	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '	specularFactor *= texelSpecular.rgb;', '#endif'].join('\n');

				var glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '	vec4 texelGlossiness = texture2D( glossinessMap, vUv );', '	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '	glossinessFactor *= texelGlossiness.a;', '#endif'].join('\n');

				var lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb;', 'material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );', 'material.specularColor = specularFactor.rgb;'].join('\n');

				var fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;').replace('uniform float metalness;', 'uniform float glossiness;').replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk).replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk).replace('#include <roughnessmap_fragment>', specularMapFragmentChunk).replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk).replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);

				delete uniforms.roughness;
				delete uniforms.metalness;
				delete uniforms.roughnessMap;
				delete uniforms.metalnessMap;

				uniforms.specular = { value: new THREE.Color().setHex(0x111111) };
				uniforms.glossiness = { value: 0.5 };
				uniforms.specularMap = { value: null };
				uniforms.glossinessMap = { value: null };

				params.vertexShader = shader.vertexShader;
				params.fragmentShader = fragmentShader;
				params.uniforms = uniforms;
				params.defines = { 'STANDARD': '' };

				params.color = new THREE.Color(1.0, 1.0, 1.0);
				params.opacity = 1.0;

				var pending = [];

				if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {

					var array = pbrSpecularGlossiness.diffuseFactor;

					params.color.fromArray(array);
					params.opacity = array[3];
				}

				if (pbrSpecularGlossiness.diffuseTexture !== undefined) {

					pending.push(parser.assignTexture(params, 'map', pbrSpecularGlossiness.diffuseTexture.index));
				}

				params.emissive = new THREE.Color(0.0, 0.0, 0.0);
				params.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
				params.specular = new THREE.Color(1.0, 1.0, 1.0);

				if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {

					params.specular.fromArray(pbrSpecularGlossiness.specularFactor);
				}

				if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {

					var specGlossIndex = pbrSpecularGlossiness.specularGlossinessTexture.index;
					pending.push(parser.assignTexture(params, 'glossinessMap', specGlossIndex));
					pending.push(parser.assignTexture(params, 'specularMap', specGlossIndex));
				}

				return Promise.all(pending);
			},

			createMaterial: function createMaterial(params) {

				// setup material properties based on MeshStandardMaterial for Specular-Glossiness

				var material = new THREE.ShaderMaterial({
					defines: params.defines,
					vertexShader: params.vertexShader,
					fragmentShader: params.fragmentShader,
					uniforms: params.uniforms,
					fog: true,
					lights: true,
					opacity: params.opacity,
					transparent: params.transparent
				});

				material.isGLTFSpecularGlossinessMaterial = true;

				material.color = params.color;

				material.map = params.map === undefined ? null : params.map;

				material.lightMap = null;
				material.lightMapIntensity = 1.0;

				material.aoMap = params.aoMap === undefined ? null : params.aoMap;
				material.aoMapIntensity = 1.0;

				material.emissive = params.emissive;
				material.emissiveIntensity = 1.0;
				material.emissiveMap = params.emissiveMap === undefined ? null : params.emissiveMap;

				material.bumpMap = params.bumpMap === undefined ? null : params.bumpMap;
				material.bumpScale = 1;

				material.normalMap = params.normalMap === undefined ? null : params.normalMap;
				if (params.normalScale) material.normalScale = params.normalScale;

				material.displacementMap = null;
				material.displacementScale = 1;
				material.displacementBias = 0;

				material.specularMap = params.specularMap === undefined ? null : params.specularMap;
				material.specular = params.specular;

				material.glossinessMap = params.glossinessMap === undefined ? null : params.glossinessMap;
				material.glossiness = params.glossiness;

				material.alphaMap = null;

				material.envMap = params.envMap === undefined ? null : params.envMap;
				material.envMapIntensity = 1.0;

				material.refractionRatio = 0.98;

				material.extensions.derivatives = true;

				return material;
			},

			/**
    * Clones a GLTFSpecularGlossinessMaterial instance. The ShaderMaterial.copy() method can
    * copy only properties it knows about or inherits, and misses many properties that would
    * normally be defined by MeshStandardMaterial.
    *
    * This method allows GLTFSpecularGlossinessMaterials to be cloned in the process of
    * loading a glTF model, but cloning later (e.g. by the user) would require these changes
    * AND also updating `.onBeforeRender` on the parent mesh.
    *
    * @param  {THREE.ShaderMaterial} source
    * @return {THREE.ShaderMaterial}
    */
			cloneMaterial: function cloneMaterial(source) {

				var target = source.clone();

				target.isGLTFSpecularGlossinessMaterial = true;

				var params = this.specularGlossinessParams;

				for (var i = 0, il = params.length; i < il; i++) {

					target[params[i]] = source[params[i]];
				}

				return target;
			},

			// Here's based on refreshUniformsCommon() and refreshUniformsStandard() in WebGLRenderer.
			refreshUniforms: function refreshUniforms(renderer, scene, camera, geometry, material, group) {

				if (material.isGLTFSpecularGlossinessMaterial !== true) {

					return;
				}

				var uniforms = material.uniforms;
				var defines = material.defines;

				uniforms.opacity.value = material.opacity;

				uniforms.diffuse.value.copy(material.color);
				uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);

				uniforms.map.value = material.map;
				uniforms.specularMap.value = material.specularMap;
				uniforms.alphaMap.value = material.alphaMap;

				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;

				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;

				// uv repeat and offset setting priorities
				// 1. color map
				// 2. specular map
				// 3. normal map
				// 4. bump map
				// 5. alpha map
				// 6. emissive map

				var uvScaleMap;

				if (material.map) {

					uvScaleMap = material.map;
				} else if (material.specularMap) {

					uvScaleMap = material.specularMap;
				} else if (material.displacementMap) {

					uvScaleMap = material.displacementMap;
				} else if (material.normalMap) {

					uvScaleMap = material.normalMap;
				} else if (material.bumpMap) {

					uvScaleMap = material.bumpMap;
				} else if (material.glossinessMap) {

					uvScaleMap = material.glossinessMap;
				} else if (material.alphaMap) {

					uvScaleMap = material.alphaMap;
				} else if (material.emissiveMap) {

					uvScaleMap = material.emissiveMap;
				}

				if (uvScaleMap !== undefined) {

					// backwards compatibility
					if (uvScaleMap.isWebGLRenderTarget) {

						uvScaleMap = uvScaleMap.texture;
					}

					var offset;
					var repeat;

					if (uvScaleMap.matrix !== undefined) {

						// > r88.

						if (uvScaleMap.matrixAutoUpdate === true) {

							offset = uvScaleMap.offset;
							repeat = uvScaleMap.repeat;
							var rotation = uvScaleMap.rotation;
							var center = uvScaleMap.center;

							uvScaleMap.matrix.setUvTransform(offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y);
						}

						uniforms.uvTransform.value.copy(uvScaleMap.matrix);
					} else {

						// <= r87. Remove when reasonable.

						offset = uvScaleMap.offset;
						repeat = uvScaleMap.repeat;

						uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
					}
				}

				uniforms.envMap.value = material.envMap;
				uniforms.envMapIntensity.value = material.envMapIntensity;
				uniforms.flipEnvMap.value = material.envMap && material.envMap.isCubeTexture ? -1 : 1;

				uniforms.refractionRatio.value = material.refractionRatio;

				uniforms.specular.value.copy(material.specular);
				uniforms.glossiness.value = material.glossiness;

				uniforms.glossinessMap.value = material.glossinessMap;

				uniforms.emissiveMap.value = material.emissiveMap;
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.normalMap.value = material.normalMap;

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

				if (uniforms.glossinessMap.value !== null && defines.USE_GLOSSINESSMAP === undefined) {

					defines.USE_GLOSSINESSMAP = '';
					// set USE_ROUGHNESSMAP to enable vUv
					defines.USE_ROUGHNESSMAP = '';
				}

				if (uniforms.glossinessMap.value === null && defines.USE_GLOSSINESSMAP !== undefined) {

					delete defines.USE_GLOSSINESSMAP;
					delete defines.USE_ROUGHNESSMAP;
				}
			}

		};
	}

	/*********************************/
	/********** INTERPOLATION ********/
	/*********************************/

	// Spline Interpolation
	// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
	function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {

		THREE.Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
	};

	GLTFCubicSplineInterpolant.prototype = Object.create(THREE.Interpolant.prototype);
	GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;

	GLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {

		var result = this.resultBuffer;
		var values = this.sampleValues;
		var stride = this.valueSize;

		var stride2 = stride * 2;
		var stride3 = stride * 3;

		var td = t1 - t0;

		var p = (t - t0) / td;
		var pp = p * p;
		var ppp = pp * p;

		var offset1 = i1 * stride3;
		var offset0 = offset1 - stride3;

		var s0 = 2 * ppp - 3 * pp + 1;
		var s1 = ppp - 2 * pp + p;
		var s2 = -2 * ppp + 3 * pp;
		var s3 = ppp - pp;

		// Layout of keyframe output values for CUBICSPLINE animations:
		//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
		for (var i = 0; i !== stride; i++) {

			var p0 = values[offset0 + i + stride]; // splineVertex_k
			var m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)
			var p1 = values[offset1 + i + stride]; // splineVertex_k+1
			var m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)

			result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
		}

		return result;
	};

	/*********************************/
	/********** INTERNALS ************/
	/*********************************/

	/* CONSTANTS */

	var WEBGL_CONSTANTS = {
		FLOAT: 5126,
		//FLOAT_MAT2: 35674,
		FLOAT_MAT3: 35675,
		FLOAT_MAT4: 35676,
		FLOAT_VEC2: 35664,
		FLOAT_VEC3: 35665,
		FLOAT_VEC4: 35666,
		LINEAR: 9729,
		REPEAT: 10497,
		SAMPLER_2D: 35678,
		POINTS: 0,
		LINES: 1,
		LINE_LOOP: 2,
		LINE_STRIP: 3,
		TRIANGLES: 4,
		TRIANGLE_STRIP: 5,
		TRIANGLE_FAN: 6,
		UNSIGNED_BYTE: 5121,
		UNSIGNED_SHORT: 5123
	};

	var WEBGL_TYPE = {
		5126: Number,
		//35674: THREE.Matrix2,
		35675: THREE.Matrix3,
		35676: THREE.Matrix4,
		35664: THREE.Vector2,
		35665: THREE.Vector3,
		35666: THREE.Vector4,
		35678: THREE.Texture
	};

	var WEBGL_COMPONENT_TYPES = {
		5120: Int8Array,
		5121: Uint8Array,
		5122: Int16Array,
		5123: Uint16Array,
		5125: Uint32Array,
		5126: Float32Array
	};

	var WEBGL_FILTERS = {
		9728: THREE.NearestFilter,
		9729: THREE.LinearFilter,
		9984: THREE.NearestMipMapNearestFilter,
		9985: THREE.LinearMipMapNearestFilter,
		9986: THREE.NearestMipMapLinearFilter,
		9987: THREE.LinearMipMapLinearFilter
	};

	var WEBGL_WRAPPINGS = {
		33071: THREE.ClampToEdgeWrapping,
		33648: THREE.MirroredRepeatWrapping,
		10497: THREE.RepeatWrapping
	};

	var WEBGL_TEXTURE_FORMATS = {
		6406: THREE.AlphaFormat,
		6407: THREE.RGBFormat,
		6408: THREE.RGBAFormat,
		6409: THREE.LuminanceFormat,
		6410: THREE.LuminanceAlphaFormat
	};

	var WEBGL_TEXTURE_DATATYPES = {
		5121: THREE.UnsignedByteType,
		32819: THREE.UnsignedShort4444Type,
		32820: THREE.UnsignedShort5551Type,
		33635: THREE.UnsignedShort565Type
	};

	var WEBGL_SIDES = {
		1028: THREE.BackSide, // Culling front
		1029: THREE.FrontSide // Culling back
		//1032: THREE.NoSide   // Culling front and back, what to do?
	};

	var WEBGL_DEPTH_FUNCS = {
		512: THREE.NeverDepth,
		513: THREE.LessDepth,
		514: THREE.EqualDepth,
		515: THREE.LessEqualDepth,
		516: THREE.GreaterEqualDepth,
		517: THREE.NotEqualDepth,
		518: THREE.GreaterEqualDepth,
		519: THREE.AlwaysDepth
	};

	var WEBGL_BLEND_EQUATIONS = {
		32774: THREE.AddEquation,
		32778: THREE.SubtractEquation,
		32779: THREE.ReverseSubtractEquation
	};

	var WEBGL_BLEND_FUNCS = {
		0: THREE.ZeroFactor,
		1: THREE.OneFactor,
		768: THREE.SrcColorFactor,
		769: THREE.OneMinusSrcColorFactor,
		770: THREE.SrcAlphaFactor,
		771: THREE.OneMinusSrcAlphaFactor,
		772: THREE.DstAlphaFactor,
		773: THREE.OneMinusDstAlphaFactor,
		774: THREE.DstColorFactor,
		775: THREE.OneMinusDstColorFactor,
		776: THREE.SrcAlphaSaturateFactor
		// The followings are not supported by Three.js yet
		//32769: CONSTANT_COLOR,
		//32770: ONE_MINUS_CONSTANT_COLOR,
		//32771: CONSTANT_ALPHA,
		//32772: ONE_MINUS_CONSTANT_COLOR
	};

	var WEBGL_TYPE_SIZES = {
		'SCALAR': 1,
		'VEC2': 2,
		'VEC3': 3,
		'VEC4': 4,
		'MAT2': 4,
		'MAT3': 9,
		'MAT4': 16
	};

	var ATTRIBUTES = {
		POSITION: 'position',
		NORMAL: 'normal',
		TEXCOORD_0: 'uv',
		TEXCOORD0: 'uv', // deprecated
		TEXCOORD: 'uv', // deprecated
		TEXCOORD_1: 'uv2',
		COLOR_0: 'color',
		COLOR0: 'color', // deprecated
		COLOR: 'color', // deprecated
		WEIGHTS_0: 'skinWeight',
		WEIGHT: 'skinWeight', // deprecated
		JOINTS_0: 'skinIndex',
		JOINT: 'skinIndex' // deprecated
	};

	var PATH_PROPERTIES = {
		scale: 'scale',
		translation: 'position',
		rotation: 'quaternion',
		weights: 'morphTargetInfluences'
	};

	var INTERPOLATION = {
		CUBICSPLINE: THREE.InterpolateSmooth, // We use custom interpolation GLTFCubicSplineInterpolation for CUBICSPLINE.
		// KeyframeTrack.optimize() can't handle glTF Cubic Spline output values layout,
		// using THREE.InterpolateSmooth for KeyframeTrack instantiation to prevent optimization.
		// See KeyframeTrack.optimize() for the detail.
		LINEAR: THREE.InterpolateLinear,
		STEP: THREE.InterpolateDiscrete
	};

	var STATES_ENABLES = {
		2884: 'CULL_FACE',
		2929: 'DEPTH_TEST',
		3042: 'BLEND',
		3089: 'SCISSOR_TEST',
		32823: 'POLYGON_OFFSET_FILL',
		32926: 'SAMPLE_ALPHA_TO_COVERAGE'
	};

	var ALPHA_MODES = {
		OPAQUE: 'OPAQUE',
		MASK: 'MASK',
		BLEND: 'BLEND'
	};

	/* UTILITY FUNCTIONS */

	function resolveURL(url, path) {

		// Invalid URL
		if (typeof url !== 'string' || url === '') return '';

		// Absolute URL http://,https://,//
		if (/^(https?:)?\/\//i.test(url)) return url;

		// Data URI
		if (/^data:.*,.*$/i.test(url)) return url;

		// Blob URL
		if (/^blob:.*$/i.test(url)) return url;

		// Relative URL
		return path + url;
	}

	/**
  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
  */
	function createDefaultMaterial() {

		return new THREE.MeshStandardMaterial({
			color: 0xFFFFFF,
			emissive: 0x000000,
			metalness: 1,
			roughness: 1,
			transparent: false,
			depthTest: true,
			side: THREE.FrontSide
		});
	}

	/**
  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
  *
  * @param {THREE.Mesh} mesh
  * @param {GLTF.Mesh} meshDef
  * @param {GLTF.Primitive} primitiveDef
  * @param {Array<THREE.BufferAttribute>} accessors
  */
	function addMorphTargets(mesh, meshDef, primitiveDef, accessors) {

		var geometry = mesh.geometry;
		var targets = primitiveDef.targets;

		var hasMorphPosition = false;
		var hasMorphNormal = false;

		for (var i = 0, il = targets.length; i < il; i++) {

			var target = targets[i];

			if (target.POSITION !== undefined) hasMorphPosition = true;
			if (target.NORMAL !== undefined) hasMorphNormal = true;

			if (hasMorphPosition && hasMorphNormal) break;
		}

		if (!hasMorphPosition && !hasMorphNormal) return;

		var morphPositions = [];
		var morphNormals = [];

		for (var i = 0, il = targets.length; i < il; i++) {

			var target = targets[i];
			var attributeName = 'morphTarget' + i;

			if (hasMorphPosition) {

				// Three.js morph position is absolute value. The formula is
				//   basePosition
				//     + weight0 * ( morphPosition0 - basePosition )
				//     + weight1 * ( morphPosition1 - basePosition )
				//     ...
				// while the glTF one is relative
				//   basePosition
				//     + weight0 * glTFmorphPosition0
				//     + weight1 * glTFmorphPosition1
				//     ...
				// then we need to convert from relative to absolute here.

				if (target.POSITION !== undefined) {

					// Cloning not to pollute original accessor
					var positionAttribute = cloneBufferAttribute(accessors[target.POSITION]);
					positionAttribute.name = attributeName;

					var position = geometry.attributes.position;

					for (var j = 0, jl = positionAttribute.count; j < jl; j++) {

						positionAttribute.setXYZ(j, positionAttribute.getX(j) + position.getX(j), positionAttribute.getY(j) + position.getY(j), positionAttribute.getZ(j) + position.getZ(j));
					}
				} else {

					positionAttribute = geometry.attributes.position;
				}

				morphPositions.push(positionAttribute);
			}

			if (hasMorphNormal) {

				// see target.POSITION's comment

				var normalAttribute;

				if (target.NORMAL !== undefined) {

					var normalAttribute = cloneBufferAttribute(accessors[target.NORMAL]);
					normalAttribute.name = attributeName;

					var normal = geometry.attributes.normal;

					for (var j = 0, jl = normalAttribute.count; j < jl; j++) {

						normalAttribute.setXYZ(j, normalAttribute.getX(j) + normal.getX(j), normalAttribute.getY(j) + normal.getY(j), normalAttribute.getZ(j) + normal.getZ(j));
					}
				} else {

					normalAttribute = geometry.attributes.normal;
				}

				morphNormals.push(normalAttribute);
			}
		}

		if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;
		if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;

		mesh.updateMorphTargets();

		if (meshDef.weights !== undefined) {

			for (var i = 0, il = meshDef.weights.length; i < il; i++) {

				mesh.morphTargetInfluences[i] = meshDef.weights[i];
			}
		}

		// .extras has user-defined data, so check that .extras.targetNames is an array.
		if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {

			var targetNames = meshDef.extras.targetNames;

			if (mesh.morphTargetInfluences.length === targetNames.length) {

				mesh.morphTargetDictionary = {};

				for (var i = 0, il = targetNames.length; i < il; i++) {

					mesh.morphTargetDictionary[targetNames[i]] = i;
				}
			} else {

				console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');
			}
		}
	}

	function isPrimitiveEqual(a, b) {

		if (a.indices !== b.indices) {

			return false;
		}

		var attribA = a.attributes || {};
		var attribB = b.attributes || {};
		var keysA = Object.keys(attribA);
		var keysB = Object.keys(attribB);

		if (keysA.length !== keysB.length) {

			return false;
		}

		for (var i = 0, il = keysA.length; i < il; i++) {

			var key = keysA[i];

			if (attribA[key] !== attribB[key]) {

				return false;
			}
		}

		return true;
	}

	function getCachedGeometry(cache, newPrimitive) {

		for (var i = 0, il = cache.length; i < il; i++) {

			var cached = cache[i];

			if (isPrimitiveEqual(cached.primitive, newPrimitive)) {

				return cached.promise;
			}
		}

		return null;
	}

	function cloneBufferAttribute(attribute) {

		if (attribute.isInterleavedBufferAttribute) {

			var count = attribute.count;
			var itemSize = attribute.itemSize;
			var array = attribute.array.slice(0, count * itemSize);

			for (var i = 0; i < count; ++i) {

				array[i] = attribute.getX(i);
				if (itemSize >= 2) array[i + 1] = attribute.getY(i);
				if (itemSize >= 3) array[i + 2] = attribute.getZ(i);
				if (itemSize >= 4) array[i + 3] = attribute.getW(i);
			}

			return new THREE.BufferAttribute(array, itemSize, attribute.normalized);
		}

		return attribute.clone();
	}

	/* GLTF PARSER */

	function GLTFParser(json, extensions, options) {

		this.json = json || {};
		this.extensions = extensions || {};
		this.options = options || {};

		// loader object cache
		this.cache = new GLTFRegistry();

		// BufferGeometry caching
		this.primitiveCache = [];

		this.textureLoader = new THREE.TextureLoader(this.options.manager);
		this.textureLoader.setCrossOrigin(this.options.crossOrigin);

		this.fileLoader = new THREE.FileLoader(this.options.manager);
		this.fileLoader.setResponseType('arraybuffer');
	}

	GLTFParser.prototype.parse = function (onLoad, onError) {

		var json = this.json;

		// Clear the loader cache
		this.cache.removeAll();

		// Mark the special nodes/meshes in json for efficient parse
		this.markDefs();

		// Fire the callback on complete
		this.getMultiDependencies(['scene', 'animation', 'camera']).then(function (dependencies) {

			var scenes = dependencies.scenes || [];
			var scene = scenes[json.scene || 0];
			var animations = dependencies.animations || [];
			var asset = json.asset;
			var cameras = dependencies.cameras || [];

			onLoad(scene, scenes, cameras, animations, asset);
		}).catch(onError);
	};

	/**
  * Marks the special nodes/meshes in json for efficient parse.
  */
	GLTFParser.prototype.markDefs = function () {

		var nodeDefs = this.json.nodes || [];
		var skinDefs = this.json.skins || [];
		var meshDefs = this.json.meshes || [];

		var meshReferences = {};
		var meshUses = {};

		// Nothing in the node definition indicates whether it is a Bone or an
		// Object3D. Use the skins' joint references to mark bones.
		for (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {

			var joints = skinDefs[skinIndex].joints;

			for (var i = 0, il = joints.length; i < il; i++) {

				nodeDefs[joints[i]].isBone = true;
			}
		}

		// Meshes can (and should) be reused by multiple nodes in a glTF asset. To
		// avoid having more than one THREE.Mesh with the same name, count
		// references and rename instances below.
		//
		// Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
		for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {

			var nodeDef = nodeDefs[nodeIndex];

			if (nodeDef.mesh !== undefined) {

				if (meshReferences[nodeDef.mesh] === undefined) {

					meshReferences[nodeDef.mesh] = meshUses[nodeDef.mesh] = 0;
				}

				meshReferences[nodeDef.mesh]++;

				// Nothing in the mesh definition indicates whether it is
				// a SkinnedMesh or Mesh. Use the node's mesh reference
				// to mark SkinnedMesh if node has skin.
				if (nodeDef.skin !== undefined) {

					meshDefs[nodeDef.mesh].isSkinnedMesh = true;
				}
			}
		}

		this.json.meshReferences = meshReferences;
		this.json.meshUses = meshUses;
	};

	/**
  * Requests the specified dependency asynchronously, with caching.
  * @param {string} type
  * @param {number} index
  * @return {Promise<Object>}
  */
	GLTFParser.prototype.getDependency = function (type, index) {

		var cacheKey = type + ':' + index;
		var dependency = this.cache.get(cacheKey);

		if (!dependency) {

			switch (type) {

				case 'scene':
					dependency = this.loadScene(index);
					break;

				case 'node':
					dependency = this.loadNode(index);
					break;

				case 'mesh':
					dependency = this.loadMesh(index);
					break;

				case 'accessor':
					dependency = this.loadAccessor(index);
					break;

				case 'bufferView':
					dependency = this.loadBufferView(index);
					break;

				case 'buffer':
					dependency = this.loadBuffer(index);
					break;

				case 'material':
					dependency = this.loadMaterial(index);
					break;

				case 'texture':
					dependency = this.loadTexture(index);
					break;

				case 'skin':
					dependency = this.loadSkin(index);
					break;

				case 'animation':
					dependency = this.loadAnimation(index);
					break;

				case 'camera':
					dependency = this.loadCamera(index);
					break;

				default:
					throw new Error('Unknown type: ' + type);

			}

			this.cache.add(cacheKey, dependency);
		}

		return dependency;
	};

	/**
  * Requests all dependencies of the specified type asynchronously, with caching.
  * @param {string} type
  * @return {Promise<Array<Object>>}
  */
	GLTFParser.prototype.getDependencies = function (type) {

		var dependencies = this.cache.get(type);

		if (!dependencies) {

			var parser = this;
			var defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];

			dependencies = Promise.all(defs.map(function (def, index) {

				return parser.getDependency(type, index);
			}));

			this.cache.add(type, dependencies);
		}

		return dependencies;
	};

	/**
  * Requests all multiple dependencies of the specified types asynchronously, with caching.
  * @param {Array<string>} types
  * @return {Promise<Object<Array<Object>>>}
  */
	GLTFParser.prototype.getMultiDependencies = function (types) {

		var results = {};
		var pendings = [];

		for (var i = 0, il = types.length; i < il; i++) {

			var type = types[i];
			var value = this.getDependencies(type);

			value = value.then(function (key, value) {

				results[key] = value;
			}.bind(this, type + (type === 'mesh' ? 'es' : 's')));

			pendings.push(value);
		}

		return Promise.all(pendings).then(function () {

			return results;
		});
	};

	/**
  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
  * @param {number} bufferIndex
  * @return {Promise<ArrayBuffer>}
  */
	GLTFParser.prototype.loadBuffer = function (bufferIndex) {

		var bufferDef = this.json.buffers[bufferIndex];
		var loader = this.fileLoader;

		if (bufferDef.type && bufferDef.type !== 'arraybuffer') {

			throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');
		}

		// If present, GLB container is required to be the first buffer.
		if (bufferDef.uri === undefined && bufferIndex === 0) {

			return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
		}

		var options = this.options;

		return new Promise(function (resolve, reject) {

			loader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {

				reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
			});
		});
	};

	/**
  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
  * @param {number} bufferViewIndex
  * @return {Promise<ArrayBuffer>}
  */
	GLTFParser.prototype.loadBufferView = function (bufferViewIndex) {

		var bufferViewDef = this.json.bufferViews[bufferViewIndex];

		return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {

			var byteLength = bufferViewDef.byteLength || 0;
			var byteOffset = bufferViewDef.byteOffset || 0;
			return buffer.slice(byteOffset, byteOffset + byteLength);
		});
	};

	/**
  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
  * @param {number} accessorIndex
  * @return {Promise<THREE.BufferAttribute|THREE.InterleavedBufferAttribute>}
  */
	GLTFParser.prototype.loadAccessor = function (accessorIndex) {

		var parser = this;
		var json = this.json;

		var accessorDef = this.json.accessors[accessorIndex];

		if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {

			// Ignore empty accessors, which may be used to declare runtime
			// information about attributes coming from another source (e.g. Draco
			// compression extension).
			return null;
		}

		var pendingBufferViews = [];

		if (accessorDef.bufferView !== undefined) {

			pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));
		} else {

			pendingBufferViews.push(null);
		}

		if (accessorDef.sparse !== undefined) {

			pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));
			pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));
		}

		return Promise.all(pendingBufferViews).then(function (bufferViews) {

			var bufferView = bufferViews[0];

			var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
			var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];

			// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
			var elementBytes = TypedArray.BYTES_PER_ELEMENT;
			var itemBytes = elementBytes * itemSize;
			var byteOffset = accessorDef.byteOffset || 0;
			var byteStride = json.bufferViews[accessorDef.bufferView].byteStride;
			var normalized = accessorDef.normalized === true;
			var array, bufferAttribute;

			// The buffer is not interleaved if the stride is the item size in bytes.
			if (byteStride && byteStride !== itemBytes) {

				var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType;
				var ib = parser.cache.get(ibCacheKey);

				if (!ib) {

					// Use the full buffer if it's interleaved.
					array = new TypedArray(bufferView);

					// Integer parameters to IB/IBA are in array elements, not bytes.
					ib = new THREE.InterleavedBuffer(array, byteStride / elementBytes);

					parser.cache.add(ibCacheKey, ib);
				}

				bufferAttribute = new THREE.InterleavedBufferAttribute(ib, itemSize, byteOffset / elementBytes, normalized);
			} else {

				if (bufferView === null) {

					array = new TypedArray(accessorDef.count * itemSize);
				} else {

					array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
				}

				bufferAttribute = new THREE.BufferAttribute(array, itemSize, normalized);
			}

			// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
			if (accessorDef.sparse !== undefined) {

				var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
				var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];

				var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
				var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;

				var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
				var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);

				if (bufferView !== null) {

					// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
					bufferAttribute.setArray(bufferAttribute.array.slice());
				}

				for (var i = 0, il = sparseIndices.length; i < il; i++) {

					var index = sparseIndices[i];

					bufferAttribute.setX(index, sparseValues[i * itemSize]);
					if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
					if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
					if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
					if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');
				}
			}

			return bufferAttribute;
		});
	};

	/**
  * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
  * @param {number} textureIndex
  * @return {Promise<THREE.Texture>}
  */
	GLTFParser.prototype.loadTexture = function (textureIndex) {

		var parser = this;
		var json = this.json;
		var options = this.options;
		var textureLoader = this.textureLoader;

		var URL = window.URL || window.webkitURL;

		var textureDef = json.textures[textureIndex];

		var textureExtensions = textureDef.extensions || {};

		var source;

		if (textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]) {

			source = json.images[textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS].source];
		} else {

			source = json.images[textureDef.source];
		}

		var sourceURI = source.uri;
		var isObjectURL = false;

		if (source.bufferView !== undefined) {

			// Load binary image data from bufferView, if provided.

			sourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {

				isObjectURL = true;
				var blob = new Blob([bufferView], { type: source.mimeType });
				sourceURI = URL.createObjectURL(blob);
				return sourceURI;
			});
		}

		return Promise.resolve(sourceURI).then(function (sourceURI) {

			// Load Texture resource.

			var loader = THREE.Loader.Handlers.get(sourceURI);

			if (!loader) {

				loader = textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS] ? parser.extensions[EXTENSIONS.MSFT_TEXTURE_DDS].ddsLoader : textureLoader;
			}

			return new Promise(function (resolve, reject) {

				loader.load(resolveURL(sourceURI, options.path), resolve, undefined, reject);
			});
		}).then(function (texture) {

			// Clean up resources and configure Texture.

			if (isObjectURL === true) {

				URL.revokeObjectURL(sourceURI);
			}

			texture.flipY = false;

			if (textureDef.name !== undefined) texture.name = textureDef.name;

			// .format of dds texture is set in DDSLoader
			if (!textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]) {

				texture.format = textureDef.format !== undefined ? WEBGL_TEXTURE_FORMATS[textureDef.format] : THREE.RGBAFormat;
			}

			if (textureDef.internalFormat !== undefined && texture.format !== WEBGL_TEXTURE_FORMATS[textureDef.internalFormat]) {

				console.warn('THREE.GLTFLoader: Three.js does not support texture internalFormat which is different from texture format. ' + 'internalFormat will be forced to be the same value as format.');
			}

			texture.type = textureDef.type !== undefined ? WEBGL_TEXTURE_DATATYPES[textureDef.type] : THREE.UnsignedByteType;

			var samplers = json.samplers || {};
			var sampler = samplers[textureDef.sampler] || {};

			texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || THREE.LinearFilter;
			texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || THREE.LinearMipMapLinearFilter;
			texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || THREE.RepeatWrapping;
			texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || THREE.RepeatWrapping;

			return texture;
		});
	};

	/**
  * Asynchronously assigns a texture to the given material parameters.
  * @param {Object} materialParams
  * @param {string} textureName
  * @param {number} textureIndex
  * @return {Promise}
  */
	GLTFParser.prototype.assignTexture = function (materialParams, textureName, textureIndex) {

		return this.getDependency('texture', textureIndex).then(function (texture) {

			materialParams[textureName] = texture;
		});
	};

	/**
  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
  * @param {number} materialIndex
  * @return {Promise<THREE.Material>}
  */
	GLTFParser.prototype.loadMaterial = function (materialIndex) {

		var parser = this;
		var json = this.json;
		var extensions = this.extensions;
		var materialDef = this.json.materials[materialIndex];

		var materialType;
		var materialParams = {};
		var materialExtensions = materialDef.extensions || {};

		var pending = [];

		if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {

			var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
			materialType = sgExtension.getMaterialType(materialDef);
			pending.push(sgExtension.extendParams(materialParams, materialDef, parser));
		} else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {

			var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
			materialType = kmuExtension.getMaterialType(materialDef);
			pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
		} else {

			// Specification:
			// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

			materialType = THREE.MeshStandardMaterial;

			var metallicRoughness = materialDef.pbrMetallicRoughness || {};

			materialParams.color = new THREE.Color(1.0, 1.0, 1.0);
			materialParams.opacity = 1.0;

			if (Array.isArray(metallicRoughness.baseColorFactor)) {

				var array = metallicRoughness.baseColorFactor;

				materialParams.color.fromArray(array);
				materialParams.opacity = array[3];
			}

			if (metallicRoughness.baseColorTexture !== undefined) {

				pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture.index));
			}

			materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
			materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

			if (metallicRoughness.metallicRoughnessTexture !== undefined) {

				var textureIndex = metallicRoughness.metallicRoughnessTexture.index;
				pending.push(parser.assignTexture(materialParams, 'metalnessMap', textureIndex));
				pending.push(parser.assignTexture(materialParams, 'roughnessMap', textureIndex));
			}
		}

		if (materialDef.doubleSided === true) {

			materialParams.side = THREE.DoubleSide;
		}

		var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

		if (alphaMode === ALPHA_MODES.BLEND) {

			materialParams.transparent = true;
		} else {

			materialParams.transparent = false;

			if (alphaMode === ALPHA_MODES.MASK) {

				materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;
			}
		}

		if (materialDef.normalTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {

			pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture.index));

			materialParams.normalScale = new THREE.Vector2(1, 1);

			if (materialDef.normalTexture.scale !== undefined) {

				materialParams.normalScale.set(materialDef.normalTexture.scale, materialDef.normalTexture.scale);
			}
		}

		if (materialDef.occlusionTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {

			pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture.index));

			if (materialDef.occlusionTexture.strength !== undefined) {

				materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
			}
		}

		if (materialDef.emissiveFactor !== undefined && materialType !== THREE.MeshBasicMaterial) {

			materialParams.emissive = new THREE.Color().fromArray(materialDef.emissiveFactor);
		}

		if (materialDef.emissiveTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {

			pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture.index));
		}

		return Promise.all(pending).then(function () {

			var material;

			if (materialType === THREE.ShaderMaterial) {

				material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);
			} else {

				material = new materialType(materialParams);
			}

			if (materialDef.name !== undefined) material.name = materialDef.name;

			// Normal map textures use OpenGL conventions:
			// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#materialnormaltexture
			if (material.normalScale) {

				material.normalScale.y = -material.normalScale.y;
			}

			// emissiveTexture and baseColorTexture use sRGB encoding.
			if (material.map) material.map.encoding = THREE.sRGBEncoding;
			if (material.emissiveMap) material.emissiveMap.encoding = THREE.sRGBEncoding;

			if (materialDef.extras) material.userData = materialDef.extras;

			return material;
		});
	};

	/**
  * @param  {THREE.BufferGeometry} geometry
  * @param  {GLTF.Primitive} primitiveDef
  * @param  {Array<THREE.BufferAttribute>} accessors
  */
	function addPrimitiveAttributes(geometry, primitiveDef, accessors) {

		var attributes = primitiveDef.attributes;

		for (var gltfAttributeName in attributes) {

			var threeAttributeName = ATTRIBUTES[gltfAttributeName];
			var bufferAttribute = accessors[attributes[gltfAttributeName]];

			// Skip attributes already provided by e.g. Draco extension.
			if (!threeAttributeName) continue;
			if (threeAttributeName in geometry.attributes) continue;

			geometry.addAttribute(threeAttributeName, bufferAttribute);
		}

		if (primitiveDef.indices !== undefined && !geometry.index) {

			geometry.setIndex(accessors[primitiveDef.indices]);
		}
	}

	/**
  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
  * @param {Array<Object>} primitives
  * @return {Promise<Array<THREE.BufferGeometry>>}
  */
	GLTFParser.prototype.loadGeometries = function (primitives) {

		var parser = this;
		var extensions = this.extensions;
		var cache = this.primitiveCache;

		return this.getDependencies('accessor').then(function (accessors) {

			var pending = [];

			for (var i = 0, il = primitives.length; i < il; i++) {

				var primitive = primitives[i];

				// See if we've already created this geometry
				var cached = getCachedGeometry(cache, primitive);

				if (cached) {

					// Use the cached geometry if it exists
					pending.push(cached);
				} else if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {

					// Use DRACO geometry if available
					var geometryPromise = extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {

						addPrimitiveAttributes(geometry, primitive, accessors);

						return geometry;
					});

					cache.push({ primitive: primitive, promise: geometryPromise });

					pending.push(geometryPromise);
				} else {

					// Otherwise create a new geometry
					var geometry = new THREE.BufferGeometry();

					addPrimitiveAttributes(geometry, primitive, accessors);

					var geometryPromise = Promise.resolve(geometry);

					// Cache this geometry
					cache.push({

						primitive: primitive,
						promise: geometryPromise

					});

					pending.push(geometryPromise);
				}
			}

			return Promise.all(pending);
		});
	};

	/**
  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
  * @param {number} meshIndex
  * @return {Promise<THREE.Group|THREE.Mesh|THREE.SkinnedMesh>}
  */
	GLTFParser.prototype.loadMesh = function (meshIndex) {

		var scope = this;
		var json = this.json;
		var extensions = this.extensions;

		var meshDef = this.json.meshes[meshIndex];

		return this.getMultiDependencies(['accessor', 'material']).then(function (dependencies) {

			var group = new THREE.Group();

			var primitives = meshDef.primitives;

			return scope.loadGeometries(primitives).then(function (geometries) {

				for (var i = 0, il = primitives.length; i < il; i++) {

					var primitive = primitives[i];
					var geometry = geometries[i];

					var material = primitive.material === undefined ? createDefaultMaterial() : dependencies.materials[primitive.material];

					if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {

						console.log('THREE.GLTFLoader: Duplicating UVs to support aoMap.');
						geometry.addAttribute('uv2', new THREE.BufferAttribute(geometry.attributes.uv.array, 2));
					}

					// If the material will be modified later on, clone it now.
					var useVertexColors = geometry.attributes.color !== undefined;
					var useFlatShading = geometry.attributes.normal === undefined;
					var useSkinning = meshDef.isSkinnedMesh === true;
					var useMorphTargets = primitive.targets !== undefined;

					if (useVertexColors || useFlatShading || useSkinning || useMorphTargets) {

						if (material.isGLTFSpecularGlossinessMaterial) {

							var specGlossExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
							material = specGlossExtension.cloneMaterial(material);
						} else {

							material = material.clone();
						}
					}

					if (useVertexColors) {

						material.vertexColors = THREE.VertexColors;
						material.needsUpdate = true;
					}

					if (useFlatShading) {

						material.flatShading = true;
					}

					var mesh;

					if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {

						if (useSkinning) {

							mesh = new THREE.SkinnedMesh(geometry, material);
							material.skinning = true;
						} else {

							mesh = new THREE.Mesh(geometry, material);
						}

						if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {

							mesh.drawMode = THREE.TriangleStripDrawMode;
						} else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {

							mesh.drawMode = THREE.TriangleFanDrawMode;
						}
					} else if (primitive.mode === WEBGL_CONSTANTS.LINES || primitive.mode === WEBGL_CONSTANTS.LINE_STRIP || primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {

						var cacheKey = 'LineBasicMaterial:' + material.uuid;

						var lineMaterial = scope.cache.get(cacheKey);

						if (!lineMaterial) {

							lineMaterial = new THREE.LineBasicMaterial();
							THREE.Material.prototype.copy.call(lineMaterial, material);
							lineMaterial.color.copy(material.color);
							lineMaterial.lights = false; // LineBasicMaterial doesn't support lights yet

							scope.cache.add(cacheKey, lineMaterial);
						}

						material = lineMaterial;

						if (primitive.mode === WEBGL_CONSTANTS.LINES) {

							mesh = new THREE.LineSegments(geometry, material);
						} else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {

							mesh = new THREE.Line(geometry, material);
						} else {

							mesh = new THREE.LineLoop(geometry, material);
						}
					} else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {

						var cacheKey = 'PointsMaterial:' + material.uuid;

						var pointsMaterial = scope.cache.get(cacheKey);

						if (!pointsMaterial) {

							pointsMaterial = new THREE.PointsMaterial();
							THREE.Material.prototype.copy.call(pointsMaterial, material);
							pointsMaterial.color.copy(material.color);
							pointsMaterial.map = material.map;
							pointsMaterial.lights = false; // PointsMaterial doesn't support lights yet

							scope.cache.add(cacheKey, pointsMaterial);
						}

						material = pointsMaterial;

						mesh = new THREE.Points(geometry, material);
					} else {

						throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);
					}

					mesh.name = meshDef.name || 'mesh_' + meshIndex;

					if (useMorphTargets) {

						addMorphTargets(mesh, meshDef, primitive, dependencies.accessors);

						material.morphTargets = true;

						if (mesh.geometry.morphAttributes.normal !== undefined) material.morphNormals = true;
					}

					if (meshDef.extras !== undefined) mesh.userData = meshDef.extras;
					if (primitive.extras !== undefined) mesh.geometry.userData = primitive.extras;

					// for Specular-Glossiness.
					if (material.isGLTFSpecularGlossinessMaterial === true) {

						mesh.onBeforeRender = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].refreshUniforms;
					}

					if (primitives.length > 1) {

						mesh.name += '_' + i;

						group.add(mesh);
					} else {

						return mesh;
					}
				}

				return group;
			});
		});
	};

	/**
  * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
  * @param {number} cameraIndex
  * @return {Promise<THREE.Camera>}
  */
	GLTFParser.prototype.loadCamera = function (cameraIndex) {

		var camera;
		var cameraDef = this.json.cameras[cameraIndex];
		var params = cameraDef[cameraDef.type];

		if (!params) {

			console.warn('THREE.GLTFLoader: Missing camera parameters.');
			return;
		}

		if (cameraDef.type === 'perspective') {

			camera = new THREE.PerspectiveCamera(THREE.Math.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
		} else if (cameraDef.type === 'orthographic') {

			camera = new THREE.OrthographicCamera(params.xmag / -2, params.xmag / 2, params.ymag / 2, params.ymag / -2, params.znear, params.zfar);
		}

		if (cameraDef.name !== undefined) camera.name = cameraDef.name;
		if (cameraDef.extras) camera.userData = cameraDef.extras;

		return Promise.resolve(camera);
	};

	/**
  * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
  * @param {number} skinIndex
  * @return {Promise<Object>}
  */
	GLTFParser.prototype.loadSkin = function (skinIndex) {

		var skinDef = this.json.skins[skinIndex];

		var skinEntry = { joints: skinDef.joints };

		if (skinDef.inverseBindMatrices === undefined) {

			return Promise.resolve(skinEntry);
		}

		return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {

			skinEntry.inverseBindMatrices = accessor;

			return skinEntry;
		});
	};

	/**
  * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
  * @param {number} animationIndex
  * @return {Promise<THREE.AnimationClip>}
  */
	GLTFParser.prototype.loadAnimation = function (animationIndex) {

		var json = this.json;

		var animationDef = this.json.animations[animationIndex];

		return this.getMultiDependencies(['accessor', 'node']).then(function (dependencies) {

			var tracks = [];

			for (var i = 0, il = animationDef.channels.length; i < il; i++) {

				var channel = animationDef.channels[i];
				var sampler = animationDef.samplers[channel.sampler];

				if (sampler) {

					var target = channel.target;
					var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.
					var input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;
					var output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;

					var inputAccessor = dependencies.accessors[input];
					var outputAccessor = dependencies.accessors[output];

					var node = dependencies.nodes[name];

					if (node) {

						node.updateMatrix();
						node.matrixAutoUpdate = true;

						var TypedKeyframeTrack;

						switch (PATH_PROPERTIES[target.path]) {

							case PATH_PROPERTIES.weights:

								TypedKeyframeTrack = THREE.NumberKeyframeTrack;
								break;

							case PATH_PROPERTIES.rotation:

								TypedKeyframeTrack = THREE.QuaternionKeyframeTrack;
								break;

							case PATH_PROPERTIES.position:
							case PATH_PROPERTIES.scale:
							default:

								TypedKeyframeTrack = THREE.VectorKeyframeTrack;
								break;

						}

						var targetName = node.name ? node.name : node.uuid;

						var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : THREE.InterpolateLinear;

						var targetNames = [];

						if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {

							// node should be THREE.Group here but
							// PATH_PROPERTIES.weights(morphTargetInfluences) should be
							// the property of a mesh object under node.
							// So finding targets here.

							node.traverse(function (object) {

								if (object.isMesh === true && object.material.morphTargets === true) {

									targetNames.push(object.name ? object.name : object.uuid);
								}
							});
						} else {

							targetNames.push(targetName);
						}

						// KeyframeTrack.optimize() will modify given 'times' and 'values'
						// buffers before creating a truncated copy to keep. Because buffers may
						// be reused by other tracks, make copies here.
						for (var j = 0, jl = targetNames.length; j < jl; j++) {

							var track = new TypedKeyframeTrack(targetNames[j] + '.' + PATH_PROPERTIES[target.path], THREE.AnimationUtils.arraySlice(inputAccessor.array, 0), THREE.AnimationUtils.arraySlice(outputAccessor.array, 0), interpolation);

							// Here is the trick to enable custom interpolation.
							// Overrides .createInterpolant in a factory method which creates custom interpolation.
							if (sampler.interpolation === 'CUBICSPLINE') {

								track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {

									// A CUBICSPLINE keyframe in glTF has three output values for each input value,
									// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
									// must be divided by three to get the interpolant's sampleSize argument.

									return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);
								};

								// Workaround, provide an alternate way to know if the interpolant type is cubis spline to track.
								// track.getInterpolation() doesn't return valid value for custom interpolant.
								track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
							}

							tracks.push(track);
						}
					}
				}
			}

			var name = animationDef.name !== undefined ? animationDef.name : 'animation_' + animationIndex;

			return new THREE.AnimationClip(name, undefined, tracks);
		});
	};

	/**
  * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
  * @param {number} nodeIndex
  * @return {Promise<THREE.Object3D>}
  */
	GLTFParser.prototype.loadNode = function (nodeIndex) {

		var json = this.json;
		var extensions = this.extensions;

		var meshReferences = this.json.meshReferences;
		var meshUses = this.json.meshUses;

		var nodeDef = this.json.nodes[nodeIndex];

		return this.getMultiDependencies(['mesh', 'skin', 'camera', 'light']).then(function (dependencies) {

			var node;

			if (nodeDef.isBone === true) {

				node = new THREE.Bone();
			} else if (nodeDef.mesh !== undefined) {

				var mesh = dependencies.meshes[nodeDef.mesh];

				node = mesh.clone();

				// for Specular-Glossiness
				if (mesh.isGroup === true) {

					for (var i = 0, il = mesh.children.length; i < il; i++) {

						var child = mesh.children[i];

						if (child.material && child.material.isGLTFSpecularGlossinessMaterial === true) {

							node.children[i].onBeforeRender = child.onBeforeRender;
						}
					}
				} else {

					if (mesh.material && mesh.material.isGLTFSpecularGlossinessMaterial === true) {

						node.onBeforeRender = mesh.onBeforeRender;
					}
				}

				if (meshReferences[nodeDef.mesh] > 1) {

					node.name += '_instance_' + meshUses[nodeDef.mesh]++;
				}
			} else if (nodeDef.camera !== undefined) {

				node = dependencies.cameras[nodeDef.camera];
			} else if (nodeDef.extensions && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS] && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS].light !== undefined) {

				var lights = extensions[EXTENSIONS.KHR_LIGHTS].lights;
				node = lights[nodeDef.extensions[EXTENSIONS.KHR_LIGHTS].light];
			} else {

				node = new THREE.Object3D();
			}

			if (nodeDef.name !== undefined) {

				node.name = THREE.PropertyBinding.sanitizeNodeName(nodeDef.name);
			}

			if (nodeDef.extras) node.userData = nodeDef.extras;

			if (nodeDef.matrix !== undefined) {

				var matrix = new THREE.Matrix4();
				matrix.fromArray(nodeDef.matrix);
				node.applyMatrix(matrix);
			} else {

				if (nodeDef.translation !== undefined) {

					node.position.fromArray(nodeDef.translation);
				}

				if (nodeDef.rotation !== undefined) {

					node.quaternion.fromArray(nodeDef.rotation);
				}

				if (nodeDef.scale !== undefined) {

					node.scale.fromArray(nodeDef.scale);
				}
			}

			return node;
		});
	};

	/**
  * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
  * @param {number} sceneIndex
  * @return {Promise<THREE.Scene>}
  */
	GLTFParser.prototype.loadScene = function () {

		// scene node hierachy builder

		function buildNodeHierachy(nodeId, parentObject, json, allNodes, skins) {

			var node = allNodes[nodeId];
			var nodeDef = json.nodes[nodeId];

			// build skeleton here as well

			if (nodeDef.skin !== undefined) {

				var meshes = node.isGroup === true ? node.children : [node];

				for (var i = 0, il = meshes.length; i < il; i++) {

					var mesh = meshes[i];
					var skinEntry = skins[nodeDef.skin];

					var bones = [];
					var boneInverses = [];

					for (var j = 0, jl = skinEntry.joints.length; j < jl; j++) {

						var jointId = skinEntry.joints[j];
						var jointNode = allNodes[jointId];

						if (jointNode) {

							bones.push(jointNode);

							var mat = new THREE.Matrix4();

							if (skinEntry.inverseBindMatrices !== undefined) {

								mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);
							}

							boneInverses.push(mat);
						} else {

							console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', jointId);
						}
					}

					mesh.bind(new THREE.Skeleton(bones, boneInverses), mesh.matrixWorld);
				}
			}

			// build node hierachy

			parentObject.add(node);

			if (nodeDef.children) {

				var children = nodeDef.children;

				for (var i = 0, il = children.length; i < il; i++) {

					var child = children[i];
					buildNodeHierachy(child, node, json, allNodes, skins);
				}
			}
		}

		return function loadScene(sceneIndex) {

			var json = this.json;
			var extensions = this.extensions;
			var sceneDef = this.json.scenes[sceneIndex];

			return this.getMultiDependencies(['node', 'skin']).then(function (dependencies) {

				var scene = new THREE.Scene();
				if (sceneDef.name !== undefined) scene.name = sceneDef.name;

				if (sceneDef.extras) scene.userData = sceneDef.extras;

				var nodeIds = sceneDef.nodes || [];

				for (var i = 0, il = nodeIds.length; i < il; i++) {

					buildNodeHierachy(nodeIds[i], scene, json, dependencies.nodes, dependencies.skins);
				}

				// Ambient lighting, if present, is always attached to the scene root.
				if (sceneDef.extensions && sceneDef.extensions[EXTENSIONS.KHR_LIGHTS] && sceneDef.extensions[EXTENSIONS.KHR_LIGHTS].light !== undefined) {

					var lights = extensions[EXTENSIONS.KHR_LIGHTS].lights;
					scene.add(lights[sceneDef.extensions[EXTENSIONS.KHR_LIGHTS].light]);
				}

				return scene;
			});
		};
	}();

	return GLTFLoader;
}();

exports.default = GLTFLoader;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author Nikos M. / https://github.com/foo123/
 */

// https://github.com/mrdoob/three.js/issues/5552
// http://en.wikipedia.org/wiki/RGBE_image_format

var RGBELoader = function RGBELoader(manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};

// extend THREE.DataTextureLoader
RGBELoader.prototype = Object.create(THREE.DataTextureLoader.prototype);

// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
RGBELoader.prototype._parser = function (buffer) {

	var
	/* return codes for rgbe routines */
	RGBE_RETURN_SUCCESS = 0,
	    RGBE_RETURN_FAILURE = -1,


	/* default error routine.  change this to change error handling */
	rgbe_read_error = 1,
	    rgbe_write_error = 2,
	    rgbe_format_error = 3,
	    rgbe_memory_error = 4,
	    rgbe_error = function rgbe_error(rgbe_error_code, msg) {

		switch (rgbe_error_code) {

			case rgbe_read_error:
				console.error("THREE.RGBELoader Read Error: " + (msg || ''));
				break;
			case rgbe_write_error:
				console.error("THREE.RGBELoader Write Error: " + (msg || ''));
				break;
			case rgbe_format_error:
				console.error("THREE.RGBELoader Bad File Format: " + (msg || ''));
				break;
			default:
			case rgbe_memory_error:
				console.error("THREE.RGBELoader: Error: " + (msg || ''));

		}
		return RGBE_RETURN_FAILURE;
	},


	/* offsets to red, green, and blue components in a data (float) pixel */
	RGBE_DATA_RED = 0,
	    RGBE_DATA_GREEN = 1,
	    RGBE_DATA_BLUE = 2,


	/* number of floats per pixel, use 4 since stored in rgba image format */
	RGBE_DATA_SIZE = 4,


	/* flags indicating which fields in an rgbe_header_info are valid */
	RGBE_VALID_PROGRAMTYPE = 1,
	    RGBE_VALID_FORMAT = 2,
	    RGBE_VALID_DIMENSIONS = 4,
	    NEWLINE = "\n",
	    fgets = function fgets(buffer, lineLimit, consume) {

		lineLimit = !lineLimit ? 1024 : lineLimit;
		var p = buffer.pos,
		    i = -1,
		    len = 0,
		    s = '',
		    chunkSize = 128,
		    chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));
		while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {

			s += chunk;len += chunk.length;
			p += chunkSize;
			chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));
		}

		if (-1 < i) {

			/*for (i=l-1; i>=0; i--) {
   	byteCode = m.charCodeAt(i);
   	if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;
   	else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;
   	if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate
   }*/
			if (false !== consume) buffer.pos += len + i + 1;
			return s + chunk.slice(0, i);
		}
		return false;
	},


	/* minimal header reading.  modify if you want to parse more information */
	RGBE_ReadHeader = function RGBE_ReadHeader(buffer) {

		var line,
		    match,


		// regexes to parse header info fields
		magic_token_re = /^#\?(\S+)$/,
		    gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
		    exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
		    format_re = /^\s*FORMAT=(\S+)\s*$/,
		    dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,


		// RGBE format header struct
		header = {

			valid: 0, /* indicate which fields are valid */

			string: '', /* the actual header string */

			comments: '', /* comments found in header */

			programtype: 'RGBE', /* listed at beginning of file to identify it after "#?". defaults to "RGBE" */

			format: '', /* RGBE format, default 32-bit_rle_rgbe */

			gamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */

			exposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */

			width: 0, height: 0 /* image dimensions, width/height */

		};

		if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {

			return rgbe_error(rgbe_read_error, "no header found");
		}
		/* if you want to require the magic token then uncomment the next line */
		if (!(match = line.match(magic_token_re))) {

			return rgbe_error(rgbe_format_error, "bad initial token");
		}
		header.valid |= RGBE_VALID_PROGRAMTYPE;
		header.programtype = match[1];
		header.string += line + "\n";

		while (true) {

			line = fgets(buffer);
			if (false === line) break;
			header.string += line + "\n";

			if ('#' === line.charAt(0)) {

				header.comments += line + "\n";
				continue; // comment line
			}

			if (match = line.match(gamma_re)) {

				header.gamma = parseFloat(match[1], 10);
			}
			if (match = line.match(exposure_re)) {

				header.exposure = parseFloat(match[1], 10);
			}
			if (match = line.match(format_re)) {

				header.valid |= RGBE_VALID_FORMAT;
				header.format = match[1]; //'32-bit_rle_rgbe';
			}
			if (match = line.match(dimensions_re)) {

				header.valid |= RGBE_VALID_DIMENSIONS;
				header.height = parseInt(match[1], 10);
				header.width = parseInt(match[2], 10);
			}

			if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;
		}

		if (!(header.valid & RGBE_VALID_FORMAT)) {

			return rgbe_error(rgbe_format_error, "missing format specifier");
		}
		if (!(header.valid & RGBE_VALID_DIMENSIONS)) {

			return rgbe_error(rgbe_format_error, "missing image size specifier");
		}

		return header;
	},
	    RGBE_ReadPixels_RLE = function RGBE_ReadPixels_RLE(buffer, w, h) {

		var data_rgba,
		    offset,
		    pos,
		    count,
		    byteValue,
		    scanline_buffer,
		    ptr,
		    ptr_end,
		    i,
		    l,
		    off,
		    isEncodedRun,
		    scanline_width = w,
		    num_scanlines = h,
		    rgbeStart;

		if (
		// run length encoding is not allowed so read flat
		scanline_width < 8 || scanline_width > 0x7fff ||
		// this file is not run length encoded
		2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 0x80) {

			// return the flat buffer
			return new Uint8Array(buffer);
		}

		if (scanline_width !== (buffer[2] << 8 | buffer[3])) {

			return rgbe_error(rgbe_format_error, "wrong scanline width");
		}

		data_rgba = new Uint8Array(4 * w * h);

		if (!data_rgba || !data_rgba.length) {

			return rgbe_error(rgbe_memory_error, "unable to allocate buffer space");
		}

		offset = 0;pos = 0;ptr_end = 4 * scanline_width;
		rgbeStart = new Uint8Array(4);
		scanline_buffer = new Uint8Array(ptr_end);

		// read in each successive scanline
		while (num_scanlines > 0 && pos < buffer.byteLength) {

			if (pos + 4 > buffer.byteLength) {

				return rgbe_error(rgbe_read_error);
			}

			rgbeStart[0] = buffer[pos++];
			rgbeStart[1] = buffer[pos++];
			rgbeStart[2] = buffer[pos++];
			rgbeStart[3] = buffer[pos++];

			if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {

				return rgbe_error(rgbe_format_error, "bad rgbe scanline format");
			}

			// read each of the four channels for the scanline into the buffer
			// first red, then green, then blue, then exponent
			ptr = 0;
			while (ptr < ptr_end && pos < buffer.byteLength) {

				count = buffer[pos++];
				isEncodedRun = count > 128;
				if (isEncodedRun) count -= 128;

				if (0 === count || ptr + count > ptr_end) {

					return rgbe_error(rgbe_format_error, "bad scanline data");
				}

				if (isEncodedRun) {

					// a (encoded) run of the same value
					byteValue = buffer[pos++];
					for (i = 0; i < count; i++) {

						scanline_buffer[ptr++] = byteValue;
					}
					//ptr += count;
				} else {

					// a literal-run
					scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);
					ptr += count;pos += count;
				}
			}

			// now convert data from buffer into rgba
			// first red, then green, then blue, then exponent (alpha)
			l = scanline_width; //scanline_buffer.byteLength;
			for (i = 0; i < l; i++) {

				off = 0;
				data_rgba[offset] = scanline_buffer[i + off];
				off += scanline_width; //1;
				data_rgba[offset + 1] = scanline_buffer[i + off];
				off += scanline_width; //1;
				data_rgba[offset + 2] = scanline_buffer[i + off];
				off += scanline_width; //1;
				data_rgba[offset + 3] = scanline_buffer[i + off];
				offset += 4;
			}

			num_scanlines--;
		}

		return data_rgba;
	};

	var byteArray = new Uint8Array(buffer),
	    byteLength = byteArray.byteLength;
	byteArray.pos = 0;
	var rgbe_header_info = RGBE_ReadHeader(byteArray);

	if (RGBE_RETURN_FAILURE !== rgbe_header_info) {

		var w = rgbe_header_info.width,
		    h = rgbe_header_info.height,
		    image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);
		if (RGBE_RETURN_FAILURE !== image_rgba_data) {

			return {
				width: w, height: h,
				data: image_rgba_data,
				header: rgbe_header_info.string,
				gamma: rgbe_header_info.gamma,
				exposure: rgbe_header_info.exposure,
				format: THREE.RGBEFormat, // handled as THREE.RGBAFormat in shaders
				type: THREE.UnsignedByteType
			};
		}
	}
	return null;
};

exports.default = RGBELoader;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _global = __webpack_require__(8);

var _global2 = _interopRequireDefault(_global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var window = _global2.default;

/**
  * @author Kai Salmen / https://kaisalmen.de
  * Development repository: https://github.com/kaisalmen/WWOBJLoader
  */

'use strict';

// if ( THREE.LoaderSupport === undefined ) { THREE.LoaderSupport = {} }
var LoaderSupport = {};

/**
 * Validation functions.
 * @class
 */
LoaderSupport.Validator = {
	/**
  * If given input is null or undefined, false is returned otherwise true.
  *
  * @param input Can be anything
  * @returns {boolean}
  */
	isValid: function isValid(input) {
		return input !== null && input !== undefined;
	},
	/**
  * If given input is null or undefined, the defaultValue is returned otherwise the given input.
  *
  * @param input Can be anything
  * @param defaultValue Can be anything
  * @returns {*}
  */
	verifyInput: function verifyInput(input, defaultValue) {
		return input === null || input === undefined ? defaultValue : input;
	}
};

/**
 * Callbacks utilized by loaders and builders.
 * @class
 */
LoaderSupport.Callbacks = function () {

	var Validator = LoaderSupport.Validator;

	function Callbacks() {
		this.onProgress = null;
		this.onMeshAlter = null;
		this.onLoad = null;
		this.onLoadMaterials = null;
	}

	/**
  * Register callback function that is invoked by internal function "announceProgress" to print feedback.
  * @memberOf THREE.LoaderSupport.Callbacks
  *
  * @param {callback} callbackOnProgress Callback function for described functionality
  */
	Callbacks.prototype.setCallbackOnProgress = function (callbackOnProgress) {
		this.onProgress = Validator.verifyInput(callbackOnProgress, this.onProgress);
	};

	/**
  * Register callback function that is called every time a mesh was loaded.
  * Use {@link THREE.LoaderSupport.LoadedMeshUserOverride} for alteration instructions (geometry, material or disregard mesh).
  * @memberOf THREE.LoaderSupport.Callbacks
  *
  * @param {callback} callbackOnMeshAlter Callback function for described functionality
  */
	Callbacks.prototype.setCallbackOnMeshAlter = function (callbackOnMeshAlter) {
		this.onMeshAlter = Validator.verifyInput(callbackOnMeshAlter, this.onMeshAlter);
	};

	/**
  * Register callback function that is called once loading of the complete OBJ file is completed.
  * @memberOf THREE.LoaderSupport.Callbacks
  *
  * @param {callback} callbackOnLoad Callback function for described functionality
  */
	Callbacks.prototype.setCallbackOnLoad = function (callbackOnLoad) {
		this.onLoad = Validator.verifyInput(callbackOnLoad, this.onLoad);
	};

	/**
  * Register callback function that is called when materials have been loaded.
  * @memberOf THREE.LoaderSupport.Callbacks
  *
  * @param {callback} callbackOnLoadMaterials Callback function for described functionality
  */
	Callbacks.prototype.setCallbackOnLoadMaterials = function (callbackOnLoadMaterials) {
		this.onLoadMaterials = Validator.verifyInput(callbackOnLoadMaterials, this.onLoadMaterials);
	};

	return Callbacks;
}();

/**
 * Object to return by callback onMeshAlter. Used to disregard a certain mesh or to return one to many meshes.
 * @class
 *
 * @param {boolean} disregardMesh=false Tell implementation to completely disregard this mesh
 * @param {boolean} disregardMesh=false Tell implementation that mesh(es) have been altered or added
 */
LoaderSupport.LoadedMeshUserOverride = function () {

	function LoadedMeshUserOverride(disregardMesh, alteredMesh) {
		this.disregardMesh = disregardMesh === true;
		this.alteredMesh = alteredMesh === true;
		this.meshes = [];
	}

	/**
  * Add a mesh created within callback.
  *
  * @memberOf THREE.OBJLoader2.LoadedMeshUserOverride
  *
  * @param {THREE.Mesh} mesh
  */
	LoadedMeshUserOverride.prototype.addMesh = function (mesh) {
		this.meshes.push(mesh);
		this.alteredMesh = true;
	};

	/**
  * Answers if mesh shall be disregarded completely.
  *
  * @returns {boolean}
  */
	LoadedMeshUserOverride.prototype.isDisregardMesh = function () {
		return this.disregardMesh;
	};

	/**
  * Answers if new mesh(es) were created.
  *
  * @returns {boolean}
  */
	LoadedMeshUserOverride.prototype.providesAlteredMeshes = function () {
		return this.alteredMesh;
	};

	return LoadedMeshUserOverride;
}();

/**
 * A resource description used by {@link THREE.LoaderSupport.PrepData} and others.
 * @class
 *
 * @param {string} url URL to the file
 * @param {string} extension The file extension (type)
 */
LoaderSupport.ResourceDescriptor = function () {

	var Validator = LoaderSupport.Validator;

	function ResourceDescriptor(url, extension) {
		var urlParts = url.split('/');

		if (urlParts.length < 2) {

			this.path = null;
			this.name = url;
			this.url = url;
		} else {

			this.path = Validator.verifyInput(urlParts.slice(0, urlParts.length - 1).join('/') + '/', null);
			this.name = Validator.verifyInput(urlParts[urlParts.length - 1], null);
			this.url = url;
		}
		this.extension = Validator.verifyInput(extension, "default");
		this.extension = this.extension.trim();
		this.content = null;
	}

	/**
  * Set the content of this resource
  * @memberOf THREE.LoaderSupport.ResourceDescriptor
  *
  * @param {Object} content The file content as arraybuffer or text
  */
	ResourceDescriptor.prototype.setContent = function (content) {
		this.content = Validator.verifyInput(content, null);
	};

	return ResourceDescriptor;
}();

/**
 * Configuration instructions to be used by run method.
 * @class
 */
LoaderSupport.PrepData = function () {

	var Validator = LoaderSupport.Validator;

	function PrepData(modelName) {
		this.logging = {
			enabled: true,
			debug: false
		};
		this.modelName = Validator.verifyInput(modelName, '');
		this.resources = [];
		this.callbacks = new LoaderSupport.Callbacks();
	}

	/**
  * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.
  * @memberOf THREE.LoaderSupport.PrepData
  *
  * @param {boolean} enabled True or false.
  * @param {boolean} debug True or false.
  */
	PrepData.prototype.setLogging = function (enabled, debug) {
		this.logging.enabled = enabled === true;
		this.logging.debug = debug === true;
	};

	/**
  * Returns all callbacks as {@link THREE.LoaderSupport.Callbacks}
  * @memberOf THREE.LoaderSupport.PrepData
  *
  * @returns {THREE.LoaderSupport.Callbacks}
  */
	PrepData.prototype.getCallbacks = function () {
		return this.callbacks;
	};

	/**
  * Add a resource description.
  * @memberOf THREE.LoaderSupport.PrepData
  *
  * @param {THREE.LoaderSupport.ResourceDescriptor} Adds a {@link THREE.LoaderSupport.ResourceDescriptor}
  */
	PrepData.prototype.addResource = function (resource) {
		this.resources.push(resource);
	};

	/**
  * Clones this object and returns it afterwards. Callbacks and resources are not cloned deep (references!).
  * @memberOf THREE.LoaderSupport.PrepData
  *
  * @returns {@link THREE.LoaderSupport.PrepData}
  */
	PrepData.prototype.clone = function () {
		var clone = new LoaderSupport.PrepData(this.modelName);
		clone.logging.enabled = this.logging.enabled;
		clone.logging.debug = this.logging.debug;
		clone.resources = this.resources;
		clone.callbacks = this.callbacks;

		var property, value;
		for (property in this) {

			value = this[property];
			if (!clone.hasOwnProperty(property) && typeof this[property] !== 'function') {

				clone[property] = value;
			}
		}

		return clone;
	};

	/**
  * Identify files or content of interest from an Array of {@link THREE.LoaderSupport.ResourceDescriptor}.
  * @memberOf THREE.LoaderSupport.PrepData
  *
  * @param {THREE.LoaderSupport.ResourceDescriptor[]} resources Array of {@link THREE.LoaderSupport.ResourceDescriptor}
  * @param Object fileDesc Object describing which resources are of interest (ext, type (string or UInt8Array) and ignore (boolean))
  * @returns {{}} Object with each "ext" and the corresponding {@link THREE.LoaderSupport.ResourceDescriptor}
  */
	PrepData.prototype.checkResourceDescriptorFiles = function (resources, fileDesc) {
		var resource, triple, i, found;
		var result = {};

		for (var index in resources) {

			resource = resources[index];
			found = false;
			if (!Validator.isValid(resource.name)) continue;
			if (Validator.isValid(resource.content)) {

				for (i = 0; i < fileDesc.length && !found; i++) {

					triple = fileDesc[i];
					if (resource.extension.toLowerCase() === triple.ext.toLowerCase()) {

						if (triple.ignore) {

							found = true;
						} else if (triple.type === "ArrayBuffer") {

							// fast-fail on bad type
							if (!(resource.content instanceof ArrayBuffer || resource.content instanceof Uint8Array)) throw 'Provided content is not of type ArrayBuffer! Aborting...';
							result[triple.ext] = resource;
							found = true;
						} else if (triple.type === "String") {

							if (!(typeof resource.content === 'string' || resource.content instanceof String)) throw 'Provided  content is not of type String! Aborting...';
							result[triple.ext] = resource;
							found = true;
						}
					}
				}
				if (!found) throw 'Unidentified resource "' + resource.name + '": ' + resource.url;
			} else {

				// fast-fail on bad type
				if (!(typeof resource.name === 'string' || resource.name instanceof String)) throw 'Provided file is not properly defined! Aborting...';
				for (i = 0; i < fileDesc.length && !found; i++) {

					triple = fileDesc[i];
					if (resource.extension.toLowerCase() === triple.ext.toLowerCase()) {

						if (!triple.ignore) result[triple.ext] = resource;
						found = true;
					}
				}
				if (!found) throw 'Unidentified resource "' + resource.name + '": ' + resource.url;
			}
		}

		return result;
	};

	return PrepData;
}();

/**
 * Builds one or many THREE.Mesh from one raw set of Arraybuffers, materialGroup descriptions and further parameters.
 * Supports vertex, vertexColor, normal, uv and index buffers.
 * @class
 */
LoaderSupport.MeshBuilder = function () {

	var LOADER_MESH_BUILDER_VERSION = '1.2.0';

	var Validator = LoaderSupport.Validator;

	function MeshBuilder() {
		console.info('Using THREE.LoaderSupport.MeshBuilder version: ' + LOADER_MESH_BUILDER_VERSION);
		this.logging = {
			enabled: true,
			debug: false
		};

		this.callbacks = new LoaderSupport.Callbacks();
		this.materials = [];
	}

	/**
  * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.
  * @memberOf THREE.LoaderSupport.MeshBuilder
  *
  * @param {boolean} enabled True or false.
  * @param {boolean} debug True or false.
  */
	MeshBuilder.prototype.setLogging = function (enabled, debug) {
		this.logging.enabled = enabled === true;
		this.logging.debug = debug === true;
	};

	/**
  * Initializes the MeshBuilder (currently only default material initialisation).
  * @memberOf THREE.LoaderSupport.MeshBuilder
  *
  */
	MeshBuilder.prototype.init = function () {
		var defaultMaterial = new THREE.MeshStandardMaterial({ color: 0xDCF1FF });
		defaultMaterial.name = 'defaultMaterial';

		var defaultVertexColorMaterial = new THREE.MeshStandardMaterial({ color: 0xDCF1FF });
		defaultVertexColorMaterial.name = 'defaultVertexColorMaterial';
		defaultVertexColorMaterial.vertexColors = THREE.VertexColors;

		var defaultLineMaterial = new THREE.LineBasicMaterial();
		defaultLineMaterial.name = 'defaultLineMaterial';

		var defaultPointMaterial = new THREE.PointsMaterial({ size: 1 });
		defaultPointMaterial.name = 'defaultPointMaterial';

		var runtimeMaterials = {};
		runtimeMaterials[defaultMaterial.name] = defaultMaterial;
		runtimeMaterials[defaultVertexColorMaterial.name] = defaultVertexColorMaterial;
		runtimeMaterials[defaultLineMaterial.name] = defaultLineMaterial;
		runtimeMaterials[defaultPointMaterial.name] = defaultPointMaterial;

		this.updateMaterials({
			cmd: 'materialData',
			materials: {
				materialCloneInstructions: null,
				serializedMaterials: null,
				runtimeMaterials: runtimeMaterials
			}
		});
	};

	/**
  * Set materials loaded by any supplier of an Array of {@link THREE.Material}.
  * @memberOf THREE.LoaderSupport.MeshBuilder
  *
  * @param {THREE.Material[]} materials Array of {@link THREE.Material}
  */
	MeshBuilder.prototype.setMaterials = function (materials) {
		var payload = {
			cmd: 'materialData',
			materials: {
				materialCloneInstructions: null,
				serializedMaterials: null,
				runtimeMaterials: Validator.isValid(this.callbacks.onLoadMaterials) ? this.callbacks.onLoadMaterials(materials) : materials
			}
		};
		this.updateMaterials(payload);
	};

	MeshBuilder.prototype._setCallbacks = function (callbacks) {
		if (Validator.isValid(callbacks.onProgress)) this.callbacks.setCallbackOnProgress(callbacks.onProgress);
		if (Validator.isValid(callbacks.onMeshAlter)) this.callbacks.setCallbackOnMeshAlter(callbacks.onMeshAlter);
		if (Validator.isValid(callbacks.onLoad)) this.callbacks.setCallbackOnLoad(callbacks.onLoad);
		if (Validator.isValid(callbacks.onLoadMaterials)) this.callbacks.setCallbackOnLoadMaterials(callbacks.onLoadMaterials);
	};

	/**
  * Delegates processing of the payload (mesh building or material update) to the corresponding functions (BW-compatibility).
  * @memberOf THREE.LoaderSupport.MeshBuilder
  *
  * @param {Object} payload Raw Mesh or Material descriptions.
  * @returns {THREE.Mesh[]} mesh Array of {@link THREE.Mesh} or null in case of material update
  */
	MeshBuilder.prototype.processPayload = function (payload) {
		if (payload.cmd === 'meshData') {

			return this.buildMeshes(payload);
		} else if (payload.cmd === 'materialData') {

			this.updateMaterials(payload);
			return null;
		}
	};

	/**
  * Builds one or multiple meshes from the data described in the payload (buffers, params, material info).
  * @memberOf THREE.LoaderSupport.MeshBuilder
  *
  * @param {Object} meshPayload Raw mesh description (buffers, params, materials) used to build one to many meshes.
  * @returns {THREE.Mesh[]} mesh Array of {@link THREE.Mesh}
  */
	MeshBuilder.prototype.buildMeshes = function (meshPayload) {
		var meshName = meshPayload.params.meshName;

		var bufferGeometry = new THREE.BufferGeometry();
		bufferGeometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(meshPayload.buffers.vertices), 3));
		if (Validator.isValid(meshPayload.buffers.indices)) {

			bufferGeometry.setIndex(new THREE.BufferAttribute(new Uint32Array(meshPayload.buffers.indices), 1));
		}
		var haveVertexColors = Validator.isValid(meshPayload.buffers.colors);
		if (haveVertexColors) {

			bufferGeometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(meshPayload.buffers.colors), 3));
		}
		if (Validator.isValid(meshPayload.buffers.normals)) {

			bufferGeometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(meshPayload.buffers.normals), 3));
		} else {

			bufferGeometry.computeVertexNormals();
		}
		if (Validator.isValid(meshPayload.buffers.uvs)) {

			bufferGeometry.addAttribute('uv', new THREE.BufferAttribute(new Float32Array(meshPayload.buffers.uvs), 2));
		}

		var material, materialName, key;
		var materialNames = meshPayload.materials.materialNames;
		var createMultiMaterial = meshPayload.materials.multiMaterial;
		var multiMaterials = [];
		for (key in materialNames) {

			materialName = materialNames[key];
			material = this.materials[materialName];
			if (createMultiMaterial) multiMaterials.push(material);
		}
		if (createMultiMaterial) {

			material = multiMaterials;
			var materialGroups = meshPayload.materials.materialGroups;
			var materialGroup;
			for (key in materialGroups) {

				materialGroup = materialGroups[key];
				bufferGeometry.addGroup(materialGroup.start, materialGroup.count, materialGroup.index);
			}
		}

		var meshes = [];
		var mesh;
		var callbackOnMeshAlter = this.callbacks.onMeshAlter;
		var callbackOnMeshAlterResult;
		var useOrgMesh = true;
		var geometryType = Validator.verifyInput(meshPayload.geometryType, 0);
		if (Validator.isValid(callbackOnMeshAlter)) {

			callbackOnMeshAlterResult = callbackOnMeshAlter({
				detail: {
					meshName: meshName,
					bufferGeometry: bufferGeometry,
					material: material,
					geometryType: geometryType
				}
			});
			if (Validator.isValid(callbackOnMeshAlterResult)) {

				if (!callbackOnMeshAlterResult.isDisregardMesh() && callbackOnMeshAlterResult.providesAlteredMeshes()) {

					for (var i in callbackOnMeshAlterResult.meshes) {

						meshes.push(callbackOnMeshAlterResult.meshes[i]);
					}
				}
				useOrgMesh = false;
			}
		}
		if (useOrgMesh) {

			if (meshPayload.computeBoundingSphere) bufferGeometry.computeBoundingSphere();
			if (geometryType === 0) {

				mesh = new THREE.Mesh(bufferGeometry, material);
			} else if (geometryType === 1) {

				mesh = new THREE.LineSegments(bufferGeometry, material);
			} else {

				mesh = new THREE.Points(bufferGeometry, material);
			}
			mesh.name = meshName;
			meshes.push(mesh);
		}

		var progressMessage;
		if (Validator.isValid(meshes) && meshes.length > 0) {

			var meshNames = [];
			for (var i in meshes) {

				mesh = meshes[i];
				meshNames[i] = mesh.name;
			}
			progressMessage = 'Adding mesh(es) (' + meshNames.length + ': ' + meshNames + ') from input mesh: ' + meshName;
			progressMessage += ' (' + (meshPayload.progress.numericalValue * 100).toFixed(2) + '%)';
		} else {

			progressMessage = 'Not adding mesh: ' + meshName;
			progressMessage += ' (' + (meshPayload.progress.numericalValue * 100).toFixed(2) + '%)';
		}
		var callbackOnProgress = this.callbacks.onProgress;
		if (Validator.isValid(callbackOnProgress)) {

			var event = new CustomEvent('MeshBuilderEvent', {
				detail: {
					type: 'progress',
					modelName: meshPayload.params.meshName,
					text: progressMessage,
					numericalValue: meshPayload.progress.numericalValue
				}
			});
			callbackOnProgress(event);
		}

		return meshes;
	};

	/**
  * Updates the materials with contained material objects (sync) or from alteration instructions (async).
  * @memberOf THREE.LoaderSupport.MeshBuilder
  *
  * @param {Object} materialPayload Material update instructions
  */
	MeshBuilder.prototype.updateMaterials = function (materialPayload) {
		var material, materialName;
		var materialCloneInstructions = materialPayload.materials.materialCloneInstructions;
		if (Validator.isValid(materialCloneInstructions)) {

			var materialNameOrg = materialCloneInstructions.materialNameOrg;
			var materialOrg = this.materials[materialNameOrg];

			if (Validator.isValid(materialNameOrg)) {

				material = materialOrg.clone();

				materialName = materialCloneInstructions.materialName;
				material.name = materialName;

				var materialProperties = materialCloneInstructions.materialProperties;
				for (var key in materialProperties) {

					if (material.hasOwnProperty(key) && materialProperties.hasOwnProperty(key)) material[key] = materialProperties[key];
				}
				this.materials[materialName] = material;
			} else {

				console.warn('Requested material "' + materialNameOrg + '" is not available!');
			}
		}

		var materials = materialPayload.materials.serializedMaterials;
		if (Validator.isValid(materials) && Object.keys(materials).length > 0) {

			var loader = new THREE.MaterialLoader();
			var materialJson;
			for (materialName in materials) {

				materialJson = materials[materialName];
				if (Validator.isValid(materialJson)) {

					material = loader.parse(materialJson);
					if (this.logging.enabled) console.info('De-serialized material with name "' + materialName + '" will be added.');
					this.materials[materialName] = material;
				}
			}
		}

		materials = materialPayload.materials.runtimeMaterials;
		if (Validator.isValid(materials) && Object.keys(materials).length > 0) {

			for (materialName in materials) {

				material = materials[materialName];
				if (this.logging.enabled) console.info('Material with name "' + materialName + '" will be added.');
				this.materials[materialName] = material;
			}
		}
	};

	/**
  * Returns the mapping object of material name and corresponding jsonified material.
  *
  * @returns {Object} Map of Materials in JSON representation
  */
	MeshBuilder.prototype.getMaterialsJSON = function () {
		var materialsJSON = {};
		var material;
		for (var materialName in this.materials) {

			material = this.materials[materialName];
			materialsJSON[materialName] = material.toJSON();
		}

		return materialsJSON;
	};

	/**
  * Returns the mapping object of material name and corresponding material.
  *
  * @returns {Object} Map of {@link THREE.Material}
  */
	MeshBuilder.prototype.getMaterials = function () {
		return this.materials;
	};

	return MeshBuilder;
}();

/**
 * Default implementation of the WorkerRunner responsible for creation and configuration of the parser within the worker.
 *
 * @class
 */
LoaderSupport.WorkerRunnerRefImpl = function () {

	function WorkerRunnerRefImpl() {
		var scope = this;
		var scopedRunner = function scopedRunner(event) {
			scope.processMessage(event.data);
		};
		self.addEventListener('message', scopedRunner, false);
	}

	/**
  * Applies values from parameter object via set functions or via direct assignment.
  * @memberOf THREE.LoaderSupport.WorkerRunnerRefImpl
  *
  * @param {Object} parser The parser instance
  * @param {Object} params The parameter object
  */
	WorkerRunnerRefImpl.prototype.applyProperties = function (parser, params) {
		var property, funcName, values;
		for (property in params) {
			funcName = 'set' + property.substring(0, 1).toLocaleUpperCase() + property.substring(1);
			values = params[property];

			if (typeof parser[funcName] === 'function') {

				parser[funcName](values);
			} else if (parser.hasOwnProperty(property)) {

				parser[property] = values;
			}
		}
	};

	/**
  * Configures the Parser implementation according the supplied configuration object.
  * @memberOf THREE.LoaderSupport.WorkerRunnerRefImpl
  *
  * @param {Object} payload Raw mesh description (buffers, params, materials) used to build one to many meshes.
  */
	WorkerRunnerRefImpl.prototype.processMessage = function (payload) {
		if (payload.cmd === 'run') {

			var callbacks = {
				callbackMeshBuilder: function callbackMeshBuilder(payload) {
					self.postMessage(payload);
				},
				callbackProgress: function callbackProgress(text) {
					if (payload.logging.enabled && payload.logging.debug) console.debug('WorkerRunner: progress: ' + text);
				}
			};

			// Parser is expected to be named as such
			var parser = new Parser();
			if (typeof parser['setLogging'] === 'function') parser.setLogging(payload.logging.enabled, payload.logging.debug);
			this.applyProperties(parser, payload.params);
			this.applyProperties(parser, payload.materials);
			this.applyProperties(parser, callbacks);
			parser.workerScope = self;
			parser.parse(payload.data.input, payload.data.options);

			if (payload.logging.enabled) console.log('WorkerRunner: Run complete!');

			callbacks.callbackMeshBuilder({
				cmd: 'complete',
				msg: 'WorkerRunner completed run.'
			});
		} else {

			console.error('WorkerRunner: Received unknown command: ' + payload.cmd);
		}
	};

	return WorkerRunnerRefImpl;
}();

/**
 * This class provides means to transform existing parser code into a web worker. It defines a simple communication protocol
 * which allows to configure the worker and receive raw mesh data during execution.
 * @class
 */
LoaderSupport.WorkerSupport = function () {

	var WORKER_SUPPORT_VERSION = '2.2.0';

	var Validator = LoaderSupport.Validator;

	var LoaderWorker = function () {

		function LoaderWorker() {
			this._reset();
		}

		LoaderWorker.prototype._reset = function () {
			this.logging = {
				enabled: true,
				debug: false
			};
			this.worker = null;
			this.runnerImplName = null;
			this.callbacks = {
				meshBuilder: null,
				onLoad: null
			};
			this.terminateRequested = false;
			this.queuedMessage = null;
			this.started = false;
			this.forceCopy = false;
		};

		LoaderWorker.prototype.setLogging = function (enabled, debug) {
			this.logging.enabled = enabled === true;
			this.logging.debug = debug === true;
		};

		LoaderWorker.prototype.setForceCopy = function (forceCopy) {
			this.forceCopy = forceCopy === true;
		};

		LoaderWorker.prototype.initWorker = function (code, runnerImplName) {
			this.runnerImplName = runnerImplName;
			var blob = new Blob([code], { type: 'application/javascript' });
			this.worker = new Worker(window.URL.createObjectURL(blob));
			this.worker.onmessage = this._receiveWorkerMessage;

			// set referemce to this, then processing in worker scope within "_receiveWorkerMessage" can access members
			this.worker.runtimeRef = this;

			// process stored queuedMessage
			this._postMessage();
		};

		/**
   * Executed in worker scope
  	 */
		LoaderWorker.prototype._receiveWorkerMessage = function (e) {
			var payload = e.data;
			switch (payload.cmd) {
				case 'meshData':
				case 'materialData':
				case 'imageData':
					this.runtimeRef.callbacks.meshBuilder(payload);
					break;

				case 'complete':
					this.runtimeRef.queuedMessage = null;
					this.started = false;
					this.runtimeRef.callbacks.onLoad(payload.msg);

					if (this.runtimeRef.terminateRequested) {

						if (this.runtimeRef.logging.enabled) console.info('WorkerSupport [' + this.runtimeRef.runnerImplName + ']: Run is complete. Terminating application on request!');
						this.runtimeRef._terminate();
					}
					break;

				case 'error':
					console.error('WorkerSupport [' + this.runtimeRef.runnerImplName + ']: Reported error: ' + payload.msg);
					this.runtimeRef.queuedMessage = null;
					this.started = false;
					this.runtimeRef.callbacks.onLoad(payload.msg);

					if (this.runtimeRef.terminateRequested) {

						if (this.runtimeRef.logging.enabled) console.info('WorkerSupport [' + this.runtimeRef.runnerImplName + ']: Run reported error. Terminating application on request!');
						this.runtimeRef._terminate();
					}
					break;

				default:
					console.error('WorkerSupport [' + this.runtimeRef.runnerImplName + ']: Received unknown command: ' + payload.cmd);
					break;

			}
		};

		LoaderWorker.prototype.setCallbacks = function (meshBuilder, onLoad) {
			this.callbacks.meshBuilder = Validator.verifyInput(meshBuilder, this.callbacks.meshBuilder);
			this.callbacks.onLoad = Validator.verifyInput(onLoad, this.callbacks.onLoad);
		};

		LoaderWorker.prototype.run = function (payload) {
			if (Validator.isValid(this.queuedMessage)) {

				console.warn('Already processing message. Rejecting new run instruction');
				return;
			} else {

				this.queuedMessage = payload;
				this.started = true;
			}
			if (!Validator.isValid(this.callbacks.meshBuilder)) throw 'Unable to run as no "MeshBuilder" callback is set.';
			if (!Validator.isValid(this.callbacks.onLoad)) throw 'Unable to run as no "onLoad" callback is set.';
			if (payload.cmd !== 'run') payload.cmd = 'run';
			if (Validator.isValid(payload.logging)) {

				payload.logging.enabled = payload.logging.enabled === true;
				payload.logging.debug = payload.logging.debug === true;
			} else {

				payload.logging = {
					enabled: true,
					debug: false
				};
			}
			this._postMessage();
		};

		LoaderWorker.prototype._postMessage = function () {
			if (Validator.isValid(this.queuedMessage) && Validator.isValid(this.worker)) {

				if (this.queuedMessage.data.input instanceof ArrayBuffer) {

					var content;
					if (this.forceCopy) {

						content = this.queuedMessage.data.input.slice(0);
					} else {

						content = this.queuedMessage.data.input;
					}
					this.worker.postMessage(this.queuedMessage, [content]);
				} else {

					this.worker.postMessage(this.queuedMessage);
				}
			}
		};

		LoaderWorker.prototype.setTerminateRequested = function (terminateRequested) {
			this.terminateRequested = terminateRequested === true;
			if (this.terminateRequested && Validator.isValid(this.worker) && !Validator.isValid(this.queuedMessage) && this.started) {

				if (this.logging.enabled) console.info('Worker is terminated immediately as it is not running!');
				this._terminate();
			}
		};

		LoaderWorker.prototype._terminate = function () {
			this.worker.terminate();
			this._reset();
		};

		return LoaderWorker;
	}();

	function WorkerSupport() {
		console.info('Using THREE.LoaderSupport.WorkerSupport version: ' + WORKER_SUPPORT_VERSION);
		this.logging = {
			enabled: true,
			debug: false
		};

		// check worker support first
		if (window.Worker === undefined) throw "This browser does not support web workers!";
		if (window.Blob === undefined) throw "This browser does not support Blob!";
		if (typeof window.URL.createObjectURL !== 'function') throw "This browser does not support Object creation from URL!";

		this.loaderWorker = new LoaderWorker();
	}

	/**
  * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.
  * @memberOf THREE.LoaderSupport.WorkerSupport
  *
  * @param {boolean} enabled True or false.
  * @param {boolean} debug True or false.
  */
	WorkerSupport.prototype.setLogging = function (enabled, debug) {
		this.logging.enabled = enabled === true;
		this.logging.debug = debug === true;
		this.loaderWorker.setLogging(this.logging.enabled, this.logging.debug);
	};

	/**
  * Forces all ArrayBuffers to be transferred to worker to be copied.
  * @memberOf THREE.LoaderSupport.WorkerSupport
  *
  * @param {boolean} forceWorkerDataCopy True or false.
  */
	WorkerSupport.prototype.setForceWorkerDataCopy = function (forceWorkerDataCopy) {
		this.loaderWorker.setForceCopy(forceWorkerDataCopy);
	};

	/**
  * Validate the status of worker code and the derived worker.
  * @memberOf THREE.LoaderSupport.WorkerSupport
  *
  * @param {Function} functionCodeBuilder Function that is invoked with funcBuildObject and funcBuildSingleton that allows stringification of objects and singletons.
  * @param {String} parserName Name of the Parser object
  * @param {String[]} libLocations URL of libraries that shall be added to worker code relative to libPath
  * @param {String} libPath Base path used for loading libraries
  * @param {THREE.LoaderSupport.WorkerRunnerRefImpl} runnerImpl The default worker parser wrapper implementation (communication and execution). An extended class could be passed here.
  */
	WorkerSupport.prototype.validate = function (functionCodeBuilder, parserName, libLocations, libPath, runnerImpl) {
		if (Validator.isValid(this.loaderWorker.worker)) return;

		if (this.logging.enabled) {

			console.info('WorkerSupport: Building worker code...');
			console.time('buildWebWorkerCode');
		}
		if (Validator.isValid(runnerImpl)) {

			if (this.logging.enabled) console.info('WorkerSupport: Using "' + runnerImpl.name + '" as Runner class for worker.');
		} else {

			runnerImpl = LoaderSupport.WorkerRunnerRefImpl;
			if (this.logging.enabled) console.info('WorkerSupport: Using DEFAULT "THREE.LoaderSupport.WorkerRunnerRefImpl" as Runner class for worker.');
		}

		var userWorkerCode = functionCodeBuilder(buildObject, buildSingleton);
		userWorkerCode += 'var Parser = ' + parserName + ';\n\n';
		userWorkerCode += buildSingleton(runnerImpl.name, runnerImpl);
		userWorkerCode += 'new ' + runnerImpl.name + '();\n\n';

		var scope = this;
		if (Validator.isValid(libLocations) && libLocations.length > 0) {

			var libsContent = '';
			var loadAllLibraries = function loadAllLibraries(path, locations) {
				if (locations.length === 0) {

					scope.loaderWorker.initWorker(libsContent + userWorkerCode, runnerImpl.name);
					if (scope.logging.enabled) console.timeEnd('buildWebWorkerCode');
				} else {

					var loadedLib = function loadedLib(contentAsString) {
						libsContent += contentAsString;
						loadAllLibraries(path, locations);
					};

					var fileLoader = new THREE.FileLoader();
					fileLoader.setPath(path);
					fileLoader.setResponseType('text');
					fileLoader.load(locations[0], loadedLib);
					locations.shift();
				}
			};
			loadAllLibraries(libPath, libLocations);
		} else {

			this.loaderWorker.initWorker(userWorkerCode, runnerImpl.name);
			if (this.logging.enabled) console.timeEnd('buildWebWorkerCode');
		}
	};

	/**
  * Specify functions that should be build when new raw mesh data becomes available and when the parser is finished.
  * @memberOf THREE.LoaderSupport.WorkerSupport
  *
  * @param {Function} meshBuilder The mesh builder function. Default is {@link THREE.LoaderSupport.MeshBuilder}.
  * @param {Function} onLoad The function that is called when parsing is complete.
  */
	WorkerSupport.prototype.setCallbacks = function (meshBuilder, onLoad) {
		this.loaderWorker.setCallbacks(meshBuilder, onLoad);
	};

	/**
  * Runs the parser with the provided configuration.
  * @memberOf THREE.LoaderSupport.WorkerSupport
  *
  * @param {Object} payload Raw mesh description (buffers, params, materials) used to build one to many meshes.
  */
	WorkerSupport.prototype.run = function (payload) {
		this.loaderWorker.run(payload);
	};

	/**
  * Request termination of worker once parser is finished.
  * @memberOf THREE.LoaderSupport.WorkerSupport
  *
  * @param {boolean} terminateRequested True or false.
  */
	WorkerSupport.prototype.setTerminateRequested = function (terminateRequested) {
		this.loaderWorker.setTerminateRequested(terminateRequested);
	};

	var buildObject = function buildObject(fullName, object) {
		var objectString = fullName + ' = {\n';
		var part;
		for (var name in object) {

			part = object[name];
			if (typeof part === 'string' || part instanceof String) {

				part = part.replace('\n', '\\n');
				part = part.replace('\r', '\\r');
				objectString += '\t' + name + ': "' + part + '",\n';
			} else if (part instanceof Array) {

				objectString += '\t' + name + ': [' + part + '],\n';
			} else if (Number.isInteger(part)) {

				objectString += '\t' + name + ': ' + part + ',\n';
			} else if (typeof part === 'function') {

				objectString += '\t' + name + ': ' + part + ',\n';
			}
		}
		objectString += '}\n\n';

		return objectString;
	};

	var buildSingleton = function buildSingleton(fullName, object, internalName, basePrototypeName, ignoreFunctions) {
		var objectString = '';
		var objectName = Validator.isValid(internalName) ? internalName : object.name;

		var funcString, objectPart, constructorString;
		ignoreFunctions = Validator.verifyInput(ignoreFunctions, []);
		for (var name in object.prototype) {

			objectPart = object.prototype[name];
			if (name === 'constructor') {

				funcString = objectPart.toString();
				funcString = funcString.replace('function', '');
				constructorString = '\tfunction ' + objectName + funcString + ';\n\n';
			} else if (typeof objectPart === 'function') {

				if (ignoreFunctions.indexOf(name) < 0) {

					funcString = objectPart.toString();
					objectString += '\t' + objectName + '.prototype.' + name + ' = ' + funcString + ';\n\n';
				}
			}
		}
		objectString += '\treturn ' + objectName + ';\n';
		objectString += '})();\n\n';

		var inheritanceBlock = '';
		if (Validator.isValid(basePrototypeName)) {

			inheritanceBlock += '\n';
			inheritanceBlock += objectName + '.prototype = Object.create( ' + basePrototypeName + '.prototype );\n';
			inheritanceBlock += objectName + '.constructor = ' + objectName + ';\n';
			inheritanceBlock += '\n';
		}
		if (!Validator.isValid(constructorString)) {

			constructorString = fullName + ' = (function () {\n\n';
			constructorString += inheritanceBlock + '\t' + object.prototype.constructor.toString() + '\n\n';
			objectString = constructorString + objectString;
		} else {

			objectString = fullName + ' = (function () {\n\n' + inheritanceBlock + constructorString + objectString;
		}

		return objectString;
	};

	return WorkerSupport;
}();

/**
 * Orchestrate loading of multiple OBJ files/data from an instruction queue with a configurable amount of workers (1-16).
 * Workflow:
 *   prepareWorkers
 *   enqueueForRun
 *   processQueue
 *   tearDown (to force stop)
 *
 * @class
 *
 * @param {string} classDef Class definition to be used for construction
 */
LoaderSupport.WorkerDirector = function () {

	var LOADER_WORKER_DIRECTOR_VERSION = '2.2.0';

	var Validator = LoaderSupport.Validator;

	var MAX_WEB_WORKER = 16;
	var MAX_QUEUE_SIZE = 8192;

	function WorkerDirector(classDef) {
		console.info('Using THREE.LoaderSupport.WorkerDirector version: ' + LOADER_WORKER_DIRECTOR_VERSION);
		this.logging = {
			enabled: true,
			debug: false
		};

		this.maxQueueSize = MAX_QUEUE_SIZE;
		this.maxWebWorkers = MAX_WEB_WORKER;
		this.crossOrigin = null;

		if (!Validator.isValid(classDef)) throw 'Provided invalid classDef: ' + classDef;

		this.workerDescription = {
			classDef: classDef,
			globalCallbacks: {},
			workerSupports: {},
			forceWorkerDataCopy: true
		};
		this.objectsCompleted = 0;
		this.instructionQueue = [];
		this.instructionQueuePointer = 0;

		this.callbackOnFinishedProcessing = null;
	}

	/**
  * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.
  * @memberOf THREE.LoaderSupport.WorkerDirector
  *
  * @param {boolean} enabled True or false.
  * @param {boolean} debug True or false.
  */
	WorkerDirector.prototype.setLogging = function (enabled, debug) {
		this.logging.enabled = enabled === true;
		this.logging.debug = debug === true;
	};

	/**
  * Returns the maximum length of the instruction queue.
  * @memberOf THREE.LoaderSupport.WorkerDirector
  *
  * @returns {number}
  */
	WorkerDirector.prototype.getMaxQueueSize = function () {
		return this.maxQueueSize;
	};

	/**
  * Returns the maximum number of workers.
  * @memberOf THREE.LoaderSupport.WorkerDirector
  *
  * @returns {number}
  */
	WorkerDirector.prototype.getMaxWebWorkers = function () {
		return this.maxWebWorkers;
	};

	/**
  * Sets the CORS string to be used.
  * @memberOf THREE.LoaderSupport.WorkerDirector
  *
  * @param {string} crossOrigin CORS value
  */
	WorkerDirector.prototype.setCrossOrigin = function (crossOrigin) {
		this.crossOrigin = crossOrigin;
	};

	/**
  * Forces all ArrayBuffers to be transferred to worker to be copied.
  * @memberOf THREE.LoaderSupport.WorkerDirector
  *
  * @param {boolean} forceWorkerDataCopy True or false.
  */
	WorkerDirector.prototype.setForceWorkerDataCopy = function (forceWorkerDataCopy) {
		this.workerDescription.forceWorkerDataCopy = forceWorkerDataCopy === true;
	};

	/**
  * Create or destroy workers according limits. Set the name and register callbacks for dynamically created web workers.
  * @memberOf THREE.LoaderSupport.WorkerDirector
  *
  * @param {THREE.OBJLoader2.WWOBJLoader2.PrepDataCallbacks} globalCallbacks  Register global callbacks used by all web workers
  * @param {number} maxQueueSize Set the maximum size of the instruction queue (1-1024)
  * @param {number} maxWebWorkers Set the maximum amount of workers (1-16)
  */
	WorkerDirector.prototype.prepareWorkers = function (globalCallbacks, maxQueueSize, maxWebWorkers) {
		if (Validator.isValid(globalCallbacks)) this.workerDescription.globalCallbacks = globalCallbacks;
		this.maxQueueSize = Math.min(maxQueueSize, MAX_QUEUE_SIZE);
		this.maxWebWorkers = Math.min(maxWebWorkers, MAX_WEB_WORKER);
		this.maxWebWorkers = Math.min(this.maxWebWorkers, this.maxQueueSize);
		this.objectsCompleted = 0;
		this.instructionQueue = [];
		this.instructionQueuePointer = 0;

		for (var instanceNo = 0; instanceNo < this.maxWebWorkers; instanceNo++) {

			var workerSupport = new THREE.LoaderSupport.WorkerSupport();
			workerSupport.setLogging(this.logging.enabled, this.logging.debug);
			workerSupport.setForceWorkerDataCopy(this.workerDescription.forceWorkerDataCopy);
			this.workerDescription.workerSupports[instanceNo] = {
				instanceNo: instanceNo,
				inUse: false,
				terminateRequested: false,
				workerSupport: workerSupport,
				loader: null
			};
		}
	};

	/**
  * Store run instructions in internal instructionQueue.
  * @memberOf THREE.LoaderSupport.WorkerDirector
  *
  * @param {THREE.LoaderSupport.PrepData} prepData
  */
	WorkerDirector.prototype.enqueueForRun = function (prepData) {
		if (this.instructionQueue.length < this.maxQueueSize) {
			this.instructionQueue.push(prepData);
		}
	};

	/**
  * Returns if any workers are running.
  *
  * @memberOf THREE.LoaderSupport.WorkerDirector
  * @returns {boolean}
  */
	WorkerDirector.prototype.isRunning = function () {
		var wsKeys = Object.keys(this.workerDescription.workerSupports);
		return this.instructionQueue.length > 0 && this.instructionQueuePointer < this.instructionQueue.length || wsKeys.length > 0;
	};

	/**
  * Process the instructionQueue until it is depleted.
  * @memberOf THREE.LoaderSupport.WorkerDirector
  */
	WorkerDirector.prototype.processQueue = function () {
		var prepData, supportDesc;
		for (var instanceNo in this.workerDescription.workerSupports) {

			supportDesc = this.workerDescription.workerSupports[instanceNo];
			if (!supportDesc.inUse) {

				if (this.instructionQueuePointer < this.instructionQueue.length) {

					prepData = this.instructionQueue[this.instructionQueuePointer];
					this._kickWorkerRun(prepData, supportDesc);
					this.instructionQueuePointer++;
				} else {

					this._deregister(supportDesc);
				}
			}
		}

		if (!this.isRunning() && this.callbackOnFinishedProcessing !== null) {

			this.callbackOnFinishedProcessing();
			this.callbackOnFinishedProcessing = null;
		}
	};

	WorkerDirector.prototype._kickWorkerRun = function (prepData, supportDesc) {
		supportDesc.inUse = true;
		supportDesc.workerSupport.setTerminateRequested(supportDesc.terminateRequested);

		if (this.logging.enabled) console.info('\nAssigning next item from queue to worker (queue length: ' + this.instructionQueue.length + ')\n\n');

		var scope = this;
		var prepDataCallbacks = prepData.getCallbacks();
		var globalCallbacks = this.workerDescription.globalCallbacks;
		var wrapperOnLoad = function wrapperOnLoad(event) {
			if (Validator.isValid(globalCallbacks.onLoad)) globalCallbacks.onLoad(event);
			if (Validator.isValid(prepDataCallbacks.onLoad)) prepDataCallbacks.onLoad(event);
			scope.objectsCompleted++;
			supportDesc.inUse = false;

			scope.processQueue();
		};

		var wrapperOnProgress = function wrapperOnProgress(event) {
			if (Validator.isValid(globalCallbacks.onProgress)) globalCallbacks.onProgress(event);
			if (Validator.isValid(prepDataCallbacks.onProgress)) prepDataCallbacks.onProgress(event);
		};

		var wrapperOnMeshAlter = function wrapperOnMeshAlter(event) {
			if (Validator.isValid(globalCallbacks.onMeshAlter)) globalCallbacks.onMeshAlter(event);
			if (Validator.isValid(prepDataCallbacks.onMeshAlter)) prepDataCallbacks.onMeshAlter(event);
		};

		supportDesc.loader = this._buildLoader(supportDesc.instanceNo);

		var updatedCallbacks = new LoaderSupport.Callbacks();
		updatedCallbacks.setCallbackOnLoad(wrapperOnLoad);
		updatedCallbacks.setCallbackOnProgress(wrapperOnProgress);
		updatedCallbacks.setCallbackOnMeshAlter(wrapperOnMeshAlter);
		prepData.callbacks = updatedCallbacks;

		supportDesc.loader.run(prepData, supportDesc.workerSupport);
	};

	WorkerDirector.prototype._buildLoader = function (instanceNo) {
		var classDef = this.workerDescription.classDef;
		var loader = Object.create(classDef.prototype);
		classDef.call(loader, THREE.DefaultLoadingManager);

		// verify that all required functions are implemented
		if (!loader.hasOwnProperty('instanceNo')) throw classDef.name + ' has no property "instanceNo".';
		loader.instanceNo = instanceNo;

		if (!loader.hasOwnProperty('workerSupport')) {

			throw classDef.name + ' has no property "workerSupport".';
		}
		if (typeof loader.run !== 'function') throw classDef.name + ' has no function "run".';
		if (!loader.hasOwnProperty('callbacks') || !Validator.isValid(loader.callbacks)) {

			console.warn(classDef.name + ' has an invalid property "callbacks". Will change to "THREE.LoaderSupport.Callbacks"');
			loader.callbacks = new THREE.LoaderSupport.Callbacks();
		}

		return loader;
	};

	WorkerDirector.prototype._deregister = function (supportDesc) {
		if (Validator.isValid(supportDesc)) {

			supportDesc.workerSupport.setTerminateRequested(true);
			if (this.logging.enabled) console.info('Requested termination of worker #' + supportDesc.instanceNo + '.');

			var loaderCallbacks = supportDesc.loader.callbacks;
			if (Validator.isValid(loaderCallbacks.onProgress)) loaderCallbacks.onProgress({ detail: { text: '' } });
			delete this.workerDescription.workerSupports[supportDesc.instanceNo];
		}
	};

	/**
  * Terminate all workers.
  * @memberOf THREE.LoaderSupport.WorkerDirector
  *
  * @param {callback} callbackOnFinishedProcessing Function called once all workers finished processing.
  */
	WorkerDirector.prototype.tearDown = function (callbackOnFinishedProcessing) {
		if (this.logging.enabled) console.info('WorkerDirector received the deregister call. Terminating all workers!');

		this.instructionQueuePointer = this.instructionQueue.length;
		this.callbackOnFinishedProcessing = Validator.verifyInput(callbackOnFinishedProcessing, null);

		for (var name in this.workerDescription.workerSupports) {

			this.workerDescription.workerSupports[name].terminateRequested = true;
		}
	};

	return WorkerDirector;
}();

exports.default = LoaderSupport;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var win;

if (typeof window !== "undefined") {
    win = window;
} else if (typeof global !== "undefined") {
    win = global;
} else if (typeof self !== "undefined"){
    win = self;
} else {
    win = {};
}

module.exports = win;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(67)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Loads a Wavefront .mtl file specifying materials
 *
 * @author angelxuanchang
 */

var MTLLoader = function MTLLoader(manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};

MTLLoader.prototype = {

	constructor: MTLLoader,

	/**
  * Loads and parses a MTL asset from a URL.
  *
  * @param {String} url - URL to the MTL file.
  * @param {Function} [onLoad] - Callback invoked with the loaded object.
  * @param {Function} [onProgress] - Callback for download progress.
  * @param {Function} [onError] - Callback for download errors.
  *
  * @see setPath setTexturePath
  *
  * @note In order for relative texture references to resolve correctly
  * you must call setPath and/or setTexturePath explicitly prior to load.
  */
	load: function load(url, onLoad, onProgress, onError) {

		var scope = this;

		var loader = new THREE.FileLoader(this.manager);
		loader.setPath(this.path);
		loader.load(url, function (text) {

			onLoad(scope.parse(text));
		}, onProgress, onError);
	},

	/**
  * Set base path for resolving references.
  * If set this path will be prepended to each loaded and found reference.
  *
  * @see setTexturePath
  * @param {String} path
  * @return {THREE.MTLLoader}
  *
  * @example
  *     mtlLoader.setPath( 'assets/obj/' );
  *     mtlLoader.load( 'my.mtl', ... );
  */
	setPath: function setPath(path) {

		this.path = path;
		return this;
	},

	/**
  * Set base path for resolving texture references.
  * If set this path will be prepended found texture reference.
  * If not set and setPath is, it will be used as texture base path.
  *
  * @see setPath
  * @param {String} path
  * @return {THREE.MTLLoader}
  *
  * @example
  *     mtlLoader.setPath( 'assets/obj/' );
  *     mtlLoader.setTexturePath( 'assets/textures/' );
  *     mtlLoader.load( 'my.mtl', ... );
  */
	setTexturePath: function setTexturePath(path) {

		this.texturePath = path;
		return this;
	},

	setBaseUrl: function setBaseUrl(path) {

		console.warn('THREE.MTLLoader: .setBaseUrl() is deprecated. Use .setTexturePath( path ) for texture path or .setPath( path ) for general base path instead.');

		return this.setTexturePath(path);
	},

	setCrossOrigin: function setCrossOrigin(value) {

		this.crossOrigin = value;
		return this;
	},

	setMaterialOptions: function setMaterialOptions(value) {

		this.materialOptions = value;
		return this;
	},

	/**
  * Parses a MTL file.
  *
  * @param {String} text - Content of MTL file
  * @return {MTLLoader.MaterialCreator}
  *
  * @see setPath setTexturePath
  *
  * @note In order for relative texture references to resolve correctly
  * you must call setPath and/or setTexturePath explicitly prior to parse.
  */
	parse: function parse(text) {

		var lines = text.split('\n');
		var info = {};
		var delimiter_pattern = /\s+/;
		var materialsInfo = {};

		for (var i = 0; i < lines.length; i++) {

			var line = lines[i];
			line = line.trim();

			if (line.length === 0 || line.charAt(0) === '#') {

				// Blank line or comment ignore
				continue;
			}

			var pos = line.indexOf(' ');

			var key = pos >= 0 ? line.substring(0, pos) : line;
			key = key.toLowerCase();

			var value = pos >= 0 ? line.substring(pos + 1) : '';
			value = value.trim();

			if (key === 'newmtl') {

				// New material

				info = { name: value };
				materialsInfo[value] = info;
			} else if (info) {

				if (key === 'ka' || key === 'kd' || key === 'ks') {

					var ss = value.split(delimiter_pattern, 3);
					info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];
				} else {

					info[key] = value;
				}
			}
		}

		var materialCreator = new MTLLoader.MaterialCreator(this.texturePath || this.path, this.materialOptions);
		materialCreator.setCrossOrigin(this.crossOrigin);
		materialCreator.setManager(this.manager);
		materialCreator.setMaterials(materialsInfo);
		return materialCreator;
	}

};

/**
 * Create a new THREE-MTLLoader.MaterialCreator
 * @param baseUrl - Url relative to which textures are loaded
 * @param options - Set of options on how to construct the materials
 *                  side: Which side to apply the material
 *                        THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide
 *                  wrap: What type of wrapping to apply for textures
 *                        THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping
 *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255
 *                                Default: false, assumed to be already normalized
 *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's
 *                                  Default: false
 * @constructor
 */

MTLLoader.MaterialCreator = function (baseUrl, options) {

	this.baseUrl = baseUrl || '';
	this.options = options;
	this.materialsInfo = {};
	this.materials = {};
	this.materialsArray = [];
	this.nameLookup = {};

	this.side = this.options && this.options.side ? this.options.side : THREE.FrontSide;
	this.wrap = this.options && this.options.wrap ? this.options.wrap : THREE.RepeatWrapping;
};

MTLLoader.MaterialCreator.prototype = {

	constructor: MTLLoader.MaterialCreator,

	crossOrigin: 'Anonymous',

	setCrossOrigin: function setCrossOrigin(value) {

		this.crossOrigin = value;
	},

	setManager: function setManager(value) {

		this.manager = value;
	},

	setMaterials: function setMaterials(materialsInfo) {

		this.materialsInfo = this.convert(materialsInfo);
		this.materials = {};
		this.materialsArray = [];
		this.nameLookup = {};
	},

	convert: function convert(materialsInfo) {

		if (!this.options) return materialsInfo;

		var converted = {};

		for (var mn in materialsInfo) {

			// Convert materials info into normalized form based on options

			var mat = materialsInfo[mn];

			var covmat = {};

			converted[mn] = covmat;

			for (var prop in mat) {

				var save = true;
				var value = mat[prop];
				var lprop = prop.toLowerCase();

				switch (lprop) {

					case 'kd':
					case 'ka':
					case 'ks':

						// Diffuse color (color under white light) using RGB values

						if (this.options && this.options.normalizeRGB) {

							value = [value[0] / 255, value[1] / 255, value[2] / 255];
						}

						if (this.options && this.options.ignoreZeroRGBs) {

							if (value[0] === 0 && value[1] === 0 && value[2] === 0) {

								// ignore

								save = false;
							}
						}

						break;

					default:

						break;

				}

				if (save) {

					covmat[lprop] = value;
				}
			}
		}

		return converted;
	},

	preload: function preload() {

		for (var mn in this.materialsInfo) {

			this.create(mn);
		}
	},

	getIndex: function getIndex(materialName) {

		return this.nameLookup[materialName];
	},

	getAsArray: function getAsArray() {

		var index = 0;

		for (var mn in this.materialsInfo) {

			this.materialsArray[index] = this.create(mn);
			this.nameLookup[mn] = index;
			index++;
		}

		return this.materialsArray;
	},

	create: function create(materialName) {

		if (this.materials[materialName] === undefined) {

			this.createMaterial_(materialName);
		}

		return this.materials[materialName];
	},

	createMaterial_: function createMaterial_(materialName) {

		// Create material

		var scope = this;
		var mat = this.materialsInfo[materialName];
		var params = {

			name: materialName,
			side: this.side

		};

		function resolveURL(baseUrl, url) {

			if (typeof url !== 'string' || url === '') return '';

			// Absolute URL
			if (/^https?:\/\//i.test(url)) return url;

			return baseUrl + url;
		}

		function setMapForType(mapType, value) {

			if (params[mapType]) return; // Keep the first encountered texture

			var texParams = scope.getTextureParams(value, params);
			var map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));

			map.repeat.copy(texParams.scale);
			map.offset.copy(texParams.offset);

			map.wrapS = scope.wrap;
			map.wrapT = scope.wrap;

			params[mapType] = map;
		}

		for (var prop in mat) {

			var value = mat[prop];
			var n;

			if (value === '') continue;

			switch (prop.toLowerCase()) {

				// Ns is material specular exponent

				case 'kd':

					// Diffuse color (color under white light) using RGB values

					params.color = new THREE.Color().fromArray(value);

					break;

				case 'ks':

					// Specular color (color when light is reflected from shiny surface) using RGB values
					params.specular = new THREE.Color().fromArray(value);

					break;

				case 'map_kd':

					// Diffuse texture map

					setMapForType("map", value);

					break;

				case 'map_ks':

					// Specular map

					setMapForType("specularMap", value);

					break;

				case 'norm':

					setMapForType("normalMap", value);

					break;

				case 'map_bump':
				case 'bump':

					// Bump texture map

					setMapForType("bumpMap", value);

					break;

				case 'ns':

					// The specular exponent (defines the focus of the specular highlight)
					// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.

					params.shininess = parseFloat(value);

					break;

				case 'd':
					n = parseFloat(value);

					if (n < 1) {

						params.opacity = n;
						params.transparent = true;
					}

					break;

				case 'tr':
					n = parseFloat(value);

					if (this.options && this.options.invertTrProperty) n = 1 - n;

					if (n > 0) {

						params.opacity = 1 - n;
						params.transparent = true;
					}

					break;

				default:
					break;

			}
		}

		this.materials[materialName] = new THREE.MeshPhongMaterial(params);
		return this.materials[materialName];
	},

	getTextureParams: function getTextureParams(value, matParams) {

		var texParams = {

			scale: new THREE.Vector2(1, 1),
			offset: new THREE.Vector2(0, 0)

		};

		var items = value.split(/\s+/);
		var pos;

		pos = items.indexOf('-bm');

		if (pos >= 0) {

			matParams.bumpScale = parseFloat(items[pos + 1]);
			items.splice(pos, 2);
		}

		pos = items.indexOf('-s');

		if (pos >= 0) {

			texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));
			items.splice(pos, 4); // we expect 3 parameters here!
		}

		pos = items.indexOf('-o');

		if (pos >= 0) {

			texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));
			items.splice(pos, 4); // we expect 3 parameters here!
		}

		texParams.url = items.join(' ').trim();
		return texParams;
	},

	loadTexture: function loadTexture(url, mapping, onLoad, onProgress, onError) {

		var texture;
		var loader = THREE.Loader.Handlers.get(url);
		var manager = this.manager !== undefined ? this.manager : THREE.DefaultLoadingManager;

		if (loader === null) {

			loader = new THREE.TextureLoader(manager);
		}

		if (loader.setCrossOrigin) loader.setCrossOrigin(this.crossOrigin);
		texture = loader.load(url, onLoad, onProgress, onError);

		if (mapping !== undefined) texture.mapping = mapping;

		return texture;
	}

};

exports.default = MTLLoader;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * This class had been written to handle the output of the NRRD loader.
 * It contains a volume of data and informations about it.
 * For now it only handles 3 dimensional data.
 * See the webgl_loader_nrrd.html example and the loaderNRRD.js file to see how to use this class.
 * @class
 * @author Valentin Demeusy / https://github.com/stity
 * @param   {number}        xLength         Width of the volume
 * @param   {number}        yLength         Length of the volume
 * @param   {number}        zLength         Depth of the volume
 * @param   {string}        type            The type of data (uint8, uint16, ...)
 * @param   {ArrayBuffer}   arrayBuffer     The buffer with volume data
 */
var Volume = function Volume(xLength, yLength, zLength, type, arrayBuffer) {

	if (arguments.length > 0) {

		/**
   * @member {number} xLength Width of the volume in the IJK coordinate system
   */
		this.xLength = Number(xLength) || 1;
		/**
   * @member {number} yLength Height of the volume in the IJK coordinate system
   */
		this.yLength = Number(yLength) || 1;
		/**
   * @member {number} zLength Depth of the volume in the IJK coordinate system
   */
		this.zLength = Number(zLength) || 1;

		/**
   * @member {TypedArray} data Data of the volume
   */

		switch (type) {

			case 'Uint8':
			case 'uint8':
			case 'uchar':
			case 'unsigned char':
			case 'uint8_t':
				this.data = new Uint8Array(arrayBuffer);
				break;
			case 'Int8':
			case 'int8':
			case 'signed char':
			case 'int8_t':
				this.data = new Int8Array(arrayBuffer);
				break;
			case 'Int16':
			case 'int16':
			case 'short':
			case 'short int':
			case 'signed short':
			case 'signed short int':
			case 'int16_t':
				this.data = new Int16Array(arrayBuffer);
				break;
			case 'Uint16':
			case 'uint16':
			case 'ushort':
			case 'unsigned short':
			case 'unsigned short int':
			case 'uint16_t':
				this.data = new Uint16Array(arrayBuffer);
				break;
			case 'Int32':
			case 'int32':
			case 'int':
			case 'signed int':
			case 'int32_t':
				this.data = new Int32Array(arrayBuffer);
				break;
			case 'Uint32':
			case 'uint32':
			case 'uint':
			case 'unsigned int':
			case 'uint32_t':
				this.data = new Uint32Array(arrayBuffer);
				break;
			case 'longlong':
			case 'long long':
			case 'long long int':
			case 'signed long long':
			case 'signed long long int':
			case 'int64':
			case 'int64_t':
			case 'ulonglong':
			case 'unsigned long long':
			case 'unsigned long long int':
			case 'uint64':
			case 'uint64_t':
				throw 'Error in THREE.Volume constructor : this type is not supported in JavaScript';
				break;
			case 'Float32':
			case 'float32':
			case 'float':
				this.data = new Float32Array(arrayBuffer);
				break;
			case 'Float64':
			case 'float64':
			case 'double':
				this.data = new Float64Array(arrayBuffer);
				break;
			default:
				this.data = new Uint8Array(arrayBuffer);

		}

		if (this.data.length !== this.xLength * this.yLength * this.zLength) {

			throw 'Error in THREE.Volume constructor, lengths are not matching arrayBuffer size';
		}
	}

	/**
  * @member {Array}  spacing Spacing to apply to the volume from IJK to RAS coordinate system
  */
	this.spacing = [1, 1, 1];
	/**
  * @member {Array}  offset Offset of the volume in the RAS coordinate system
  */
	this.offset = [0, 0, 0];
	/**
  * @member {THREE.Martrix3} matrix The IJK to RAS matrix
  */
	this.matrix = new THREE.Matrix3();
	this.matrix.identity();
	/**
  * @member {THREE.Martrix3} inverseMatrix The RAS to IJK matrix
  */
	/**
  * @member {number} lowerThreshold The voxels with values under this threshold won't appear in the slices.
  *                      If changed, geometryNeedsUpdate is automatically set to true on all the slices associated to this volume
  */
	var lowerThreshold = -Infinity;
	Object.defineProperty(this, 'lowerThreshold', {
		get: function get() {

			return lowerThreshold;
		},
		set: function set(value) {

			lowerThreshold = value;
			this.sliceList.forEach(function (slice) {

				slice.geometryNeedsUpdate = true;
			});
		}
	});
	/**
  * @member {number} upperThreshold The voxels with values over this threshold won't appear in the slices.
  *                      If changed, geometryNeedsUpdate is automatically set to true on all the slices associated to this volume
  */
	var upperThreshold = Infinity;
	Object.defineProperty(this, 'upperThreshold', {
		get: function get() {

			return upperThreshold;
		},
		set: function set(value) {

			upperThreshold = value;
			this.sliceList.forEach(function (slice) {

				slice.geometryNeedsUpdate = true;
			});
		}
	});

	/**
  * @member {Array} sliceList The list of all the slices associated to this volume
  */
	this.sliceList = [];

	/**
  * @member {Array} RASDimensions This array holds the dimensions of the volume in the RAS space
  */
};

Volume.prototype = {

	constructor: Volume,

	/**
  * @member {Function} getData Shortcut for data[access(i,j,k)]
  * @memberof THREE.Volume
  * @param {number} i    First coordinate
  * @param {number} j    Second coordinate
  * @param {number} k    Third coordinate
  * @returns {number}  value in the data array
  */
	getData: function getData(i, j, k) {

		return this.data[k * this.xLength * this.yLength + j * this.xLength + i];
	},

	/**
  * @member {Function} access compute the index in the data array corresponding to the given coordinates in IJK system
  * @memberof THREE.Volume
  * @param {number} i    First coordinate
  * @param {number} j    Second coordinate
  * @param {number} k    Third coordinate
  * @returns {number}  index
  */
	access: function access(i, j, k) {

		return k * this.xLength * this.yLength + j * this.xLength + i;
	},

	/**
  * @member {Function} reverseAccess Retrieve the IJK coordinates of the voxel corresponding of the given index in the data
  * @memberof THREE.Volume
  * @param {number} index index of the voxel
  * @returns {Array}  [x,y,z]
  */
	reverseAccess: function reverseAccess(index) {

		var z = Math.floor(index / (this.yLength * this.xLength));
		var y = Math.floor((index - z * this.yLength * this.xLength) / this.xLength);
		var x = index - z * this.yLength * this.xLength - y * this.xLength;
		return [x, y, z];
	},

	/**
  * @member {Function} map Apply a function to all the voxels, be careful, the value will be replaced
  * @memberof THREE.Volume
  * @param {Function} functionToMap A function to apply to every voxel, will be called with the following parameters :
  *                                 value of the voxel
  *                                 index of the voxel
  *                                 the data (TypedArray)
  * @param {Object}   context    You can specify a context in which call the function, default if this Volume
  * @returns {THREE.Volume}   this
  */
	map: function map(functionToMap, context) {

		var length = this.data.length;
		context = context || this;

		for (var i = 0; i < length; i++) {

			this.data[i] = functionToMap.call(context, this.data[i], i, this.data);
		}

		return this;
	},

	/**
  * @member {Function} extractPerpendicularPlane Compute the orientation of the slice and returns all the information relative to the geometry such as sliceAccess, the plane matrix (orientation and position in RAS coordinate) and the dimensions of the plane in both coordinate system.
  * @memberof THREE.Volume
  * @param {string}            axis  the normal axis to the slice 'x' 'y' or 'z'
  * @param {number}            index the index of the slice
  * @returns {Object} an object containing all the usefull information on the geometry of the slice
  */
	extractPerpendicularPlane: function extractPerpendicularPlane(axis, RASIndex) {

		var iLength,
		    jLength,
		    sliceAccess,
		    planeMatrix = new THREE.Matrix4().identity(),
		    volume = this,
		    planeWidth,
		    planeHeight,
		    firstSpacing,
		    secondSpacing,
		    positionOffset,
		    IJKIndex;

		var axisInIJK = new THREE.Vector3(),
		    firstDirection = new THREE.Vector3(),
		    secondDirection = new THREE.Vector3();

		var dimensions = new THREE.Vector3(this.xLength, this.yLength, this.zLength);

		switch (axis) {

			case 'x':
				axisInIJK.set(1, 0, 0);
				firstDirection.set(0, 0, -1);
				secondDirection.set(0, -1, 0);
				firstSpacing = this.spacing[2];
				secondSpacing = this.spacing[1];
				IJKIndex = new THREE.Vector3(RASIndex, 0, 0);

				planeMatrix.multiply(new THREE.Matrix4().makeRotationY(Math.PI / 2));
				positionOffset = (volume.RASDimensions[0] - 1) / 2;
				planeMatrix.setPosition(new THREE.Vector3(RASIndex - positionOffset, 0, 0));
				break;
			case 'y':
				axisInIJK.set(0, 1, 0);
				firstDirection.set(1, 0, 0);
				secondDirection.set(0, 0, 1);
				firstSpacing = this.spacing[0];
				secondSpacing = this.spacing[2];
				IJKIndex = new THREE.Vector3(0, RASIndex, 0);

				planeMatrix.multiply(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
				positionOffset = (volume.RASDimensions[1] - 1) / 2;
				planeMatrix.setPosition(new THREE.Vector3(0, RASIndex - positionOffset, 0));
				break;
			case 'z':
			default:
				axisInIJK.set(0, 0, 1);
				firstDirection.set(1, 0, 0);
				secondDirection.set(0, -1, 0);
				firstSpacing = this.spacing[0];
				secondSpacing = this.spacing[1];
				IJKIndex = new THREE.Vector3(0, 0, RASIndex);

				positionOffset = (volume.RASDimensions[2] - 1) / 2;
				planeMatrix.setPosition(new THREE.Vector3(0, 0, RASIndex - positionOffset));
				break;
		}

		firstDirection.applyMatrix4(volume.inverseMatrix).normalize();
		firstDirection.argVar = 'i';
		secondDirection.applyMatrix4(volume.inverseMatrix).normalize();
		secondDirection.argVar = 'j';
		axisInIJK.applyMatrix4(volume.inverseMatrix).normalize();
		iLength = Math.floor(Math.abs(firstDirection.dot(dimensions)));
		jLength = Math.floor(Math.abs(secondDirection.dot(dimensions)));
		planeWidth = Math.abs(iLength * firstSpacing);
		planeHeight = Math.abs(jLength * secondSpacing);

		IJKIndex = Math.abs(Math.round(IJKIndex.applyMatrix4(volume.inverseMatrix).dot(axisInIJK)));
		var base = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1)];
		var iDirection = [firstDirection, secondDirection, axisInIJK].find(function (x) {

			return Math.abs(x.dot(base[0])) > 0.9;
		});
		var jDirection = [firstDirection, secondDirection, axisInIJK].find(function (x) {

			return Math.abs(x.dot(base[1])) > 0.9;
		});
		var kDirection = [firstDirection, secondDirection, axisInIJK].find(function (x) {

			return Math.abs(x.dot(base[2])) > 0.9;
		});
		var argumentsWithInversion = ['volume.xLength-1-', 'volume.yLength-1-', 'volume.zLength-1-'];
		// var arguments = [ 'i', 'j', 'k' ];
		var argArray = [iDirection, jDirection, kDirection].map(function (direction, n) {

			return (direction.dot(base[n]) > 0 ? '' : argumentsWithInversion[n]) + (direction === axisInIJK ? 'IJKIndex' : direction.argVar);
		});
		var argString = argArray.join(',');
		sliceAccess = eval('(function sliceAccess (i,j) {return volume.access( ' + argString + ');})');

		return {
			iLength: iLength,
			jLength: jLength,
			sliceAccess: sliceAccess,
			matrix: planeMatrix,
			planeWidth: planeWidth,
			planeHeight: planeHeight
		};
	},

	/**
  * @member {Function} extractSlice Returns a slice corresponding to the given axis and index
  *                        The coordinate are given in the Right Anterior Superior coordinate format
  * @memberof THREE.Volume
  * @param {string}            axis  the normal axis to the slice 'x' 'y' or 'z'
  * @param {number}            index the index of the slice
  * @returns {THREE.VolumeSlice} the extracted slice
  */
	extractSlice: function extractSlice(axis, index) {

		var slice = new THREE.VolumeSlice(this, index, axis);
		this.sliceList.push(slice);
		return slice;
	},

	/**
  * @member {Function} repaintAllSlices Call repaint on all the slices extracted from this volume
  * @see THREE.VolumeSlice.repaint
  * @memberof THREE.Volume
  * @returns {THREE.Volume} this
  */
	repaintAllSlices: function repaintAllSlices() {

		this.sliceList.forEach(function (slice) {

			slice.repaint();
		});

		return this;
	},

	/**
  * @member {Function} computeMinMax Compute the minimum and the maximum of the data in the volume
  * @memberof THREE.Volume
  * @returns {Array} [min,max]
  */
	computeMinMax: function computeMinMax() {

		var min = Infinity;
		var max = -Infinity;

		// buffer the length
		var datasize = this.data.length;

		var i = 0;
		for (i = 0; i < datasize; i++) {

			if (!isNaN(this.data[i])) {

				var value = this.data[i];
				min = Math.min(min, value);
				max = Math.max(max, value);
			}
		}
		this.min = min;
		this.max = max;

		return [min, max];
	}

};

exports.default = Volume;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Luminosity
 * http://en.wikipedia.org/wiki/Luminosity
 */

var LuminosityShader = {

	uniforms: {

		"tDiffuse": { value: null }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["#include <common>", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "float l = linearToRelativeLuminance( texel.rgb );", "gl_FragColor = vec4( l, l, l, texel.w );", "}"].join("\n")

};

exports.default = LuminosityShader;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author miibond
 *
 * Full-screen tone-mapping shader based on http://www.cis.rit.edu/people/faculty/ferwerda/publications/sig02_paper.pdf
 */

var ToneMapShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"averageLuminance": { value: 1.0 },
		"luminanceMap": { value: null },
		"maxLuminance": { value: 16.0 },
		"minLuminance": { value: 0.01 },
		"middleGrey": { value: 0.6 }
	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["#include <common>", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "uniform float middleGrey;", "uniform float minLuminance;", "uniform float maxLuminance;", "#ifdef ADAPTED_LUMINANCE", "uniform sampler2D luminanceMap;", "#else", "uniform float averageLuminance;", "#endif", "vec3 ToneMap( vec3 vColor ) {", "#ifdef ADAPTED_LUMINANCE",
	// Get the calculated average luminance
	"float fLumAvg = texture2D(luminanceMap, vec2(0.5, 0.5)).r;", "#else", "float fLumAvg = averageLuminance;", "#endif",

	// Calculate the luminance of the current pixel
	"float fLumPixel = linearToRelativeLuminance( vColor );",

	// Apply the modified operator (Eq. 4)
	"float fLumScaled = (fLumPixel * middleGrey) / max( minLuminance, fLumAvg );", "float fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);", "return fLumCompressed * vColor;", "}", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "gl_FragColor = vec4( ToneMap( texel.xyz ), texel.w );", "}"].join("\n")

};

exports.default = ToneMapShader;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Convolution shader
 * ported from o3d sample to WebGL / GLSL
 * http://o3d.googlecode.com/svn/trunk/samples/convolution.html
 */

var ConvolutionShader = {

	defines: {

		"KERNEL_SIZE_FLOAT": "25.0",
		"KERNEL_SIZE_INT": "25"

	},

	uniforms: {

		"tDiffuse": { value: null },
		"uImageIncrement": { value: new THREE.Vector2(0.001953125, 0.0) },
		"cKernel": { value: [] }

	},

	vertexShader: ["uniform vec2 uImageIncrement;", "varying vec2 vUv;", "void main() {", "vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform float cKernel[ KERNEL_SIZE_INT ];", "uniform sampler2D tDiffuse;", "uniform vec2 uImageIncrement;", "varying vec2 vUv;", "void main() {", "vec2 imageCoord = vUv;", "vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );", "for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {", "sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];", "imageCoord += uImageIncrement;", "}", "gl_FragColor = sum;", "}"].join("\n"),

	buildKernel: function buildKernel(sigma) {

		// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.

		function gauss(x, sigma) {

			return Math.exp(-(x * x) / (2.0 * sigma * sigma));
		}

		var i,
		    values,
		    sum,
		    halfWidth,
		    kMaxKernelSize = 25,
		    kernelSize = 2 * Math.ceil(sigma * 3.0) + 1;

		if (kernelSize > kMaxKernelSize) kernelSize = kMaxKernelSize;
		halfWidth = (kernelSize - 1) * 0.5;

		values = new Array(kernelSize);
		sum = 0.0;
		for (i = 0; i < kernelSize; ++i) {

			values[i] = gauss(i - halfWidth, sigma);
			sum += values[i];
		}

		// normalize the kernel

		for (i = 0; i < kernelSize; ++i) {
			values[i] /= sum;
		}return values;
	}

};

exports.default = ConvolutionShader;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Depth-of-field shader with bokeh
 * ported from GLSL shader by Martins Upitis
 * http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html
 */

var BokehShader = {

	defines: {
		"DEPTH_PACKING": 1,
		"PERSPECTIVE_CAMERA": 1
	},

	uniforms: {

		"tColor": { value: null },
		"tDepth": { value: null },
		"focus": { value: 1.0 },
		"aspect": { value: 1.0 },
		"aperture": { value: 0.025 },
		"maxblur": { value: 1.0 },
		"nearClip": { value: 1.0 },
		"farClip": { value: 1000.0 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["#include <common>", "varying vec2 vUv;", "uniform sampler2D tColor;", "uniform sampler2D tDepth;", "uniform float maxblur;", // max blur amount
	"uniform float aperture;", // aperture - bigger values for shallower depth of field

	"uniform float nearClip;", "uniform float farClip;", "uniform float focus;", "uniform float aspect;", "#include <packing>", "float getDepth( const in vec2 screenPosition ) {", "	#if DEPTH_PACKING == 1", "	return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );", "	#else", "	return texture2D( tDepth, screenPosition ).x;", "	#endif", "}", "float getViewZ( const in float depth ) {", "	#if PERSPECTIVE_CAMERA == 1", "	return perspectiveDepthToViewZ( depth, nearClip, farClip );", "	#else", "	return orthographicDepthToViewZ( depth, nearClip, farClip );", "	#endif", "}", "void main() {", "vec2 aspectcorrect = vec2( 1.0, aspect );", "float viewZ = getViewZ( getDepth( vUv ) );", "float factor = ( focus + viewZ );", // viewZ is <= 0, so this is a difference equation

	"vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );", "vec2 dofblur9 = dofblur * 0.9;", "vec2 dofblur7 = dofblur * 0.7;", "vec2 dofblur4 = dofblur * 0.4;", "vec4 col = vec4( 0.0 );", "col += texture2D( tColor, vUv.xy );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );", "gl_FragColor = col / 41.0;", "gl_FragColor.a = 1.0;", "}"].join("\n")

};

exports.default = BokehShader;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Dot screen shader
 * based on glfx.js sepia shader
 * https://github.com/evanw/glfx.js
 */

var DotScreenShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"tSize": { value: new THREE.Vector2(256, 256) },
		"center": { value: new THREE.Vector2(0.5, 0.5) },
		"angle": { value: 1.57 },
		"scale": { value: 1.0 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform vec2 center;", "uniform float angle;", "uniform float scale;", "uniform vec2 tSize;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "float pattern() {", "float s = sin( angle ), c = cos( angle );", "vec2 tex = vUv * tSize - center;", "vec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;", "return ( sin( point.x ) * sin( point.y ) ) * 4.0;", "}", "void main() {", "vec4 color = texture2D( tDiffuse, vUv );", "float average = ( color.r + color.g + color.b ) / 3.0;", "gl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );", "}"].join("\n")

};

exports.default = DotScreenShader;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Film grain & scanlines shader
 *
 * - ported from HLSL to WebGL / GLSL
 * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html
 *
 * Screen Space Static Postprocessor
 *
 * Produces an analogue noise overlay similar to a film grain / TV static
 *
 * Original implementation and noise algorithm
 * Pat 'Hawthorne' Shearon
 *
 * Optimized scanlines + noise version with intensity scaling
 * Georg 'Leviathan' Steinrohder
 *
 * This version is provided under a Creative Commons Attribution 3.0 License
 * http://creativecommons.org/licenses/by/3.0/
 */

var FilmShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"time": { value: 0.0 },
		"nIntensity": { value: 0.5 },
		"sIntensity": { value: 0.05 },
		"sCount": { value: 4096 },
		"grayscale": { value: 1 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["#include <common>",

	// control parameter
	"uniform float time;", "uniform bool grayscale;",

	// noise effect intensity value (0 = no effect, 1 = full effect)
	"uniform float nIntensity;",

	// scanlines effect intensity value (0 = no effect, 1 = full effect)
	"uniform float sIntensity;",

	// scanlines effect count value (0 = no effect, 4096 = full effect)
	"uniform float sCount;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {",

	// sample the source
	"vec4 cTextureScreen = texture2D( tDiffuse, vUv );",

	// make some noise
	"float dx = rand( vUv + time );",

	// add noise
	"vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );",

	// get us a sine and cosine
	"vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );",

	// add scanlines
	"cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;",

	// interpolate between source and result by intensity
	"cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );",

	// convert to grayscale if desired
	"if( grayscale ) {", "cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );", "}", "gl_FragColor =  vec4( cResult, cTextureScreen.a );", "}"].join("\n")

};

exports.default = FilmShader;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author felixturner / http://airtight.cc/
 *
 * RGB Shift Shader
 * Shifts red and blue channels from center in opposite directions
 * Ported from http://kriss.cx/tom/2009/05/rgb-shift/
 * by Tom Butterworth / http://kriss.cx/tom/
 *
 * amount: shift distance (1 is width of input)
 * angle: shift angle in radians
 */

var DigitalGlitch = {

	uniforms: {

		"tDiffuse": { value: null }, //diffuse texture
		"tDisp": { value: null }, //displacement texture for digital glitch squares
		"byp": { value: 0 }, //apply the glitch ?
		"amount": { value: 0.08 },
		"angle": { value: 0.02 },
		"seed": { value: 0.02 },
		"seed_x": { value: 0.02 }, //-1,1
		"seed_y": { value: 0.02 }, //-1,1
		"distortion_x": { value: 0.5 },
		"distortion_y": { value: 0.6 },
		"col_s": { value: 0.05 }
	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform int byp;", //should we apply the glitch ?

	"uniform sampler2D tDiffuse;", "uniform sampler2D tDisp;", "uniform float amount;", "uniform float angle;", "uniform float seed;", "uniform float seed_x;", "uniform float seed_y;", "uniform float distortion_x;", "uniform float distortion_y;", "uniform float col_s;", "varying vec2 vUv;", "float rand(vec2 co){", "return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);", "}", "void main() {", "if(byp<1) {", "vec2 p = vUv;", "float xs = floor(gl_FragCoord.x / 0.5);", "float ys = floor(gl_FragCoord.y / 0.5);",
	//based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch
	"vec4 normal = texture2D (tDisp, p*seed*seed);", "if(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {", "if(seed_x>0.){", "p.y = 1. - (p.y + distortion_y);", "}", "else {", "p.y = distortion_y;", "}", "}", "if(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {", "if(seed_y>0.){", "p.x=distortion_x;", "}", "else {", "p.x = 1. - (p.x + distortion_x);", "}", "}", "p.x+=normal.x*seed_x*(seed/5.);", "p.y+=normal.y*seed_y*(seed/5.);",
	//base from RGB shift shader
	"vec2 offset = amount * vec2( cos(angle), sin(angle));", "vec4 cr = texture2D(tDiffuse, p + offset);", "vec4 cga = texture2D(tDiffuse, p);", "vec4 cb = texture2D(tDiffuse, p - offset);", "gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);",
	//add noise
	"vec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);", "gl_FragColor = gl_FragColor+ snow;", "}", "else {", "gl_FragColor=texture2D (tDiffuse, vUv);", "}", "}"].join("\n")

};

exports.default = DigitalGlitch;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author meatbags / xavierburrow.com, github/meatbags
 *
 * RGB Halftone shader for three.js.
 *	NOTE:
 * 		Shape (1 = Dot, 2 = Ellipse, 3 = Line, 4 = Square)
 *		Blending Mode (1 = Linear, 2 = Multiply, 3 = Add, 4 = Lighter, 5 = Darker)
 */

var HalftoneShader = {

	uniforms: {
		"tDiffuse": { value: null },
		"shape": { value: 1 },
		"radius": { value: 4 },
		"rotateR": { value: Math.PI / 12 * 1 },
		"rotateG": { value: Math.PI / 12 * 2 },
		"rotateB": { value: Math.PI / 12 * 3 },
		"scatter": { value: 0 },
		"width": { value: 1 },
		"height": { value: 1 },
		"blending": { value: 1 },
		"blendingMode": { value: 1 },
		"greyscale": { value: false },
		"disable": { value: false }
	},

	vertexShader: ["varying vec2 vUV;", "void main() {", "vUV = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);", "}"].join("\n"),

	fragmentShader: ["#define SQRT2_MINUS_ONE 0.41421356", "#define SQRT2_HALF_MINUS_ONE 0.20710678", "#define PI2 6.28318531", "#define SHAPE_DOT 1", "#define SHAPE_ELLIPSE 2", "#define SHAPE_LINE 3", "#define SHAPE_SQUARE 4", "#define BLENDING_LINEAR 1", "#define BLENDING_MULTIPLY 2", "#define BLENDING_ADD 3", "#define BLENDING_LIGHTER 4", "#define BLENDING_DARKER 5", "uniform sampler2D tDiffuse;", "uniform float radius;", "uniform float rotateR;", "uniform float rotateG;", "uniform float rotateB;", "uniform float scatter;", "uniform float width;", "uniform float height;", "uniform int shape;", "uniform bool disable;", "uniform float blending;", "uniform int blendingMode;", "varying vec2 vUV;", "uniform bool greyscale;", "const int samples = 8;", "float blend( float a, float b, float t ) {",

	// linear blend
	"return a * ( 1.0 - t ) + b * t;", "}", "float hypot( float x, float y ) {",

	// vector magnitude
	"return sqrt( x * x + y * y );", "}", "float rand( vec2 seed ){",

	// get pseudo-random number
	"return fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );", "}", "float distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {",

	// apply shape-specific transforms
	"float dist = hypot( coord.x - p.x, coord.y - p.y );", "float rad = channel;", "if ( shape == SHAPE_DOT ) {", "rad = pow( abs( rad ), 1.125 ) * rad_max;", "} else if ( shape == SHAPE_ELLIPSE ) {", "rad = pow( abs( rad ), 1.125 ) * rad_max;", "if ( dist != 0.0 ) {", "float dot_p = abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );", "dist = ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;", "}", "} else if ( shape == SHAPE_LINE ) {", "rad = pow( abs( rad ), 1.5) * rad_max;", "float dot_p = ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;", "dist = hypot( normal.x * dot_p, normal.y * dot_p );", "} else if ( shape == SHAPE_SQUARE ) {", "float theta = atan( p.y - coord.y, p.x - coord.x ) - angle;", "float sin_t = abs( sin( theta ) );", "float cos_t = abs( cos( theta ) );", "rad = pow( abs( rad ), 1.4 );", "rad = rad_max * ( rad + ( ( sin_t > cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );", "}", "return rad - dist;", "}", "struct Cell {",

	// grid sample positions
	"vec2 normal;", "vec2 p1;", "vec2 p2;", "vec2 p3;", "vec2 p4;", "float samp2;", "float samp1;", "float samp3;", "float samp4;", "};", "vec4 getSample( vec2 point ) {",

	// multi-sampled point
	"vec4 tex = texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );", "float base = rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;", "float step = PI2 / float( samples );", "float dist = radius * 0.66;", "for ( int i = 0; i < samples; ++i ) {", "float r = base + step * float( i );", "vec2 coord = point + vec2( cos( r ) * dist, sin( r ) * dist );", "tex += texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );", "}", "tex /= float( samples ) + 1.0;", "return tex;", "}", "float getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {",

	// get colour for given point
	"float dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;", "if ( channel == 0 ) {", "c.samp1 = getSample( c.p1 ).r;", "c.samp2 = getSample( c.p2 ).r;", "c.samp3 = getSample( c.p3 ).r;", "c.samp4 = getSample( c.p4 ).r;", "} else if (channel == 1) {", "c.samp1 = getSample( c.p1 ).g;", "c.samp2 = getSample( c.p2 ).g;", "c.samp3 = getSample( c.p3 ).g;", "c.samp4 = getSample( c.p4 ).g;", "} else {", "c.samp1 = getSample( c.p1 ).b;", "c.samp3 = getSample( c.p3 ).b;", "c.samp2 = getSample( c.p2 ).b;", "c.samp4 = getSample( c.p4 ).b;", "}", "dist_c_1 = distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );", "dist_c_2 = distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );", "dist_c_3 = distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );", "dist_c_4 = distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );", "res = ( dist_c_1 > 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;", "res += ( dist_c_2 > 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;", "res += ( dist_c_3 > 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;", "res += ( dist_c_4 > 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;", "res = clamp( res, 0.0, 1.0 );", "return res;", "}", "Cell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {",

	// get containing cell
	"Cell c;",

	// calc grid
	"vec2 n = vec2( cos( grid_angle ), sin( grid_angle ) );", "float threshold = step * 0.5;", "float dot_normal = n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );", "float dot_line = -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );", "vec2 offset = vec2( n.x * dot_normal, n.y * dot_normal );", "float offset_normal = mod( hypot( offset.x, offset.y ), step );", "float normal_dir = ( dot_normal < 0.0 ) ? 1.0 : -1.0;", "float normal_scale = ( ( offset_normal < threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;", "float offset_line = mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );", "float line_dir = ( dot_line < 0.0 ) ? 1.0 : -1.0;", "float line_scale = ( ( offset_line < threshold ) ? -offset_line : step - offset_line ) * line_dir;",

	// get closest corner
	"c.normal = n;", "c.p1.x = p.x - n.x * normal_scale + n.y * line_scale;", "c.p1.y = p.y - n.y * normal_scale - n.x * line_scale;",

	// scatter
	"if ( scatter != 0.0 ) {", "float off_mag = scatter * threshold * 0.5;", "float off_angle = rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;", "c.p1.x += cos( off_angle ) * off_mag;", "c.p1.y += sin( off_angle ) * off_mag;", "}",

	// find corners
	"float normal_step = normal_dir * ( ( offset_normal < threshold ) ? step : -step );", "float line_step = line_dir * ( ( offset_line < threshold ) ? step : -step );", "c.p2.x = c.p1.x - n.x * normal_step;", "c.p2.y = c.p1.y - n.y * normal_step;", "c.p3.x = c.p1.x + n.y * line_step;", "c.p3.y = c.p1.y - n.x * line_step;", "c.p4.x = c.p1.x - n.x * normal_step + n.y * line_step;", "c.p4.y = c.p1.y - n.y * normal_step - n.x * line_step;", "return c;", "}", "float blendColour( float a, float b, float t ) {",

	// blend colours
	"if ( blendingMode == BLENDING_LINEAR ) {", "return blend( a, b, 1.0 - t );", "} else if ( blendingMode == BLENDING_ADD ) {", "return blend( a, min( 1.0, a + b ), t );", "} else if ( blendingMode == BLENDING_MULTIPLY ) {", "return blend( a, max( 0.0, a * b ), t );", "} else if ( blendingMode == BLENDING_LIGHTER ) {", "return blend( a, max( a, b ), t );", "} else if ( blendingMode == BLENDING_DARKER ) {", "return blend( a, min( a, b ), t );", "} else {", "return blend( a, b, 1.0 - t );", "}", "}", "void main() {", "if ( ! disable ) {",

	// setup
	"vec2 p = vec2( vUV.x * width, vUV.y * height );", "vec2 origin = vec2( 0, 0 );", "float aa = ( radius < 2.5 ) ? radius * 0.5 : 1.25;",

	// get channel samples
	"Cell cell_r = getReferenceCell( p, origin, rotateR, radius );", "Cell cell_g = getReferenceCell( p, origin, rotateG, radius );", "Cell cell_b = getReferenceCell( p, origin, rotateB, radius );", "float r = getDotColour( cell_r, p, 0, rotateR, aa );", "float g = getDotColour( cell_g, p, 1, rotateG, aa );", "float b = getDotColour( cell_b, p, 2, rotateB, aa );",

	// blend with original
	"vec4 colour = texture2D( tDiffuse, vUV );", "r = blendColour( r, colour.r, blending );", "g = blendColour( g, colour.g, blending );", "b = blendColour( b, colour.b, blending );", "if ( greyscale ) {", "r = g = b = (r + b + g) / 3.0;", "}", "gl_FragColor = vec4( r, g, b, 1.0 );", "} else {", "gl_FragColor = texture2D( tDiffuse, vUV );", "}", "}"].join("\n")

};

exports.default = HalftoneShader;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var SAOShader = {
	defines: {
		'NUM_SAMPLES': 7,
		'NUM_RINGS': 4,
		'NORMAL_TEXTURE': 0,
		'DIFFUSE_TEXTURE': 0,
		'DEPTH_PACKING': 1,
		'PERSPECTIVE_CAMERA': 1
	},
	uniforms: {

		'tDepth': { type: 't', value: null },
		'tDiffuse': { type: 't', value: null },
		'tNormal': { type: 't', value: null },
		'size': { type: 'v2', value: new THREE.Vector2(512, 512) },

		'cameraNear': { type: 'f', value: 1 },
		'cameraFar': { type: 'f', value: 100 },
		'cameraProjectionMatrix': { type: 'm4', value: new THREE.Matrix4() },
		'cameraInverseProjectionMatrix': { type: 'm4', value: new THREE.Matrix4() },

		'scale': { type: 'f', value: 1.0 },
		'intensity': { type: 'f', value: 0.1 },
		'bias': { type: 'f', value: 0.5 },

		'minResolution': { type: 'f', value: 0.0 },
		'kernelRadius': { type: 'f', value: 100.0 },
		'randomSeed': { type: 'f', value: 0.0 }
	},
	vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
	fragmentShader: ["#include <common>", "varying vec2 vUv;", "#if DIFFUSE_TEXTURE == 1", "uniform sampler2D tDiffuse;", "#endif", "uniform sampler2D tDepth;", "#if NORMAL_TEXTURE == 1", "uniform sampler2D tNormal;", "#endif", "uniform float cameraNear;", "uniform float cameraFar;", "uniform mat4 cameraProjectionMatrix;", "uniform mat4 cameraInverseProjectionMatrix;", "uniform float scale;", "uniform float intensity;", "uniform float bias;", "uniform float kernelRadius;", "uniform float minResolution;", "uniform vec2 size;", "uniform float randomSeed;", "// RGBA depth", "#include <packing>", "vec4 getDefaultColor( const in vec2 screenPosition ) {", "	#if DIFFUSE_TEXTURE == 1", "	return texture2D( tDiffuse, vUv );", "	#else", "	return vec4( 1.0 );", "	#endif", "}", "float getDepth( const in vec2 screenPosition ) {", "	#if DEPTH_PACKING == 1", "	return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );", "	#else", "	return texture2D( tDepth, screenPosition ).x;", "	#endif", "}", "float getViewZ( const in float depth ) {", "	#if PERSPECTIVE_CAMERA == 1", "	return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );", "	#else", "	return orthographicDepthToViewZ( depth, cameraNear, cameraFar );", "	#endif", "}", "vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {", "	float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];", "	vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );", "	clipPosition *= clipW; // unprojection.", "	return ( cameraInverseProjectionMatrix * clipPosition ).xyz;", "}", "vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {", "	#if NORMAL_TEXTURE == 1", "	return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );", "	#else", "	return normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );", "	#endif", "}", "float scaleDividedByCameraFar;", "float minResolutionMultipliedByCameraFar;", "float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {", "	vec3 viewDelta = sampleViewPosition - centerViewPosition;", "	float viewDistance = length( viewDelta );", "	float scaledScreenDistance = scaleDividedByCameraFar * viewDistance;", "	return max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );", "}", "// moving costly divides into consts", "const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );", "const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );", "float getAmbientOcclusion( const in vec3 centerViewPosition ) {", "	// precompute some variables require in getOcclusion.", "	scaleDividedByCameraFar = scale / cameraFar;", "	minResolutionMultipliedByCameraFar = minResolution * cameraFar;", "	vec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );", "	// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/", "	float angle = rand( vUv + randomSeed ) * PI2;", "	vec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;", "	vec2 radiusStep = radius;", "	float occlusionSum = 0.0;", "	float weightSum = 0.0;", "	for( int i = 0; i < NUM_SAMPLES; i ++ ) {", "		vec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;", "		radius += radiusStep;", "		angle += ANGLE_STEP;", "		float sampleDepth = getDepth( sampleUv );", "		if( sampleDepth >= ( 1.0 - EPSILON ) ) {", "			continue;", "		}", "		float sampleViewZ = getViewZ( sampleDepth );", "		vec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );", "		occlusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );", "		weightSum += 1.0;", "	}", "	if( weightSum == 0.0 ) discard;", "	return occlusionSum * ( intensity / weightSum );", "}", "void main() {", "	float centerDepth = getDepth( vUv );", "	if( centerDepth >= ( 1.0 - EPSILON ) ) {", "		discard;", "	}", "	float centerViewZ = getViewZ( centerDepth );", "	vec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );", "	float ambientOcclusion = getAmbientOcclusion( viewPosition );", "	gl_FragColor = getDefaultColor( vUv );", "	gl_FragColor.xyz *=  1.0 - ambientOcclusion;", "}"].join("\n")
};

exports.default = SAOShader;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var DepthLimitedBlurShader = {
	defines: {
		'KERNEL_RADIUS': 4,
		'DEPTH_PACKING': 1,
		'PERSPECTIVE_CAMERA': 1
	},
	uniforms: {
		'tDiffuse': { type: 't', value: null },
		'size': { type: 'v2', value: new THREE.Vector2(512, 512) },
		'sampleUvOffsets': { type: 'v2v', value: [new THREE.Vector2(0, 0)] },
		'sampleWeights': { type: '1fv', value: [1.0] },
		'tDepth': { type: 't', value: null },
		'cameraNear': { type: 'f', value: 10 },
		'cameraFar': { type: 'f', value: 1000 },
		'depthCutoff': { type: 'f', value: 10 }
	},
	vertexShader: ["#include <common>", "uniform vec2 size;", "varying vec2 vUv;", "varying vec2 vInvSize;", "void main() {", "	vUv = uv;", "	vInvSize = 1.0 / size;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
	fragmentShader: ["#include <common>", "#include <packing>", "uniform sampler2D tDiffuse;", "uniform sampler2D tDepth;", "uniform float cameraNear;", "uniform float cameraFar;", "uniform float depthCutoff;", "uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];", "uniform float sampleWeights[ KERNEL_RADIUS + 1 ];", "varying vec2 vUv;", "varying vec2 vInvSize;", "float getDepth( const in vec2 screenPosition ) {", "	#if DEPTH_PACKING == 1", "	return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );", "	#else", "	return texture2D( tDepth, screenPosition ).x;", "	#endif", "}", "float getViewZ( const in float depth ) {", "	#if PERSPECTIVE_CAMERA == 1", "	return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );", "	#else", "	return orthographicDepthToViewZ( depth, cameraNear, cameraFar );", "	#endif", "}", "void main() {", "	float depth = getDepth( vUv );", "	if( depth >= ( 1.0 - EPSILON ) ) {", "		discard;", "	}", "	float centerViewZ = -getViewZ( depth );", "	bool rBreak = false, lBreak = false;", "	float weightSum = sampleWeights[0];", "	vec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;", "	for( int i = 1; i <= KERNEL_RADIUS; i ++ ) {", "		float sampleWeight = sampleWeights[i];", "		vec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;", "		vec2 sampleUv = vUv + sampleUvOffset;", "		float viewZ = -getViewZ( getDepth( sampleUv ) );", "		if( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;", "		if( ! rBreak ) {", "			diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;", "			weightSum += sampleWeight;", "		}", "		sampleUv = vUv - sampleUvOffset;", "		viewZ = -getViewZ( getDepth( sampleUv ) );", "		if( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;", "		if( ! lBreak ) {", "			diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;", "			weightSum += sampleWeight;", "		}", "	}", "	gl_FragColor = diffuseSum / weightSum;", "}"].join("\n")
};

exports.default = DepthLimitedBlurShader;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Unpack RGBA depth shader
 * - show RGBA encoded depth as monochrome color
 */

var UnpackDepthRGBAShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"opacity": { value: 1.0 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "#include <packing>", "void main() {", "float depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );", "gl_FragColor = vec4( vec3( depth ), opacity );", "}"].join("\n")

};

exports.default = UnpackDepthRGBAShader;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var BlurShaderUtils = {

  createSampleWeights: function createSampleWeights(kernelRadius, stdDev) {

    var gaussian = function gaussian(x, stdDev) {

      return Math.exp(-(x * x) / (2.0 * (stdDev * stdDev))) / (Math.sqrt(2.0 * Math.PI) * stdDev);
    };

    var weights = [];

    for (var i = 0; i <= kernelRadius; i++) {

      weights.push(gaussian(i, stdDev));
    }

    return weights;
  },

  createSampleOffsets: function createSampleOffsets(kernelRadius, uvIncrement) {

    var offsets = [];

    for (var i = 0; i <= kernelRadius; i++) {

      offsets.push(uvIncrement.clone().multiplyScalar(i));
    }

    return offsets;
  },

  configure: function configure(material, kernelRadius, stdDev, uvIncrement) {

    material.defines['KERNEL_RADIUS'] = kernelRadius;
    material.uniforms['sampleUvOffsets'].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);
    material.uniforms['sampleWeights'].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);
    material.needsUpdate = true;
  }

};

exports.default = BlurShaderUtils;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author mpk / http://polko.me/
 *
 * WebGL port of Subpixel Morphological Antialiasing (SMAA) v2.8
 * Preset: SMAA 1x Medium (with color edge detection)
 * https://github.com/iryoku/smaa/releases/tag/v2.8
 */

var SMAAShader = [{

	defines: {

		"SMAA_THRESHOLD": "0.1"

	},

	uniforms: {

		"tDiffuse": { value: null },
		"resolution": { value: new THREE.Vector2(1 / 1024, 1 / 512) }

	},

	vertexShader: ["uniform vec2 resolution;", "varying vec2 vUv;", "varying vec4 vOffset[ 3 ];", "void SMAAEdgeDetectionVS( vec2 texcoord ) {", "vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );", // WebGL port note: Changed sign in W component
	"vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );", // WebGL port note: Changed sign in W component
	"vOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );", // WebGL port note: Changed sign in W component
	"}", "void main() {", "vUv = uv;", "SMAAEdgeDetectionVS( vUv );", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform sampler2D tDiffuse;", "varying vec2 vUv;", "varying vec4 vOffset[ 3 ];", "vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {", "vec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );",

	// Calculate color deltas:
	"vec4 delta;", "vec3 C = texture2D( colorTex, texcoord ).rgb;", "vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;", "vec3 t = abs( C - Cleft );", "delta.x = max( max( t.r, t.g ), t.b );", "vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;", "t = abs( C - Ctop );", "delta.y = max( max( t.r, t.g ), t.b );",

	// We do the usual threshold:
	"vec2 edges = step( threshold, delta.xy );",

	// Then discard if there is no edge:
	"if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )", "discard;",

	// Calculate right and bottom deltas:
	"vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;", "t = abs( C - Cright );", "delta.z = max( max( t.r, t.g ), t.b );", "vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;", "t = abs( C - Cbottom );", "delta.w = max( max( t.r, t.g ), t.b );",

	// Calculate the maximum delta in the direct neighborhood:
	"float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );",

	// Calculate left-left and top-top deltas:
	"vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;", "t = abs( C - Cleftleft );", "delta.z = max( max( t.r, t.g ), t.b );", "vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;", "t = abs( C - Ctoptop );", "delta.w = max( max( t.r, t.g ), t.b );",

	// Calculate the final maximum delta:
	"maxDelta = max( max( maxDelta, delta.z ), delta.w );",

	// Local contrast adaptation in action:
	"edges.xy *= step( 0.5 * maxDelta, delta.xy );", "return vec4( edges, 0.0, 0.0 );", "}", "void main() {", "gl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );", "}"].join("\n")

}, {

	defines: {

		"SMAA_MAX_SEARCH_STEPS": "8",
		"SMAA_AREATEX_MAX_DISTANCE": "16",
		"SMAA_AREATEX_PIXEL_SIZE": "( 1.0 / vec2( 160.0, 560.0 ) )",
		"SMAA_AREATEX_SUBTEX_SIZE": "( 1.0 / 7.0 )"

	},

	uniforms: {

		"tDiffuse": { value: null },
		"tArea": { value: null },
		"tSearch": { value: null },
		"resolution": { value: new THREE.Vector2(1 / 1024, 1 / 512) }

	},

	vertexShader: ["uniform vec2 resolution;", "varying vec2 vUv;", "varying vec4 vOffset[ 3 ];", "varying vec2 vPixcoord;", "void SMAABlendingWeightCalculationVS( vec2 texcoord ) {", "vPixcoord = texcoord / resolution;",

	// We will use these offsets for the searches later on (see @PSEUDO_GATHER4):
	"vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );", // WebGL port note: Changed sign in Y and W components
	"vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );", // WebGL port note: Changed sign in Y and W components

	// And these for the searches, they indicate the ends of the loops:
	"vOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );", "}", "void main() {", "vUv = uv;", "SMAABlendingWeightCalculationVS( vUv );", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )", "uniform sampler2D tDiffuse;", "uniform sampler2D tArea;", "uniform sampler2D tSearch;", "uniform vec2 resolution;", "varying vec2 vUv;", "varying vec4 vOffset[3];", "varying vec2 vPixcoord;", "vec2 round( vec2 x ) {", "return sign( x ) * floor( abs( x ) + 0.5 );", "}", "float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {",
	// Not required if searchTex accesses are set to point:
	// float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);
	// e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +
	//     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;
	"e.r = bias + e.r * scale;", "return 255.0 * texture2D( searchTex, e, 0.0 ).r;", "}", "float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
	/**
 * @PSEUDO_GATHER4
 * This texcoord has been offset by (-0.25, -0.125) in the vertex shader to
 * sample between edge, thus fetching four edges in a row.
 * Sampling with different offsets in each direction allows to disambiguate
 * which edges are active from the four fetched ones.
 */
	"vec2 e = vec2( 0.0, 1.0 );", "for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {", // WebGL port note: Changed while to for
	"e = texture2D( edgesTex, texcoord, 0.0 ).rg;", "texcoord -= vec2( 2.0, 0.0 ) * resolution;", "if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;", "}",

	// We correct the previous (-0.25, -0.125) offset we applied:
	"texcoord.x += 0.25 * resolution.x;",

	// The searches are bias by 1, so adjust the coords accordingly:
	"texcoord.x += resolution.x;",

	// Disambiguate the length added by the last step:
	"texcoord.x += 2.0 * resolution.x;", // Undo last step
	"texcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);", "return texcoord.x;", "}", "float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {", "vec2 e = vec2( 0.0, 1.0 );", "for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {", // WebGL port note: Changed while to for
	"e = texture2D( edgesTex, texcoord, 0.0 ).rg;", "texcoord += vec2( 2.0, 0.0 ) * resolution;", "if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;", "}", "texcoord.x -= 0.25 * resolution.x;", "texcoord.x -= resolution.x;", "texcoord.x -= 2.0 * resolution.x;", "texcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );", "return texcoord.x;", "}", "float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {", "vec2 e = vec2( 1.0, 0.0 );", "for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {", // WebGL port note: Changed while to for
	"e = texture2D( edgesTex, texcoord, 0.0 ).rg;", "texcoord += vec2( 0.0, 2.0 ) * resolution;", // WebGL port note: Changed sign
	"if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;", "}", "texcoord.y -= 0.25 * resolution.y;", // WebGL port note: Changed sign
	"texcoord.y -= resolution.y;", // WebGL port note: Changed sign
	"texcoord.y -= 2.0 * resolution.y;", // WebGL port note: Changed sign
	"texcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 );", // WebGL port note: Changed sign

	"return texcoord.y;", "}", "float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {", "vec2 e = vec2( 1.0, 0.0 );", "for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {", // WebGL port note: Changed while to for
	"e = texture2D( edgesTex, texcoord, 0.0 ).rg;", "texcoord -= vec2( 0.0, 2.0 ) * resolution;", // WebGL port note: Changed sign
	"if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;", "}", "texcoord.y += 0.25 * resolution.y;", // WebGL port note: Changed sign
	"texcoord.y += resolution.y;", // WebGL port note: Changed sign
	"texcoord.y += 2.0 * resolution.y;", // WebGL port note: Changed sign
	"texcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 );", // WebGL port note: Changed sign

	"return texcoord.y;", "}", "vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {",
	// Rounding prevents precision errors of bilinear filtering:
	"vec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;",

	// We do a scale and bias for mapping to texel space:
	"texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );",

	// Move to proper place, according to the subpixel offset:
	"texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;", "return texture2D( areaTex, texcoord, 0.0 ).rg;", "}", "vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {", "vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );", "vec2 e = texture2D( edgesTex, texcoord ).rg;", "if ( e.g > 0.0 ) {", // Edge at north
	"vec2 d;",

	// Find the distance to the left:
	"vec2 coords;", "coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );", "coords.y = offset[ 1 ].y;", // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)
	"d.x = coords.x;",

	// Now fetch the left crossing edges, two at a time using bilinear
	// filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to
	// discern what value each edge has:
	"float e1 = texture2D( edgesTex, coords, 0.0 ).r;",

	// Find the distance to the right:
	"coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );", "d.y = coords.x;",

	// We want the distances to be in pixel units (doing this here allow to
	// better interleave arithmetic and memory accesses):
	"d = d / resolution.x - pixcoord.x;",

	// SMAAArea below needs a sqrt, as the areas texture is compressed
	// quadratically:
	"vec2 sqrt_d = sqrt( abs( d ) );",

	// Fetch the right crossing edges:
	"coords.y -= 1.0 * resolution.y;", // WebGL port note: Added
	"float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;",

	// Ok, we know how this pattern looks like, now it is time for getting
	// the actual area:
	"weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );", "}", "if ( e.r > 0.0 ) {", // Edge at west
	"vec2 d;",

	// Find the distance to the top:
	"vec2 coords;", "coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );", "coords.x = offset[ 0 ].x;", // offset[1].x = texcoord.x - 0.25 * resolution.x;
	"d.x = coords.y;",

	// Fetch the top crossing edges:
	"float e1 = texture2D( edgesTex, coords, 0.0 ).g;",

	// Find the distance to the bottom:
	"coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );", "d.y = coords.y;",

	// We want the distances to be in pixel units:
	"d = d / resolution.y - pixcoord.y;",

	// SMAAArea below needs a sqrt, as the areas texture is compressed
	// quadratically:
	"vec2 sqrt_d = sqrt( abs( d ) );",

	// Fetch the bottom crossing edges:
	"coords.y -= 1.0 * resolution.y;", // WebGL port note: Added
	"float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;",

	// Get the area for this direction:
	"weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );", "}", "return weights;", "}", "void main() {", "gl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );", "}"].join("\n")

}, {

	uniforms: {

		"tDiffuse": { value: null },
		"tColor": { value: null },
		"resolution": { value: new THREE.Vector2(1 / 1024, 1 / 512) }

	},

	vertexShader: ["uniform vec2 resolution;", "varying vec2 vUv;", "varying vec4 vOffset[ 2 ];", "void SMAANeighborhoodBlendingVS( vec2 texcoord ) {", "vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 );", // WebGL port note: Changed sign in W component
	"vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 );", // WebGL port note: Changed sign in W component
	"}", "void main() {", "vUv = uv;", "SMAANeighborhoodBlendingVS( vUv );", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform sampler2D tDiffuse;", "uniform sampler2D tColor;", "uniform vec2 resolution;", "varying vec2 vUv;", "varying vec4 vOffset[ 2 ];", "vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {",
	// Fetch the blending weights for current pixel:
	"vec4 a;", "a.xz = texture2D( blendTex, texcoord ).xz;", "a.y = texture2D( blendTex, offset[ 1 ].zw ).g;", "a.w = texture2D( blendTex, offset[ 1 ].xy ).a;",

	// Is there any blending weight with a value greater than 0.0?
	"if ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {", "return texture2D( colorTex, texcoord, 0.0 );", "} else {",
	// Up to 4 lines can be crossing a pixel (one through each edge). We
	// favor blending by choosing the line with the maximum weight for each
	// direction:
	"vec2 offset;", "offset.x = a.a > a.b ? a.a : -a.b;", // left vs. right
	"offset.y = a.g > a.r ? -a.g : a.r;", // top vs. bottom // WebGL port note: Changed signs

	// Then we go in the direction that has the maximum weight:
	"if ( abs( offset.x ) > abs( offset.y )) {", // horizontal vs. vertical
	"offset.y = 0.0;", "} else {", "offset.x = 0.0;", "}",

	// Fetch the opposite color and lerp by hand:
	"vec4 C = texture2D( colorTex, texcoord, 0.0 );", "texcoord += sign( offset ) * resolution;", "vec4 Cop = texture2D( colorTex, texcoord, 0.0 );", "float s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );",

	// WebGL port note: Added gamma correction
	"C.xyz = pow(C.xyz, vec3(2.2));", "Cop.xyz = pow(Cop.xyz, vec3(2.2));", "vec4 mixed = mix(C, Cop, s);", "mixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));", "return mixed;", "}", "}", "void main() {", "gl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );", "}"].join("\n")

}];

exports.default = SMAAShader;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _Pass = __webpack_require__(1);

var _Pass2 = _interopRequireDefault(_Pass);

var _CopyShader = __webpack_require__(2);

var _CopyShader2 = _interopRequireDefault(_CopyShader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
*
* Supersample Anti-Aliasing Render Pass
*
* @author bhouston / http://clara.io/
*
* This manual approach to SSAA re-renders the scene ones for each sample with camera jitter and accumulates the results.
*
* References: https://en.wikipedia.org/wiki/Supersampling
*
*/

var SSAARenderPass = function SSAARenderPass(scene, camera, clearColor, clearAlpha) {

	_Pass2.default.call(this);

	this.scene = scene;
	this.camera = camera;

	this.sampleLevel = 4; // specified as n, where the number of samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.
	this.unbiased = true;

	// as we need to clear the buffer in this pass, clearColor must be set to something, defaults to black.
	this.clearColor = clearColor !== undefined ? clearColor : 0x000000;
	this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;

	if (_CopyShader2.default === undefined) console.error("THREE.SSAARenderPass relies on THREE.CopyShader");

	var copyShader = _CopyShader2.default;
	this.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);

	this.copyMaterial = new THREE.ShaderMaterial({
		uniforms: this.copyUniforms,
		vertexShader: copyShader.vertexShader,
		fragmentShader: copyShader.fragmentShader,
		premultipliedAlpha: true,
		transparent: true,
		blending: THREE.AdditiveBlending,
		depthTest: false,
		depthWrite: false
	});

	this.camera2 = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
	this.scene2 = new THREE.Scene();
	this.quad2 = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), this.copyMaterial);
	this.quad2.frustumCulled = false; // Avoid getting clipped
	this.scene2.add(this.quad2);
};

SSAARenderPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {

	constructor: SSAARenderPass,

	dispose: function dispose() {

		if (this.sampleRenderTarget) {

			this.sampleRenderTarget.dispose();
			this.sampleRenderTarget = null;
		}
	},

	setSize: function setSize(width, height) {

		if (this.sampleRenderTarget) this.sampleRenderTarget.setSize(width, height);
	},

	render: function render(renderer, writeBuffer, readBuffer) {

		if (!this.sampleRenderTarget) {

			this.sampleRenderTarget = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat });
			this.sampleRenderTarget.texture.name = "SSAARenderPass.sample";
		}

		var jitterOffsets = SSAARenderPass.JitterVectors[Math.max(0, Math.min(this.sampleLevel, 5))];

		var autoClear = renderer.autoClear;
		renderer.autoClear = false;

		var oldClearColor = renderer.getClearColor().getHex();
		var oldClearAlpha = renderer.getClearAlpha();

		var baseSampleWeight = 1.0 / jitterOffsets.length;
		var roundingRange = 1 / 32;
		this.copyUniforms["tDiffuse"].value = this.sampleRenderTarget.texture;

		var width = readBuffer.width,
		    height = readBuffer.height;

		// render the scene multiple times, each slightly jitter offset from the last and accumulate the results.
		for (var i = 0; i < jitterOffsets.length; i++) {

			var jitterOffset = jitterOffsets[i];

			if (this.camera.setViewOffset) {

				this.camera.setViewOffset(width, height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625, // 0.0625 = 1 / 16
				width, height);
			}

			var sampleWeight = baseSampleWeight;

			if (this.unbiased) {

				// the theory is that equal weights for each sample lead to an accumulation of rounding errors.
				// The following equation varies the sampleWeight per sample so that it is uniformly distributed
				// across a range of values whose rounding errors cancel each other out.

				var uniformCenteredDistribution = -0.5 + (i + 0.5) / jitterOffsets.length;
				sampleWeight += roundingRange * uniformCenteredDistribution;
			}

			this.copyUniforms["opacity"].value = sampleWeight;
			renderer.setClearColor(this.clearColor, this.clearAlpha);
			renderer.render(this.scene, this.camera, this.sampleRenderTarget, true);

			if (i === 0) {

				renderer.setClearColor(0x000000, 0.0);
			}

			renderer.render(this.scene2, this.camera2, this.renderToScreen ? null : writeBuffer, i === 0);
		}

		if (this.camera.clearViewOffset) this.camera.clearViewOffset();

		renderer.autoClear = autoClear;
		renderer.setClearColor(oldClearColor, oldClearAlpha);
	}

});

// These jitter vectors are specified in integers because it is easier.
// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)
// before being used, thus these integers need to be scaled by 1/16.
//
// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396
SSAARenderPass.JitterVectors = [[[0, 0]], [[4, 4], [-4, -4]], [[-2, -6], [6, -2], [-6, 2], [2, 6]], [[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]], [[1, 1], [-1, -3], [-3, 2], [4, -1], [-5, -2], [2, 5], [5, 3], [3, -5], [-2, 6], [0, -7], [-4, -6], [-6, 4], [-8, 0], [7, -4], [6, 7], [-7, -8]], [[-4, -7], [-7, -5], [-3, -5], [-5, -4], [-1, -4], [-2, -2], [-6, -1], [-4, 0], [-7, 1], [-1, 2], [-6, 3], [-3, 3], [-7, 6], [-3, 6], [-5, 7], [-1, 7], [5, -7], [1, -6], [6, -5], [4, -4], [2, -3], [7, -2], [1, -1], [4, -1], [2, 1], [6, 2], [0, 4], [4, 4], [2, 5], [7, 5], [5, 6], [3, 7]]];

exports.default = SSAARenderPass;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Screen-space ambient occlusion shader
 * - ported from
 *   SSAO GLSL shader v1.2
 *   assembled by Martins Upitis (martinsh) (http://devlog-martinsh.blogspot.com)
 *   original technique is made by ArKano22 (http://www.gamedev.net/topic/550699-ssao-no-halo-artifacts/)
 * - modifications
 * - modified to use RGBA packed depth texture (use clear color 1,1,1,1 for depth pass)
 * - refactoring and optimizations
 */

var SSAOShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"tDepth": { value: null },
		"size": { value: new THREE.Vector2(512, 512) },
		"cameraNear": { value: 1 },
		"cameraFar": { value: 100 },
		"radius": { value: 32 },
		"onlyAO": { value: 0 },
		"aoClamp": { value: 0.25 },
		"lumInfluence": { value: 0.7 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform float cameraNear;", "uniform float cameraFar;", "#ifdef USE_LOGDEPTHBUF", "uniform float logDepthBufFC;", "#endif", "uniform float radius;", // ao radius
	"uniform bool onlyAO;", // use only ambient occlusion pass?

	"uniform vec2 size;", // texture width, height
	"uniform float aoClamp;", // depth clamp - reduces haloing at screen edges

	"uniform float lumInfluence;", // how much luminance affects occlusion

	"uniform sampler2D tDiffuse;", "uniform sampler2D tDepth;", "varying vec2 vUv;",

	// "#define PI 3.14159265",
	"#define DL 2.399963229728653", // PI * ( 3.0 - sqrt( 5.0 ) )
	"#define EULER 2.718281828459045",

	// user variables

	"const int samples = 64;", // ao sample count

	"const bool useNoise = true;", // use noise instead of pattern for sample dithering
	"const float noiseAmount = 0.0004;", // dithering amount

	"const float diffArea = 0.4;", // self-shadowing reduction
	"const float gDisplace = 0.4;", // gauss bell center


	// RGBA depth

	"#include <packing>",

	// generating noise / pattern texture for dithering

	"vec2 rand( const vec2 coord ) {", "vec2 noise;", "if ( useNoise ) {", "float nx = dot ( coord, vec2( 12.9898, 78.233 ) );", "float ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );", "noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );", "} else {", "float ff = fract( 1.0 - coord.s * ( size.x / 2.0 ) );", "float gg = fract( coord.t * ( size.y / 2.0 ) );", "noise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;", "}", "return ( noise * 2.0  - 1.0 ) * noiseAmount;", "}", "float readDepth( const in vec2 coord ) {", "float cameraFarPlusNear = cameraFar + cameraNear;", "float cameraFarMinusNear = cameraFar - cameraNear;", "float cameraCoef = 2.0 * cameraNear;", "#ifdef USE_LOGDEPTHBUF", "float logz = unpackRGBAToDepth( texture2D( tDepth, coord ) );", "float w = pow(2.0, (logz / logDepthBufFC)) - 1.0;", "float z = (logz / w) + 1.0;", "#else", "float z = unpackRGBAToDepth( texture2D( tDepth, coord ) );", "#endif", "return cameraCoef / ( cameraFarPlusNear - z * cameraFarMinusNear );", "}", "float compareDepths( const in float depth1, const in float depth2, inout int far ) {", "float garea = 8.0;", // gauss bell width
	"float diff = ( depth1 - depth2 ) * 100.0;", // depth difference (0-100)

	// reduce left bell width to avoid self-shadowing

	"if ( diff < gDisplace ) {", "garea = diffArea;", "} else {", "far = 1;", "}", "float dd = diff - gDisplace;", "float gauss = pow( EULER, -2.0 * ( dd * dd ) / ( garea * garea ) );", "return gauss;", "}", "float calcAO( float depth, float dw, float dh ) {", "vec2 vv = vec2( dw, dh );", "vec2 coord1 = vUv + radius * vv;", "vec2 coord2 = vUv - radius * vv;", "float temp1 = 0.0;", "float temp2 = 0.0;", "int far = 0;", "temp1 = compareDepths( depth, readDepth( coord1 ), far );",

	// DEPTH EXTRAPOLATION

	"if ( far > 0 ) {", "temp2 = compareDepths( readDepth( coord2 ), depth, far );", "temp1 += ( 1.0 - temp1 ) * temp2;", "}", "return temp1;", "}", "void main() {", "vec2 noise = rand( vUv );", "float depth = readDepth( vUv );", "float tt = clamp( depth, aoClamp, 1.0 );", "float w = ( 1.0 / size.x ) / tt + ( noise.x * ( 1.0 - noise.x ) );", "float h = ( 1.0 / size.y ) / tt + ( noise.y * ( 1.0 - noise.y ) );", "float ao = 0.0;", "float dz = 1.0 / float( samples );", "float l = 0.0;", "float z = 1.0 - dz / 2.0;", "for ( int i = 0; i <= samples; i ++ ) {", "float r = sqrt( 1.0 - z );", "float pw = cos( l ) * r;", "float ph = sin( l ) * r;", "ao += calcAO( depth, pw * w, ph * h );", "z = z - dz;", "l = l + DL;", "}", "ao /= float( samples );", "ao = 1.0 - ao;", "vec3 color = texture2D( tDiffuse, vUv ).rgb;", "vec3 lumcoeff = vec3( 0.299, 0.587, 0.114 );", "float lum = dot( color.rgb, lumcoeff );", "vec3 luminance = vec3( lum );", "vec3 final = vec3( color * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );", // mix( color * ao, white, luminance )

	"if ( onlyAO ) {", "final = vec3( mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );", // ambient occlusion only

	"}", "gl_FragColor = vec4( final, 1.0 );", "}"].join("\n")

};

exports.default = SSAOShader;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author bhouston / http://clara.io/
 *
 * Luminosity
 * http://en.wikipedia.org/wiki/Luminosity
 */

var LuminosityHighPassShader = {

	shaderID: "luminosityHighPass",

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"luminosityThreshold": { type: "f", value: 1.0 },
		"smoothWidth": { type: "f", value: 1.0 },
		"defaultColor": { type: "c", value: new THREE.Color(0x000000) },
		"defaultOpacity": { type: "f", value: 0.0 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform sampler2D tDiffuse;", "uniform vec3 defaultColor;", "uniform float defaultOpacity;", "uniform float luminosityThreshold;", "uniform float smoothWidth;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "vec3 luma = vec3( 0.299, 0.587, 0.114 );", "float v = dot( texel.xyz, luma );", "vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );", "float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );", "gl_FragColor = mix( outputColor, texel, alpha );", "}"].join("\n")

};

exports.default = LuminosityHighPassShader;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _controls = __webpack_require__(28);

Object.keys(_controls).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _controls[key];
    }
  });
});

var _exporters = __webpack_require__(40);

Object.keys(_exporters).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _exporters[key];
    }
  });
});

var _loaders = __webpack_require__(48);

Object.keys(_loaders).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _loaders[key];
    }
  });
});

var _postprocessing = __webpack_require__(90);

Object.keys(_postprocessing).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _postprocessing[key];
    }
  });
});

var _shaders = __webpack_require__(112);

Object.keys(_shaders).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _shaders[key];
    }
  });
});

var _uncategories = __webpack_require__(144);

Object.keys(_uncategories).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _uncategories[key];
    }
  });
});

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VRControls = exports.TransformControls = exports.TrackballControls = exports.PointerLockControls = exports.OrthographicTrackballControls = exports.OrbitControls = exports.FlyControls = exports.FirstPersonControls = exports.EditorControls = exports.DragControls = exports.DeviceOrientationControls = undefined;

var _DeviceOrientationControls = __webpack_require__(29);

var _DeviceOrientationControls2 = _interopRequireDefault(_DeviceOrientationControls);

var _DragControls = __webpack_require__(30);

var _DragControls2 = _interopRequireDefault(_DragControls);

var _EditorControls = __webpack_require__(31);

var _EditorControls2 = _interopRequireDefault(_EditorControls);

var _FirstPersonControls = __webpack_require__(32);

var _FirstPersonControls2 = _interopRequireDefault(_FirstPersonControls);

var _FlyControls = __webpack_require__(33);

var _FlyControls2 = _interopRequireDefault(_FlyControls);

var _OrbitControls = __webpack_require__(34);

var _OrbitControls2 = _interopRequireDefault(_OrbitControls);

var _OrthographicTrackballControls = __webpack_require__(35);

var _OrthographicTrackballControls2 = _interopRequireDefault(_OrthographicTrackballControls);

var _PointerLockControls = __webpack_require__(36);

var _PointerLockControls2 = _interopRequireDefault(_PointerLockControls);

var _TrackballControls = __webpack_require__(37);

var _TrackballControls2 = _interopRequireDefault(_TrackballControls);

var _TransformControls = __webpack_require__(38);

var _TransformControls2 = _interopRequireDefault(_TransformControls);

var _VRControls = __webpack_require__(39);

var _VRControls2 = _interopRequireDefault(_VRControls);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.DeviceOrientationControls = _DeviceOrientationControls2.default;
exports.DragControls = _DragControls2.default;
exports.EditorControls = _EditorControls2.default;
exports.FirstPersonControls = _FirstPersonControls2.default;
exports.FlyControls = _FlyControls2.default;
exports.OrbitControls = _OrbitControls2.default;
exports.OrthographicTrackballControls = _OrthographicTrackballControls2.default;
exports.PointerLockControls = _PointerLockControls2.default;
exports.TrackballControls = _TrackballControls2.default;
exports.TransformControls = _TransformControls2.default;
exports.VRControls = _VRControls2.default;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author richt / http://richt.me
 * @author WestLangley / http://github.com/WestLangley
 *
 * W3C Device Orientation control (http://w3c.github.io/deviceorientation/spec-source-orientation.html)
 */

var DeviceOrientationControls = function DeviceOrientationControls(object) {

	var scope = this;

	this.object = object;
	this.object.rotation.reorder('YXZ');

	this.enabled = true;

	this.deviceOrientation = {};
	this.screenOrientation = 0;

	this.alphaOffset = 0; // radians

	var onDeviceOrientationChangeEvent = function onDeviceOrientationChangeEvent(event) {

		scope.deviceOrientation = event;
	};

	var onScreenOrientationChangeEvent = function onScreenOrientationChangeEvent() {

		scope.screenOrientation = window.orientation || 0;
	};

	// The angles alpha, beta and gamma form a set of intrinsic Tait-Bryan angles of type Z-X'-Y''

	var setObjectQuaternion = function () {

		var zee = new THREE.Vector3(0, 0, 1);

		var euler = new THREE.Euler();

		var q0 = new THREE.Quaternion();

		var q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); // - PI/2 around the x-axis

		return function (quaternion, alpha, beta, gamma, orient) {

			euler.set(beta, alpha, -gamma, 'YXZ'); // 'ZXY' for the device, but 'YXZ' for us

			quaternion.setFromEuler(euler); // orient the device

			quaternion.multiply(q1); // camera looks out the back of the device, not the top

			quaternion.multiply(q0.setFromAxisAngle(zee, -orient)); // adjust for screen orientation
		};
	}();

	this.connect = function () {

		onScreenOrientationChangeEvent(); // run once on load

		window.addEventListener('orientationchange', onScreenOrientationChangeEvent, false);
		window.addEventListener('deviceorientation', onDeviceOrientationChangeEvent, false);

		scope.enabled = true;
	};

	this.disconnect = function () {

		window.removeEventListener('orientationchange', onScreenOrientationChangeEvent, false);
		window.removeEventListener('deviceorientation', onDeviceOrientationChangeEvent, false);

		scope.enabled = false;
	};

	this.update = function () {

		if (scope.enabled === false) return;

		var device = scope.deviceOrientation;

		if (device) {

			var alpha = device.alpha ? THREE.Math.degToRad(device.alpha) + scope.alphaOffset : 0; // Z

			var beta = device.beta ? THREE.Math.degToRad(device.beta) : 0; // X'

			var gamma = device.gamma ? THREE.Math.degToRad(device.gamma) : 0; // Y''

			var orient = scope.screenOrientation ? THREE.Math.degToRad(scope.screenOrientation) : 0; // O

			setObjectQuaternion(scope.object.quaternion, alpha, beta, gamma, orient);
		}
	};

	this.dispose = function () {

		scope.disconnect();
	};

	this.connect();
};

exports.default = DeviceOrientationControls;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @author zz85 / https://github.com/zz85
 * @author mrdoob / http://mrdoob.com
 * Running this will allow you to drag three.js objects around the screen.
 */

var DragControls = function DragControls(_objects, _camera, _domElement) {

	if (_objects instanceof THREE.Camera) {

		console.warn('THREE.DragControls: Constructor now expects ( objects, camera, domElement )');
		var temp = _objects;_objects = _camera;_camera = temp;
	}

	var _plane = new THREE.Plane();
	var _raycaster = new THREE.Raycaster();

	var _mouse = new THREE.Vector2();
	var _offset = new THREE.Vector3();
	var _intersection = new THREE.Vector3();

	var _selected = null,
	    _hovered = null;

	//

	var scope = this;

	function activate() {

		_domElement.addEventListener('mousemove', onDocumentMouseMove, false);
		_domElement.addEventListener('mousedown', onDocumentMouseDown, false);
		_domElement.addEventListener('mouseup', onDocumentMouseCancel, false);
		_domElement.addEventListener('mouseleave', onDocumentMouseCancel, false);
		_domElement.addEventListener('touchmove', onDocumentTouchMove, false);
		_domElement.addEventListener('touchstart', onDocumentTouchStart, false);
		_domElement.addEventListener('touchend', onDocumentTouchEnd, false);
	}

	function deactivate() {

		_domElement.removeEventListener('mousemove', onDocumentMouseMove, false);
		_domElement.removeEventListener('mousedown', onDocumentMouseDown, false);
		_domElement.removeEventListener('mouseup', onDocumentMouseCancel, false);
		_domElement.removeEventListener('mouseleave', onDocumentMouseCancel, false);
		_domElement.removeEventListener('touchmove', onDocumentTouchMove, false);
		_domElement.removeEventListener('touchstart', onDocumentTouchStart, false);
		_domElement.removeEventListener('touchend', onDocumentTouchEnd, false);
	}

	function dispose() {

		deactivate();
	}

	function onDocumentMouseMove(event) {

		event.preventDefault();

		var rect = _domElement.getBoundingClientRect();

		_mouse.x = (event.clientX - rect.left) / rect.width * 2 - 1;
		_mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

		_raycaster.setFromCamera(_mouse, _camera);

		if (_selected && scope.enabled) {

			if (_raycaster.ray.intersectPlane(_plane, _intersection)) {

				_selected.position.copy(_intersection.sub(_offset));
			}

			scope.dispatchEvent({ type: 'drag', object: _selected });

			return;
		}

		_raycaster.setFromCamera(_mouse, _camera);

		var intersects = _raycaster.intersectObjects(_objects);

		if (intersects.length > 0) {

			var object = intersects[0].object;

			_plane.setFromNormalAndCoplanarPoint(_camera.getWorldDirection(_plane.normal), object.position);

			if (_hovered !== object) {

				scope.dispatchEvent({ type: 'hoveron', object: object });

				_domElement.style.cursor = 'pointer';
				_hovered = object;
			}
		} else {

			if (_hovered !== null) {

				scope.dispatchEvent({ type: 'hoveroff', object: _hovered });

				_domElement.style.cursor = 'auto';
				_hovered = null;
			}
		}
	}

	function onDocumentMouseDown(event) {

		event.preventDefault();

		_raycaster.setFromCamera(_mouse, _camera);

		var intersects = _raycaster.intersectObjects(_objects);

		if (intersects.length > 0) {

			_selected = intersects[0].object;

			if (_raycaster.ray.intersectPlane(_plane, _intersection)) {

				_offset.copy(_intersection).sub(_selected.position);
			}

			_domElement.style.cursor = 'move';

			scope.dispatchEvent({ type: 'dragstart', object: _selected });
		}
	}

	function onDocumentMouseCancel(event) {

		event.preventDefault();

		if (_selected) {

			scope.dispatchEvent({ type: 'dragend', object: _selected });

			_selected = null;
		}

		_domElement.style.cursor = 'auto';
	}

	function onDocumentTouchMove(event) {

		event.preventDefault();
		event = event.changedTouches[0];

		var rect = _domElement.getBoundingClientRect();

		_mouse.x = (event.clientX - rect.left) / rect.width * 2 - 1;
		_mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

		_raycaster.setFromCamera(_mouse, _camera);

		if (_selected && scope.enabled) {

			if (_raycaster.ray.intersectPlane(_plane, _intersection)) {

				_selected.position.copy(_intersection.sub(_offset));
			}

			scope.dispatchEvent({ type: 'drag', object: _selected });

			return;
		}
	}

	function onDocumentTouchStart(event) {

		event.preventDefault();
		event = event.changedTouches[0];

		var rect = _domElement.getBoundingClientRect();

		_mouse.x = (event.clientX - rect.left) / rect.width * 2 - 1;
		_mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

		_raycaster.setFromCamera(_mouse, _camera);

		var intersects = _raycaster.intersectObjects(_objects);

		if (intersects.length > 0) {

			_selected = intersects[0].object;

			_plane.setFromNormalAndCoplanarPoint(_camera.getWorldDirection(_plane.normal), _selected.position);

			if (_raycaster.ray.intersectPlane(_plane, _intersection)) {

				_offset.copy(_intersection).sub(_selected.position);
			}

			_domElement.style.cursor = 'move';

			scope.dispatchEvent({ type: 'dragstart', object: _selected });
		}
	}

	function onDocumentTouchEnd(event) {

		event.preventDefault();

		if (_selected) {

			scope.dispatchEvent({ type: 'dragend', object: _selected });

			_selected = null;
		}

		_domElement.style.cursor = 'auto';
	}

	activate();

	// API

	this.enabled = true;

	this.activate = activate;
	this.deactivate = deactivate;
	this.dispose = dispose;

	// Backward compatibility

	this.setObjects = function () {

		console.error('THREE.DragControls: setObjects() has been removed.');
	};

	this.on = function (type, listener) {

		console.warn('THREE.DragControls: on() has been deprecated. Use addEventListener() instead.');
		scope.addEventListener(type, listener);
	};

	this.off = function (type, listener) {

		console.warn('THREE.DragControls: off() has been deprecated. Use removeEventListener() instead.');
		scope.removeEventListener(type, listener);
	};

	this.notify = function (type) {

		console.error('THREE.DragControls: notify() has been deprecated. Use dispatchEvent() instead.');
		scope.dispatchEvent({ type: type });
	};
};

DragControls.prototype = Object.create(THREE.EventDispatcher.prototype);
DragControls.prototype.constructor = DragControls;

exports.default = DragControls;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author qiao / https://github.com/qiao
 * @author mrdoob / http://mrdoob.com
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 */

var EditorControls = function EditorControls(object, domElement) {

	domElement = domElement !== undefined ? domElement : document;

	// API

	this.enabled = true;
	this.center = new THREE.Vector3();
	this.panSpeed = 0.001;
	this.zoomSpeed = 0.001;
	this.rotationSpeed = 0.005;

	// internals

	var scope = this;
	var vector = new THREE.Vector3();

	var STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2 };
	var state = STATE.NONE;

	var center = this.center;
	var normalMatrix = new THREE.Matrix3();
	var pointer = new THREE.Vector2();
	var pointerOld = new THREE.Vector2();
	var spherical = new THREE.Spherical();

	// events

	var changeEvent = { type: 'change' };

	this.focus = function (target) {

		var box = new THREE.Box3().setFromObject(target);

		var distance;

		if (box.isEmpty() === false) {

			center.copy(box.getCenter());
			distance = box.getBoundingSphere().radius;
		} else {

			// Focusing on an Group, AmbientLight, etc

			center.setFromMatrixPosition(target.matrixWorld);
			distance = 0.1;
		}

		var delta = new THREE.Vector3(0, 0, 1);
		delta.applyQuaternion(object.quaternion);
		delta.multiplyScalar(distance * 4);

		object.position.copy(center).add(delta);

		scope.dispatchEvent(changeEvent);
	};

	this.pan = function (delta) {

		var distance = object.position.distanceTo(center);

		delta.multiplyScalar(distance * scope.panSpeed);
		delta.applyMatrix3(normalMatrix.getNormalMatrix(object.matrix));

		object.position.add(delta);
		center.add(delta);

		scope.dispatchEvent(changeEvent);
	};

	this.zoom = function (delta) {

		var distance = object.position.distanceTo(center);

		delta.multiplyScalar(distance * scope.zoomSpeed);

		if (delta.length() > distance) return;

		delta.applyMatrix3(normalMatrix.getNormalMatrix(object.matrix));

		object.position.add(delta);

		scope.dispatchEvent(changeEvent);
	};

	this.rotate = function (delta) {

		vector.copy(object.position).sub(center);

		spherical.setFromVector3(vector);

		spherical.theta += delta.x;
		spherical.phi += delta.y;

		spherical.makeSafe();

		vector.setFromSpherical(spherical);

		object.position.copy(center).add(vector);

		object.lookAt(center);

		scope.dispatchEvent(changeEvent);
	};

	// mouse

	function onMouseDown(event) {

		if (scope.enabled === false) return;

		if (event.button === 0) {

			state = STATE.ROTATE;
		} else if (event.button === 1) {

			state = STATE.ZOOM;
		} else if (event.button === 2) {

			state = STATE.PAN;
		}

		pointerOld.set(event.clientX, event.clientY);

		domElement.addEventListener('mousemove', onMouseMove, false);
		domElement.addEventListener('mouseup', onMouseUp, false);
		domElement.addEventListener('mouseout', onMouseUp, false);
		domElement.addEventListener('dblclick', onMouseUp, false);
	}

	function onMouseMove(event) {

		if (scope.enabled === false) return;

		pointer.set(event.clientX, event.clientY);

		var movementX = pointer.x - pointerOld.x;
		var movementY = pointer.y - pointerOld.y;

		if (state === STATE.ROTATE) {

			scope.rotate(new THREE.Vector3(-movementX * scope.rotationSpeed, -movementY * scope.rotationSpeed, 0));
		} else if (state === STATE.ZOOM) {

			scope.zoom(new THREE.Vector3(0, 0, movementY));
		} else if (state === STATE.PAN) {

			scope.pan(new THREE.Vector3(-movementX, movementY, 0));
		}

		pointerOld.set(event.clientX, event.clientY);
	}

	function onMouseUp(event) {

		domElement.removeEventListener('mousemove', onMouseMove, false);
		domElement.removeEventListener('mouseup', onMouseUp, false);
		domElement.removeEventListener('mouseout', onMouseUp, false);
		domElement.removeEventListener('dblclick', onMouseUp, false);

		state = STATE.NONE;
	}

	function onMouseWheel(event) {

		event.preventDefault();

		// if ( scope.enabled === false ) return;

		scope.zoom(new THREE.Vector3(0, 0, event.deltaY));
	}

	function contextmenu(event) {

		event.preventDefault();
	}

	this.dispose = function () {

		domElement.removeEventListener('contextmenu', contextmenu, false);
		domElement.removeEventListener('mousedown', onMouseDown, false);
		domElement.removeEventListener('wheel', onMouseWheel, false);

		domElement.removeEventListener('mousemove', onMouseMove, false);
		domElement.removeEventListener('mouseup', onMouseUp, false);
		domElement.removeEventListener('mouseout', onMouseUp, false);
		domElement.removeEventListener('dblclick', onMouseUp, false);

		domElement.removeEventListener('touchstart', touchStart, false);
		domElement.removeEventListener('touchmove', touchMove, false);
	};

	domElement.addEventListener('contextmenu', contextmenu, false);
	domElement.addEventListener('mousedown', onMouseDown, false);
	domElement.addEventListener('wheel', onMouseWheel, false);

	// touch

	var touches = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];
	var prevTouches = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];

	var prevDistance = null;

	function touchStart(event) {

		if (scope.enabled === false) return;

		switch (event.touches.length) {

			case 1:
				touches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0);
				touches[1].set(event.touches[0].pageX, event.touches[0].pageY, 0);
				break;

			case 2:
				touches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0);
				touches[1].set(event.touches[1].pageX, event.touches[1].pageY, 0);
				prevDistance = touches[0].distanceTo(touches[1]);
				break;

		}

		prevTouches[0].copy(touches[0]);
		prevTouches[1].copy(touches[1]);
	}

	function touchMove(event) {

		if (scope.enabled === false) return;

		event.preventDefault();
		event.stopPropagation();

		function getClosest(touch, touches) {

			var closest = touches[0];

			for (var i in touches) {

				if (closest.distanceTo(touch) > touches[i].distanceTo(touch)) closest = touches[i];
			}

			return closest;
		}

		switch (event.touches.length) {

			case 1:
				touches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0);
				touches[1].set(event.touches[0].pageX, event.touches[0].pageY, 0);
				scope.rotate(touches[0].sub(getClosest(touches[0], prevTouches)).multiplyScalar(-scope.rotationSpeed));
				break;

			case 2:
				touches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0);
				touches[1].set(event.touches[1].pageX, event.touches[1].pageY, 0);
				var distance = touches[0].distanceTo(touches[1]);
				scope.zoom(new THREE.Vector3(0, 0, prevDistance - distance));
				prevDistance = distance;

				var offset0 = touches[0].clone().sub(getClosest(touches[0], prevTouches));
				var offset1 = touches[1].clone().sub(getClosest(touches[1], prevTouches));
				offset0.x = -offset0.x;
				offset1.x = -offset1.x;

				scope.pan(offset0.add(offset1).multiplyScalar(0.5));

				break;

		}

		prevTouches[0].copy(touches[0]);
		prevTouches[1].copy(touches[1]);
	}

	domElement.addEventListener('touchstart', touchStart, false);
	domElement.addEventListener('touchmove', touchMove, false);
};

EditorControls.prototype = Object.create(THREE.EventDispatcher.prototype);
EditorControls.prototype.constructor = EditorControls;

exports.default = EditorControls;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author paulirish / http://paulirish.com/
 */

var FirstPersonControls = function FirstPersonControls(object, domElement) {

	this.object = object;
	this.target = new THREE.Vector3(0, 0, 0);

	this.domElement = domElement !== undefined ? domElement : document;

	this.enabled = true;

	this.movementSpeed = 1.0;
	this.lookSpeed = 0.005;

	this.lookVertical = true;
	this.autoForward = false;

	this.activeLook = true;

	this.heightSpeed = false;
	this.heightCoef = 1.0;
	this.heightMin = 0.0;
	this.heightMax = 1.0;

	this.constrainVertical = false;
	this.verticalMin = 0;
	this.verticalMax = Math.PI;

	this.autoSpeedFactor = 0.0;

	this.mouseX = 0;
	this.mouseY = 0;

	this.lat = 0;
	this.lon = 0;
	this.phi = 0;
	this.theta = 0;

	this.moveForward = false;
	this.moveBackward = false;
	this.moveLeft = false;
	this.moveRight = false;

	this.mouseDragOn = false;

	this.viewHalfX = 0;
	this.viewHalfY = 0;

	if (this.domElement !== document) {

		this.domElement.setAttribute('tabindex', -1);
	}

	//

	this.handleResize = function () {

		if (this.domElement === document) {

			this.viewHalfX = window.innerWidth / 2;
			this.viewHalfY = window.innerHeight / 2;
		} else {

			this.viewHalfX = this.domElement.offsetWidth / 2;
			this.viewHalfY = this.domElement.offsetHeight / 2;
		}
	};

	this.onMouseDown = function (event) {

		if (this.domElement !== document) {

			this.domElement.focus();
		}

		event.preventDefault();
		event.stopPropagation();

		if (this.activeLook) {

			switch (event.button) {

				case 0:
					this.moveForward = true;break;
				case 2:
					this.moveBackward = true;break;

			}
		}

		this.mouseDragOn = true;
	};

	this.onMouseUp = function (event) {

		event.preventDefault();
		event.stopPropagation();

		if (this.activeLook) {

			switch (event.button) {

				case 0:
					this.moveForward = false;break;
				case 2:
					this.moveBackward = false;break;

			}
		}

		this.mouseDragOn = false;
	};

	this.onMouseMove = function (event) {

		if (this.domElement === document) {

			this.mouseX = event.pageX - this.viewHalfX;
			this.mouseY = event.pageY - this.viewHalfY;
		} else {

			this.mouseX = event.pageX - this.domElement.offsetLeft - this.viewHalfX;
			this.mouseY = event.pageY - this.domElement.offsetTop - this.viewHalfY;
		}
	};

	this.onKeyDown = function (event) {

		//event.preventDefault();

		switch (event.keyCode) {

			case 38: /*up*/
			case 87:
				/*W*/this.moveForward = true;break;

			case 37: /*left*/
			case 65:
				/*A*/this.moveLeft = true;break;

			case 40: /*down*/
			case 83:
				/*S*/this.moveBackward = true;break;

			case 39: /*right*/
			case 68:
				/*D*/this.moveRight = true;break;

			case 82:
				/*R*/this.moveUp = true;break;
			case 70:
				/*F*/this.moveDown = true;break;

		}
	};

	this.onKeyUp = function (event) {

		switch (event.keyCode) {

			case 38: /*up*/
			case 87:
				/*W*/this.moveForward = false;break;

			case 37: /*left*/
			case 65:
				/*A*/this.moveLeft = false;break;

			case 40: /*down*/
			case 83:
				/*S*/this.moveBackward = false;break;

			case 39: /*right*/
			case 68:
				/*D*/this.moveRight = false;break;

			case 82:
				/*R*/this.moveUp = false;break;
			case 70:
				/*F*/this.moveDown = false;break;

		}
	};

	this.update = function (delta) {

		if (this.enabled === false) return;

		if (this.heightSpeed) {

			var y = THREE.Math.clamp(this.object.position.y, this.heightMin, this.heightMax);
			var heightDelta = y - this.heightMin;

			this.autoSpeedFactor = delta * (heightDelta * this.heightCoef);
		} else {

			this.autoSpeedFactor = 0.0;
		}

		var actualMoveSpeed = delta * this.movementSpeed;

		if (this.moveForward || this.autoForward && !this.moveBackward) this.object.translateZ(-(actualMoveSpeed + this.autoSpeedFactor));
		if (this.moveBackward) this.object.translateZ(actualMoveSpeed);

		if (this.moveLeft) this.object.translateX(-actualMoveSpeed);
		if (this.moveRight) this.object.translateX(actualMoveSpeed);

		if (this.moveUp) this.object.translateY(actualMoveSpeed);
		if (this.moveDown) this.object.translateY(-actualMoveSpeed);

		var actualLookSpeed = delta * this.lookSpeed;

		if (!this.activeLook) {

			actualLookSpeed = 0;
		}

		var verticalLookRatio = 1;

		if (this.constrainVertical) {

			verticalLookRatio = Math.PI / (this.verticalMax - this.verticalMin);
		}

		this.lon += this.mouseX * actualLookSpeed;
		if (this.lookVertical) this.lat -= this.mouseY * actualLookSpeed * verticalLookRatio;

		this.lat = Math.max(-85, Math.min(85, this.lat));
		this.phi = THREE.Math.degToRad(90 - this.lat);

		this.theta = THREE.Math.degToRad(this.lon);

		if (this.constrainVertical) {

			this.phi = THREE.Math.mapLinear(this.phi, 0, Math.PI, this.verticalMin, this.verticalMax);
		}

		var targetPosition = this.target,
		    position = this.object.position;

		targetPosition.x = position.x + 100 * Math.sin(this.phi) * Math.cos(this.theta);
		targetPosition.y = position.y + 100 * Math.cos(this.phi);
		targetPosition.z = position.z + 100 * Math.sin(this.phi) * Math.sin(this.theta);

		this.object.lookAt(targetPosition);
	};

	function contextmenu(event) {

		event.preventDefault();
	}

	this.dispose = function () {

		this.domElement.removeEventListener('contextmenu', contextmenu, false);
		this.domElement.removeEventListener('mousedown', _onMouseDown, false);
		this.domElement.removeEventListener('mousemove', _onMouseMove, false);
		this.domElement.removeEventListener('mouseup', _onMouseUp, false);

		window.removeEventListener('keydown', _onKeyDown, false);
		window.removeEventListener('keyup', _onKeyUp, false);
	};

	var _onMouseMove = bind(this, this.onMouseMove);
	var _onMouseDown = bind(this, this.onMouseDown);
	var _onMouseUp = bind(this, this.onMouseUp);
	var _onKeyDown = bind(this, this.onKeyDown);
	var _onKeyUp = bind(this, this.onKeyUp);

	this.domElement.addEventListener('contextmenu', contextmenu, false);
	this.domElement.addEventListener('mousemove', _onMouseMove, false);
	this.domElement.addEventListener('mousedown', _onMouseDown, false);
	this.domElement.addEventListener('mouseup', _onMouseUp, false);

	window.addEventListener('keydown', _onKeyDown, false);
	window.addEventListener('keyup', _onKeyUp, false);

	function bind(scope, fn) {

		return function () {

			fn.apply(scope, arguments);
		};
	}

	this.handleResize();
};

exports.default = FirstPersonControls;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author James Baicoianu / http://www.baicoianu.com/
 */

var FlyControls = function FlyControls(object, domElement) {

	this.object = object;

	this.domElement = domElement !== undefined ? domElement : document;
	if (domElement) this.domElement.setAttribute('tabindex', -1);

	// API

	this.movementSpeed = 1.0;
	this.rollSpeed = 0.005;

	this.dragToLook = false;
	this.autoForward = false;

	// disable default target object behavior

	// internals

	this.tmpQuaternion = new THREE.Quaternion();

	this.mouseStatus = 0;

	this.moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 };
	this.moveVector = new THREE.Vector3(0, 0, 0);
	this.rotationVector = new THREE.Vector3(0, 0, 0);

	this.handleEvent = function (event) {

		if (typeof this[event.type] == 'function') {

			this[event.type](event);
		}
	};

	this.keydown = function (event) {

		if (event.altKey) {

			return;
		}

		//event.preventDefault();

		switch (event.keyCode) {

			case 16:
				/* shift */this.movementSpeedMultiplier = .1;break;

			case 87:
				/*W*/this.moveState.forward = 1;break;
			case 83:
				/*S*/this.moveState.back = 1;break;

			case 65:
				/*A*/this.moveState.left = 1;break;
			case 68:
				/*D*/this.moveState.right = 1;break;

			case 82:
				/*R*/this.moveState.up = 1;break;
			case 70:
				/*F*/this.moveState.down = 1;break;

			case 38:
				/*up*/this.moveState.pitchUp = 1;break;
			case 40:
				/*down*/this.moveState.pitchDown = 1;break;

			case 37:
				/*left*/this.moveState.yawLeft = 1;break;
			case 39:
				/*right*/this.moveState.yawRight = 1;break;

			case 81:
				/*Q*/this.moveState.rollLeft = 1;break;
			case 69:
				/*E*/this.moveState.rollRight = 1;break;

		}

		this.updateMovementVector();
		this.updateRotationVector();
	};

	this.keyup = function (event) {

		switch (event.keyCode) {

			case 16:
				/* shift */this.movementSpeedMultiplier = 1;break;

			case 87:
				/*W*/this.moveState.forward = 0;break;
			case 83:
				/*S*/this.moveState.back = 0;break;

			case 65:
				/*A*/this.moveState.left = 0;break;
			case 68:
				/*D*/this.moveState.right = 0;break;

			case 82:
				/*R*/this.moveState.up = 0;break;
			case 70:
				/*F*/this.moveState.down = 0;break;

			case 38:
				/*up*/this.moveState.pitchUp = 0;break;
			case 40:
				/*down*/this.moveState.pitchDown = 0;break;

			case 37:
				/*left*/this.moveState.yawLeft = 0;break;
			case 39:
				/*right*/this.moveState.yawRight = 0;break;

			case 81:
				/*Q*/this.moveState.rollLeft = 0;break;
			case 69:
				/*E*/this.moveState.rollRight = 0;break;

		}

		this.updateMovementVector();
		this.updateRotationVector();
	};

	this.mousedown = function (event) {

		if (this.domElement !== document) {

			this.domElement.focus();
		}

		event.preventDefault();
		event.stopPropagation();

		if (this.dragToLook) {

			this.mouseStatus++;
		} else {

			switch (event.button) {

				case 0:
					this.moveState.forward = 1;break;
				case 2:
					this.moveState.back = 1;break;

			}

			this.updateMovementVector();
		}
	};

	this.mousemove = function (event) {

		if (!this.dragToLook || this.mouseStatus > 0) {

			var container = this.getContainerDimensions();
			var halfWidth = container.size[0] / 2;
			var halfHeight = container.size[1] / 2;

			this.moveState.yawLeft = -(event.pageX - container.offset[0] - halfWidth) / halfWidth;
			this.moveState.pitchDown = (event.pageY - container.offset[1] - halfHeight) / halfHeight;

			this.updateRotationVector();
		}
	};

	this.mouseup = function (event) {

		event.preventDefault();
		event.stopPropagation();

		if (this.dragToLook) {

			this.mouseStatus--;

			this.moveState.yawLeft = this.moveState.pitchDown = 0;
		} else {

			switch (event.button) {

				case 0:
					this.moveState.forward = 0;break;
				case 2:
					this.moveState.back = 0;break;

			}

			this.updateMovementVector();
		}

		this.updateRotationVector();
	};

	this.update = function (delta) {

		var moveMult = delta * this.movementSpeed;
		var rotMult = delta * this.rollSpeed;

		this.object.translateX(this.moveVector.x * moveMult);
		this.object.translateY(this.moveVector.y * moveMult);
		this.object.translateZ(this.moveVector.z * moveMult);

		this.tmpQuaternion.set(this.rotationVector.x * rotMult, this.rotationVector.y * rotMult, this.rotationVector.z * rotMult, 1).normalize();
		this.object.quaternion.multiply(this.tmpQuaternion);

		// expose the rotation vector for convenience
		this.object.rotation.setFromQuaternion(this.object.quaternion, this.object.rotation.order);
	};

	this.updateMovementVector = function () {

		var forward = this.moveState.forward || this.autoForward && !this.moveState.back ? 1 : 0;

		this.moveVector.x = -this.moveState.left + this.moveState.right;
		this.moveVector.y = -this.moveState.down + this.moveState.up;
		this.moveVector.z = -forward + this.moveState.back;

		//console.log( 'move:', [ this.moveVector.x, this.moveVector.y, this.moveVector.z ] );
	};

	this.updateRotationVector = function () {

		this.rotationVector.x = -this.moveState.pitchDown + this.moveState.pitchUp;
		this.rotationVector.y = -this.moveState.yawRight + this.moveState.yawLeft;
		this.rotationVector.z = -this.moveState.rollRight + this.moveState.rollLeft;

		//console.log( 'rotate:', [ this.rotationVector.x, this.rotationVector.y, this.rotationVector.z ] );
	};

	this.getContainerDimensions = function () {

		if (this.domElement != document) {

			return {
				size: [this.domElement.offsetWidth, this.domElement.offsetHeight],
				offset: [this.domElement.offsetLeft, this.domElement.offsetTop]
			};
		} else {

			return {
				size: [window.innerWidth, window.innerHeight],
				offset: [0, 0]
			};
		}
	};

	function bind(scope, fn) {

		return function () {

			fn.apply(scope, arguments);
		};
	}

	function contextmenu(event) {

		event.preventDefault();
	}

	this.dispose = function () {

		this.domElement.removeEventListener('contextmenu', contextmenu, false);
		this.domElement.removeEventListener('mousedown', _mousedown, false);
		this.domElement.removeEventListener('mousemove', _mousemove, false);
		this.domElement.removeEventListener('mouseup', _mouseup, false);

		window.removeEventListener('keydown', _keydown, false);
		window.removeEventListener('keyup', _keyup, false);
	};

	var _mousemove = bind(this, this.mousemove);
	var _mousedown = bind(this, this.mousedown);
	var _mouseup = bind(this, this.mouseup);
	var _keydown = bind(this, this.keydown);
	var _keyup = bind(this, this.keyup);

	this.domElement.addEventListener('contextmenu', contextmenu, false);

	this.domElement.addEventListener('mousemove', _mousemove, false);
	this.domElement.addEventListener('mousedown', _mousedown, false);
	this.domElement.addEventListener('mouseup', _mouseup, false);

	window.addEventListener('keydown', _keydown, false);
	window.addEventListener('keyup', _keyup, false);

	this.updateMovementVector();
	this.updateRotationVector();
};

exports.default = FlyControls;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author qiao / https://github.com/qiao
 * @author mrdoob / http://mrdoob.com
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author erich666 / http://erichaines.com
 */

// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or arrow keys / touch: two-finger move

var OrbitControls = function OrbitControls(object, domElement) {

	this.object = object;

	this.domElement = domElement !== undefined ? domElement : document;

	// Set to false to disable this control
	this.enabled = true;

	// "target" sets the location of focus, where the object orbits around
	this.target = new THREE.Vector3();

	// How far you can dolly in and out ( PerspectiveCamera only )
	this.minDistance = 0;
	this.maxDistance = Infinity;

	// How far you can zoom in and out ( OrthographicCamera only )
	this.minZoom = 0;
	this.maxZoom = Infinity;

	// How far you can orbit vertically, upper and lower limits.
	// Range is 0 to Math.PI radians.
	this.minPolarAngle = 0; // radians
	this.maxPolarAngle = Math.PI; // radians

	// How far you can orbit horizontally, upper and lower limits.
	// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
	this.minAzimuthAngle = -Infinity; // radians
	this.maxAzimuthAngle = Infinity; // radians

	// Set to true to enable damping (inertia)
	// If damping is enabled, you must call controls.update() in your animation loop
	this.enableDamping = false;
	this.dampingFactor = 0.25;

	// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
	// Set to false to disable zooming
	this.enableZoom = true;
	this.zoomSpeed = 1.0;

	// Set to false to disable rotating
	this.enableRotate = true;
	this.rotateSpeed = 1.0;

	// Set to false to disable panning
	this.enablePan = true;
	this.panSpeed = 1.0;
	this.screenSpacePanning = false; // if true, pan in screen-space
	this.keyPanSpeed = 7.0; // pixels moved per arrow key push

	// Set to true to automatically rotate around the target
	// If auto-rotate is enabled, you must call controls.update() in your animation loop
	this.autoRotate = false;
	this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

	// Set to false to disable use of the keys
	this.enableKeys = true;

	// The four arrow keys
	this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

	// Mouse buttons
	this.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };

	// for reset
	this.target0 = this.target.clone();
	this.position0 = this.object.position.clone();
	this.zoom0 = this.object.zoom;

	//
	// public methods
	//

	this.getPolarAngle = function () {

		return spherical.phi;
	};

	this.getAzimuthalAngle = function () {

		return spherical.theta;
	};

	this.saveState = function () {

		scope.target0.copy(scope.target);
		scope.position0.copy(scope.object.position);
		scope.zoom0 = scope.object.zoom;
	};

	this.reset = function () {

		scope.target.copy(scope.target0);
		scope.object.position.copy(scope.position0);
		scope.object.zoom = scope.zoom0;

		scope.object.updateProjectionMatrix();
		scope.dispatchEvent(changeEvent);

		scope.update();

		state = STATE.NONE;
	};

	// this method is exposed, but perhaps it would be better if we can make it private...
	this.update = function () {

		var offset = new THREE.Vector3();

		// so camera.up is the orbit axis
		var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));
		var quatInverse = quat.clone().inverse();

		var lastPosition = new THREE.Vector3();
		var lastQuaternion = new THREE.Quaternion();

		return function update() {

			var position = scope.object.position;

			offset.copy(position).sub(scope.target);

			// rotate offset to "y-axis-is-up" space
			offset.applyQuaternion(quat);

			// angle from z-axis around y-axis
			spherical.setFromVector3(offset);

			if (scope.autoRotate && state === STATE.NONE) {

				rotateLeft(getAutoRotationAngle());
			}

			spherical.theta += sphericalDelta.theta;
			spherical.phi += sphericalDelta.phi;

			// restrict theta to be between desired limits
			spherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta));

			// restrict phi to be between desired limits
			spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));

			spherical.makeSafe();

			spherical.radius *= scale;

			// restrict radius to be between desired limits
			spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));

			// move target to panned location
			scope.target.add(panOffset);

			offset.setFromSpherical(spherical);

			// rotate offset back to "camera-up-vector-is-up" space
			offset.applyQuaternion(quatInverse);

			position.copy(scope.target).add(offset);

			scope.object.lookAt(scope.target);

			if (scope.enableDamping === true) {

				sphericalDelta.theta *= 1 - scope.dampingFactor;
				sphericalDelta.phi *= 1 - scope.dampingFactor;

				panOffset.multiplyScalar(1 - scope.dampingFactor);
			} else {

				sphericalDelta.set(0, 0, 0);

				panOffset.set(0, 0, 0);
			}

			scale = 1;

			// update condition is:
			// min(camera displacement, camera rotation in radians)^2 > EPS
			// using small-angle approximation cos(x/2) = 1 - x^2 / 8

			if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {

				scope.dispatchEvent(changeEvent);

				lastPosition.copy(scope.object.position);
				lastQuaternion.copy(scope.object.quaternion);
				zoomChanged = false;

				return true;
			}

			return false;
		};
	}();

	this.dispose = function () {

		scope.domElement.removeEventListener('contextmenu', onContextMenu, false);
		scope.domElement.removeEventListener('mousedown', onMouseDown, false);
		scope.domElement.removeEventListener('wheel', onMouseWheel, false);

		scope.domElement.removeEventListener('touchstart', onTouchStart, false);
		scope.domElement.removeEventListener('touchend', onTouchEnd, false);
		scope.domElement.removeEventListener('touchmove', onTouchMove, false);

		document.removeEventListener('mousemove', onMouseMove, false);
		document.removeEventListener('mouseup', onMouseUp, false);

		window.removeEventListener('keydown', onKeyDown, false);

		//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?
	};

	//
	// internals
	//

	var scope = this;

	var changeEvent = { type: 'change' };
	var startEvent = { type: 'start' };
	var endEvent = { type: 'end' };

	var STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY_PAN: 4 };

	var state = STATE.NONE;

	var EPS = 0.000001;

	// current position in spherical coordinates
	var spherical = new THREE.Spherical();
	var sphericalDelta = new THREE.Spherical();

	var scale = 1;
	var panOffset = new THREE.Vector3();
	var zoomChanged = false;

	var rotateStart = new THREE.Vector2();
	var rotateEnd = new THREE.Vector2();
	var rotateDelta = new THREE.Vector2();

	var panStart = new THREE.Vector2();
	var panEnd = new THREE.Vector2();
	var panDelta = new THREE.Vector2();

	var dollyStart = new THREE.Vector2();
	var dollyEnd = new THREE.Vector2();
	var dollyDelta = new THREE.Vector2();

	function getAutoRotationAngle() {

		return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
	}

	function getZoomScale() {

		return Math.pow(0.95, scope.zoomSpeed);
	}

	function rotateLeft(angle) {

		sphericalDelta.theta -= angle;
	}

	function rotateUp(angle) {

		sphericalDelta.phi -= angle;
	}

	var panLeft = function () {

		var v = new THREE.Vector3();

		return function panLeft(distance, objectMatrix) {

			v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix
			v.multiplyScalar(-distance);

			panOffset.add(v);
		};
	}();

	var panUp = function () {

		var v = new THREE.Vector3();

		return function panUp(distance, objectMatrix) {

			if (scope.screenSpacePanning === true) {

				v.setFromMatrixColumn(objectMatrix, 1);
			} else {

				v.setFromMatrixColumn(objectMatrix, 0);
				v.crossVectors(scope.object.up, v);
			}

			v.multiplyScalar(distance);

			panOffset.add(v);
		};
	}();

	// deltaX and deltaY are in pixels; right and down are positive
	var pan = function () {

		var offset = new THREE.Vector3();

		return function pan(deltaX, deltaY) {

			var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

			if (scope.object.isPerspectiveCamera) {

				// perspective
				var position = scope.object.position;
				offset.copy(position).sub(scope.target);
				var targetDistance = offset.length();

				// half of the fov is center to top of screen
				targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0);

				// we use only clientHeight here so aspect ratio does not distort speed
				panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
				panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
			} else if (scope.object.isOrthographicCamera) {

				// orthographic
				panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
				panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
			} else {

				// camera neither orthographic nor perspective
				console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
				scope.enablePan = false;
			}
		};
	}();

	function dollyIn(dollyScale) {

		if (scope.object.isPerspectiveCamera) {

			scale /= dollyScale;
		} else if (scope.object.isOrthographicCamera) {

			scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
			scope.object.updateProjectionMatrix();
			zoomChanged = true;
		} else {

			console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
			scope.enableZoom = false;
		}
	}

	function dollyOut(dollyScale) {

		if (scope.object.isPerspectiveCamera) {

			scale *= dollyScale;
		} else if (scope.object.isOrthographicCamera) {

			scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
			scope.object.updateProjectionMatrix();
			zoomChanged = true;
		} else {

			console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
			scope.enableZoom = false;
		}
	}

	//
	// event callbacks - update the object state
	//

	function handleMouseDownRotate(event) {

		//console.log( 'handleMouseDownRotate' );

		rotateStart.set(event.clientX, event.clientY);
	}

	function handleMouseDownDolly(event) {

		//console.log( 'handleMouseDownDolly' );

		dollyStart.set(event.clientX, event.clientY);
	}

	function handleMouseDownPan(event) {

		//console.log( 'handleMouseDownPan' );

		panStart.set(event.clientX, event.clientY);
	}

	function handleMouseMoveRotate(event) {

		//console.log( 'handleMouseMoveRotate' );

		rotateEnd.set(event.clientX, event.clientY);

		rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);

		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

		rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height

		rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);

		rotateStart.copy(rotateEnd);

		scope.update();
	}

	function handleMouseMoveDolly(event) {

		//console.log( 'handleMouseMoveDolly' );

		dollyEnd.set(event.clientX, event.clientY);

		dollyDelta.subVectors(dollyEnd, dollyStart);

		if (dollyDelta.y > 0) {

			dollyIn(getZoomScale());
		} else if (dollyDelta.y < 0) {

			dollyOut(getZoomScale());
		}

		dollyStart.copy(dollyEnd);

		scope.update();
	}

	function handleMouseMovePan(event) {

		//console.log( 'handleMouseMovePan' );

		panEnd.set(event.clientX, event.clientY);

		panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);

		pan(panDelta.x, panDelta.y);

		panStart.copy(panEnd);

		scope.update();
	}

	function handleMouseUp(event) {

		// console.log( 'handleMouseUp' );

	}

	function handleMouseWheel(event) {

		// console.log( 'handleMouseWheel' );

		if (event.deltaY < 0) {

			dollyOut(getZoomScale());
		} else if (event.deltaY > 0) {

			dollyIn(getZoomScale());
		}

		scope.update();
	}

	function handleKeyDown(event) {

		//console.log( 'handleKeyDown' );

		switch (event.keyCode) {

			case scope.keys.UP:
				pan(0, scope.keyPanSpeed);
				scope.update();
				break;

			case scope.keys.BOTTOM:
				pan(0, -scope.keyPanSpeed);
				scope.update();
				break;

			case scope.keys.LEFT:
				pan(scope.keyPanSpeed, 0);
				scope.update();
				break;

			case scope.keys.RIGHT:
				pan(-scope.keyPanSpeed, 0);
				scope.update();
				break;

		}
	}

	function handleTouchStartRotate(event) {

		//console.log( 'handleTouchStartRotate' );

		rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
	}

	function handleTouchStartDollyPan(event) {

		//console.log( 'handleTouchStartDollyPan' );

		if (scope.enableZoom) {

			var dx = event.touches[0].pageX - event.touches[1].pageX;
			var dy = event.touches[0].pageY - event.touches[1].pageY;

			var distance = Math.sqrt(dx * dx + dy * dy);

			dollyStart.set(0, distance);
		}

		if (scope.enablePan) {

			var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
			var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);

			panStart.set(x, y);
		}
	}

	function handleTouchMoveRotate(event) {

		//console.log( 'handleTouchMoveRotate' );

		rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);

		rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);

		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

		rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height

		rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);

		rotateStart.copy(rotateEnd);

		scope.update();
	}

	function handleTouchMoveDollyPan(event) {

		//console.log( 'handleTouchMoveDollyPan' );

		if (scope.enableZoom) {

			var dx = event.touches[0].pageX - event.touches[1].pageX;
			var dy = event.touches[0].pageY - event.touches[1].pageY;

			var distance = Math.sqrt(dx * dx + dy * dy);

			dollyEnd.set(0, distance);

			dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));

			dollyIn(dollyDelta.y);

			dollyStart.copy(dollyEnd);
		}

		if (scope.enablePan) {

			var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
			var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);

			panEnd.set(x, y);

			panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);

			pan(panDelta.x, panDelta.y);

			panStart.copy(panEnd);
		}

		scope.update();
	}

	function handleTouchEnd(event) {}

	//console.log( 'handleTouchEnd' );

	//
	// event handlers - FSM: listen for events and reset state
	//

	function onMouseDown(event) {

		if (scope.enabled === false) return;

		event.preventDefault();

		switch (event.button) {

			case scope.mouseButtons.ORBIT:

				if (scope.enableRotate === false) return;

				handleMouseDownRotate(event);

				state = STATE.ROTATE;

				break;

			case scope.mouseButtons.ZOOM:

				if (scope.enableZoom === false) return;

				handleMouseDownDolly(event);

				state = STATE.DOLLY;

				break;

			case scope.mouseButtons.PAN:

				if (scope.enablePan === false) return;

				handleMouseDownPan(event);

				state = STATE.PAN;

				break;

		}

		if (state !== STATE.NONE) {

			document.addEventListener('mousemove', onMouseMove, false);
			document.addEventListener('mouseup', onMouseUp, false);

			scope.dispatchEvent(startEvent);
		}
	}

	function onMouseMove(event) {

		if (scope.enabled === false) return;

		event.preventDefault();

		switch (state) {

			case STATE.ROTATE:

				if (scope.enableRotate === false) return;

				handleMouseMoveRotate(event);

				break;

			case STATE.DOLLY:

				if (scope.enableZoom === false) return;

				handleMouseMoveDolly(event);

				break;

			case STATE.PAN:

				if (scope.enablePan === false) return;

				handleMouseMovePan(event);

				break;

		}
	}

	function onMouseUp(event) {

		if (scope.enabled === false) return;

		handleMouseUp(event);

		document.removeEventListener('mousemove', onMouseMove, false);
		document.removeEventListener('mouseup', onMouseUp, false);

		scope.dispatchEvent(endEvent);

		state = STATE.NONE;
	}

	function onMouseWheel(event) {

		if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) return;

		event.preventDefault();
		event.stopPropagation();

		scope.dispatchEvent(startEvent);

		handleMouseWheel(event);

		scope.dispatchEvent(endEvent);
	}

	function onKeyDown(event) {

		if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;

		handleKeyDown(event);
	}

	function onTouchStart(event) {

		if (scope.enabled === false) return;

		event.preventDefault();

		switch (event.touches.length) {

			case 1:
				// one-fingered touch: rotate

				if (scope.enableRotate === false) return;

				handleTouchStartRotate(event);

				state = STATE.TOUCH_ROTATE;

				break;

			case 2:
				// two-fingered touch: dolly-pan

				if (scope.enableZoom === false && scope.enablePan === false) return;

				handleTouchStartDollyPan(event);

				state = STATE.TOUCH_DOLLY_PAN;

				break;

			default:

				state = STATE.NONE;

		}

		if (state !== STATE.NONE) {

			scope.dispatchEvent(startEvent);
		}
	}

	function onTouchMove(event) {

		if (scope.enabled === false) return;

		event.preventDefault();
		event.stopPropagation();

		switch (event.touches.length) {

			case 1:
				// one-fingered touch: rotate

				if (scope.enableRotate === false) return;
				if (state !== STATE.TOUCH_ROTATE) return; // is this needed?

				handleTouchMoveRotate(event);

				break;

			case 2:
				// two-fingered touch: dolly-pan

				if (scope.enableZoom === false && scope.enablePan === false) return;
				if (state !== STATE.TOUCH_DOLLY_PAN) return; // is this needed?

				handleTouchMoveDollyPan(event);

				break;

			default:

				state = STATE.NONE;

		}
	}

	function onTouchEnd(event) {

		if (scope.enabled === false) return;

		handleTouchEnd(event);

		scope.dispatchEvent(endEvent);

		state = STATE.NONE;
	}

	function onContextMenu(event) {

		if (scope.enabled === false) return;

		event.preventDefault();
	}

	//

	scope.domElement.addEventListener('contextmenu', onContextMenu, false);

	scope.domElement.addEventListener('mousedown', onMouseDown, false);
	scope.domElement.addEventListener('wheel', onMouseWheel, false);

	scope.domElement.addEventListener('touchstart', onTouchStart, false);
	scope.domElement.addEventListener('touchend', onTouchEnd, false);
	scope.domElement.addEventListener('touchmove', onTouchMove, false);

	window.addEventListener('keydown', onKeyDown, false);

	// force an update at start

	this.update();
};

OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);
OrbitControls.prototype.constructor = OrbitControls;

Object.defineProperties(OrbitControls.prototype, {

	center: {

		get: function get() {

			console.warn('THREE.OrbitControls: .center has been renamed to .target');
			return this.target;
		}

	},

	// backward compatibility

	noZoom: {

		get: function get() {

			console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
			return !this.enableZoom;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
			this.enableZoom = !value;
		}

	},

	noRotate: {

		get: function get() {

			console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
			return !this.enableRotate;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
			this.enableRotate = !value;
		}

	},

	noPan: {

		get: function get() {

			console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
			return !this.enablePan;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
			this.enablePan = !value;
		}

	},

	noKeys: {

		get: function get() {

			console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
			return !this.enableKeys;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
			this.enableKeys = !value;
		}

	},

	staticMoving: {

		get: function get() {

			console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
			return !this.enableDamping;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
			this.enableDamping = !value;
		}

	},

	dynamicDampingFactor: {

		get: function get() {

			console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
			return this.dampingFactor;
		},

		set: function set(value) {

			console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
			this.dampingFactor = value;
		}

	}

});

exports.default = OrbitControls;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author Eberhard Graether / http://egraether.com/
 * @author Mark Lundin 	/ http://mark-lundin.com
 * @author Patrick Fuller / http://patrick-fuller.com
 * @author Max Smolens / https://github.com/msmolens
 */

var OrthographicTrackballControls = function OrthographicTrackballControls(object, domElement) {

	var _this = this;
	var STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };

	this.object = object;
	this.domElement = domElement !== undefined ? domElement : document;

	// API

	this.enabled = true;

	this.screen = { left: 0, top: 0, width: 0, height: 0 };

	this.radius = 0;

	this.rotateSpeed = 1.0;
	this.zoomSpeed = 1.2;

	this.noRotate = false;
	this.noZoom = false;
	this.noPan = false;
	this.noRoll = false;

	this.staticMoving = false;
	this.dynamicDampingFactor = 0.2;

	this.keys = [65 /*A*/, 83 /*S*/, 68 /*D*/];

	// internals

	this.target = new THREE.Vector3();

	var EPS = 0.000001;

	var _changed = true;

	var _state = STATE.NONE,
	    _prevState = STATE.NONE,
	    _eye = new THREE.Vector3(),
	    _rotateStart = new THREE.Vector3(),
	    _rotateEnd = new THREE.Vector3(),
	    _zoomStart = new THREE.Vector2(),
	    _zoomEnd = new THREE.Vector2(),
	    _touchZoomDistanceStart = 0,
	    _touchZoomDistanceEnd = 0,
	    _panStart = new THREE.Vector2(),
	    _panEnd = new THREE.Vector2();

	// for reset

	this.target0 = this.target.clone();
	this.position0 = this.object.position.clone();
	this.up0 = this.object.up.clone();

	this.left0 = this.object.left;
	this.right0 = this.object.right;
	this.top0 = this.object.top;
	this.bottom0 = this.object.bottom;

	// events

	var changeEvent = { type: 'change' };
	var startEvent = { type: 'start' };
	var endEvent = { type: 'end' };

	// methods

	this.handleResize = function () {

		if (this.domElement === document) {

			this.screen.left = 0;
			this.screen.top = 0;
			this.screen.width = window.innerWidth;
			this.screen.height = window.innerHeight;
		} else {

			var box = this.domElement.getBoundingClientRect();
			// adjustments come from similar code in the jquery offset() function
			var d = this.domElement.ownerDocument.documentElement;
			this.screen.left = box.left + window.pageXOffset - d.clientLeft;
			this.screen.top = box.top + window.pageYOffset - d.clientTop;
			this.screen.width = box.width;
			this.screen.height = box.height;
		}

		this.radius = 0.5 * Math.min(this.screen.width, this.screen.height);

		this.left0 = this.object.left;
		this.right0 = this.object.right;
		this.top0 = this.object.top;
		this.bottom0 = this.object.bottom;
	};

	this.handleEvent = function (event) {

		if (typeof this[event.type] == 'function') {

			this[event.type](event);
		}
	};

	var getMouseOnScreen = function () {

		var vector = new THREE.Vector2();

		return function getMouseOnScreen(pageX, pageY) {

			vector.set((pageX - _this.screen.left) / _this.screen.width, (pageY - _this.screen.top) / _this.screen.height);

			return vector;
		};
	}();

	var getMouseProjectionOnBall = function () {

		var vector = new THREE.Vector3();
		var objectUp = new THREE.Vector3();
		var mouseOnBall = new THREE.Vector3();

		return function getMouseProjectionOnBall(pageX, pageY) {

			mouseOnBall.set((pageX - _this.screen.width * 0.5 - _this.screen.left) / _this.radius, (_this.screen.height * 0.5 + _this.screen.top - pageY) / _this.radius, 0.0);

			var length = mouseOnBall.length();

			if (_this.noRoll) {

				if (length < Math.SQRT1_2) {

					mouseOnBall.z = Math.sqrt(1.0 - length * length);
				} else {

					mouseOnBall.z = .5 / length;
				}
			} else if (length > 1.0) {

				mouseOnBall.normalize();
			} else {

				mouseOnBall.z = Math.sqrt(1.0 - length * length);
			}

			_eye.copy(_this.object.position).sub(_this.target);

			vector.copy(_this.object.up).setLength(mouseOnBall.y);
			vector.add(objectUp.copy(_this.object.up).cross(_eye).setLength(mouseOnBall.x));
			vector.add(_eye.setLength(mouseOnBall.z));

			return vector;
		};
	}();

	this.rotateCamera = function () {

		var axis = new THREE.Vector3(),
		    quaternion = new THREE.Quaternion();

		return function rotateCamera() {

			var angle = Math.acos(_rotateStart.dot(_rotateEnd) / _rotateStart.length() / _rotateEnd.length());

			if (angle) {

				axis.crossVectors(_rotateStart, _rotateEnd).normalize();

				angle *= _this.rotateSpeed;

				quaternion.setFromAxisAngle(axis, -angle);

				_eye.applyQuaternion(quaternion);
				_this.object.up.applyQuaternion(quaternion);

				_rotateEnd.applyQuaternion(quaternion);

				if (_this.staticMoving) {

					_rotateStart.copy(_rotateEnd);
				} else {

					quaternion.setFromAxisAngle(axis, angle * (_this.dynamicDampingFactor - 1.0));
					_rotateStart.applyQuaternion(quaternion);
				}

				_changed = true;
			}
		};
	}();

	this.zoomCamera = function () {

		if (_state === STATE.TOUCH_ZOOM_PAN) {

			var factor = _touchZoomDistanceEnd / _touchZoomDistanceStart;
			_touchZoomDistanceStart = _touchZoomDistanceEnd;

			_this.object.zoom *= factor;

			_changed = true;
		} else {

			var factor = 1.0 + (_zoomEnd.y - _zoomStart.y) * _this.zoomSpeed;

			if (Math.abs(factor - 1.0) > EPS && factor > 0.0) {

				_this.object.zoom /= factor;

				if (_this.staticMoving) {

					_zoomStart.copy(_zoomEnd);
				} else {

					_zoomStart.y += (_zoomEnd.y - _zoomStart.y) * this.dynamicDampingFactor;
				}

				_changed = true;
			}
		}
	};

	this.panCamera = function () {

		var mouseChange = new THREE.Vector2(),
		    objectUp = new THREE.Vector3(),
		    pan = new THREE.Vector3();

		return function panCamera() {

			mouseChange.copy(_panEnd).sub(_panStart);

			if (mouseChange.lengthSq()) {

				// Scale movement to keep clicked/dragged position under cursor
				var scale_x = (_this.object.right - _this.object.left) / _this.object.zoom;
				var scale_y = (_this.object.top - _this.object.bottom) / _this.object.zoom;
				mouseChange.x *= scale_x;
				mouseChange.y *= scale_y;

				pan.copy(_eye).cross(_this.object.up).setLength(mouseChange.x);
				pan.add(objectUp.copy(_this.object.up).setLength(mouseChange.y));

				_this.object.position.add(pan);
				_this.target.add(pan);

				if (_this.staticMoving) {

					_panStart.copy(_panEnd);
				} else {

					_panStart.add(mouseChange.subVectors(_panEnd, _panStart).multiplyScalar(_this.dynamicDampingFactor));
				}

				_changed = true;
			}
		};
	}();

	this.update = function () {

		_eye.subVectors(_this.object.position, _this.target);

		if (!_this.noRotate) {

			_this.rotateCamera();
		}

		if (!_this.noZoom) {

			_this.zoomCamera();

			if (_changed) {

				_this.object.updateProjectionMatrix();
			}
		}

		if (!_this.noPan) {

			_this.panCamera();
		}

		_this.object.position.addVectors(_this.target, _eye);

		_this.object.lookAt(_this.target);

		if (_changed) {

			_this.dispatchEvent(changeEvent);

			_changed = false;
		}
	};

	this.reset = function () {

		_state = STATE.NONE;
		_prevState = STATE.NONE;

		_this.target.copy(_this.target0);
		_this.object.position.copy(_this.position0);
		_this.object.up.copy(_this.up0);

		_eye.subVectors(_this.object.position, _this.target);

		_this.object.left = _this.left0;
		_this.object.right = _this.right0;
		_this.object.top = _this.top0;
		_this.object.bottom = _this.bottom0;

		_this.object.lookAt(_this.target);

		_this.dispatchEvent(changeEvent);

		_changed = false;
	};

	// listeners

	function keydown(event) {

		if (_this.enabled === false) return;

		window.removeEventListener('keydown', keydown);

		_prevState = _state;

		if (_state !== STATE.NONE) {

			return;
		} else if (event.keyCode === _this.keys[STATE.ROTATE] && !_this.noRotate) {

			_state = STATE.ROTATE;
		} else if (event.keyCode === _this.keys[STATE.ZOOM] && !_this.noZoom) {

			_state = STATE.ZOOM;
		} else if (event.keyCode === _this.keys[STATE.PAN] && !_this.noPan) {

			_state = STATE.PAN;
		}
	}

	function keyup(event) {

		if (_this.enabled === false) return;

		_state = _prevState;

		window.addEventListener('keydown', keydown, false);
	}

	function mousedown(event) {

		if (_this.enabled === false) return;

		event.preventDefault();
		event.stopPropagation();

		if (_state === STATE.NONE) {

			_state = event.button;
		}

		if (_state === STATE.ROTATE && !_this.noRotate) {

			_rotateStart.copy(getMouseProjectionOnBall(event.pageX, event.pageY));
			_rotateEnd.copy(_rotateStart);
		} else if (_state === STATE.ZOOM && !_this.noZoom) {

			_zoomStart.copy(getMouseOnScreen(event.pageX, event.pageY));
			_zoomEnd.copy(_zoomStart);
		} else if (_state === STATE.PAN && !_this.noPan) {

			_panStart.copy(getMouseOnScreen(event.pageX, event.pageY));
			_panEnd.copy(_panStart);
		}

		document.addEventListener('mousemove', mousemove, false);
		document.addEventListener('mouseup', mouseup, false);

		_this.dispatchEvent(startEvent);
	}

	function mousemove(event) {

		if (_this.enabled === false) return;

		event.preventDefault();
		event.stopPropagation();

		if (_state === STATE.ROTATE && !_this.noRotate) {

			_rotateEnd.copy(getMouseProjectionOnBall(event.pageX, event.pageY));
		} else if (_state === STATE.ZOOM && !_this.noZoom) {

			_zoomEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
		} else if (_state === STATE.PAN && !_this.noPan) {

			_panEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
		}
	}

	function mouseup(event) {

		if (_this.enabled === false) return;

		event.preventDefault();
		event.stopPropagation();

		_state = STATE.NONE;

		document.removeEventListener('mousemove', mousemove);
		document.removeEventListener('mouseup', mouseup);
		_this.dispatchEvent(endEvent);
	}

	function mousewheel(event) {

		if (_this.enabled === false) return;

		event.preventDefault();
		event.stopPropagation();

		_zoomStart.y += event.deltaY * 0.01;
		_this.dispatchEvent(startEvent);
		_this.dispatchEvent(endEvent);
	}

	function touchstart(event) {

		if (_this.enabled === false) return;

		switch (event.touches.length) {

			case 1:
				_state = STATE.TOUCH_ROTATE;
				_rotateStart.copy(getMouseProjectionOnBall(event.touches[0].pageX, event.touches[0].pageY));
				_rotateEnd.copy(_rotateStart);
				break;

			case 2:
				_state = STATE.TOUCH_ZOOM_PAN;
				var dx = event.touches[0].pageX - event.touches[1].pageX;
				var dy = event.touches[0].pageY - event.touches[1].pageY;
				_touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);

				var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
				var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
				_panStart.copy(getMouseOnScreen(x, y));
				_panEnd.copy(_panStart);
				break;

			default:
				_state = STATE.NONE;

		}
		_this.dispatchEvent(startEvent);
	}

	function touchmove(event) {

		if (_this.enabled === false) return;

		event.preventDefault();
		event.stopPropagation();

		switch (event.touches.length) {

			case 1:
				_rotateEnd.copy(getMouseProjectionOnBall(event.touches[0].pageX, event.touches[0].pageY));
				break;

			case 2:
				var dx = event.touches[0].pageX - event.touches[1].pageX;
				var dy = event.touches[0].pageY - event.touches[1].pageY;
				_touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);

				var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
				var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
				_panEnd.copy(getMouseOnScreen(x, y));
				break;

			default:
				_state = STATE.NONE;

		}
	}

	function touchend(event) {

		if (_this.enabled === false) return;

		switch (event.touches.length) {

			case 1:
				_rotateEnd.copy(getMouseProjectionOnBall(event.touches[0].pageX, event.touches[0].pageY));
				_rotateStart.copy(_rotateEnd);
				break;

			case 2:
				_touchZoomDistanceStart = _touchZoomDistanceEnd = 0;

				var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
				var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
				_panEnd.copy(getMouseOnScreen(x, y));
				_panStart.copy(_panEnd);
				break;

		}

		_state = STATE.NONE;
		_this.dispatchEvent(endEvent);
	}

	function contextmenu(event) {

		event.preventDefault();
	}

	this.dispose = function () {

		this.domElement.removeEventListener('contextmenu', contextmenu, false);
		this.domElement.removeEventListener('mousedown', mousedown, false);
		this.domElement.removeEventListener('wheel', mousewheel, false);

		this.domElement.removeEventListener('touchstart', touchstart, false);
		this.domElement.removeEventListener('touchend', touchend, false);
		this.domElement.removeEventListener('touchmove', touchmove, false);

		document.removeEventListener('mousemove', mousemove, false);
		document.removeEventListener('mouseup', mouseup, false);

		window.removeEventListener('keydown', keydown, false);
		window.removeEventListener('keyup', keyup, false);
	};

	this.domElement.addEventListener('contextmenu', contextmenu, false);
	this.domElement.addEventListener('mousedown', mousedown, false);
	this.domElement.addEventListener('wheel', mousewheel, false);

	this.domElement.addEventListener('touchstart', touchstart, false);
	this.domElement.addEventListener('touchend', touchend, false);
	this.domElement.addEventListener('touchmove', touchmove, false);

	window.addEventListener('keydown', keydown, false);
	window.addEventListener('keyup', keyup, false);

	this.handleResize();

	// force an update at start
	this.update();
};

OrthographicTrackballControls.prototype = Object.create(THREE.EventDispatcher.prototype);
OrthographicTrackballControls.prototype.constructor = OrthographicTrackballControls;

exports.default = OrthographicTrackballControls;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author mrdoob / http://mrdoob.com/
 */

var PointerLockControls = function PointerLockControls(camera) {

	var scope = this;

	camera.rotation.set(0, 0, 0);

	var pitchObject = new THREE.Object3D();
	pitchObject.add(camera);

	var yawObject = new THREE.Object3D();
	yawObject.position.y = 10;
	yawObject.add(pitchObject);

	var PI_2 = Math.PI / 2;

	var onMouseMove = function onMouseMove(event) {

		if (scope.enabled === false) return;

		var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
		var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

		yawObject.rotation.y -= movementX * 0.002;
		pitchObject.rotation.x -= movementY * 0.002;

		pitchObject.rotation.x = Math.max(-PI_2, Math.min(PI_2, pitchObject.rotation.x));
	};

	this.dispose = function () {

		document.removeEventListener('mousemove', onMouseMove, false);
	};

	document.addEventListener('mousemove', onMouseMove, false);

	this.enabled = false;

	this.getObject = function () {

		return yawObject;
	};

	this.getDirection = function () {

		// assumes the camera itself is not rotated

		var direction = new THREE.Vector3(0, 0, -1);
		var rotation = new THREE.Euler(0, 0, 0, 'YXZ');

		return function (v) {

			rotation.set(pitchObject.rotation.x, yawObject.rotation.y, 0);

			v.copy(direction).applyEuler(rotation);

			return v;
		};
	}();
};

exports.default = PointerLockControls;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author Eberhard Graether / http://egraether.com/
 * @author Mark Lundin 	/ http://mark-lundin.com
 * @author Simone Manini / http://daron1337.github.io
 * @author Luca Antiga 	/ http://lantiga.github.io
 */

var TrackballControls = function TrackballControls(object, domElement) {

	var _this = this;
	var STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };

	this.object = object;
	this.domElement = domElement !== undefined ? domElement : document;

	// API

	this.enabled = true;

	this.screen = { left: 0, top: 0, width: 0, height: 0 };

	this.rotateSpeed = 1.0;
	this.zoomSpeed = 1.2;
	this.panSpeed = 0.3;

	this.noRotate = false;
	this.noZoom = false;
	this.noPan = false;

	this.staticMoving = false;
	this.dynamicDampingFactor = 0.2;

	this.minDistance = 0;
	this.maxDistance = Infinity;

	this.keys = [65 /*A*/, 83 /*S*/, 68 /*D*/];

	// internals

	this.target = new THREE.Vector3();

	var EPS = 0.000001;

	var lastPosition = new THREE.Vector3();

	var _state = STATE.NONE,
	    _prevState = STATE.NONE,
	    _eye = new THREE.Vector3(),
	    _movePrev = new THREE.Vector2(),
	    _moveCurr = new THREE.Vector2(),
	    _lastAxis = new THREE.Vector3(),
	    _lastAngle = 0,
	    _zoomStart = new THREE.Vector2(),
	    _zoomEnd = new THREE.Vector2(),
	    _touchZoomDistanceStart = 0,
	    _touchZoomDistanceEnd = 0,
	    _panStart = new THREE.Vector2(),
	    _panEnd = new THREE.Vector2();

	// for reset

	this.target0 = this.target.clone();
	this.position0 = this.object.position.clone();
	this.up0 = this.object.up.clone();

	// events

	var changeEvent = { type: 'change' };
	var startEvent = { type: 'start' };
	var endEvent = { type: 'end' };

	// methods

	this.handleResize = function () {

		if (this.domElement === document) {

			this.screen.left = 0;
			this.screen.top = 0;
			this.screen.width = window.innerWidth;
			this.screen.height = window.innerHeight;
		} else {

			var box = this.domElement.getBoundingClientRect();
			// adjustments come from similar code in the jquery offset() function
			var d = this.domElement.ownerDocument.documentElement;
			this.screen.left = box.left + window.pageXOffset - d.clientLeft;
			this.screen.top = box.top + window.pageYOffset - d.clientTop;
			this.screen.width = box.width;
			this.screen.height = box.height;
		}
	};

	this.handleEvent = function (event) {

		if (typeof this[event.type] == 'function') {

			this[event.type](event);
		}
	};

	var getMouseOnScreen = function () {

		var vector = new THREE.Vector2();

		return function getMouseOnScreen(pageX, pageY) {

			vector.set((pageX - _this.screen.left) / _this.screen.width, (pageY - _this.screen.top) / _this.screen.height);

			return vector;
		};
	}();

	var getMouseOnCircle = function () {

		var vector = new THREE.Vector2();

		return function getMouseOnCircle(pageX, pageY) {

			vector.set((pageX - _this.screen.width * 0.5 - _this.screen.left) / (_this.screen.width * 0.5), (_this.screen.height + 2 * (_this.screen.top - pageY)) / _this.screen.width // screen.width intentional
			);

			return vector;
		};
	}();

	this.rotateCamera = function () {

		var axis = new THREE.Vector3(),
		    quaternion = new THREE.Quaternion(),
		    eyeDirection = new THREE.Vector3(),
		    objectUpDirection = new THREE.Vector3(),
		    objectSidewaysDirection = new THREE.Vector3(),
		    moveDirection = new THREE.Vector3(),
		    angle;

		return function rotateCamera() {

			moveDirection.set(_moveCurr.x - _movePrev.x, _moveCurr.y - _movePrev.y, 0);
			angle = moveDirection.length();

			if (angle) {

				_eye.copy(_this.object.position).sub(_this.target);

				eyeDirection.copy(_eye).normalize();
				objectUpDirection.copy(_this.object.up).normalize();
				objectSidewaysDirection.crossVectors(objectUpDirection, eyeDirection).normalize();

				objectUpDirection.setLength(_moveCurr.y - _movePrev.y);
				objectSidewaysDirection.setLength(_moveCurr.x - _movePrev.x);

				moveDirection.copy(objectUpDirection.add(objectSidewaysDirection));

				axis.crossVectors(moveDirection, _eye).normalize();

				angle *= _this.rotateSpeed;
				quaternion.setFromAxisAngle(axis, angle);

				_eye.applyQuaternion(quaternion);
				_this.object.up.applyQuaternion(quaternion);

				_lastAxis.copy(axis);
				_lastAngle = angle;
			} else if (!_this.staticMoving && _lastAngle) {

				_lastAngle *= Math.sqrt(1.0 - _this.dynamicDampingFactor);
				_eye.copy(_this.object.position).sub(_this.target);
				quaternion.setFromAxisAngle(_lastAxis, _lastAngle);
				_eye.applyQuaternion(quaternion);
				_this.object.up.applyQuaternion(quaternion);
			}

			_movePrev.copy(_moveCurr);
		};
	}();

	this.zoomCamera = function () {

		var factor;

		if (_state === STATE.TOUCH_ZOOM_PAN) {

			factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
			_touchZoomDistanceStart = _touchZoomDistanceEnd;
			_eye.multiplyScalar(factor);
		} else {

			factor = 1.0 + (_zoomEnd.y - _zoomStart.y) * _this.zoomSpeed;

			if (factor !== 1.0 && factor > 0.0) {

				_eye.multiplyScalar(factor);
			}

			if (_this.staticMoving) {

				_zoomStart.copy(_zoomEnd);
			} else {

				_zoomStart.y += (_zoomEnd.y - _zoomStart.y) * this.dynamicDampingFactor;
			}
		}
	};

	this.panCamera = function () {

		var mouseChange = new THREE.Vector2(),
		    objectUp = new THREE.Vector3(),
		    pan = new THREE.Vector3();

		return function panCamera() {

			mouseChange.copy(_panEnd).sub(_panStart);

			if (mouseChange.lengthSq()) {

				mouseChange.multiplyScalar(_eye.length() * _this.panSpeed);

				pan.copy(_eye).cross(_this.object.up).setLength(mouseChange.x);
				pan.add(objectUp.copy(_this.object.up).setLength(mouseChange.y));

				_this.object.position.add(pan);
				_this.target.add(pan);

				if (_this.staticMoving) {

					_panStart.copy(_panEnd);
				} else {

					_panStart.add(mouseChange.subVectors(_panEnd, _panStart).multiplyScalar(_this.dynamicDampingFactor));
				}
			}
		};
	}();

	this.checkDistances = function () {

		if (!_this.noZoom || !_this.noPan) {

			if (_eye.lengthSq() > _this.maxDistance * _this.maxDistance) {

				_this.object.position.addVectors(_this.target, _eye.setLength(_this.maxDistance));
				_zoomStart.copy(_zoomEnd);
			}

			if (_eye.lengthSq() < _this.minDistance * _this.minDistance) {

				_this.object.position.addVectors(_this.target, _eye.setLength(_this.minDistance));
				_zoomStart.copy(_zoomEnd);
			}
		}
	};

	this.update = function () {

		_eye.subVectors(_this.object.position, _this.target);

		if (!_this.noRotate) {

			_this.rotateCamera();
		}

		if (!_this.noZoom) {

			_this.zoomCamera();
		}

		if (!_this.noPan) {

			_this.panCamera();
		}

		_this.object.position.addVectors(_this.target, _eye);

		_this.checkDistances();

		_this.object.lookAt(_this.target);

		if (lastPosition.distanceToSquared(_this.object.position) > EPS) {

			_this.dispatchEvent(changeEvent);

			lastPosition.copy(_this.object.position);
		}
	};

	this.reset = function () {

		_state = STATE.NONE;
		_prevState = STATE.NONE;

		_this.target.copy(_this.target0);
		_this.object.position.copy(_this.position0);
		_this.object.up.copy(_this.up0);

		_eye.subVectors(_this.object.position, _this.target);

		_this.object.lookAt(_this.target);

		_this.dispatchEvent(changeEvent);

		lastPosition.copy(_this.object.position);
	};

	// listeners

	function keydown(event) {

		if (_this.enabled === false) return;

		window.removeEventListener('keydown', keydown);

		_prevState = _state;

		if (_state !== STATE.NONE) {

			return;
		} else if (event.keyCode === _this.keys[STATE.ROTATE] && !_this.noRotate) {

			_state = STATE.ROTATE;
		} else if (event.keyCode === _this.keys[STATE.ZOOM] && !_this.noZoom) {

			_state = STATE.ZOOM;
		} else if (event.keyCode === _this.keys[STATE.PAN] && !_this.noPan) {

			_state = STATE.PAN;
		}
	}

	function keyup(event) {

		if (_this.enabled === false) return;

		_state = _prevState;

		window.addEventListener('keydown', keydown, false);
	}

	function mousedown(event) {

		if (_this.enabled === false) return;

		event.preventDefault();
		event.stopPropagation();

		if (_state === STATE.NONE) {

			_state = event.button;
		}

		if (_state === STATE.ROTATE && !_this.noRotate) {

			_moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));
			_movePrev.copy(_moveCurr);
		} else if (_state === STATE.ZOOM && !_this.noZoom) {

			_zoomStart.copy(getMouseOnScreen(event.pageX, event.pageY));
			_zoomEnd.copy(_zoomStart);
		} else if (_state === STATE.PAN && !_this.noPan) {

			_panStart.copy(getMouseOnScreen(event.pageX, event.pageY));
			_panEnd.copy(_panStart);
		}

		document.addEventListener('mousemove', mousemove, false);
		document.addEventListener('mouseup', mouseup, false);

		_this.dispatchEvent(startEvent);
	}

	function mousemove(event) {

		if (_this.enabled === false) return;

		event.preventDefault();
		event.stopPropagation();

		if (_state === STATE.ROTATE && !_this.noRotate) {

			_movePrev.copy(_moveCurr);
			_moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));
		} else if (_state === STATE.ZOOM && !_this.noZoom) {

			_zoomEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
		} else if (_state === STATE.PAN && !_this.noPan) {

			_panEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
		}
	}

	function mouseup(event) {

		if (_this.enabled === false) return;

		event.preventDefault();
		event.stopPropagation();

		_state = STATE.NONE;

		document.removeEventListener('mousemove', mousemove);
		document.removeEventListener('mouseup', mouseup);
		_this.dispatchEvent(endEvent);
	}

	function mousewheel(event) {

		if (_this.enabled === false) return;

		if (_this.noZoom === true) return;

		event.preventDefault();
		event.stopPropagation();

		switch (event.deltaMode) {

			case 2:
				// Zoom in pages
				_zoomStart.y -= event.deltaY * 0.025;
				break;

			case 1:
				// Zoom in lines
				_zoomStart.y -= event.deltaY * 0.01;
				break;

			default:
				// undefined, 0, assume pixels
				_zoomStart.y -= event.deltaY * 0.00025;
				break;

		}

		_this.dispatchEvent(startEvent);
		_this.dispatchEvent(endEvent);
	}

	function touchstart(event) {

		if (_this.enabled === false) return;

		switch (event.touches.length) {

			case 1:
				_state = STATE.TOUCH_ROTATE;
				_moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
				_movePrev.copy(_moveCurr);
				break;

			default:
				// 2 or more
				_state = STATE.TOUCH_ZOOM_PAN;
				var dx = event.touches[0].pageX - event.touches[1].pageX;
				var dy = event.touches[0].pageY - event.touches[1].pageY;
				_touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);

				var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
				var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
				_panStart.copy(getMouseOnScreen(x, y));
				_panEnd.copy(_panStart);
				break;

		}

		_this.dispatchEvent(startEvent);
	}

	function touchmove(event) {

		if (_this.enabled === false) return;

		event.preventDefault();
		event.stopPropagation();

		switch (event.touches.length) {

			case 1:
				_movePrev.copy(_moveCurr);
				_moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
				break;

			default:
				// 2 or more
				var dx = event.touches[0].pageX - event.touches[1].pageX;
				var dy = event.touches[0].pageY - event.touches[1].pageY;
				_touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);

				var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
				var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
				_panEnd.copy(getMouseOnScreen(x, y));
				break;

		}
	}

	function touchend(event) {

		if (_this.enabled === false) return;

		switch (event.touches.length) {

			case 0:
				_state = STATE.NONE;
				break;

			case 1:
				_state = STATE.TOUCH_ROTATE;
				_moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
				_movePrev.copy(_moveCurr);
				break;

		}

		_this.dispatchEvent(endEvent);
	}

	function contextmenu(event) {

		if (_this.enabled === false) return;

		event.preventDefault();
	}

	this.dispose = function () {

		this.domElement.removeEventListener('contextmenu', contextmenu, false);
		this.domElement.removeEventListener('mousedown', mousedown, false);
		this.domElement.removeEventListener('wheel', mousewheel, false);

		this.domElement.removeEventListener('touchstart', touchstart, false);
		this.domElement.removeEventListener('touchend', touchend, false);
		this.domElement.removeEventListener('touchmove', touchmove, false);

		document.removeEventListener('mousemove', mousemove, false);
		document.removeEventListener('mouseup', mouseup, false);

		window.removeEventListener('keydown', keydown, false);
		window.removeEventListener('keyup', keyup, false);
	};

	this.domElement.addEventListener('contextmenu', contextmenu, false);
	this.domElement.addEventListener('mousedown', mousedown, false);
	this.domElement.addEventListener('wheel', mousewheel, false);

	this.domElement.addEventListener('touchstart', touchstart, false);
	this.domElement.addEventListener('touchend', touchend, false);
	this.domElement.addEventListener('touchmove', touchmove, false);

	window.addEventListener('keydown', keydown, false);
	window.addEventListener('keyup', keyup, false);

	this.handleResize();

	// force an update at start
	this.update();
};

TrackballControls.prototype = Object.create(THREE.EventDispatcher.prototype);
TrackballControls.prototype.constructor = TrackballControls;

exports.default = TrackballControls;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author arodic / https://github.com/arodic
 */

exports.default = function () {

	'use strict';

	var GizmoMaterial = function GizmoMaterial(parameters) {

		THREE.MeshBasicMaterial.call(this);

		this.depthTest = false;
		this.depthWrite = false;
		this.fog = false;
		this.side = THREE.FrontSide;
		this.transparent = true;

		this.setValues(parameters);

		this.oldColor = this.color.clone();
		this.oldOpacity = this.opacity;

		this.highlight = function (highlighted) {

			if (highlighted) {

				this.color.setRGB(1, 1, 0);
				this.opacity = 1;
			} else {

				this.color.copy(this.oldColor);
				this.opacity = this.oldOpacity;
			}
		};
	};

	GizmoMaterial.prototype = Object.create(THREE.MeshBasicMaterial.prototype);
	GizmoMaterial.prototype.constructor = GizmoMaterial;

	var GizmoLineMaterial = function GizmoLineMaterial(parameters) {

		THREE.LineBasicMaterial.call(this);

		this.depthTest = false;
		this.depthWrite = false;
		this.fog = false;
		this.transparent = true;
		this.linewidth = 1;

		this.setValues(parameters);

		this.oldColor = this.color.clone();
		this.oldOpacity = this.opacity;

		this.highlight = function (highlighted) {

			if (highlighted) {

				this.color.setRGB(1, 1, 0);
				this.opacity = 1;
			} else {

				this.color.copy(this.oldColor);
				this.opacity = this.oldOpacity;
			}
		};
	};

	GizmoLineMaterial.prototype = Object.create(THREE.LineBasicMaterial.prototype);
	GizmoLineMaterial.prototype.constructor = GizmoLineMaterial;

	var pickerMaterial = new GizmoMaterial({ visible: false, transparent: false });

	var TransformGizmo = function TransformGizmo() {

		this.init = function () {

			THREE.Object3D.call(this);

			this.handles = new THREE.Object3D();
			this.pickers = new THREE.Object3D();
			this.planes = new THREE.Object3D();

			this.add(this.handles);
			this.add(this.pickers);
			this.add(this.planes);

			//// PLANES

			var planeGeometry = new THREE.PlaneBufferGeometry(50, 50, 2, 2);
			var planeMaterial = new THREE.MeshBasicMaterial({ visible: false, side: THREE.DoubleSide });

			var planes = {
				"XY": new THREE.Mesh(planeGeometry, planeMaterial),
				"YZ": new THREE.Mesh(planeGeometry, planeMaterial),
				"XZ": new THREE.Mesh(planeGeometry, planeMaterial),
				"XYZE": new THREE.Mesh(planeGeometry, planeMaterial)
			};

			this.activePlane = planes["XYZE"];

			planes["YZ"].rotation.set(0, Math.PI / 2, 0);
			planes["XZ"].rotation.set(-Math.PI / 2, 0, 0);

			for (var i in planes) {

				planes[i].name = i;
				this.planes.add(planes[i]);
				this.planes[i] = planes[i];
			}

			//// HANDLES AND PICKERS

			var setupGizmos = function setupGizmos(gizmoMap, parent) {

				for (var name in gizmoMap) {

					for (i = gizmoMap[name].length; i--;) {

						var object = gizmoMap[name][i][0];
						var position = gizmoMap[name][i][1];
						var rotation = gizmoMap[name][i][2];

						object.name = name;

						object.renderOrder = Infinity; // avoid being hidden by other transparent objects

						if (position) object.position.set(position[0], position[1], position[2]);
						if (rotation) object.rotation.set(rotation[0], rotation[1], rotation[2]);

						parent.add(object);
					}
				}
			};

			setupGizmos(this.handleGizmos, this.handles);
			setupGizmos(this.pickerGizmos, this.pickers);

			// reset Transformations

			this.traverse(function (child) {

				if (child instanceof THREE.Mesh) {

					child.updateMatrix();

					var tempGeometry = child.geometry.clone();
					tempGeometry.applyMatrix(child.matrix);
					child.geometry = tempGeometry;

					child.position.set(0, 0, 0);
					child.rotation.set(0, 0, 0);
					child.scale.set(1, 1, 1);
				}
			});
		};

		this.highlight = function (axis) {

			this.traverse(function (child) {

				if (child.material && child.material.highlight) {

					if (child.name === axis) {

						child.material.highlight(true);
					} else {

						child.material.highlight(false);
					}
				}
			});
		};
	};

	TransformGizmo.prototype = Object.create(THREE.Object3D.prototype);
	TransformGizmo.prototype.constructor = TransformGizmo;

	TransformGizmo.prototype.update = function (rotation, eye) {

		var vec1 = new THREE.Vector3(0, 0, 0);
		var vec2 = new THREE.Vector3(0, 1, 0);
		var lookAtMatrix = new THREE.Matrix4();

		this.traverse(function (child) {

			if (child.name.search("E") !== -1) {

				child.quaternion.setFromRotationMatrix(lookAtMatrix.lookAt(eye, vec1, vec2));
			} else if (child.name.search("X") !== -1 || child.name.search("Y") !== -1 || child.name.search("Z") !== -1) {

				child.quaternion.setFromEuler(rotation);
			}
		});
	};

	var TransformGizmoTranslate = function TransformGizmoTranslate() {

		TransformGizmo.call(this);

		var arrowGeometry = new THREE.Geometry();
		var mesh = new THREE.Mesh(new THREE.CylinderGeometry(0, 0.05, 0.2, 12, 1, false));
		mesh.position.y = 0.5;
		mesh.updateMatrix();

		arrowGeometry.merge(mesh.geometry, mesh.matrix);

		var lineXGeometry = new THREE.BufferGeometry();
		lineXGeometry.addAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));

		var lineYGeometry = new THREE.BufferGeometry();
		lineYGeometry.addAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));

		var lineZGeometry = new THREE.BufferGeometry();
		lineZGeometry.addAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));

		this.handleGizmos = {

			X: [[new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0xff0000 })), [0.5, 0, 0], [0, 0, -Math.PI / 2]], [new THREE.Line(lineXGeometry, new GizmoLineMaterial({ color: 0xff0000 }))]],

			Y: [[new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x00ff00 })), [0, 0.5, 0]], [new THREE.Line(lineYGeometry, new GizmoLineMaterial({ color: 0x00ff00 }))]],

			Z: [[new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x0000ff })), [0, 0, 0.5], [Math.PI / 2, 0, 0]], [new THREE.Line(lineZGeometry, new GizmoLineMaterial({ color: 0x0000ff }))]],

			XYZ: [[new THREE.Mesh(new THREE.OctahedronGeometry(0.1, 0), new GizmoMaterial({ color: 0xffffff, opacity: 0.25 })), [0, 0, 0], [0, 0, 0]]],

			XY: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(0.29, 0.29), new GizmoMaterial({ color: 0xffff00, opacity: 0.25 })), [0.15, 0.15, 0]]],

			YZ: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(0.29, 0.29), new GizmoMaterial({ color: 0x00ffff, opacity: 0.25 })), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]],

			XZ: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(0.29, 0.29), new GizmoMaterial({ color: 0xff00ff, opacity: 0.25 })), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]]

		};

		this.pickerGizmos = {

			X: [[new THREE.Mesh(new THREE.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), pickerMaterial), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],

			Y: [[new THREE.Mesh(new THREE.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), pickerMaterial), [0, 0.6, 0]]],

			Z: [[new THREE.Mesh(new THREE.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), pickerMaterial), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],

			XYZ: [[new THREE.Mesh(new THREE.OctahedronGeometry(0.2, 0), pickerMaterial)]],

			XY: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(0.4, 0.4), pickerMaterial), [0.2, 0.2, 0]]],

			YZ: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(0.4, 0.4), pickerMaterial), [0, 0.2, 0.2], [0, Math.PI / 2, 0]]],

			XZ: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(0.4, 0.4), pickerMaterial), [0.2, 0, 0.2], [-Math.PI / 2, 0, 0]]]

		};

		this.setActivePlane = function (axis, eye) {

			var tempMatrix = new THREE.Matrix4();
			eye.applyMatrix4(tempMatrix.getInverse(tempMatrix.extractRotation(this.planes["XY"].matrixWorld)));

			if (axis === "X") {

				this.activePlane = this.planes["XY"];

				if (Math.abs(eye.y) > Math.abs(eye.z)) this.activePlane = this.planes["XZ"];
			}

			if (axis === "Y") {

				this.activePlane = this.planes["XY"];

				if (Math.abs(eye.x) > Math.abs(eye.z)) this.activePlane = this.planes["YZ"];
			}

			if (axis === "Z") {

				this.activePlane = this.planes["XZ"];

				if (Math.abs(eye.x) > Math.abs(eye.y)) this.activePlane = this.planes["YZ"];
			}

			if (axis === "XYZ") this.activePlane = this.planes["XYZE"];

			if (axis === "XY") this.activePlane = this.planes["XY"];

			if (axis === "YZ") this.activePlane = this.planes["YZ"];

			if (axis === "XZ") this.activePlane = this.planes["XZ"];
		};

		this.init();
	};

	TransformGizmoTranslate.prototype = Object.create(TransformGizmo.prototype);
	TransformGizmoTranslate.prototype.constructor = TransformGizmoTranslate;

	var TransformGizmoRotate = function TransformGizmoRotate() {

		TransformGizmo.call(this);

		var CircleGeometry = function CircleGeometry(radius, facing, arc) {

			var geometry = new THREE.BufferGeometry();
			var vertices = [];
			arc = arc ? arc : 1;

			for (var i = 0; i <= 64 * arc; ++i) {

				if (facing === 'x') vertices.push(0, Math.cos(i / 32 * Math.PI) * radius, Math.sin(i / 32 * Math.PI) * radius);
				if (facing === 'y') vertices.push(Math.cos(i / 32 * Math.PI) * radius, 0, Math.sin(i / 32 * Math.PI) * radius);
				if (facing === 'z') vertices.push(Math.sin(i / 32 * Math.PI) * radius, Math.cos(i / 32 * Math.PI) * radius, 0);
			}

			geometry.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
			return geometry;
		};

		this.handleGizmos = {

			X: [[new THREE.Line(new CircleGeometry(1, 'x', 0.5), new GizmoLineMaterial({ color: 0xff0000 }))]],

			Y: [[new THREE.Line(new CircleGeometry(1, 'y', 0.5), new GizmoLineMaterial({ color: 0x00ff00 }))]],

			Z: [[new THREE.Line(new CircleGeometry(1, 'z', 0.5), new GizmoLineMaterial({ color: 0x0000ff }))]],

			E: [[new THREE.Line(new CircleGeometry(1.25, 'z', 1), new GizmoLineMaterial({ color: 0xcccc00 }))]],

			XYZE: [[new THREE.Line(new CircleGeometry(1, 'z', 1), new GizmoLineMaterial({ color: 0x787878 }))]]

		};

		this.pickerGizmos = {

			X: [[new THREE.Mesh(new THREE.TorusBufferGeometry(1, 0.12, 4, 12, Math.PI), pickerMaterial), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],

			Y: [[new THREE.Mesh(new THREE.TorusBufferGeometry(1, 0.12, 4, 12, Math.PI), pickerMaterial), [0, 0, 0], [Math.PI / 2, 0, 0]]],

			Z: [[new THREE.Mesh(new THREE.TorusBufferGeometry(1, 0.12, 4, 12, Math.PI), pickerMaterial), [0, 0, 0], [0, 0, -Math.PI / 2]]],

			E: [[new THREE.Mesh(new THREE.TorusBufferGeometry(1.25, 0.12, 2, 24), pickerMaterial)]],

			XYZE: [[new THREE.Mesh(new THREE.TorusBufferGeometry(1, 0.12, 2, 24), pickerMaterial)]]

		};

		this.pickerGizmos.XYZE[0][0].visible = false; // disable XYZE picker gizmo

		this.setActivePlane = function (axis) {

			if (axis === "E") this.activePlane = this.planes["XYZE"];

			if (axis === "X") this.activePlane = this.planes["YZ"];

			if (axis === "Y") this.activePlane = this.planes["XZ"];

			if (axis === "Z") this.activePlane = this.planes["XY"];
		};

		this.update = function (rotation, eye2) {

			TransformGizmo.prototype.update.apply(this, arguments);

			var tempMatrix = new THREE.Matrix4();
			var worldRotation = new THREE.Euler(0, 0, 1);
			var tempQuaternion = new THREE.Quaternion();
			var unitX = new THREE.Vector3(1, 0, 0);
			var unitY = new THREE.Vector3(0, 1, 0);
			var unitZ = new THREE.Vector3(0, 0, 1);
			var quaternionX = new THREE.Quaternion();
			var quaternionY = new THREE.Quaternion();
			var quaternionZ = new THREE.Quaternion();
			var eye = eye2.clone();

			worldRotation.copy(this.planes["XY"].rotation);
			tempQuaternion.setFromEuler(worldRotation);

			tempMatrix.makeRotationFromQuaternion(tempQuaternion).getInverse(tempMatrix);
			eye.applyMatrix4(tempMatrix);

			this.traverse(function (child) {

				tempQuaternion.setFromEuler(worldRotation);

				if (child.name === "X") {

					quaternionX.setFromAxisAngle(unitX, Math.atan2(-eye.y, eye.z));
					tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);
					child.quaternion.copy(tempQuaternion);
				}

				if (child.name === "Y") {

					quaternionY.setFromAxisAngle(unitY, Math.atan2(eye.x, eye.z));
					tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionY);
					child.quaternion.copy(tempQuaternion);
				}

				if (child.name === "Z") {

					quaternionZ.setFromAxisAngle(unitZ, Math.atan2(eye.y, eye.x));
					tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionZ);
					child.quaternion.copy(tempQuaternion);
				}
			});
		};

		this.init();
	};

	TransformGizmoRotate.prototype = Object.create(TransformGizmo.prototype);
	TransformGizmoRotate.prototype.constructor = TransformGizmoRotate;

	var TransformGizmoScale = function TransformGizmoScale() {

		TransformGizmo.call(this);

		var arrowGeometry = new THREE.Geometry();
		var mesh = new THREE.Mesh(new THREE.BoxGeometry(0.125, 0.125, 0.125));
		mesh.position.y = 0.5;
		mesh.updateMatrix();

		arrowGeometry.merge(mesh.geometry, mesh.matrix);

		var lineXGeometry = new THREE.BufferGeometry();
		lineXGeometry.addAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));

		var lineYGeometry = new THREE.BufferGeometry();
		lineYGeometry.addAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));

		var lineZGeometry = new THREE.BufferGeometry();
		lineZGeometry.addAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));

		this.handleGizmos = {

			X: [[new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0xff0000 })), [0.5, 0, 0], [0, 0, -Math.PI / 2]], [new THREE.Line(lineXGeometry, new GizmoLineMaterial({ color: 0xff0000 }))]],

			Y: [[new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x00ff00 })), [0, 0.5, 0]], [new THREE.Line(lineYGeometry, new GizmoLineMaterial({ color: 0x00ff00 }))]],

			Z: [[new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x0000ff })), [0, 0, 0.5], [Math.PI / 2, 0, 0]], [new THREE.Line(lineZGeometry, new GizmoLineMaterial({ color: 0x0000ff }))]],

			XYZ: [[new THREE.Mesh(new THREE.BoxBufferGeometry(0.125, 0.125, 0.125), new GizmoMaterial({ color: 0xffffff, opacity: 0.25 }))]]

		};

		this.pickerGizmos = {

			X: [[new THREE.Mesh(new THREE.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), pickerMaterial), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],

			Y: [[new THREE.Mesh(new THREE.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), pickerMaterial), [0, 0.6, 0]]],

			Z: [[new THREE.Mesh(new THREE.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), pickerMaterial), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],

			XYZ: [[new THREE.Mesh(new THREE.BoxBufferGeometry(0.4, 0.4, 0.4), pickerMaterial)]]

		};

		this.setActivePlane = function (axis, eye) {

			var tempMatrix = new THREE.Matrix4();
			eye.applyMatrix4(tempMatrix.getInverse(tempMatrix.extractRotation(this.planes["XY"].matrixWorld)));

			if (axis === "X") {

				this.activePlane = this.planes["XY"];
				if (Math.abs(eye.y) > Math.abs(eye.z)) this.activePlane = this.planes["XZ"];
			}

			if (axis === "Y") {

				this.activePlane = this.planes["XY"];
				if (Math.abs(eye.x) > Math.abs(eye.z)) this.activePlane = this.planes["YZ"];
			}

			if (axis === "Z") {

				this.activePlane = this.planes["XZ"];
				if (Math.abs(eye.x) > Math.abs(eye.y)) this.activePlane = this.planes["YZ"];
			}

			if (axis === "XYZ") this.activePlane = this.planes["XYZE"];
		};

		this.init();
	};

	TransformGizmoScale.prototype = Object.create(TransformGizmo.prototype);
	TransformGizmoScale.prototype.constructor = TransformGizmoScale;

	var TransformControls = function TransformControls(camera, domElement) {

		// TODO: Make non-uniform scale and rotate play nice in hierarchies
		// TODO: ADD RXYZ contol

		THREE.Object3D.call(this);

		domElement = domElement !== undefined ? domElement : document;

		this.object = undefined;
		this.visible = false;
		this.translationSnap = null;
		this.rotationSnap = null;
		this.space = "world";
		this.size = 1;
		this.axis = null;

		var scope = this;

		var _mode = "translate";
		var _dragging = false;
		var _gizmo = {

			"translate": new TransformGizmoTranslate(),
			"rotate": new TransformGizmoRotate(),
			"scale": new TransformGizmoScale()
		};

		for (var type in _gizmo) {

			var gizmoObj = _gizmo[type];

			gizmoObj.visible = type === _mode;
			this.add(gizmoObj);
		}

		var changeEvent = { type: "change" };
		var mouseDownEvent = { type: "mouseDown" };
		var mouseUpEvent = { type: "mouseUp", mode: _mode };
		var objectChangeEvent = { type: "objectChange" };

		var ray = new THREE.Raycaster();
		var pointerVector = new THREE.Vector2();

		var point = new THREE.Vector3();
		var offset = new THREE.Vector3();

		var rotation = new THREE.Vector3();
		var offsetRotation = new THREE.Vector3();
		var scale = 1;

		var lookAtMatrix = new THREE.Matrix4();
		var eye = new THREE.Vector3();

		var tempMatrix = new THREE.Matrix4();
		var tempVector = new THREE.Vector3();
		var tempQuaternion = new THREE.Quaternion();
		var unitX = new THREE.Vector3(1, 0, 0);
		var unitY = new THREE.Vector3(0, 1, 0);
		var unitZ = new THREE.Vector3(0, 0, 1);

		var quaternionXYZ = new THREE.Quaternion();
		var quaternionX = new THREE.Quaternion();
		var quaternionY = new THREE.Quaternion();
		var quaternionZ = new THREE.Quaternion();
		var quaternionE = new THREE.Quaternion();

		var oldPosition = new THREE.Vector3();
		var oldScale = new THREE.Vector3();
		var oldRotationMatrix = new THREE.Matrix4();

		var parentRotationMatrix = new THREE.Matrix4();
		var parentScale = new THREE.Vector3();

		var worldPosition = new THREE.Vector3();
		var worldRotation = new THREE.Euler();
		var worldRotationMatrix = new THREE.Matrix4();
		var camPosition = new THREE.Vector3();
		var camRotation = new THREE.Euler();

		domElement.addEventListener("mousedown", onPointerDown, false);
		domElement.addEventListener("touchstart", onPointerDown, false);

		domElement.addEventListener("mousemove", onPointerHover, false);
		domElement.addEventListener("touchmove", onPointerHover, false);

		domElement.addEventListener("mousemove", onPointerMove, false);
		domElement.addEventListener("touchmove", onPointerMove, false);

		domElement.addEventListener("mouseup", onPointerUp, false);
		domElement.addEventListener("mouseout", onPointerUp, false);
		domElement.addEventListener("touchend", onPointerUp, false);
		domElement.addEventListener("touchcancel", onPointerUp, false);
		domElement.addEventListener("touchleave", onPointerUp, false);

		this.dispose = function () {

			domElement.removeEventListener("mousedown", onPointerDown);
			domElement.removeEventListener("touchstart", onPointerDown);

			domElement.removeEventListener("mousemove", onPointerHover);
			domElement.removeEventListener("touchmove", onPointerHover);

			domElement.removeEventListener("mousemove", onPointerMove);
			domElement.removeEventListener("touchmove", onPointerMove);

			domElement.removeEventListener("mouseup", onPointerUp);
			domElement.removeEventListener("mouseout", onPointerUp);
			domElement.removeEventListener("touchend", onPointerUp);
			domElement.removeEventListener("touchcancel", onPointerUp);
			domElement.removeEventListener("touchleave", onPointerUp);
		};

		this.attach = function (object) {

			this.object = object;
			this.visible = true;
			this.update();
		};

		this.detach = function () {

			this.object = undefined;
			this.visible = false;
			this.axis = null;
		};

		this.getMode = function () {

			return _mode;
		};

		this.setMode = function (mode) {

			_mode = mode ? mode : _mode;

			if (_mode === "scale") scope.space = "local";

			for (var type in _gizmo) {
				_gizmo[type].visible = type === _mode;
			}this.update();
			scope.dispatchEvent(changeEvent);
		};

		this.setTranslationSnap = function (translationSnap) {

			scope.translationSnap = translationSnap;
		};

		this.setRotationSnap = function (rotationSnap) {

			scope.rotationSnap = rotationSnap;
		};

		this.setSize = function (size) {

			scope.size = size;
			this.update();
			scope.dispatchEvent(changeEvent);
		};

		this.setSpace = function (space) {

			scope.space = space;
			this.update();
			scope.dispatchEvent(changeEvent);
		};

		this.update = function () {

			if (scope.object === undefined) return;

			scope.object.updateMatrixWorld();
			worldPosition.setFromMatrixPosition(scope.object.matrixWorld);
			worldRotation.setFromRotationMatrix(tempMatrix.extractRotation(scope.object.matrixWorld));

			camera.updateMatrixWorld();
			camPosition.setFromMatrixPosition(camera.matrixWorld);
			camRotation.setFromRotationMatrix(tempMatrix.extractRotation(camera.matrixWorld));

			scale = worldPosition.distanceTo(camPosition) / 6 * scope.size;
			this.position.copy(worldPosition);
			this.scale.set(scale, scale, scale);

			if (camera instanceof THREE.PerspectiveCamera) {

				eye.copy(camPosition).sub(worldPosition).normalize();
			} else if (camera instanceof THREE.OrthographicCamera) {

				eye.copy(camPosition).normalize();
			}

			if (scope.space === "local") {

				_gizmo[_mode].update(worldRotation, eye);
			} else if (scope.space === "world") {

				_gizmo[_mode].update(new THREE.Euler(), eye);
			}

			_gizmo[_mode].highlight(scope.axis);
		};

		function onPointerHover(event) {

			if (scope.object === undefined || _dragging === true || event.button !== undefined && event.button !== 0) return;

			var pointer = event.changedTouches ? event.changedTouches[0] : event;

			var intersect = intersectObjects(pointer, _gizmo[_mode].pickers.children);

			var axis = null;

			if (intersect) {

				axis = intersect.object.name;

				event.preventDefault();
			}

			if (scope.axis !== axis) {

				scope.axis = axis;
				scope.update();
				scope.dispatchEvent(changeEvent);
			}
		}

		function onPointerDown(event) {

			if (scope.object === undefined || _dragging === true || event.button !== undefined && event.button !== 0) return;

			var pointer = event.changedTouches ? event.changedTouches[0] : event;

			if (pointer.button === 0 || pointer.button === undefined) {

				var intersect = intersectObjects(pointer, _gizmo[_mode].pickers.children);

				if (intersect) {

					event.preventDefault();
					event.stopPropagation();

					scope.axis = intersect.object.name;

					scope.dispatchEvent(mouseDownEvent);

					scope.update();

					eye.copy(camPosition).sub(worldPosition).normalize();

					_gizmo[_mode].setActivePlane(scope.axis, eye);

					var planeIntersect = intersectObjects(pointer, [_gizmo[_mode].activePlane]);

					if (planeIntersect) {

						oldPosition.copy(scope.object.position);
						oldScale.copy(scope.object.scale);

						oldRotationMatrix.extractRotation(scope.object.matrix);
						worldRotationMatrix.extractRotation(scope.object.matrixWorld);

						parentRotationMatrix.extractRotation(scope.object.parent.matrixWorld);
						parentScale.setFromMatrixScale(tempMatrix.getInverse(scope.object.parent.matrixWorld));

						offset.copy(planeIntersect.point);
					}
				}
			}

			_dragging = true;
		}

		function onPointerMove(event) {

			if (scope.object === undefined || scope.axis === null || _dragging === false || event.button !== undefined && event.button !== 0) return;

			var pointer = event.changedTouches ? event.changedTouches[0] : event;

			var planeIntersect = intersectObjects(pointer, [_gizmo[_mode].activePlane]);

			if (planeIntersect === false) return;

			event.preventDefault();
			event.stopPropagation();

			point.copy(planeIntersect.point);

			if (_mode === "translate") {

				point.sub(offset);
				point.multiply(parentScale);

				if (scope.space === "local") {

					point.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));

					if (scope.axis.search("X") === -1) point.x = 0;
					if (scope.axis.search("Y") === -1) point.y = 0;
					if (scope.axis.search("Z") === -1) point.z = 0;

					point.applyMatrix4(oldRotationMatrix);

					scope.object.position.copy(oldPosition);
					scope.object.position.add(point);
				}

				if (scope.space === "world" || scope.axis.search("XYZ") !== -1) {

					if (scope.axis.search("X") === -1) point.x = 0;
					if (scope.axis.search("Y") === -1) point.y = 0;
					if (scope.axis.search("Z") === -1) point.z = 0;

					point.applyMatrix4(tempMatrix.getInverse(parentRotationMatrix));

					scope.object.position.copy(oldPosition);
					scope.object.position.add(point);
				}

				if (scope.translationSnap !== null) {

					if (scope.space === "local") {

						scope.object.position.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));
					}

					if (scope.axis.search("X") !== -1) scope.object.position.x = Math.round(scope.object.position.x / scope.translationSnap) * scope.translationSnap;
					if (scope.axis.search("Y") !== -1) scope.object.position.y = Math.round(scope.object.position.y / scope.translationSnap) * scope.translationSnap;
					if (scope.axis.search("Z") !== -1) scope.object.position.z = Math.round(scope.object.position.z / scope.translationSnap) * scope.translationSnap;

					if (scope.space === "local") {

						scope.object.position.applyMatrix4(worldRotationMatrix);
					}
				}
			} else if (_mode === "scale") {

				point.sub(offset);
				point.multiply(parentScale);

				if (scope.space === "local") {

					if (scope.axis === "XYZ") {

						scale = 1 + point.y / Math.max(oldScale.x, oldScale.y, oldScale.z);

						scope.object.scale.x = oldScale.x * scale;
						scope.object.scale.y = oldScale.y * scale;
						scope.object.scale.z = oldScale.z * scale;
					} else {

						point.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));

						if (scope.axis === "X") scope.object.scale.x = oldScale.x * (1 + point.x / oldScale.x);
						if (scope.axis === "Y") scope.object.scale.y = oldScale.y * (1 + point.y / oldScale.y);
						if (scope.axis === "Z") scope.object.scale.z = oldScale.z * (1 + point.z / oldScale.z);
					}
				}
			} else if (_mode === "rotate") {

				point.sub(worldPosition);
				point.multiply(parentScale);
				tempVector.copy(offset).sub(worldPosition);
				tempVector.multiply(parentScale);

				if (scope.axis === "E") {

					point.applyMatrix4(tempMatrix.getInverse(lookAtMatrix));
					tempVector.applyMatrix4(tempMatrix.getInverse(lookAtMatrix));

					rotation.set(Math.atan2(point.z, point.y), Math.atan2(point.x, point.z), Math.atan2(point.y, point.x));
					offsetRotation.set(Math.atan2(tempVector.z, tempVector.y), Math.atan2(tempVector.x, tempVector.z), Math.atan2(tempVector.y, tempVector.x));

					tempQuaternion.setFromRotationMatrix(tempMatrix.getInverse(parentRotationMatrix));

					quaternionE.setFromAxisAngle(eye, rotation.z - offsetRotation.z);
					quaternionXYZ.setFromRotationMatrix(worldRotationMatrix);

					tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionE);
					tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);

					scope.object.quaternion.copy(tempQuaternion);
				} else if (scope.axis === "XYZE") {

					quaternionE.setFromEuler(point.clone().cross(tempVector).normalize()); // rotation axis

					tempQuaternion.setFromRotationMatrix(tempMatrix.getInverse(parentRotationMatrix));
					quaternionX.setFromAxisAngle(quaternionE, -point.clone().angleTo(tempVector));
					quaternionXYZ.setFromRotationMatrix(worldRotationMatrix);

					tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);
					tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);

					scope.object.quaternion.copy(tempQuaternion);
				} else if (scope.space === "local") {

					point.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));

					tempVector.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));

					rotation.set(Math.atan2(point.z, point.y), Math.atan2(point.x, point.z), Math.atan2(point.y, point.x));
					offsetRotation.set(Math.atan2(tempVector.z, tempVector.y), Math.atan2(tempVector.x, tempVector.z), Math.atan2(tempVector.y, tempVector.x));

					quaternionXYZ.setFromRotationMatrix(oldRotationMatrix);

					if (scope.rotationSnap !== null) {

						quaternionX.setFromAxisAngle(unitX, Math.round((rotation.x - offsetRotation.x) / scope.rotationSnap) * scope.rotationSnap);
						quaternionY.setFromAxisAngle(unitY, Math.round((rotation.y - offsetRotation.y) / scope.rotationSnap) * scope.rotationSnap);
						quaternionZ.setFromAxisAngle(unitZ, Math.round((rotation.z - offsetRotation.z) / scope.rotationSnap) * scope.rotationSnap);
					} else {

						quaternionX.setFromAxisAngle(unitX, rotation.x - offsetRotation.x);
						quaternionY.setFromAxisAngle(unitY, rotation.y - offsetRotation.y);
						quaternionZ.setFromAxisAngle(unitZ, rotation.z - offsetRotation.z);
					}

					if (scope.axis === "X") quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionX);
					if (scope.axis === "Y") quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionY);
					if (scope.axis === "Z") quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionZ);

					scope.object.quaternion.copy(quaternionXYZ);
				} else if (scope.space === "world") {

					rotation.set(Math.atan2(point.z, point.y), Math.atan2(point.x, point.z), Math.atan2(point.y, point.x));
					offsetRotation.set(Math.atan2(tempVector.z, tempVector.y), Math.atan2(tempVector.x, tempVector.z), Math.atan2(tempVector.y, tempVector.x));

					tempQuaternion.setFromRotationMatrix(tempMatrix.getInverse(parentRotationMatrix));

					if (scope.rotationSnap !== null) {

						quaternionX.setFromAxisAngle(unitX, Math.round((rotation.x - offsetRotation.x) / scope.rotationSnap) * scope.rotationSnap);
						quaternionY.setFromAxisAngle(unitY, Math.round((rotation.y - offsetRotation.y) / scope.rotationSnap) * scope.rotationSnap);
						quaternionZ.setFromAxisAngle(unitZ, Math.round((rotation.z - offsetRotation.z) / scope.rotationSnap) * scope.rotationSnap);
					} else {

						quaternionX.setFromAxisAngle(unitX, rotation.x - offsetRotation.x);
						quaternionY.setFromAxisAngle(unitY, rotation.y - offsetRotation.y);
						quaternionZ.setFromAxisAngle(unitZ, rotation.z - offsetRotation.z);
					}

					quaternionXYZ.setFromRotationMatrix(worldRotationMatrix);

					if (scope.axis === "X") tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);
					if (scope.axis === "Y") tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionY);
					if (scope.axis === "Z") tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionZ);

					tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);

					scope.object.quaternion.copy(tempQuaternion);
				}
			}

			scope.update();
			scope.dispatchEvent(changeEvent);
			scope.dispatchEvent(objectChangeEvent);
		}

		function onPointerUp(event) {

			event.preventDefault(); // Prevent MouseEvent on mobile

			if (event.button !== undefined && event.button !== 0) return;

			if (_dragging && scope.axis !== null) {

				mouseUpEvent.mode = _mode;
				scope.dispatchEvent(mouseUpEvent);
			}

			_dragging = false;

			if ('TouchEvent' in window && event instanceof TouchEvent) {

				// Force "rollover"

				scope.axis = null;
				scope.update();
				scope.dispatchEvent(changeEvent);
			} else {

				onPointerHover(event);
			}
		}

		function intersectObjects(pointer, objects) {

			var rect = domElement.getBoundingClientRect();
			var x = (pointer.clientX - rect.left) / rect.width;
			var y = (pointer.clientY - rect.top) / rect.height;

			pointerVector.set(x * 2 - 1, -(y * 2) + 1);
			ray.setFromCamera(pointerVector, camera);

			var intersections = ray.intersectObjects(objects, true);
			return intersections[0] ? intersections[0] : false;
		}
	};

	TransformControls.prototype = Object.create(THREE.Object3D.prototype);
	TransformControls.prototype.constructor = TransformControls;

	return TransformControls;
}();

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author dmarcos / https://github.com/dmarcos
 * @author mrdoob / http://mrdoob.com
 */

var VRControls = function VRControls(object, onError) {

	var scope = this;

	var vrDisplay, vrDisplays;

	var standingMatrix = new THREE.Matrix4();

	var frameData = null;

	if ('VRFrameData' in window) {

		frameData = new VRFrameData();
	}

	function gotVRDisplays(displays) {

		vrDisplays = displays;

		if (displays.length > 0) {

			vrDisplay = displays[0];
		} else {

			if (onError) onError('VR input not available.');
		}
	}

	if (navigator.getVRDisplays) {

		navigator.getVRDisplays().then(gotVRDisplays).catch(function () {

			console.warn('THREE.VRControls: Unable to get VR Displays');
		});
	}

	// the Rift SDK returns the position in meters
	// this scale factor allows the user to define how meters
	// are converted to scene units.

	this.scale = 1;

	// If true will use "standing space" coordinate system where y=0 is the
	// floor and x=0, z=0 is the center of the room.
	this.standing = false;

	// Distance from the users eyes to the floor in meters. Used when
	// standing=true but the VRDisplay doesn't provide stageParameters.
	this.userHeight = 1.6;

	this.getVRDisplay = function () {

		return vrDisplay;
	};

	this.setVRDisplay = function (value) {

		vrDisplay = value;
	};

	this.getVRDisplays = function () {

		console.warn('THREE.VRControls: getVRDisplays() is being deprecated.');
		return vrDisplays;
	};

	this.getStandingMatrix = function () {

		return standingMatrix;
	};

	this.update = function () {

		if (vrDisplay) {

			var pose;

			if (vrDisplay.getFrameData) {

				vrDisplay.getFrameData(frameData);
				pose = frameData.pose;
			} else if (vrDisplay.getPose) {

				pose = vrDisplay.getPose();
			}

			if (pose.orientation !== null) {

				object.quaternion.fromArray(pose.orientation);
			}

			if (pose.position !== null) {

				object.position.fromArray(pose.position);
			} else {

				object.position.set(0, 0, 0);
			}

			if (this.standing) {

				if (vrDisplay.stageParameters) {

					object.updateMatrix();

					standingMatrix.fromArray(vrDisplay.stageParameters.sittingToStandingTransform);
					object.applyMatrix(standingMatrix);
				} else {

					object.position.setY(object.position.y + this.userHeight);
				}
			}

			object.position.multiplyScalar(scope.scale);
		}
	};

	this.dispose = function () {

		vrDisplay = null;
	};
};

exports.default = VRControls;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TypedGeometryExporter = exports.STLExporter = exports.STLBinaryExporter = exports.PLYExporter = exports.OBJExporter = exports.MMDExporter = exports.GLTFExporter = undefined;

var _GLTFExporter = __webpack_require__(41);

var _GLTFExporter2 = _interopRequireDefault(_GLTFExporter);

var _MMDExporter = __webpack_require__(42);

var _MMDExporter2 = _interopRequireDefault(_MMDExporter);

var _OBJExporter = __webpack_require__(43);

var _OBJExporter2 = _interopRequireDefault(_OBJExporter);

var _PLYExporter = __webpack_require__(44);

var _PLYExporter2 = _interopRequireDefault(_PLYExporter);

var _STLBinaryExporter = __webpack_require__(45);

var _STLBinaryExporter2 = _interopRequireDefault(_STLBinaryExporter);

var _STLExporter = __webpack_require__(46);

var _STLExporter2 = _interopRequireDefault(_STLExporter);

var _TypedGeometryExporter = __webpack_require__(47);

var _TypedGeometryExporter2 = _interopRequireDefault(_TypedGeometryExporter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.GLTFExporter = _GLTFExporter2.default;
exports.MMDExporter = _MMDExporter2.default;
exports.OBJExporter = _OBJExporter2.default;
exports.PLYExporter = _PLYExporter2.default;
exports.STLBinaryExporter = _STLBinaryExporter2.default;
exports.STLExporter = _STLExporter2.default;
exports.TypedGeometryExporter = _TypedGeometryExporter2.default;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author fernandojsg / http://fernandojsg.com
 * @author Don McCurdy / https://www.donmccurdy.com
 * @author Takahiro / https://github.com/takahirox
 */

//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------
var WEBGL_CONSTANTS = {
	POINTS: 0x0000,
	LINES: 0x0001,
	LINE_LOOP: 0x0002,
	LINE_STRIP: 0x0003,
	TRIANGLES: 0x0004,
	TRIANGLE_STRIP: 0x0005,
	TRIANGLE_FAN: 0x0006,

	UNSIGNED_BYTE: 0x1401,
	UNSIGNED_SHORT: 0x1403,
	FLOAT: 0x1406,
	UNSIGNED_INT: 0x1405,
	ARRAY_BUFFER: 0x8892,
	ELEMENT_ARRAY_BUFFER: 0x8893,

	NEAREST: 0x2600,
	LINEAR: 0x2601,
	NEAREST_MIPMAP_NEAREST: 0x2700,
	LINEAR_MIPMAP_NEAREST: 0x2701,
	NEAREST_MIPMAP_LINEAR: 0x2702,
	LINEAR_MIPMAP_LINEAR: 0x2703
};

var THREE_TO_WEBGL = {
	// @TODO Replace with computed property name [THREE.*] when available on es6
	1003: WEBGL_CONSTANTS.NEAREST,
	1004: WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST,
	1005: WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR,
	1006: WEBGL_CONSTANTS.LINEAR,
	1007: WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST,
	1008: WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR
};

var PATH_PROPERTIES = {
	scale: 'scale',
	position: 'translation',
	quaternion: 'rotation',
	morphTargetInfluences: 'weights'
};

//------------------------------------------------------------------------------
// GLTF Exporter
//------------------------------------------------------------------------------
var GLTFExporter = function GLTFExporter() {};

GLTFExporter.prototype = {

	constructor: GLTFExporter,

	/**
  * Parse scenes and generate GLTF output
  * @param  {THREE.Scene or [THREE.Scenes]} input   THREE.Scene or Array of THREE.Scenes
  * @param  {Function} onDone  Callback on completed
  * @param  {Object} options options
  */
	parse: function parse(input, onDone, options) {

		var DEFAULT_OPTIONS = {
			trs: false,
			onlyVisible: true,
			truncateDrawRange: true,
			embedImages: true,
			animations: [],
			forceIndices: false,
			forcePowerOfTwoTextures: false
		};

		options = Object.assign({}, DEFAULT_OPTIONS, options);

		if (options.animations.length > 0) {

			// Only TRS properties, and not matrices, may be targeted by animation.
			options.trs = true;
		}

		var outputJSON = {

			asset: {

				version: "2.0",
				generator: "THREE.GLTFExporter"

			}

		};

		var byteOffset = 0;
		var buffers = [];
		var pending = [];
		var nodeMap = new Map();
		var skins = [];
		var extensionsUsed = {};
		var cachedData = {

			attributes: new Map(),
			materials: new Map(),
			textures: new Map()

		};

		var cachedCanvas;

		/**
   * Compare two arrays
   */
		/**
   * Compare two arrays
   * @param  {Array} array1 Array 1 to compare
   * @param  {Array} array2 Array 2 to compare
   * @return {Boolean}        Returns true if both arrays are equal
   */
		function equalArray(array1, array2) {

			return array1.length === array2.length && array1.every(function (element, index) {

				return element === array2[index];
			});
		}

		/**
   * Converts a string to an ArrayBuffer.
   * @param  {string} text
   * @return {ArrayBuffer}
   */
		function stringToArrayBuffer(text) {

			if (window.TextEncoder !== undefined) {

				return new TextEncoder().encode(text).buffer;
			}

			var array = new Uint8Array(new ArrayBuffer(text.length));

			for (var i = 0, il = text.length; i < il; i++) {

				var value = text.charCodeAt(i);

				// Replacing multi-byte character with space(0x20).
				array[i] = value > 0xFF ? 0x20 : value;
			}

			return array.buffer;
		}

		/**
   * Get the min and max vectors from the given attribute
   * @param  {THREE.BufferAttribute} attribute Attribute to find the min/max in range from start to start + count
   * @param  {Integer} start
   * @param  {Integer} count
   * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)
   */
		function getMinMax(attribute, start, count) {

			var output = {

				min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),
				max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)

			};

			for (var i = start; i < start + count; i++) {

				for (var a = 0; a < attribute.itemSize; a++) {

					var value = attribute.array[i * attribute.itemSize + a];
					output.min[a] = Math.min(output.min[a], value);
					output.max[a] = Math.max(output.max[a], value);
				}
			}

			return output;
		}

		/**
   * Checks if image size is POT.
   *
   * @param {Image} image The image to be checked.
   * @returns {Boolean} Returns true if image size is POT.
   *
   */
		function isPowerOfTwo(image) {

			return THREE.Math.isPowerOfTwo(image.width) && THREE.Math.isPowerOfTwo(image.height);
		}

		/**
   * Checks if normal attribute values are normalized.
   *
   * @param {THREE.BufferAttribute} normal
   * @returns {Boolean}
   *
   */
		function isNormalizedNormalAttribute(normal) {

			if (cachedData.attributes.has(normal)) {

				return false;
			}

			var v = new THREE.Vector3();

			for (var i = 0, il = normal.count; i < il; i++) {

				// 0.0005 is from glTF-validator
				if (Math.abs(v.fromArray(normal.array, i * 3).length() - 1.0) > 0.0005) return false;
			}

			return true;
		}

		/**
   * Creates normalized normal buffer attribute.
   *
   * @param {THREE.BufferAttribute} normal
   * @returns {THREE.BufferAttribute}
   *
   */
		function createNormalizedNormalAttribute(normal) {

			if (cachedData.attributes.has(normal)) {

				return cachedData.textures.get(normal);
			}

			var attribute = normal.clone();

			var v = new THREE.Vector3();

			for (var i = 0, il = attribute.count; i < il; i++) {

				v.fromArray(attribute.array, i * 3);

				if (v.x === 0 && v.y === 0 && v.z === 0) {

					// if values can't be normalized set (1, 0, 0)
					v.setX(1.0);
				} else {

					v.normalize();
				}

				v.toArray(attribute.array, i * 3);
			}

			cachedData.attributes.set(normal, attribute);

			return attribute;
		}

		/**
   * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.
   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment
   *
   * @param {Integer} bufferSize The size the original buffer.
   * @returns {Integer} new buffer size with required padding.
   *
   */
		function getPaddedBufferSize(bufferSize) {

			return Math.ceil(bufferSize / 4) * 4;
		}

		/**
   * Returns a buffer aligned to 4-byte boundary.
   *
   * @param {ArrayBuffer} arrayBuffer Buffer to pad
   * @param {Integer} paddingByte (Optional)
   * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer
   */
		function getPaddedArrayBuffer(arrayBuffer, paddingByte) {

			paddingByte = paddingByte || 0;

			var paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);

			if (paddedLength !== arrayBuffer.byteLength) {

				var array = new Uint8Array(paddedLength);
				array.set(new Uint8Array(arrayBuffer));

				if (paddingByte !== 0) {

					for (var i = arrayBuffer.byteLength; i < paddedLength; i++) {

						array[i] = paddingByte;
					}
				}

				return array.buffer;
			}

			return arrayBuffer;
		}

		/**
   * Process a buffer to append to the default one.
   * @param  {ArrayBuffer} buffer
   * @return {Integer}
   */
		function processBuffer(buffer) {

			if (!outputJSON.buffers) {

				outputJSON.buffers = [{ byteLength: 0 }];
			}

			// All buffers are merged before export.
			buffers.push(buffer);

			return 0;
		}

		/**
   * Process and generate a BufferView
   * @param  {THREE.BufferAttribute} attribute
   * @param  {number} componentType
   * @param  {number} start
   * @param  {number} count
   * @param  {number} target (Optional) Target usage of the BufferView
   * @return {Object}
   */
		function processBufferView(attribute, componentType, start, count, target) {

			if (!outputJSON.bufferViews) {

				outputJSON.bufferViews = [];
			}

			// Create a new dataview and dump the attribute's array into it

			var componentSize;

			if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {

				componentSize = 1;
			} else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {

				componentSize = 2;
			} else {

				componentSize = 4;
			}

			var byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize);
			var dataView = new DataView(new ArrayBuffer(byteLength));
			var offset = 0;

			for (var i = start; i < start + count; i++) {

				for (var a = 0; a < attribute.itemSize; a++) {

					// @TODO Fails on InterleavedBufferAttribute, and could probably be
					// optimized for normal BufferAttribute.
					var value = attribute.array[i * attribute.itemSize + a];

					if (componentType === WEBGL_CONSTANTS.FLOAT) {

						dataView.setFloat32(offset, value, true);
					} else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {

						dataView.setUint32(offset, value, true);
					} else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {

						dataView.setUint16(offset, value, true);
					} else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {

						dataView.setUint8(offset, value);
					}

					offset += componentSize;
				}
			}

			var gltfBufferView = {

				buffer: processBuffer(dataView.buffer),
				byteOffset: byteOffset,
				byteLength: byteLength

			};

			if (target !== undefined) gltfBufferView.target = target;

			if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {

				// Only define byteStride for vertex attributes.
				gltfBufferView.byteStride = attribute.itemSize * componentSize;
			}

			byteOffset += byteLength;

			outputJSON.bufferViews.push(gltfBufferView);

			// @TODO Merge bufferViews where possible.
			var output = {

				id: outputJSON.bufferViews.length - 1,
				byteLength: 0

			};

			return output;
		}

		/**
   * Process and generate a BufferView from an image Blob.
   * @param {Blob} blob
   * @return {Promise<Integer>}
   */
		function processBufferViewImage(blob) {

			if (!outputJSON.bufferViews) {

				outputJSON.bufferViews = [];
			}

			return new Promise(function (resolve) {

				var reader = new window.FileReader();
				reader.readAsArrayBuffer(blob);
				reader.onloadend = function () {

					var buffer = getPaddedArrayBuffer(reader.result);

					var bufferView = {
						buffer: processBuffer(buffer),
						byteOffset: byteOffset,
						byteLength: buffer.byteLength
					};

					byteOffset += buffer.byteLength;

					outputJSON.bufferViews.push(bufferView);

					resolve(outputJSON.bufferViews.length - 1);
				};
			});
		}

		/**
   * Process attribute to generate an accessor
   * @param  {THREE.BufferAttribute} attribute Attribute to process
   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range
   * @param  {Integer} start (Optional)
   * @param  {Integer} count (Optional)
   * @return {Integer}           Index of the processed accessor on the "accessors" array
   */
		function processAccessor(attribute, geometry, start, count) {

			var types = {

				1: 'SCALAR',
				2: 'VEC2',
				3: 'VEC3',
				4: 'VEC4',
				16: 'MAT4'

			};

			var componentType;

			// Detect the component type of the attribute array (float, uint or ushort)
			if (attribute.array.constructor === Float32Array) {

				componentType = WEBGL_CONSTANTS.FLOAT;
			} else if (attribute.array.constructor === Uint32Array) {

				componentType = WEBGL_CONSTANTS.UNSIGNED_INT;
			} else if (attribute.array.constructor === Uint16Array) {

				componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;
			} else if (attribute.array.constructor === Uint8Array) {

				componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;
			} else {

				throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.');
			}

			if (start === undefined) start = 0;
			if (count === undefined) count = attribute.count;

			// @TODO Indexed buffer geometry with drawRange not supported yet
			if (options.truncateDrawRange && geometry !== undefined && geometry.index === null) {

				var end = start + count;
				var end2 = geometry.drawRange.count === Infinity ? attribute.count : geometry.drawRange.start + geometry.drawRange.count;

				start = Math.max(start, geometry.drawRange.start);
				count = Math.min(end, end2) - start;

				if (count < 0) count = 0;
			}

			// Skip creating an accessor if the attribute doesn't have data to export
			if (count === 0) {

				return null;
			}

			var minMax = getMinMax(attribute, start, count);

			var bufferViewTarget;

			// If geometry isn't provided, don't infer the target usage of the bufferView. For
			// animation samplers, target must not be set.
			if (geometry !== undefined) {

				bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;
			}

			var bufferView = processBufferView(attribute, componentType, start, count, bufferViewTarget);

			var gltfAccessor = {

				bufferView: bufferView.id,
				byteOffset: bufferView.byteOffset,
				componentType: componentType,
				count: count,
				max: minMax.max,
				min: minMax.min,
				type: types[attribute.itemSize]

			};

			if (!outputJSON.accessors) {

				outputJSON.accessors = [];
			}

			outputJSON.accessors.push(gltfAccessor);

			return outputJSON.accessors.length - 1;
		}

		/**
   * Process image
   * @param  {Texture} map Texture to process
   * @return {Integer}     Index of the processed texture in the "images" array
   */
		function processImage(map) {

			// @TODO Cache

			if (!outputJSON.images) {

				outputJSON.images = [];
			}

			var mimeType = map.format === THREE.RGBAFormat ? 'image/png' : 'image/jpeg';
			var gltfImage = { mimeType: mimeType };

			if (options.embedImages) {

				var canvas = cachedCanvas = cachedCanvas || document.createElement('canvas');

				canvas.width = map.image.width;
				canvas.height = map.image.height;

				if (options.forcePowerOfTwoTextures && !isPowerOfTwo(map.image)) {

					console.warn('GLTFExporter: Resized non-power-of-two image.', map.image);

					canvas.width = THREE.Math.floorPowerOfTwo(canvas.width);
					canvas.height = THREE.Math.floorPowerOfTwo(canvas.height);
				}

				var ctx = canvas.getContext('2d');

				if (map.flipY === true) {

					ctx.translate(0, canvas.height);
					ctx.scale(1, -1);
				}

				ctx.drawImage(map.image, 0, 0, canvas.width, canvas.height);

				if (options.binary === true) {

					pending.push(new Promise(function (resolve) {

						canvas.toBlob(function (blob) {

							processBufferViewImage(blob).then(function (bufferViewIndex) {

								gltfImage.bufferView = bufferViewIndex;

								resolve();
							});
						}, mimeType);
					}));
				} else {

					gltfImage.uri = canvas.toDataURL(mimeType);
				}
			} else {

				gltfImage.uri = map.image.src;
			}

			outputJSON.images.push(gltfImage);

			return outputJSON.images.length - 1;
		}

		/**
   * Process sampler
   * @param  {Texture} map Texture to process
   * @return {Integer}     Index of the processed texture in the "samplers" array
   */
		function processSampler(map) {

			if (!outputJSON.samplers) {

				outputJSON.samplers = [];
			}

			var gltfSampler = {

				magFilter: THREE_TO_WEBGL[map.magFilter],
				minFilter: THREE_TO_WEBGL[map.minFilter],
				wrapS: THREE_TO_WEBGL[map.wrapS],
				wrapT: THREE_TO_WEBGL[map.wrapT]

			};

			outputJSON.samplers.push(gltfSampler);

			return outputJSON.samplers.length - 1;
		}

		/**
   * Process texture
   * @param  {Texture} map Map to process
   * @return {Integer}     Index of the processed texture in the "textures" array
   */
		function processTexture(map) {

			if (cachedData.textures.has(map)) {

				return cachedData.textures.get(map);
			}

			if (!outputJSON.textures) {

				outputJSON.textures = [];
			}

			var gltfTexture = {

				sampler: processSampler(map),
				source: processImage(map)

			};

			outputJSON.textures.push(gltfTexture);

			var index = outputJSON.textures.length - 1;
			cachedData.textures.set(map, index);

			return index;
		}

		/**
   * Process material
   * @param  {THREE.Material} material Material to process
   * @return {Integer}      Index of the processed material in the "materials" array
   */
		function processMaterial(material) {

			if (cachedData.materials.has(material)) {

				return cachedData.materials.get(material);
			}

			if (!outputJSON.materials) {

				outputJSON.materials = [];
			}

			if (material.isShaderMaterial) {

				console.warn('GLTFExporter: THREE.ShaderMaterial not supported.');
				return null;
			}

			// @QUESTION Should we avoid including any attribute that has the default value?
			var gltfMaterial = {

				pbrMetallicRoughness: {}

			};

			if (material.isMeshBasicMaterial) {

				gltfMaterial.extensions = { KHR_materials_unlit: {} };

				extensionsUsed['KHR_materials_unlit'] = true;
			} else if (!material.isMeshStandardMaterial) {

				console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');
			}

			// pbrMetallicRoughness.baseColorFactor
			var color = material.color.toArray().concat([material.opacity]);

			if (!equalArray(color, [1, 1, 1, 1])) {

				gltfMaterial.pbrMetallicRoughness.baseColorFactor = color;
			}

			if (material.isMeshStandardMaterial) {

				gltfMaterial.pbrMetallicRoughness.metallicFactor = material.metalness;
				gltfMaterial.pbrMetallicRoughness.roughnessFactor = material.roughness;
			} else if (material.isMeshBasicMaterial) {

				gltfMaterial.pbrMetallicRoughness.metallicFactor = 0.0;
				gltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.9;
			} else {

				gltfMaterial.pbrMetallicRoughness.metallicFactor = 0.5;
				gltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.5;
			}

			// pbrMetallicRoughness.metallicRoughnessTexture
			if (material.metalnessMap || material.roughnessMap) {

				if (material.metalnessMap === material.roughnessMap) {

					gltfMaterial.pbrMetallicRoughness.metallicRoughnessTexture = {

						index: processTexture(material.metalnessMap)

					};
				} else {

					console.warn('THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.');
				}
			}

			// pbrMetallicRoughness.baseColorTexture
			if (material.map) {

				gltfMaterial.pbrMetallicRoughness.baseColorTexture = {

					index: processTexture(material.map)

				};
			}

			if (material.isMeshBasicMaterial || material.isLineBasicMaterial || material.isPointsMaterial) {} else {

				// emissiveFactor
				var emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity).toArray();

				if (!equalArray(emissive, [0, 0, 0])) {

					gltfMaterial.emissiveFactor = emissive;
				}

				// emissiveTexture
				if (material.emissiveMap) {

					gltfMaterial.emissiveTexture = {

						index: processTexture(material.emissiveMap)

					};
				}
			}

			// normalTexture
			if (material.normalMap) {

				gltfMaterial.normalTexture = {

					index: processTexture(material.normalMap)

				};

				if (material.normalScale.x !== -1) {

					if (material.normalScale.x !== material.normalScale.y) {

						console.warn('THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X.');
					}

					gltfMaterial.normalTexture.scale = material.normalScale.x;
				}
			}

			// occlusionTexture
			if (material.aoMap) {

				gltfMaterial.occlusionTexture = {

					index: processTexture(material.aoMap)

				};

				if (material.aoMapIntensity !== 1.0) {

					gltfMaterial.occlusionTexture.strength = material.aoMapIntensity;
				}
			}

			// alphaMode
			if (material.transparent || material.alphaTest > 0.0) {

				gltfMaterial.alphaMode = material.opacity < 1.0 ? 'BLEND' : 'MASK';

				// Write alphaCutoff if it's non-zero and different from the default (0.5).
				if (material.alphaTest > 0.0 && material.alphaTest !== 0.5) {

					gltfMaterial.alphaCutoff = material.alphaTest;
				}
			}

			// doubleSided
			if (material.side === THREE.DoubleSide) {

				gltfMaterial.doubleSided = true;
			}

			if (material.name !== '') {

				gltfMaterial.name = material.name;
			}

			outputJSON.materials.push(gltfMaterial);

			var index = outputJSON.materials.length - 1;
			cachedData.materials.set(material, index);

			return index;
		}

		/**
   * Process mesh
   * @param  {THREE.Mesh} mesh Mesh to process
   * @return {Integer}      Index of the processed mesh in the "meshes" array
   */
		function processMesh(mesh) {

			var geometry = mesh.geometry;

			var mode;

			// Use the correct mode
			if (mesh.isLineSegments) {

				mode = WEBGL_CONSTANTS.LINES;
			} else if (mesh.isLineLoop) {

				mode = WEBGL_CONSTANTS.LINE_LOOP;
			} else if (mesh.isLine) {

				mode = WEBGL_CONSTANTS.LINE_STRIP;
			} else if (mesh.isPoints) {

				mode = WEBGL_CONSTANTS.POINTS;
			} else {

				if (!geometry.isBufferGeometry) {

					var geometryTemp = new THREE.BufferGeometry();
					geometryTemp.fromGeometry(geometry);
					geometry = geometryTemp;
				}

				if (mesh.drawMode === THREE.TriangleFanDrawMode) {

					console.warn('GLTFExporter: TriangleFanDrawMode and wireframe incompatible.');
					mode = WEBGL_CONSTANTS.TRIANGLE_FAN;
				} else if (mesh.drawMode === THREE.TriangleStripDrawMode) {

					mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINE_STRIP : WEBGL_CONSTANTS.TRIANGLE_STRIP;
				} else {

					mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;
				}
			}

			var gltfMesh = {};

			var attributes = {};
			var primitives = [];
			var targets = [];

			// Conversion between attributes names in threejs and gltf spec
			var nameConversion = {

				uv: 'TEXCOORD_0',
				uv2: 'TEXCOORD_1',
				color: 'COLOR_0',
				skinWeight: 'WEIGHTS_0',
				skinIndex: 'JOINTS_0'

			};

			var originalNormal = geometry.getAttribute('normal');

			if (originalNormal !== undefined && !isNormalizedNormalAttribute(originalNormal)) {

				console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');

				geometry.addAttribute('normal', createNormalizedNormalAttribute(originalNormal));
			}

			// @QUESTION Detect if .vertexColors = THREE.VertexColors?
			// For every attribute create an accessor
			for (var attributeName in geometry.attributes) {

				var attribute = geometry.attributes[attributeName];
				attributeName = nameConversion[attributeName] || attributeName.toUpperCase();

				// JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.
				var array = attribute.array;
				if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {

					console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.');
					attribute = new THREE.BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);
				}

				if (attributeName.substr(0, 5) !== 'MORPH') {

					var accessor = processAccessor(attribute, geometry);
					if (accessor !== null) {

						attributes[attributeName] = accessor;
					}
				}
			}

			if (originalNormal !== undefined) geometry.addAttribute('normal', originalNormal);

			// Skip if no exportable attributes found
			if (Object.keys(attributes).length === 0) {

				return null;
			}

			// Morph targets
			if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {

				var weights = [];
				var targetNames = [];
				var reverseDictionary = {};

				if (mesh.morphTargetDictionary !== undefined) {

					for (var key in mesh.morphTargetDictionary) {

						reverseDictionary[mesh.morphTargetDictionary[key]] = key;
					}
				}

				for (var i = 0; i < mesh.morphTargetInfluences.length; ++i) {

					var target = {};

					var warned = false;

					for (var attributeName in geometry.morphAttributes) {

						// glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.
						// Three.js doesn't support TANGENT yet.

						if (attributeName !== 'position' && attributeName !== 'normal') {

							if (!warned) {

								console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');
								warned = true;
							}

							continue;
						}

						var attribute = geometry.morphAttributes[attributeName][i];

						// Three.js morph attribute has absolute values while the one of glTF has relative values.
						//
						// glTF 2.0 Specification:
						// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets

						var baseAttribute = geometry.attributes[attributeName];
						// Clones attribute not to override
						var relativeAttribute = attribute.clone();

						for (var j = 0, jl = attribute.count; j < jl; j++) {

							relativeAttribute.setXYZ(j, attribute.getX(j) - baseAttribute.getX(j), attribute.getY(j) - baseAttribute.getY(j), attribute.getZ(j) - baseAttribute.getZ(j));
						}

						target[attributeName.toUpperCase()] = processAccessor(relativeAttribute, geometry);
					}

					targets.push(target);

					weights.push(mesh.morphTargetInfluences[i]);
					if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[i]);
				}

				gltfMesh.weights = weights;

				if (targetNames.length > 0) {

					gltfMesh.extras = {};
					gltfMesh.extras.targetNames = targetNames;
				}
			}

			var forceIndices = options.forceIndices;
			var isMultiMaterial = Array.isArray(mesh.material);

			if (isMultiMaterial && mesh.geometry.groups.length === 0) return null;

			if (!forceIndices && geometry.index === null && isMultiMaterial) {

				// temporal workaround.
				console.warn('THREE.GLTFExporter: Creating index for non-indexed multi-material mesh.');
				forceIndices = true;
			}

			var didForceIndices = false;

			if (geometry.index === null && forceIndices) {

				var indices = [];

				for (var i = 0, il = geometry.attributes.position.count; i < il; i++) {

					indices[i] = i;
				}

				geometry.setIndex(indices);

				didForceIndices = true;
			}

			var materials = isMultiMaterial ? mesh.material : [mesh.material];
			var groups = isMultiMaterial ? mesh.geometry.groups : [{ materialIndex: 0, start: undefined, count: undefined }];

			for (var i = 0, il = groups.length; i < il; i++) {

				var primitive = {
					mode: mode,
					attributes: attributes
				};

				if (targets.length > 0) primitive.targets = targets;

				if (geometry.index !== null) {

					primitive.indices = processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);
				}

				var material = processMaterial(materials[groups[i].materialIndex]);

				if (material !== null) {

					primitive.material = material;
				}

				primitives.push(primitive);
			}

			if (didForceIndices) {

				geometry.setIndex(null);
			}

			gltfMesh.primitives = primitives;

			if (!outputJSON.meshes) {

				outputJSON.meshes = [];
			}

			outputJSON.meshes.push(gltfMesh);

			return outputJSON.meshes.length - 1;
		}

		/**
   * Process camera
   * @param  {THREE.Camera} camera Camera to process
   * @return {Integer}      Index of the processed mesh in the "camera" array
   */
		function processCamera(camera) {

			if (!outputJSON.cameras) {

				outputJSON.cameras = [];
			}

			var isOrtho = camera.isOrthographicCamera;

			var gltfCamera = {

				type: isOrtho ? 'orthographic' : 'perspective'

			};

			if (isOrtho) {

				gltfCamera.orthographic = {

					xmag: camera.right * 2,
					ymag: camera.top * 2,
					zfar: camera.far <= 0 ? 0.001 : camera.far,
					znear: camera.near < 0 ? 0 : camera.near

				};
			} else {

				gltfCamera.perspective = {

					aspectRatio: camera.aspect,
					yfov: THREE.Math.degToRad(camera.fov) / camera.aspect,
					zfar: camera.far <= 0 ? 0.001 : camera.far,
					znear: camera.near < 0 ? 0 : camera.near

				};
			}

			if (camera.name !== '') {

				gltfCamera.name = camera.type;
			}

			outputJSON.cameras.push(gltfCamera);

			return outputJSON.cameras.length - 1;
		}

		/**
   * Creates glTF animation entry from AnimationClip object.
   *
   * Status:
   * - Only properties listed in PATH_PROPERTIES may be animated.
   *
   * @param {THREE.AnimationClip} clip
   * @param {THREE.Object3D} root
   * @return {number}
   */
		function processAnimation(clip, root) {

			if (!outputJSON.animations) {

				outputJSON.animations = [];
			}

			var channels = [];
			var samplers = [];

			for (var i = 0; i < clip.tracks.length; ++i) {

				var track = clip.tracks[i];
				var trackBinding = THREE.PropertyBinding.parseTrackName(track.name);
				var trackNode = THREE.PropertyBinding.findNode(root, trackBinding.nodeName);
				var trackProperty = PATH_PROPERTIES[trackBinding.propertyName];

				if (trackBinding.objectName === 'bones') {

					if (trackNode.isSkinnedMesh === true) {

						trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);
					} else {

						trackNode = undefined;
					}
				}

				if (!trackNode || !trackProperty) {

					console.warn('THREE.GLTFExporter: Could not export animation track "%s".', track.name);
					return null;
				}

				var inputItemSize = 1;
				var outputItemSize = track.values.length / track.times.length;

				if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {

					outputItemSize /= trackNode.morphTargetInfluences.length;
				}

				var interpolation;

				// @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE

				// Detecting glTF cubic spline interpolant by checking factory method's special property
				// GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return
				// valid value from .getInterpolation().
				if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {

					interpolation = 'CUBICSPLINE';

					// itemSize of CUBICSPLINE keyframe is 9
					// (VEC3 * 3: inTangent, splineVertex, and outTangent)
					// but needs to be stored as VEC3 so dividing by 3 here.
					outputItemSize /= 3;
				} else if (track.getInterpolation() === THREE.InterpolateDiscrete) {

					interpolation = 'STEP';
				} else {

					interpolation = 'LINEAR';
				}

				samplers.push({

					input: processAccessor(new THREE.BufferAttribute(track.times, inputItemSize)),
					output: processAccessor(new THREE.BufferAttribute(track.values, outputItemSize)),
					interpolation: interpolation

				});

				channels.push({

					sampler: samplers.length - 1,
					target: {
						node: nodeMap.get(trackNode),
						path: trackProperty
					}

				});
			}

			outputJSON.animations.push({

				name: clip.name || 'clip_' + outputJSON.animations.length,
				samplers: samplers,
				channels: channels

			});

			return outputJSON.animations.length - 1;
		}

		function processSkin(object) {

			var node = outputJSON.nodes[nodeMap.get(object)];

			var skeleton = object.skeleton;
			var rootJoint = object.skeleton.bones[0];

			if (rootJoint === undefined) return null;

			var joints = [];
			var inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);

			for (var i = 0; i < skeleton.bones.length; ++i) {

				joints.push(nodeMap.get(skeleton.bones[i]));

				skeleton.boneInverses[i].toArray(inverseBindMatrices, i * 16);
			}

			if (outputJSON.skins === undefined) {

				outputJSON.skins = [];
			}

			outputJSON.skins.push({

				inverseBindMatrices: processAccessor(new THREE.BufferAttribute(inverseBindMatrices, 16)),
				joints: joints,
				skeleton: nodeMap.get(rootJoint)

			});

			var skinIndex = node.skin = outputJSON.skins.length - 1;

			return skinIndex;
		}

		/**
   * Process Object3D node
   * @param  {THREE.Object3D} node Object3D to processNode
   * @return {Integer}      Index of the node in the nodes list
   */
		function processNode(object) {

			if (object.isLight) {

				console.warn('GLTFExporter: Unsupported node type:', object.constructor.name);
				return null;
			}

			if (!outputJSON.nodes) {

				outputJSON.nodes = [];
			}

			var gltfNode = {};

			if (options.trs) {

				var rotation = object.quaternion.toArray();
				var position = object.position.toArray();
				var scale = object.scale.toArray();

				if (!equalArray(rotation, [0, 0, 0, 1])) {

					gltfNode.rotation = rotation;
				}

				if (!equalArray(position, [0, 0, 0])) {

					gltfNode.translation = position;
				}

				if (!equalArray(scale, [1, 1, 1])) {

					gltfNode.scale = scale;
				}
			} else {

				object.updateMatrix();
				if (!equalArray(object.matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])) {

					gltfNode.matrix = object.matrix.elements;
				}
			}

			// We don't export empty strings name because it represents no-name in Three.js.
			if (object.name !== '') {

				gltfNode.name = String(object.name);
			}

			if (object.userData && Object.keys(object.userData).length > 0) {

				try {

					gltfNode.extras = JSON.parse(JSON.stringify(object.userData));
				} catch (e) {

					throw new Error('THREE.GLTFExporter: userData can\'t be serialized');
				}
			}

			if (object.isMesh || object.isLine || object.isPoints) {

				var mesh = processMesh(object);

				if (mesh !== null) {

					gltfNode.mesh = mesh;
				}
			} else if (object.isCamera) {

				gltfNode.camera = processCamera(object);
			}

			if (object.isSkinnedMesh) {

				skins.push(object);
			}

			if (object.children.length > 0) {

				var children = [];

				for (var i = 0, l = object.children.length; i < l; i++) {

					var child = object.children[i];

					if (child.visible || options.onlyVisible === false) {

						var node = processNode(child);

						if (node !== null) {

							children.push(node);
						}
					}
				}

				if (children.length > 0) {

					gltfNode.children = children;
				}
			}

			outputJSON.nodes.push(gltfNode);

			var nodeIndex = outputJSON.nodes.length - 1;
			nodeMap.set(object, nodeIndex);

			return nodeIndex;
		}

		/**
   * Process Scene
   * @param  {THREE.Scene} node Scene to process
   */
		function processScene(scene) {

			if (!outputJSON.scenes) {

				outputJSON.scenes = [];
				outputJSON.scene = 0;
			}

			var gltfScene = {

				nodes: []

			};

			if (scene.name !== '') {

				gltfScene.name = scene.name;
			}

			outputJSON.scenes.push(gltfScene);

			var nodes = [];

			for (var i = 0, l = scene.children.length; i < l; i++) {

				var child = scene.children[i];

				if (child.visible || options.onlyVisible === false) {

					var node = processNode(child);

					if (node !== null) {

						nodes.push(node);
					}
				}
			}

			if (nodes.length > 0) {

				gltfScene.nodes = nodes;
			}
		}

		/**
   * Creates a THREE.Scene to hold a list of objects and parse it
   * @param  {Array} objects List of objects to process
   */
		function processObjects(objects) {

			var scene = new THREE.Scene();
			scene.name = 'AuxScene';

			for (var i = 0; i < objects.length; i++) {

				// We push directly to children instead of calling `add` to prevent
				// modify the .parent and break its original scene and hierarchy
				scene.children.push(objects[i]);
			}

			processScene(scene);
		}

		function processInput(input) {

			input = input instanceof Array ? input : [input];

			var objectsWithoutScene = [];

			for (var i = 0; i < input.length; i++) {

				if (input[i] instanceof THREE.Scene) {

					processScene(input[i]);
				} else {

					objectsWithoutScene.push(input[i]);
				}
			}

			if (objectsWithoutScene.length > 0) {

				processObjects(objectsWithoutScene);
			}

			for (var i = 0; i < skins.length; ++i) {

				processSkin(skins[i]);
			}

			for (var i = 0; i < options.animations.length; ++i) {

				processAnimation(options.animations[i], input[0]);
			}
		}

		processInput(input);

		Promise.all(pending).then(function () {

			// Merge buffers.
			var blob = new Blob(buffers, { type: 'application/octet-stream' });

			// Declare extensions.
			var extensionsUsedList = Object.keys(extensionsUsed);
			if (extensionsUsedList.length > 0) outputJSON.extensionsUsed = extensionsUsedList;

			if (outputJSON.buffers && outputJSON.buffers.length > 0) {

				// Update bytelength of the single buffer.
				outputJSON.buffers[0].byteLength = blob.size;

				var reader = new window.FileReader();

				if (options.binary === true) {

					// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification

					var GLB_HEADER_BYTES = 12;
					var GLB_HEADER_MAGIC = 0x46546C67;
					var GLB_VERSION = 2;

					var GLB_CHUNK_PREFIX_BYTES = 8;
					var GLB_CHUNK_TYPE_JSON = 0x4E4F534A;
					var GLB_CHUNK_TYPE_BIN = 0x004E4942;

					reader.readAsArrayBuffer(blob);
					reader.onloadend = function () {

						// Binary chunk.
						var binaryChunk = getPaddedArrayBuffer(reader.result);
						var binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
						binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);
						binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);

						// JSON chunk.
						var jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(outputJSON)), 0x20);
						var jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
						jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);
						jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);

						// GLB header.
						var header = new ArrayBuffer(GLB_HEADER_BYTES);
						var headerView = new DataView(header);
						headerView.setUint32(0, GLB_HEADER_MAGIC, true);
						headerView.setUint32(4, GLB_VERSION, true);
						var totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;
						headerView.setUint32(8, totalByteLength, true);

						var glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], { type: 'application/octet-stream' });

						var glbReader = new window.FileReader();
						glbReader.readAsArrayBuffer(glbBlob);
						glbReader.onloadend = function () {

							onDone(glbReader.result);
						};
					};
				} else {

					reader.readAsDataURL(blob);
					reader.onloadend = function () {

						var base64data = reader.result;
						outputJSON.buffers[0].uri = base64data;
						onDone(outputJSON);
					};
				}
			} else {

				onDone(outputJSON);
			}
		});
	}

};

exports.default = GLTFExporter;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _mmdParser = __webpack_require__(4);

var MMDParser = _interopRequireWildcard(_mmdParser);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author takahiro / http://github.com/takahirox
 *
 * Dependencies
 *  - mmd-parser https://github.com/takahirox/mmd-parser
 */

var MMDExporter = function MMDExporter() {

	// Unicode to Shift_JIS table
	var u2sTable;

	function unicodeToShiftjis(str) {

		if (u2sTable === undefined) {

			var encoder = new MMDParser.CharsetEncoder();
			var table = encoder.s2uTable;
			u2sTable = {};

			var keys = Object.keys(table);

			for (var i = 0, il = keys.length; i < il; i++) {

				var key = keys[i];

				var value = table[key];
				key = parseInt(key);

				u2sTable[value] = key;
			}
		}

		var array = [];

		for (var i = 0, il = str.length; i < il; i++) {

			var code = str.charCodeAt(i);

			var value = u2sTable[code];

			if (value === undefined) {

				throw 'cannot convert charcode 0x' + code.toString(16);
			} else if (value > 0xff) {

				array.push(value >> 8 & 0xff);
				array.push(value & 0xff);
			} else {

				array.push(value & 0xff);
			}
		}

		return new Uint8Array(array);
	}

	function getBindBones(skin) {

		// any more efficient ways?
		var poseSkin = skin.clone();
		poseSkin.pose();
		return poseSkin.skeleton.bones;
	}

	/* TODO: implement
 // mesh -> pmd
 this.parsePmd = function ( object ) {
 	};
 */

	/* TODO: implement
 // mesh -> pmx
 this.parsePmx = function ( object ) {
 	};
 */

	/*
  * skeleton -> vpd
  * Returns Shift_JIS encoded Uint8Array. Otherwise return strings.
  */
	this.parseVpd = function (skin, outputShiftJis, useOriginalBones) {

		if (skin.isSkinnedMesh !== true) {

			console.warn('THREE.MMDExporter: parseVpd() requires SkinnedMesh instance.');
			return null;
		}

		function toStringsFromNumber(num) {

			if (Math.abs(num) < 1e-6) num = 0;

			var a = num.toString();

			if (a.indexOf('.') === -1) {

				a += '.';
			}

			a += '000000';

			var index = a.indexOf('.');

			var d = a.slice(0, index);
			var p = a.slice(index + 1, index + 7);

			return d + '.' + p;
		}

		function toStringsFromArray(array) {

			var a = [];

			for (var i = 0, il = array.length; i < il; i++) {

				a.push(toStringsFromNumber(array[i]));
			}

			return a.join(',');
		}

		skin.updateMatrixWorld(true);

		var bones = skin.skeleton.bones;
		var bones2 = getBindBones(skin);

		var position = new THREE.Vector3();
		var quaternion = new THREE.Quaternion();
		var quaternion2 = new THREE.Quaternion();
		var matrix = new THREE.Matrix4();

		var array = [];
		array.push('Vocaloid Pose Data file');
		array.push('');
		array.push((skin.name !== '' ? skin.name.replace(/\s/g, '_') : 'skin') + '.osm;');
		array.push(bones.length + ';');
		array.push('');

		for (var i = 0, il = bones.length; i < il; i++) {

			var bone = bones[i];
			var bone2 = bones2[i];

			/*
    * use the bone matrix saved before solving IK.
    * see CCDIKSolver for the detail.
    */
			if (useOriginalBones === true && bone.userData.ik !== undefined && bone.userData.ik.originalMatrix !== undefined) {

				matrix.fromArray(bone.userData.ik.originalMatrix);
			} else {

				matrix.copy(bone.matrix);
			}

			position.setFromMatrixPosition(matrix);
			quaternion.setFromRotationMatrix(matrix);

			var pArray = position.sub(bone2.position).toArray();
			var qArray = quaternion2.copy(bone2.quaternion).conjugate().multiply(quaternion).toArray();

			// right to left
			pArray[2] = -pArray[2];
			qArray[0] = -qArray[0];
			qArray[1] = -qArray[1];

			array.push('Bone' + i + '{' + bone.name);
			array.push('  ' + toStringsFromArray(pArray) + ';');
			array.push('  ' + toStringsFromArray(qArray) + ';');
			array.push('}');
			array.push('');
		}

		array.push('');

		var lines = array.join('\n');

		return outputShiftJis === true ? unicodeToShiftjis(lines) : lines;
	};

	/* TODO: implement
 // animation + skeleton -> vmd
 this.parseVmd = function ( object ) {
 	};
 */
};

exports.default = MMDExporter;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author mrdoob / http://mrdoob.com/
 */

var OBJExporter = function OBJExporter() {};

OBJExporter.prototype = {

	constructor: OBJExporter,

	parse: function parse(object) {

		var output = '';

		var indexVertex = 0;
		var indexVertexUvs = 0;
		var indexNormals = 0;

		var vertex = new THREE.Vector3();
		var normal = new THREE.Vector3();
		var uv = new THREE.Vector2();

		var i,
		    j,
		    k,
		    l,
		    m,
		    face = [];

		var parseMesh = function parseMesh(mesh) {

			var nbVertex = 0;
			var nbNormals = 0;
			var nbVertexUvs = 0;

			var geometry = mesh.geometry;

			var normalMatrixWorld = new THREE.Matrix3();

			if (geometry instanceof THREE.Geometry) {

				geometry = new THREE.BufferGeometry().setFromObject(mesh);
			}

			if (geometry instanceof THREE.BufferGeometry) {

				// shortcuts
				var vertices = geometry.getAttribute('position');
				var normals = geometry.getAttribute('normal');
				var uvs = geometry.getAttribute('uv');
				var indices = geometry.getIndex();

				// name of the mesh object
				output += 'o ' + mesh.name + '\n';

				// name of the mesh material
				if (mesh.material && mesh.material.name) {

					output += 'usemtl ' + mesh.material.name + '\n';
				}

				// vertices

				if (vertices !== undefined) {

					for (i = 0, l = vertices.count; i < l; i++, nbVertex++) {

						vertex.x = vertices.getX(i);
						vertex.y = vertices.getY(i);
						vertex.z = vertices.getZ(i);

						// transfrom the vertex to world space
						vertex.applyMatrix4(mesh.matrixWorld);

						// transform the vertex to export format
						output += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\n';
					}
				}

				// uvs

				if (uvs !== undefined) {

					for (i = 0, l = uvs.count; i < l; i++, nbVertexUvs++) {

						uv.x = uvs.getX(i);
						uv.y = uvs.getY(i);

						// transform the uv to export format
						output += 'vt ' + uv.x + ' ' + uv.y + '\n';
					}
				}

				// normals

				if (normals !== undefined) {

					normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);

					for (i = 0, l = normals.count; i < l; i++, nbNormals++) {

						normal.x = normals.getX(i);
						normal.y = normals.getY(i);
						normal.z = normals.getZ(i);

						// transfrom the normal to world space
						normal.applyMatrix3(normalMatrixWorld);

						// transform the normal to export format
						output += 'vn ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\n';
					}
				}

				// faces

				if (indices !== null) {

					for (i = 0, l = indices.count; i < l; i += 3) {

						for (m = 0; m < 3; m++) {

							j = indices.getX(i + m) + 1;

							face[m] = indexVertex + j + (normals || uvs ? '/' + (uvs ? indexVertexUvs + j : '') + (normals ? '/' + (indexNormals + j) : '') : '');
						}

						// transform the face to export format
						output += 'f ' + face.join(' ') + "\n";
					}
				} else {

					for (i = 0, l = vertices.count; i < l; i += 3) {

						for (m = 0; m < 3; m++) {

							j = i + m + 1;

							face[m] = indexVertex + j + (normals || uvs ? '/' + (uvs ? indexVertexUvs + j : '') + (normals ? '/' + (indexNormals + j) : '') : '');
						}

						// transform the face to export format
						output += 'f ' + face.join(' ') + "\n";
					}
				}
			} else {

				console.warn('THREE.OBJExporter.parseMesh(): geometry type unsupported', geometry);
			}

			// update index
			indexVertex += nbVertex;
			indexVertexUvs += nbVertexUvs;
			indexNormals += nbNormals;
		};

		var parseLine = function parseLine(line) {

			var nbVertex = 0;

			var geometry = line.geometry;
			var type = line.type;

			if (geometry instanceof THREE.Geometry) {

				geometry = new THREE.BufferGeometry().setFromObject(line);
			}

			if (geometry instanceof THREE.BufferGeometry) {

				// shortcuts
				var vertices = geometry.getAttribute('position');

				// name of the line object
				output += 'o ' + line.name + '\n';

				if (vertices !== undefined) {

					for (i = 0, l = vertices.count; i < l; i++, nbVertex++) {

						vertex.x = vertices.getX(i);
						vertex.y = vertices.getY(i);
						vertex.z = vertices.getZ(i);

						// transfrom the vertex to world space
						vertex.applyMatrix4(line.matrixWorld);

						// transform the vertex to export format
						output += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\n';
					}
				}

				if (type === 'Line') {

					output += 'l ';

					for (j = 1, l = vertices.count; j <= l; j++) {

						output += indexVertex + j + ' ';
					}

					output += '\n';
				}

				if (type === 'LineSegments') {

					for (j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1) {

						output += 'l ' + (indexVertex + j) + ' ' + (indexVertex + k) + '\n';
					}
				}
			} else {

				console.warn('THREE.OBJExporter.parseLine(): geometry type unsupported', geometry);
			}

			// update index
			indexVertex += nbVertex;
		};

		object.traverse(function (child) {

			if (child instanceof THREE.Mesh) {

				parseMesh(child);
			}

			if (child instanceof THREE.Line) {

				parseLine(child);
			}
		});

		return output;
	}

};

exports.default = OBJExporter;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author Garrett Johnson / http://gkjohnson.github.io/
 * https://github.com/gkjohnson/ply-exporter-js
 *
 * Usage:
 *  var exporter = new THREE.PLYExporter();
 *
 *  // second argument is an array of attributes to
 *  // exclude from the format ('color', 'uv', 'normal')
 *  var data = exporter.parse(mesh, [ 'color' ]);
 *
 * Format Definition:
 *  http://paulbourke.net/dataformats/ply/
 */

var PLYExporter = function PLYExporter() {};

PLYExporter.prototype = {

	constructor: PLYExporter,

	parse: function parse(object, excludeProperties) {

		if (Array.isArray(excludeProperties) !== true) {

			excludeProperties = [];
		}

		var includeNormals = excludeProperties.indexOf('normal') === -1;
		var includeColors = excludeProperties.indexOf('color') === -1;
		var includeUVs = excludeProperties.indexOf('uv') === -1;

		// count the number of vertices
		var vertexCount = 0;
		var faceCount = 0;
		var vertexList = '';
		var faceList = '';

		var vertex = new THREE.Vector3();
		var normalMatrixWorld = new THREE.Matrix3();
		object.traverse(function (child) {

			if (child instanceof THREE.Mesh) {

				var mesh = child;
				var geometry = mesh.geometry;

				if (geometry instanceof THREE.Geometry) {

					geometry = new THREE.BufferGeometry().setFromObject(mesh);
				}

				if (geometry instanceof THREE.BufferGeometry) {

					var vertices = geometry.getAttribute('position');
					var normals = geometry.getAttribute('normal');
					var uvs = geometry.getAttribute('uv');
					var colors = geometry.getAttribute('color');
					var indices = geometry.getIndex();

					normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);

					if (vertices === undefined) {

						return;
					}

					// form each line
					for (var i = 0, l = vertices.count; i < l; i++) {

						vertex.x = vertices.getX(i);
						vertex.y = vertices.getY(i);
						vertex.z = vertices.getZ(i);

						vertex.applyMatrix4(mesh.matrixWorld);

						// Position information
						var line = vertex.x + ' ' + vertex.y + ' ' + vertex.z;

						// Normal information
						if (includeNormals === true) {

							if (normals !== undefined) {

								vertex.x = normals.getX(i);
								vertex.y = normals.getY(i);
								vertex.z = normals.getZ(i);

								vertex.applyMatrix3(normalMatrixWorld);

								line += ' ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z;
							} else {

								line += ' 0 0 0';
							}
						}

						// UV information
						if (includeUVs === true) {

							if (uvs !== undefined) {

								line += ' ' + uvs.getX(i) + ' ' + uvs.getY(i);
							} else if (includeUVs !== false) {

								line += ' 0 0';
							}
						}

						// Color information
						if (includeColors === true) {

							if (colors !== undefined) {

								line += ' ' + Math.floor(colors.getX(i)) + ' ' + Math.floor(colors.getY(i)) + ' ' + Math.floor(colors.getZ(i));
							} else {

								line += ' 255 255 255';
							}
						}

						vertexList += line + '\n';
					}

					// Create the face list
					if (indices !== null) {

						for (i = 0, l = indices.count; i < l; i += 3) {

							faceList += '3 ' + (indices.getX(i + 0) + vertexCount);
							faceList += ' ' + (indices.getX(i + 1) + vertexCount);
							faceList += ' ' + (indices.getX(i + 2) + vertexCount) + '\n';
						}
					} else {

						for (var i = 0, l = vertices.count; i < l; i += 3) {

							faceList += '3 ' + (vertexCount + i) + ' ' + (vertexCount + i + 1) + ' ' + (vertexCount + i + 2) + '\n';
						}
					}

					vertexCount += vertices.count;
					faceCount += indices ? indices.count / 3 : vertices.count / 3;
				}
			}
		});

		var output = 'ply\n' + 'format ascii 1.0\n' + ('element vertex ' + vertexCount + '\n') +

		// position
		'property float x\n' + 'property float y\n' + 'property float z\n';

		if (includeNormals === true) {

			// normal
			output += 'property float nx\n' + 'property float ny\n' + 'property float nz\n';
		}

		if (includeUVs === true) {

			// uvs
			output += 'property float s\n' + 'property float t\n';
		}

		if (includeColors === true) {

			// colors
			output += 'property uchar red\n' + 'property uchar green\n' + 'property uchar blue\n';
		}

		// faces
		output += 'element face ' + faceCount + '\n' + 'property list uchar int vertex_index\n' + 'end_header\n' + (vertexList + '\n') + (faceList + '\n');

		return output;
	}

};

exports.default = PLYExporter;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author kovacsv / http://kovacsv.hu/
 * @author mrdoob / http://mrdoob.com/
 * @author mudcube / http://mudcu.be/
 */

var STLBinaryExporter = function STLBinaryExporter() {};

STLBinaryExporter.prototype = {

	constructor: STLBinaryExporter,

	parse: function () {

		var vector = new THREE.Vector3();
		var normalMatrixWorld = new THREE.Matrix3();

		return function parse(scene) {

			// We collect objects first, as we may need to convert from BufferGeometry to Geometry
			var objects = [];
			var triangles = 0;
			scene.traverse(function (object) {

				if (!(object instanceof THREE.Mesh)) return;

				var geometry = object.geometry;
				if (geometry instanceof THREE.BufferGeometry) {

					geometry = new THREE.Geometry().fromBufferGeometry(geometry);
				}

				if (!(geometry instanceof THREE.Geometry)) return;
				triangles += geometry.faces.length;

				objects.push({

					geometry: geometry,
					matrix: object.matrixWorld

				});
			});

			var offset = 80; // skip header
			var bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4;
			var arrayBuffer = new ArrayBuffer(bufferLength);
			var output = new DataView(arrayBuffer);
			output.setUint32(offset, triangles, true);offset += 4;

			// Traversing our collected objects
			objects.forEach(function (object) {

				var vertices = object.geometry.vertices;
				var faces = object.geometry.faces;

				normalMatrixWorld.getNormalMatrix(object.matrix);

				for (var i = 0, l = faces.length; i < l; i++) {

					var face = faces[i];

					vector.copy(face.normal).applyMatrix3(normalMatrixWorld).normalize();

					output.setFloat32(offset, vector.x, true);offset += 4; // normal
					output.setFloat32(offset, vector.y, true);offset += 4;
					output.setFloat32(offset, vector.z, true);offset += 4;

					var indices = [face.a, face.b, face.c];

					for (var j = 0; j < 3; j++) {

						vector.copy(vertices[indices[j]]).applyMatrix4(object.matrix);

						output.setFloat32(offset, vector.x, true);offset += 4; // vertices
						output.setFloat32(offset, vector.y, true);offset += 4;
						output.setFloat32(offset, vector.z, true);offset += 4;
					}

					output.setUint16(offset, 0, true);offset += 2; // attribute byte count
				}
			});

			return output;
		};
	}()

};

exports.default = STLBinaryExporter;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author kovacsv / http://kovacsv.hu/
 * @author mrdoob / http://mrdoob.com/
 */

var STLExporter = function STLExporter() {};

STLExporter.prototype = {

	constructor: STLExporter,

	parse: function () {

		var vector = new THREE.Vector3();
		var normalMatrixWorld = new THREE.Matrix3();

		return function parse(scene) {

			var output = '';

			output += 'solid exported\n';

			scene.traverse(function (object) {

				if (object instanceof THREE.Mesh) {

					var geometry = object.geometry;
					var matrixWorld = object.matrixWorld;

					if (geometry instanceof THREE.BufferGeometry) {

						geometry = new THREE.Geometry().fromBufferGeometry(geometry);
					}

					if (geometry instanceof THREE.Geometry) {

						var vertices = geometry.vertices;
						var faces = geometry.faces;

						normalMatrixWorld.getNormalMatrix(matrixWorld);

						for (var i = 0, l = faces.length; i < l; i++) {

							var face = faces[i];

							vector.copy(face.normal).applyMatrix3(normalMatrixWorld).normalize();

							output += '\tfacet normal ' + vector.x + ' ' + vector.y + ' ' + vector.z + '\n';
							output += '\t\touter loop\n';

							var indices = [face.a, face.b, face.c];

							for (var j = 0; j < 3; j++) {

								vector.copy(vertices[indices[j]]).applyMatrix4(matrixWorld);

								output += '\t\t\tvertex ' + vector.x + ' ' + vector.y + ' ' + vector.z + '\n';
							}

							output += '\t\tendloop\n';
							output += '\tendfacet\n';
						}
					}
				}
			});

			output += 'endsolid exported\n';

			return output;
		};
	}()

};

exports.default = STLExporter;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

var TypedGeometryExporter = function TypedGeometryExporter() {};

TypedGeometryExporter.prototype = {

	constructor: TypedGeometryExporter,

	parse: function parse(geometry) {

		var output = {
			metadata: {
				version: 4.0,
				type: 'TypedGeometry',
				generator: 'TypedGeometryExporter'
			}
		};

		var attributes = ['vertices', 'normals', 'uvs'];

		for (var key in attributes) {

			var attribute = attributes[key];

			var typedArray = geometry[attribute];
			var array = [];

			for (var i = 0, l = typedArray.length; i < l; i++) {

				array[i] = typedArray[i];
			}

			output[attribute] = array;
		}

		var boundingSphere = geometry.boundingSphere;

		if (boundingSphere !== null) {

			output.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};
		}

		return output;
	}

};

exports.default = TypedGeometryExporter;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.XLoader = exports.VTKLoader = exports.UTF8Loader = exports.VRMLoader = exports.VRMLLoader = exports.TTFLoader = exports.TGALoader = exports.TDSLoader = exports.SVGLoader = exports.STLLoader = exports.RGBELoader = exports.PVRLoader = exports.PRWMLoader = exports.PLYLoader = exports.PlayCanvasLoader = exports.PDBLoader = exports.PCDLoader = exports.OBJLoader2 = exports.OBJLoader = exports.NRRDLoader = exports.NodeMaterialLoader = exports.MTLLoader = exports.MMDLoader = exports.MD2Loader = exports.LoaderSupport = exports.KTXLoader = exports.KMZLoader = exports.HDRCubeTextureLoader = exports.GLTFLoader = exports.GCodeLoader = exports.FBXLoader = exports.EXRLoader = exports.EquiangularToCubeGenerator = exports.DRACOLoader = exports.DDSLoader = exports.ColladaLoader = exports.BVHLoader = exports.BinaryLoader = exports.BabylonLoader = exports.AWDLoader = exports.AssimpLoader = exports.AssimpJSONLoader = exports.AMFLoader = exports.ThreeMFLoader = undefined;

var _MFLoader = __webpack_require__(49);

var _MFLoader2 = _interopRequireDefault(_MFLoader);

var _AMFLoader = __webpack_require__(50);

var _AMFLoader2 = _interopRequireDefault(_AMFLoader);

var _AssimpJSONLoader = __webpack_require__(51);

var _AssimpJSONLoader2 = _interopRequireDefault(_AssimpJSONLoader);

var _AssimpLoader = __webpack_require__(52);

var _AssimpLoader2 = _interopRequireDefault(_AssimpLoader);

var _AWDLoader = __webpack_require__(53);

var _AWDLoader2 = _interopRequireDefault(_AWDLoader);

var _BabylonLoader = __webpack_require__(54);

var _BabylonLoader2 = _interopRequireDefault(_BabylonLoader);

var _BinaryLoader = __webpack_require__(55);

var _BinaryLoader2 = _interopRequireDefault(_BinaryLoader);

var _BVHLoader = __webpack_require__(56);

var _BVHLoader2 = _interopRequireDefault(_BVHLoader);

var _ColladaLoader = __webpack_require__(57);

var _ColladaLoader2 = _interopRequireDefault(_ColladaLoader);

var _DDSLoader = __webpack_require__(58);

var _DDSLoader2 = _interopRequireDefault(_DDSLoader);

var _DRACOLoader = __webpack_require__(59);

var _DRACOLoader2 = _interopRequireDefault(_DRACOLoader);

var _EquiangularToCubeGenerator = __webpack_require__(60);

var _EquiangularToCubeGenerator2 = _interopRequireDefault(_EquiangularToCubeGenerator);

var _EXRLoader = __webpack_require__(61);

var _EXRLoader2 = _interopRequireDefault(_EXRLoader);

var _FBXLoader = __webpack_require__(62);

var _FBXLoader2 = _interopRequireDefault(_FBXLoader);

var _GCodeLoader = __webpack_require__(63);

var _GCodeLoader2 = _interopRequireDefault(_GCodeLoader);

var _GLTFLoader = __webpack_require__(5);

var _GLTFLoader2 = _interopRequireDefault(_GLTFLoader);

var _HDRCubeTextureLoader = __webpack_require__(64);

var _HDRCubeTextureLoader2 = _interopRequireDefault(_HDRCubeTextureLoader);

var _KMZLoader = __webpack_require__(65);

var _KMZLoader2 = _interopRequireDefault(_KMZLoader);

var _KTXLoader = __webpack_require__(66);

var _KTXLoader2 = _interopRequireDefault(_KTXLoader);

var _LoaderSupport = __webpack_require__(7);

var _LoaderSupport2 = _interopRequireDefault(_LoaderSupport);

var _MD2Loader = __webpack_require__(68);

var _MD2Loader2 = _interopRequireDefault(_MD2Loader);

var _MMDLoader = __webpack_require__(69);

var _MMDLoader2 = _interopRequireDefault(_MMDLoader);

var _MTLLoader = __webpack_require__(9);

var _MTLLoader2 = _interopRequireDefault(_MTLLoader);

var _NodeMaterialLoader = __webpack_require__(70);

var _NodeMaterialLoader2 = _interopRequireDefault(_NodeMaterialLoader);

var _NRRDLoader = __webpack_require__(71);

var _NRRDLoader2 = _interopRequireDefault(_NRRDLoader);

var _OBJLoader = __webpack_require__(72);

var _OBJLoader2 = _interopRequireDefault(_OBJLoader);

var _OBJLoader3 = __webpack_require__(73);

var _OBJLoader4 = _interopRequireDefault(_OBJLoader3);

var _PCDLoader = __webpack_require__(74);

var _PCDLoader2 = _interopRequireDefault(_PCDLoader);

var _PDBLoader = __webpack_require__(75);

var _PDBLoader2 = _interopRequireDefault(_PDBLoader);

var _PlayCanvasLoader = __webpack_require__(76);

var _PlayCanvasLoader2 = _interopRequireDefault(_PlayCanvasLoader);

var _PLYLoader = __webpack_require__(77);

var _PLYLoader2 = _interopRequireDefault(_PLYLoader);

var _PRWMLoader = __webpack_require__(78);

var _PRWMLoader2 = _interopRequireDefault(_PRWMLoader);

var _PVRLoader = __webpack_require__(79);

var _PVRLoader2 = _interopRequireDefault(_PVRLoader);

var _RGBELoader = __webpack_require__(6);

var _RGBELoader2 = _interopRequireDefault(_RGBELoader);

var _STLLoader = __webpack_require__(80);

var _STLLoader2 = _interopRequireDefault(_STLLoader);

var _SVGLoader = __webpack_require__(81);

var _SVGLoader2 = _interopRequireDefault(_SVGLoader);

var _TDSLoader = __webpack_require__(82);

var _TDSLoader2 = _interopRequireDefault(_TDSLoader);

var _TGALoader = __webpack_require__(83);

var _TGALoader2 = _interopRequireDefault(_TGALoader);

var _TTFLoader = __webpack_require__(84);

var _TTFLoader2 = _interopRequireDefault(_TTFLoader);

var _VRMLLoader = __webpack_require__(85);

var _VRMLLoader2 = _interopRequireDefault(_VRMLLoader);

var _VRMLoader = __webpack_require__(86);

var _VRMLoader2 = _interopRequireDefault(_VRMLoader);

var _UTF8Loader = __webpack_require__(87);

var _UTF8Loader2 = _interopRequireDefault(_UTF8Loader);

var _VTKLoader = __webpack_require__(88);

var _VTKLoader2 = _interopRequireDefault(_VTKLoader);

var _XLoader = __webpack_require__(89);

var _XLoader2 = _interopRequireDefault(_XLoader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.ThreeMFLoader = _MFLoader2.default;
exports.AMFLoader = _AMFLoader2.default;
exports.AssimpJSONLoader = _AssimpJSONLoader2.default;
exports.AssimpLoader = _AssimpLoader2.default;
exports.AWDLoader = _AWDLoader2.default;
exports.BabylonLoader = _BabylonLoader2.default;
exports.BinaryLoader = _BinaryLoader2.default;
exports.BVHLoader = _BVHLoader2.default;
exports.ColladaLoader = _ColladaLoader2.default;
exports.DDSLoader = _DDSLoader2.default;
exports.DRACOLoader = _DRACOLoader2.default;
exports.EquiangularToCubeGenerator = _EquiangularToCubeGenerator2.default;
exports.EXRLoader = _EXRLoader2.default;
exports.FBXLoader = _FBXLoader2.default;
exports.GCodeLoader = _GCodeLoader2.default;
exports.GLTFLoader = _GLTFLoader2.default;
exports.HDRCubeTextureLoader = _HDRCubeTextureLoader2.default;
exports.KMZLoader = _KMZLoader2.default;
exports.KTXLoader = _KTXLoader2.default;
exports.LoaderSupport = _LoaderSupport2.default;
exports.MD2Loader = _MD2Loader2.default;
exports.MMDLoader = _MMDLoader2.default;
exports.MTLLoader = _MTLLoader2.default;
exports.NodeMaterialLoader = _NodeMaterialLoader2.default;
exports.NRRDLoader = _NRRDLoader2.default;
exports.OBJLoader = _OBJLoader2.default;
exports.OBJLoader2 = _OBJLoader4.default;
exports.PCDLoader = _PCDLoader2.default;
exports.PDBLoader = _PDBLoader2.default;
exports.PlayCanvasLoader = _PlayCanvasLoader2.default;
exports.PLYLoader = _PLYLoader2.default;
exports.PRWMLoader = _PRWMLoader2.default;
exports.PVRLoader = _PVRLoader2.default;
exports.RGBELoader = _RGBELoader2.default;
exports.STLLoader = _STLLoader2.default;
exports.SVGLoader = _SVGLoader2.default;
exports.TDSLoader = _TDSLoader2.default;
exports.TGALoader = _TGALoader2.default;
exports.TTFLoader = _TTFLoader2.default;
exports.VRMLLoader = _VRMLLoader2.default;
exports.VRMLoader = _VRMLoader2.default;
exports.UTF8Loader = _UTF8Loader2.default;
exports.VTKLoader = _VTKLoader2.default;
exports.XLoader = _XLoader2.default;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author technohippy / https://github.com/technohippy
 */

var ThreeMFLoader = function ThreeMFLoader(manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
	this.availableExtensions = [];
};

ThreeMFLoader.prototype = {

	constructor: ThreeMFLoader,

	load: function load(url, onLoad, onProgress, onError) {

		var scope = this;
		var loader = new THREE.FileLoader(scope.manager);
		loader.setResponseType('arraybuffer');
		loader.load(url, function (buffer) {

			onLoad(scope.parse(buffer));
		}, onProgress, onError);
	},

	parse: function parse(data) {

		var scope = this;

		function loadDocument(data) {

			var zip = null;
			var file = null;

			var relsName;
			var modelPartNames = [];
			var printTicketPartNames = [];
			var texturesPartNames = [];
			var otherPartNames = [];

			var rels;
			var modelParts = {};
			var printTicketParts = {};
			var texturesParts = {};
			var otherParts = {};

			try {

				zip = new JSZip(data); // eslint-disable-line no-undef
			} catch (e) {

				if (e instanceof ReferenceError) {

					console.error('THREE.ThreeMFLoader: jszip missing and file is compressed.');
					return null;
				}
			}

			for (file in zip.files) {

				if (file.match(/\.rels$/)) {

					relsName = file;
				} else if (file.match(/^3D\/.*\.model$/)) {

					modelPartNames.push(file);
				} else if (file.match(/^3D\/Metadata\/.*\.xml$/)) {

					printTicketPartNames.push(file);
				} else if (file.match(/^3D\/Textures\/.*/)) {

					texturesPartNames.push(file);
				} else if (file.match(/^3D\/Other\/.*/)) {

					otherPartNames.push(file);
				}
			}

			var relsView = new Uint8Array(zip.file(relsName).asArrayBuffer());
			var relsFileText = THREE.LoaderUtils.decodeText(relsView);
			rels = parseRelsXml(relsFileText);

			for (var i = 0; i < modelPartNames.length; i++) {

				var modelPart = modelPartNames[i];
				var view = new Uint8Array(zip.file(modelPart).asArrayBuffer());

				var fileText = THREE.LoaderUtils.decodeText(view);
				var xmlData = new DOMParser().parseFromString(fileText, 'application/xml');

				if (xmlData.documentElement.nodeName.toLowerCase() !== 'model') {

					console.error('THREE.ThreeMFLoader: Error loading 3MF - no 3MF document found: ', modelPart);
				}

				var modelNode = xmlData.querySelector('model');
				var extensions = {};

				for (var i = 0; i < modelNode.attributes.length; i++) {

					var attr = modelNode.attributes[i];
					if (attr.name.match(/^xmlns:(.+)$/)) {

						extensions[attr.value] = RegExp.$1;
					}
				}

				var modelData = parseModelNode(modelNode);
				modelData['xml'] = modelNode;

				if (0 < Object.keys(extensions).length) {

					modelData['extensions'] = extensions;
				}

				modelParts[modelPart] = modelData;
			}

			for (var i = 0; i < texturesPartNames.length; i++) {

				var texturesPartName = texturesPartNames[i];
				texturesParts[texturesPartName] = zip.file(texturesPartName).asBinary();
			}

			return {
				rels: rels,
				model: modelParts,
				printTicket: printTicketParts,
				texture: texturesParts,
				other: otherParts
			};
		}

		function parseRelsXml(relsFileText) {

			var relsXmlData = new DOMParser().parseFromString(relsFileText, 'application/xml');
			var relsNode = relsXmlData.querySelector('Relationship');
			var target = relsNode.getAttribute('Target');
			var id = relsNode.getAttribute('Id');
			var type = relsNode.getAttribute('Type');

			return {
				target: target,
				id: id,
				type: type
			};
		}

		function parseMetadataNodes(metadataNodes) {

			var metadataData = {};

			for (var i = 0; i < metadataNodes.length; i++) {

				var metadataNode = metadataNodes[i];
				var name = metadataNode.getAttribute('name');
				var validNames = ['Title', 'Designer', 'Description', 'Copyright', 'LicenseTerms', 'Rating', 'CreationDate', 'ModificationDate'];

				if (0 <= validNames.indexOf(name)) {

					metadataData[name] = metadataNode.textContent;
				}
			}

			return metadataData;
		}

		function parseBasematerialsNode(basematerialsNode) {}

		function parseMeshNode(meshNode, extensions) {

			var meshData = {};

			var vertices = [];
			var vertexNodes = meshNode.querySelectorAll('vertices vertex');

			for (var i = 0; i < vertexNodes.length; i++) {

				var vertexNode = vertexNodes[i];
				var x = vertexNode.getAttribute('x');
				var y = vertexNode.getAttribute('y');
				var z = vertexNode.getAttribute('z');

				vertices.push(parseFloat(x), parseFloat(y), parseFloat(z));
			}

			meshData['vertices'] = new Float32Array(vertices.length);

			for (var i = 0; i < vertices.length; i++) {

				meshData['vertices'][i] = vertices[i];
			}

			var triangleProperties = [];
			var triangles = [];
			var triangleNodes = meshNode.querySelectorAll('triangles triangle');

			for (var i = 0; i < triangleNodes.length; i++) {

				var triangleNode = triangleNodes[i];
				var v1 = triangleNode.getAttribute('v1');
				var v2 = triangleNode.getAttribute('v2');
				var v3 = triangleNode.getAttribute('v3');
				var p1 = triangleNode.getAttribute('p1');
				var p2 = triangleNode.getAttribute('p2');
				var p3 = triangleNode.getAttribute('p3');
				var pid = triangleNode.getAttribute('pid');

				triangles.push(parseInt(v1, 10), parseInt(v2, 10), parseInt(v3, 10));

				var triangleProperty = {};

				if (p1) {

					triangleProperty['p1'] = parseInt(p1, 10);
				}

				if (p2) {

					triangleProperty['p2'] = parseInt(p2, 10);
				}

				if (p3) {

					triangleProperty['p3'] = parseInt(p3, 10);
				}

				if (pid) {

					triangleProperty['pid'] = pid;
				}

				if (0 < Object.keys(triangleProperty).length) {

					triangleProperties.push(triangleProperty);
				}
			}

			meshData['triangleProperties'] = triangleProperties;
			meshData['triangles'] = new Uint32Array(triangles.length);

			for (var i = 0; i < triangles.length; i++) {

				meshData['triangles'][i] = triangles[i];
			}

			return meshData;
		}

		function parseComponentsNode(componentsNode) {}

		function parseObjectNode(objectNode) {

			var objectData = {
				type: objectNode.getAttribute('type')
			};

			var id = objectNode.getAttribute('id');

			if (id) {

				objectData['id'] = id;
			}

			var pid = objectNode.getAttribute('pid');

			if (pid) {

				objectData['pid'] = pid;
			}

			var pindex = objectNode.getAttribute('pindex');

			if (pindex) {

				objectData['pindex'] = pindex;
			}

			var thumbnail = objectNode.getAttribute('thumbnail');

			if (thumbnail) {

				objectData['thumbnail'] = thumbnail;
			}

			var partnumber = objectNode.getAttribute('partnumber');

			if (partnumber) {

				objectData['partnumber'] = partnumber;
			}

			var name = objectNode.getAttribute('name');

			if (name) {

				objectData['name'] = name;
			}

			var meshNode = objectNode.querySelector('mesh');

			if (meshNode) {

				objectData['mesh'] = parseMeshNode(meshNode);
			}

			var componentsNode = objectNode.querySelector('components');

			if (componentsNode) {

				objectData['components'] = parseComponentsNode(componentsNode);
			}

			return objectData;
		}

		function parseResourcesNode(resourcesNode) {

			var resourcesData = {};
			var basematerialsNode = resourcesNode.querySelector('basematerials');

			if (basematerialsNode) {

				resourcesData['basematerial'] = parseBasematerialsNode(basematerialsNode);
			}

			resourcesData['object'] = {};
			var objectNodes = resourcesNode.querySelectorAll('object');

			for (var i = 0; i < objectNodes.length; i++) {

				var objectNode = objectNodes[i];
				var objectData = parseObjectNode(objectNode);
				resourcesData['object'][objectData['id']] = objectData;
			}

			return resourcesData;
		}

		function parseBuildNode(buildNode) {

			var buildData = [];
			var itemNodes = buildNode.querySelectorAll('item');

			for (var i = 0; i < itemNodes.length; i++) {

				var itemNode = itemNodes[i];
				var buildItem = {
					objectid: itemNode.getAttribute('objectid')
				};
				var transform = itemNode.getAttribute('transform');

				if (transform) {

					var t = [];
					transform.split(' ').forEach(function (s) {

						t.push(parseFloat(s));
					});
					var mat4 = new THREE.Matrix4();
					buildItem['transform'] = mat4.set(t[0], t[3], t[6], t[9], t[1], t[4], t[7], t[10], t[2], t[5], t[8], t[11], 0.0, 0.0, 0.0, 1.0);
				}

				buildData.push(buildItem);
			}

			return buildData;
		}

		function parseModelNode(modelNode) {

			var modelData = { unit: modelNode.getAttribute('unit') || 'millimeter' };
			var metadataNodes = modelNode.querySelectorAll('metadata');

			if (metadataNodes) {

				modelData['metadata'] = parseMetadataNodes(metadataNodes);
			}

			var resourcesNode = modelNode.querySelector('resources');

			if (resourcesNode) {

				modelData['resources'] = parseResourcesNode(resourcesNode);
			}

			var buildNode = modelNode.querySelector('build');

			if (buildNode) {

				modelData['build'] = parseBuildNode(buildNode);
			}

			return modelData;
		}

		function buildMesh(meshData, data3mf) {

			var geometry = new THREE.BufferGeometry();
			geometry.setIndex(new THREE.BufferAttribute(meshData['triangles'], 1));
			geometry.addAttribute('position', new THREE.BufferAttribute(meshData['vertices'], 3));

			if (meshData['colors']) {

				geometry.addAttribute('color', new THREE.BufferAttribute(meshData['colors'], 3));
			}

			geometry.computeBoundingSphere();

			var materialOpts = {
				flatShading: true
			};

			if (meshData['colors'] && 0 < meshData['colors'].length) {

				materialOpts['vertexColors'] = THREE.VertexColors;
			} else {

				materialOpts['color'] = 0xaaaaff;
			}

			var material = new THREE.MeshPhongMaterial(materialOpts);
			return new THREE.Mesh(geometry, material);
		}

		function applyExtensions(extensions, meshData, modelXml, data3mf) {

			if (!extensions) {

				return;
			}

			var availableExtensions = [];
			var keys = Object.keys(extensions);

			for (var i = 0; i < keys.length; i++) {

				var ns = keys[i];

				for (var j = 0; j < scope.availableExtensions.length; j++) {

					var extension = scope.availableExtensions[j];

					if (extension.ns === ns) {

						availableExtensions.push(extension);
					}
				}
			}

			for (var i = 0; i < availableExtensions.length; i++) {

				var extension = availableExtensions[i];
				extension.apply(modelXml, extensions[extension['ns']], meshData);
			}
		}

		function buildMeshes(data3mf) {

			var modelsData = data3mf.model;
			var meshes = {};
			var modelsKeys = Object.keys(modelsData);

			for (var i = 0; i < modelsKeys.length; i++) {

				var modelsKey = modelsKeys[i];
				var modelData = modelsData[modelsKey];
				var modelXml = modelData['xml'];
				var extensions = modelData['extensions'];

				var objectIds = Object.keys(modelData['resources']['object']);

				for (var j = 0; j < objectIds.length; j++) {

					var objectId = objectIds[j];
					var objectData = modelData['resources']['object'][objectId];
					var meshData = objectData['mesh'];
					applyExtensions(extensions, meshData, modelXml, data3mf);
					meshes[objectId] = buildMesh(meshData, data3mf);
				}
			}

			return meshes;
		}

		function build(meshes, refs, data3mf) {

			var group = new THREE.Group();
			var buildData = data3mf.model[refs['target'].substring(1)]['build'];

			for (var i = 0; i < buildData.length; i++) {

				var buildItem = buildData[i];
				var mesh = meshes[buildItem['objectid']];

				if (buildItem['transform']) {

					mesh.geometry.applyMatrix(buildItem['transform']);
				}

				group.add(mesh);
			}

			return group;
		}

		var data3mf = loadDocument(data);
		var meshes = buildMeshes(data3mf);

		return build(meshes, data3mf['rels'], data3mf);
	},

	addExtension: function addExtension(extension) {

		this.availableExtensions.push(extension);
	}

};

exports.default = ThreeMFLoader;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @author tamarintech / https://tamarintech.com
 *
 * Description: Early release of an AMF Loader following the pattern of the
 * example loaders in the three.js project.
 *
 * More information about the AMF format: http://amf.wikispaces.com
 *
 * Usage:
 *	var loader = new AMFLoader();
 *	loader.load('/path/to/project.amf', function(objecttree) {
 *		scene.add(objecttree);
 *	});
 *
 * Materials now supported, material colors supported
 * Zip support, requires jszip
 * No constellation support (yet)!
 *
 */

var AMFLoader = function AMFLoader(manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};

AMFLoader.prototype = {

	constructor: AMFLoader,

	load: function load(url, onLoad, onProgress, onError) {

		var scope = this;

		var loader = new THREE.FileLoader(scope.manager);
		loader.setResponseType('arraybuffer');
		loader.load(url, function (text) {

			onLoad(scope.parse(text));
		}, onProgress, onError);
	},

	parse: function parse(data) {

		function loadDocument(data) {

			var view = new DataView(data);
			var magic = String.fromCharCode(view.getUint8(0), view.getUint8(1));

			if (magic === 'PK') {

				var zip = null;
				var file = null;

				console.log('THREE.AMFLoader: Loading Zip');

				try {

					zip = new JSZip(data); // eslint-disable-line no-undef
				} catch (e) {

					if (e instanceof ReferenceError) {

						console.log('THREE.AMFLoader: jszip missing and file is compressed.');
						return null;
					}
				}

				for (file in zip.files) {

					if (file.toLowerCase().substr(-4) === '.amf') {

						break;
					}
				}

				console.log('THREE.AMFLoader: Trying to load file asset: ' + file);
				view = new DataView(zip.file(file).asArrayBuffer());
			}

			var fileText = THREE.LoaderUtils.decodeText(view);
			var xmlData = new DOMParser().parseFromString(fileText, 'application/xml');

			if (xmlData.documentElement.nodeName.toLowerCase() !== 'amf') {

				console.log('THREE.AMFLoader: Error loading AMF - no AMF document found.');
				return null;
			}

			return xmlData;
		}

		function loadDocumentScale(node) {

			var scale = 1.0;
			var unit = 'millimeter';

			if (node.documentElement.attributes.unit !== undefined) {

				unit = node.documentElement.attributes.unit.value.toLowerCase();
			}

			var scaleUnits = {
				millimeter: 1.0,
				inch: 25.4,
				feet: 304.8,
				meter: 1000.0,
				micron: 0.001
			};

			if (scaleUnits[unit] !== undefined) {

				scale = scaleUnits[unit];
			}

			console.log('THREE.AMFLoader: Unit scale: ' + scale);
			return scale;
		}

		function loadMaterials(node) {

			var matName = 'AMF Material';
			var matId = node.attributes.id.textContent;
			var color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };

			var loadedMaterial = null;

			for (var i = 0; i < node.childNodes.length; i++) {

				var matChildEl = node.childNodes[i];

				if (matChildEl.nodeName === 'metadata' && matChildEl.attributes.type !== undefined) {

					if (matChildEl.attributes.type.value === 'name') {

						matName = matChildEl.textContent;
					}
				} else if (matChildEl.nodeName === 'color') {

					color = loadColor(matChildEl);
				}
			}

			loadedMaterial = new THREE.MeshPhongMaterial({
				flatShading: true,
				color: new THREE.Color(color.r, color.g, color.b),
				name: matName
			});

			if (color.a !== 1.0) {

				loadedMaterial.transparent = true;
				loadedMaterial.opacity = color.a;
			}

			return { id: matId, material: loadedMaterial };
		}

		function loadColor(node) {

			var color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };

			for (var i = 0; i < node.childNodes.length; i++) {

				var matColor = node.childNodes[i];

				if (matColor.nodeName === 'r') {

					color.r = matColor.textContent;
				} else if (matColor.nodeName === 'g') {

					color.g = matColor.textContent;
				} else if (matColor.nodeName === 'b') {

					color.b = matColor.textContent;
				} else if (matColor.nodeName === 'a') {

					color.a = matColor.textContent;
				}
			}

			return color;
		}

		function loadMeshVolume(node) {

			var volume = { name: '', triangles: [], materialid: null };

			var currVolumeNode = node.firstElementChild;

			if (node.attributes.materialid !== undefined) {

				volume.materialId = node.attributes.materialid.nodeValue;
			}

			while (currVolumeNode) {

				if (currVolumeNode.nodeName === 'metadata') {

					if (currVolumeNode.attributes.type !== undefined) {

						if (currVolumeNode.attributes.type.value === 'name') {

							volume.name = currVolumeNode.textContent;
						}
					}
				} else if (currVolumeNode.nodeName === 'triangle') {

					var v1 = currVolumeNode.getElementsByTagName('v1')[0].textContent;
					var v2 = currVolumeNode.getElementsByTagName('v2')[0].textContent;
					var v3 = currVolumeNode.getElementsByTagName('v3')[0].textContent;

					volume.triangles.push(v1, v2, v3);
				}

				currVolumeNode = currVolumeNode.nextElementSibling;
			}

			return volume;
		}

		function loadMeshVertices(node) {

			var vertArray = [];
			var normalArray = [];
			var currVerticesNode = node.firstElementChild;

			while (currVerticesNode) {

				if (currVerticesNode.nodeName === 'vertex') {

					var vNode = currVerticesNode.firstElementChild;

					while (vNode) {

						if (vNode.nodeName === 'coordinates') {

							var x = vNode.getElementsByTagName('x')[0].textContent;
							var y = vNode.getElementsByTagName('y')[0].textContent;
							var z = vNode.getElementsByTagName('z')[0].textContent;

							vertArray.push(x, y, z);
						} else if (vNode.nodeName === 'normal') {

							var nx = vNode.getElementsByTagName('nx')[0].textContent;
							var ny = vNode.getElementsByTagName('ny')[0].textContent;
							var nz = vNode.getElementsByTagName('nz')[0].textContent;

							normalArray.push(nx, ny, nz);
						}

						vNode = vNode.nextElementSibling;
					}
				}
				currVerticesNode = currVerticesNode.nextElementSibling;
			}

			return { 'vertices': vertArray, 'normals': normalArray };
		}

		function loadObject(node) {

			var objId = node.attributes.id.textContent;
			var loadedObject = { name: 'amfobject', meshes: [] };
			var currColor = null;
			var currObjNode = node.firstElementChild;

			while (currObjNode) {

				if (currObjNode.nodeName === 'metadata') {

					if (currObjNode.attributes.type !== undefined) {

						if (currObjNode.attributes.type.value === 'name') {

							loadedObject.name = currObjNode.textContent;
						}
					}
				} else if (currObjNode.nodeName === 'color') {

					currColor = loadColor(currObjNode);
				} else if (currObjNode.nodeName === 'mesh') {

					var currMeshNode = currObjNode.firstElementChild;
					var mesh = { vertices: [], normals: [], volumes: [], color: currColor };

					while (currMeshNode) {

						if (currMeshNode.nodeName === 'vertices') {

							var loadedVertices = loadMeshVertices(currMeshNode);

							mesh.normals = mesh.normals.concat(loadedVertices.normals);
							mesh.vertices = mesh.vertices.concat(loadedVertices.vertices);
						} else if (currMeshNode.nodeName === 'volume') {

							mesh.volumes.push(loadMeshVolume(currMeshNode));
						}

						currMeshNode = currMeshNode.nextElementSibling;
					}

					loadedObject.meshes.push(mesh);
				}

				currObjNode = currObjNode.nextElementSibling;
			}

			return { 'id': objId, 'obj': loadedObject };
		}

		var xmlData = loadDocument(data);
		var amfName = '';
		var amfAuthor = '';
		var amfScale = loadDocumentScale(xmlData);
		var amfMaterials = {};
		var amfObjects = {};
		var childNodes = xmlData.documentElement.childNodes;

		var i, j;

		for (i = 0; i < childNodes.length; i++) {

			var child = childNodes[i];

			if (child.nodeName === 'metadata') {

				if (child.attributes.type !== undefined) {

					if (child.attributes.type.value === 'name') {

						amfName = child.textContent;
					} else if (child.attributes.type.value === 'author') {

						amfAuthor = child.textContent;
					}
				}
			} else if (child.nodeName === 'material') {

				var loadedMaterial = loadMaterials(child);

				amfMaterials[loadedMaterial.id] = loadedMaterial.material;
			} else if (child.nodeName === 'object') {

				var loadedObject = loadObject(child);

				amfObjects[loadedObject.id] = loadedObject.obj;
			}
		}

		var sceneObject = new THREE.Group();
		var defaultMaterial = new THREE.MeshPhongMaterial({ color: 0xaaaaff, flatShading: true });

		sceneObject.name = amfName;
		sceneObject.userData.author = amfAuthor;
		sceneObject.userData.loader = 'AMF';

		for (var id in amfObjects) {

			var part = amfObjects[id];
			var meshes = part.meshes;
			var newObject = new THREE.Group();
			newObject.name = part.name || '';

			for (i = 0; i < meshes.length; i++) {

				var objDefaultMaterial = defaultMaterial;
				var mesh = meshes[i];
				var vertices = new THREE.Float32BufferAttribute(mesh.vertices, 3);
				var normals = null;

				if (mesh.normals.length) {

					normals = new THREE.Float32BufferAttribute(mesh.normals, 3);
				}

				if (mesh.color) {

					var color = mesh.color;

					objDefaultMaterial = defaultMaterial.clone();
					objDefaultMaterial.color = new THREE.Color(color.r, color.g, color.b);

					if (color.a !== 1.0) {

						objDefaultMaterial.transparent = true;
						objDefaultMaterial.opacity = color.a;
					}
				}

				var volumes = mesh.volumes;

				for (j = 0; j < volumes.length; j++) {

					var volume = volumes[j];
					var newGeometry = new THREE.BufferGeometry();
					var material = objDefaultMaterial;

					newGeometry.setIndex(volume.triangles);
					newGeometry.addAttribute('position', vertices.clone());

					if (normals) {

						newGeometry.addAttribute('normal', normals.clone());
					}

					if (amfMaterials[volume.materialId] !== undefined) {

						material = amfMaterials[volume.materialId];
					}

					newGeometry.scale(amfScale, amfScale, amfScale);
					newObject.add(new THREE.Mesh(newGeometry, material.clone()));
				}
			}

			sceneObject.add(newObject);
		}

		return sceneObject;
	}

};

exports.default = AMFLoader;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author Alexander Gessler / http://www.greentoken.de/
 * https://github.com/acgessler
 *
 * Loader for models imported with Open Asset Import Library (http://assimp.sf.net)
 * through assimp2json (https://github.com/acgessler/assimp2json).
 *
 * Supports any input format that assimp supports, including 3ds, obj, dae, blend,
 * fbx, x, ms3d, lwo (and many more).
 *
 * See webgl_loader_assimp2json example.
 */

var AssimpJSONLoader = function AssimpJSONLoader(manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};

AssimpJSONLoader.prototype = {

	constructor: AssimpJSONLoader,

	crossOrigin: 'Anonymous',

	load: function load(url, onLoad, onProgress, onError) {

		var scope = this;

		var path = THREE.LoaderUtils.extractUrlBase(url);

		var loader = new THREE.FileLoader(this.manager);
		loader.load(url, function (text) {

			var json = JSON.parse(text);
			var metadata = json.__metadata__;

			// check if __metadata__ meta header is present
			// this header is used to disambiguate between different JSON-based file formats

			if (typeof metadata !== 'undefined') {

				// check if assimp2json at all

				if (metadata.format !== 'assimp2json') {

					onError('THREE.AssimpJSONLoader: Not an assimp2json scene.');
					return;

					// check major format version
				} else if (metadata.version < 100 && metadata.version >= 200) {

					onError('THREE.AssimpJSONLoader: Unsupported assimp2json file format version.');
					return;
				}
			}

			onLoad(scope.parse(json, path));
		}, onProgress, onError);
	},

	setCrossOrigin: function setCrossOrigin(value) {

		this.crossOrigin = value;
	},

	parse: function parse(json, path) {

		function parseList(json, handler) {

			var meshes = new Array(json.length);

			for (var i = 0; i < json.length; ++i) {

				meshes[i] = handler.call(this, json[i]);
			}

			return meshes;
		}

		function parseMesh(json) {

			var geometry = new THREE.BufferGeometry();

			var i, l, face;

			var indices = [];

			var vertices = json.vertices || [];
			var normals = json.normals || [];
			var uvs = json.texturecoords || [];
			var colors = json.colors || [];

			uvs = uvs[0] || []; // only support for a single set of uvs

			for (i = 0, l = json.faces.length; i < l; i++) {

				face = json.faces[i];
				indices.push(face[0], face[1], face[2]);
			}

			geometry.setIndex(indices);
			geometry.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

			if (normals.length > 0) {

				geometry.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
			}

			if (uvs.length > 0) {

				geometry.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
			}

			if (colors.length > 0) {

				geometry.addAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
			}

			geometry.computeBoundingSphere();

			return geometry;
		}

		function parseMaterial(json) {

			var material = new THREE.MeshPhongMaterial();

			for (var i in json.properties) {

				var property = json.properties[i];
				var key = property.key;
				var value = property.value;

				switch (key) {

					case '$tex.file':
						{

							var semantic = property.semantic;

							// prop.semantic gives the type of the texture
							// 1: diffuse
							// 2: specular mao
							// 5: height map (bumps)
							// 6: normal map
							// more values (i.e. emissive, environment) are known by assimp and may be relevant

							if (semantic === 1 || semantic === 2 || semantic === 5 || semantic === 6) {

								var keyname;

								switch (semantic) {

									case 1:
										keyname = 'map';
										break;
									case 2:
										keyname = 'specularMap';
										break;
									case 5:
										keyname = 'bumpMap';
										break;
									case 6:
										keyname = 'normalMap';
										break;

								}

								var texture = textureLoader.load(value);

								// TODO: read texture settings from assimp.
								// Wrapping is the default, though.

								texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

								material[keyname] = texture;
							}

							break;
						}

					case '?mat.name':
						material.name = value;
						break;

					case '$clr.diffuse':
						material.color.fromArray(value);
						break;

					case '$clr.specular':
						material.specular.fromArray(value);
						break;

					case '$clr.emissive':
						material.emissive.fromArray(value);
						break;

					case '$mat.shininess':
						material.shininess = value;
						break;

					case '$mat.shadingm':
						// aiShadingMode_Flat
						material.flatShading = value === 1 ? true : false;
						break;

					case '$mat.opacity':
						if (value < 1) {
							material.opacity = value;
							material.transparent = true;
						}
						break;

				}
			}

			return material;
		}

		function parseObject(json, node, meshes, materials) {

			var obj = new THREE.Object3D(),
			    i,
			    idx;

			obj.name = node.name || '';
			obj.matrix = new THREE.Matrix4().fromArray(node.transformation).transpose();
			obj.matrix.decompose(obj.position, obj.quaternion, obj.scale);

			for (i = 0; node.meshes && i < node.meshes.length; i++) {

				idx = node.meshes[i];
				obj.add(new THREE.Mesh(meshes[idx], materials[json.meshes[idx].materialindex]));
			}

			for (i = 0; node.children && i < node.children.length; i++) {

				obj.add(parseObject(json, node.children[i], meshes, materials));
			}

			return obj;
		}

		var textureLoader = new THREE.TextureLoader(this.manager);
		textureLoader.setPath(path).setCrossOrigin(this.crossOrigin);

		var meshes = parseList(json.meshes, parseMesh);
		var materials = parseList(json.materials, parseMaterial);
		return parseObject(json, json.rootnode, meshes, materials);
	}

};

exports.default = AssimpJSONLoader;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author Virtulous / https://virtulo.us/
 */

var AssimpLoader = function AssimpLoader(manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};

AssimpLoader.prototype = {

	constructor: AssimpLoader,

	crossOrigin: 'Anonymous',

	load: function load(url, onLoad, onProgress, onError) {

		var scope = this;

		var path = THREE.LoaderUtils.extractUrlBase(url);

		var loader = new THREE.FileLoader(this.manager);
		loader.setResponseType('arraybuffer');

		loader.load(url, function (buffer) {

			onLoad(scope.parse(buffer, path));
		}, onProgress, onError);
	},

	setCrossOrigin: function setCrossOrigin(value) {

		this.crossOrigin = value;
	},

	parse: function parse(buffer, path) {

		var textureLoader = new THREE.TextureLoader(this.manager);
		textureLoader.setPath(path).setCrossOrigin(this.crossOrigin);

		var Virtulous = {};

		Virtulous.KeyFrame = function (time, matrix) {

			this.time = time;
			this.matrix = matrix.clone();
			this.position = new THREE.Vector3();
			this.quaternion = new THREE.Quaternion();
			this.scale = new THREE.Vector3(1, 1, 1);
			this.matrix.decompose(this.position, this.quaternion, this.scale);
			this.clone = function () {

				var n = new Virtulous.KeyFrame(this.time, this.matrix);
				return n;
			};
			this.lerp = function (nextKey, time) {

				time -= this.time;
				var dist = nextKey.time - this.time;
				var l = time / dist;
				var l2 = 1 - l;
				var keypos = this.position;
				var keyrot = this.quaternion;
				//      var keyscl =  key.parentspaceScl || key.scl;
				var key2pos = nextKey.position;
				var key2rot = nextKey.quaternion;
				//  var key2scl =  key2.parentspaceScl || key2.scl;
				Virtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l;
				Virtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l;
				Virtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l;
				//     tempAniScale.x = keyscl[0] * l2 + key2scl[0] * l;
				//     tempAniScale.y = keyscl[1] * l2 + key2scl[1] * l;
				//     tempAniScale.z = keyscl[2] * l2 + key2scl[2] * l;
				Virtulous.KeyFrame.tempAniQuat.set(keyrot.x, keyrot.y, keyrot.z, keyrot.w);
				Virtulous.KeyFrame.tempAniQuat.slerp(key2rot, l);
				return Virtulous.KeyFrame.tempAniMatrix.compose(Virtulous.KeyFrame.tempAniPos, Virtulous.KeyFrame.tempAniQuat, Virtulous.KeyFrame.tempAniScale);
			};
		};

		Virtulous.KeyFrame.tempAniPos = new THREE.Vector3();
		Virtulous.KeyFrame.tempAniQuat = new THREE.Quaternion();
		Virtulous.KeyFrame.tempAniScale = new THREE.Vector3(1, 1, 1);
		Virtulous.KeyFrame.tempAniMatrix = new THREE.Matrix4();
		Virtulous.KeyFrameTrack = function () {

			this.keys = [];
			this.target = null;
			this.time = 0;
			this.length = 0;
			this._accelTable = {};
			this.fps = 20;
			this.addKey = function (key) {

				this.keys.push(key);
			};
			this.init = function () {

				this.sortKeys();

				if (this.keys.length > 0) this.length = this.keys[this.keys.length - 1].time;else this.length = 0;

				if (!this.fps) return;

				for (var j = 0; j < this.length * this.fps; j++) {

					for (var i = 0; i < this.keys.length; i++) {

						if (this.keys[i].time == j) {

							this._accelTable[j] = i;
							break;
						} else if (this.keys[i].time < j / this.fps && this.keys[i + 1] && this.keys[i + 1].time >= j / this.fps) {

							this._accelTable[j] = i;
							break;
						}
					}
				}
			};

			this.parseFromThree = function (data) {

				var fps = data.fps;
				this.target = data.node;
				var track = data.hierarchy[0].keys;
				for (var i = 0; i < track.length; i++) {

					this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].targets[0].data));
				}
				this.init();
			};

			this.parseFromCollada = function (data) {

				var track = data.keys;
				var fps = this.fps;

				for (var i = 0; i < track.length; i++) {

					this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].matrix));
				}

				this.init();
			};

			this.sortKeys = function () {

				this.keys.sort(this.keySortFunc);
			};

			this.keySortFunc = function (a, b) {

				return a.time - b.time;
			};

			this.clone = function () {

				var t = new Virtulous.KeyFrameTrack();
				t.target = this.target;
				t.time = this.time;
				t.length = this.length;

				for (var i = 0; i < this.keys.length; i++) {

					t.addKey(this.keys[i].clone());
				}

				t.init();
				return t;
			};

			this.reTarget = function (root, compareitor) {

				if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;
				this.target = compareitor(root, this.target);
			};

			this.keySearchAccel = function (time) {

				time *= this.fps;
				time = Math.floor(time);
				return this._accelTable[time] || 0;
			};

			this.setTime = function (time) {

				time = Math.abs(time);
				if (this.length) time = time % this.length + .05;
				var key0 = null;
				var key1 = null;

				for (var i = this.keySearchAccel(time); i < this.keys.length; i++) {

					if (this.keys[i].time == time) {

						key0 = this.keys[i];
						key1 = this.keys[i];
						break;
					} else if (this.keys[i].time < time && this.keys[i + 1] && this.keys[i + 1].time > time) {

						key0 = this.keys[i];
						key1 = this.keys[i + 1];
						break;
					} else if (this.keys[i].time < time && i == this.keys.length - 1) {

						key0 = this.keys[i];
						key1 = this.keys[0].clone();
						key1.time += this.length + .05;
						break;
					}
				}

				if (key0 && key1 && key0 !== key1) {

					this.target.matrixAutoUpdate = false;
					this.target.matrix.copy(key0.lerp(key1, time));
					this.target.matrixWorldNeedsUpdate = true;
					return;
				}

				if (key0 && key1 && key0 == key1) {

					this.target.matrixAutoUpdate = false;
					this.target.matrix.copy(key0.matrix);
					this.target.matrixWorldNeedsUpdate = true;
					return;
				}
			};
		};

		Virtulous.TrackTargetNodeNameCompare = function (root, target) {

			function find(node, name) {

				if (node.name == name) return node;

				for (var i = 0; i < node.children.length; i++) {

					var r = find(node.children[i], name);
					if (r) return r;
				}

				return null;
			}

			return find(root, target.name);
		};

		Virtulous.Animation = function () {

			this.tracks = [];
			this.length = 0;

			this.addTrack = function (track) {

				this.tracks.push(track);
				this.length = Math.max(track.length, this.length);
			};

			this.setTime = function (time) {

				this.time = time;

				for (var i = 0; i < this.tracks.length; i++) {
					this.tracks[i].setTime(time);
				}
			};

			this.clone = function (target, compareitor) {

				if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;
				var n = new Virtulous.Animation();
				n.target = target;
				for (var i = 0; i < this.tracks.length; i++) {

					var track = this.tracks[i].clone();
					track.reTarget(target, compareitor);
					n.addTrack(track);
				}

				return n;
			};
		};

		var ASSBIN_CHUNK_AICAMERA = 0x1234;
		var ASSBIN_CHUNK_AILIGHT = 0x1235;
		var ASSBIN_CHUNK_AITEXTURE = 0x1236;
		var ASSBIN_CHUNK_AIMESH = 0x1237;
		var ASSBIN_CHUNK_AINODEANIM = 0x1238;
		var ASSBIN_CHUNK_AISCENE = 0x1239;
		var ASSBIN_CHUNK_AIBONE = 0x123a;
		var ASSBIN_CHUNK_AIANIMATION = 0x123b;
		var ASSBIN_CHUNK_AINODE = 0x123c;
		var ASSBIN_CHUNK_AIMATERIAL = 0x123d;
		var ASSBIN_CHUNK_AIMATERIALPROPERTY = 0x123e;
		var ASSBIN_MESH_HAS_POSITIONS = 0x1;
		var ASSBIN_MESH_HAS_NORMALS = 0x2;
		var ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 0x4;
		var ASSBIN_MESH_HAS_TEXCOORD_BASE = 0x100;
		var ASSBIN_MESH_HAS_COLOR_BASE = 0x10000;
		var AI_MAX_NUMBER_OF_COLOR_SETS = 1;
		var AI_MAX_NUMBER_OF_TEXTURECOORDS = 4;
		var aiLightSource_UNDEFINED = 0x0;
		//! A directional light source has a well-defined direction
		//! but is infinitely far away. That's quite a good
		//! approximation for sun light.
		var aiLightSource_DIRECTIONAL = 0x1;
		//! A point light source has a well-defined position
		//! in space but no direction - it emits light in all
		//! directions. A normal bulb is a point light.
		var aiLightSource_POINT = 0x2;
		//! A spot light source emits light in a specific
		//! angle. It has a position and a direction it is pointing to.
		//! A good example for a spot light is a light spot in
		//! sport arenas.
		var aiLightSource_SPOT = 0x3;
		//! The generic light level of the world, including the bounces
		//! of all other lightsources.
		//! Typically, there's at most one ambient light in a scene.
		//! This light type doesn't have a valid position, direction, or
		//! other properties, just a color.
		var aiLightSource_AMBIENT = 0x4;
		/** Flat shading. Shading is done on per-face base,
   *  diffuse only. Also known as 'faceted shading'.
   */
		var aiShadingMode_Flat = 0x1;
		/** Simple Gouraud shading.
   */
		var aiShadingMode_Gouraud = 0x2;
		/** Phong-Shading -
   */
		var aiShadingMode_Phong = 0x3;
		/** Phong-Blinn-Shading
   */
		var aiShadingMode_Blinn = 0x4;
		/** Toon-Shading per pixel
   *
   *  Also known as 'comic' shader.
   */
		var aiShadingMode_Toon = 0x5;
		/** OrenNayar-Shading per pixel
   *
   *  Extension to standard Lambertian shading, taking the
   *  roughness of the material into account
   */
		var aiShadingMode_OrenNayar = 0x6;
		/** Minnaert-Shading per pixel
   *
   *  Extension to standard Lambertian shading, taking the
   *  "darkness" of the material into account
   */
		var aiShadingMode_Minnaert = 0x7;
		/** CookTorrance-Shading per pixel
   *
   *  Special shader for metallic surfaces.
   */
		var aiShadingMode_CookTorrance = 0x8;
		/** No shading at all. Constant light influence of 1.0.
   */
		var aiShadingMode_NoShading = 0x9;
		/** Fresnel shading
   */
		var aiShadingMode_Fresnel = 0xa;
		var aiTextureType_NONE = 0x0;
		/** The texture is combined with the result of the diffuse
   *  lighting equation.
   */
		var aiTextureType_DIFFUSE = 0x1;
		/** The texture is combined with the result of the specular
   *  lighting equation.
   */
		var aiTextureType_SPECULAR = 0x2;
		/** The texture is combined with the result of the ambient
   *  lighting equation.
   */
		var aiTextureType_AMBIENT = 0x3;
		/** The texture is added to the result of the lighting
   *  calculation. It isn't influenced by incoming light.
   */
		var aiTextureType_EMISSIVE = 0x4;
		/** The texture is a height map.
   *
   *  By convention, higher gray-scale values stand for
   *  higher elevations from the base height.
   */
		var aiTextureType_HEIGHT = 0x5;
		/** The texture is a (tangent space) normal-map.
   *
   *  Again, there are several conventions for tangent-space
   *  normal maps. Assimp does (intentionally) not
   *  distinguish here.
   */
		var aiTextureType_NORMALS = 0x6;
		/** The texture defines the glossiness of the material.
   *
   *  The glossiness is in fact the exponent of the specular
   *  (phong) lighting equation. Usually there is a conversion
   *  function defined to map the linear color values in the
   *  texture to a suitable exponent. Have fun.
   */
		var aiTextureType_SHININESS = 0x7;
		/** The texture defines per-pixel opacity.
   *
   *  Usually 'white' means opaque and 'black' means
   *  'transparency'. Or quite the opposite. Have fun.
   */
		var aiTextureType_OPACITY = 0x8;
		/** Displacement texture
   *
   *  The exact purpose and format is application-dependent.
   *  Higher color values stand for higher vertex displacements.
   */
		var aiTextureType_DISPLACEMENT = 0x9;
		/** Lightmap texture (aka Ambient Occlusion)
   *
   *  Both 'Lightmaps' and dedicated 'ambient occlusion maps' are
   *  covered by this material property. The texture contains a
   *  scaling value for the final color value of a pixel. Its
   *  intensity is not affected by incoming light.
   */
		var aiTextureType_LIGHTMAP = 0xA;
		/** Reflection texture
   *
   * Contains the color of a perfect mirror reflection.
   * Rarely used, almost never for real-time applications.
   */
		var aiTextureType_REFLECTION = 0xB;
		/** Unknown texture
   *
   *  A texture reference that does not match any of the definitions
   *  above is considered to be 'unknown'. It is still imported,
   *  but is excluded from any further postprocessing.
   */
		var aiTextureType_UNKNOWN = 0xC;
		var BONESPERVERT = 4;

		function ASSBIN_MESH_HAS_TEXCOORD(n) {

			return ASSBIN_MESH_HAS_TEXCOORD_BASE << n;
		}

		function ASSBIN_MESH_HAS_COLOR(n) {

			return ASSBIN_MESH_HAS_COLOR_BASE << n;
		}

		function markBones(scene) {

			for (var i in scene.mMeshes) {

				var mesh = scene.mMeshes[i];
				for (var k in mesh.mBones) {

					var boneNode = scene.findNode(mesh.mBones[k].mName);
					if (boneNode) boneNode.isBone = true;
				}
			}
		}
		function cloneTreeToBones(root, scene) {

			var rootBone = new THREE.Bone();
			rootBone.matrix.copy(root.matrix);
			rootBone.matrixWorld.copy(root.matrixWorld);
			rootBone.position.copy(root.position);
			rootBone.quaternion.copy(root.quaternion);
			rootBone.scale.copy(root.scale);
			scene.nodeCount++;
			rootBone.name = "bone_" + root.name + scene.nodeCount.toString();

			if (!scene.nodeToBoneMap[root.name]) scene.nodeToBoneMap[root.name] = [];
			scene.nodeToBoneMap[root.name].push(rootBone);
			for (var i in root.children) {

				var child = cloneTreeToBones(root.children[i], scene);
				if (child) rootBone.add(child);
			}

			return rootBone;
		}

		function sortWeights(indexes, weights) {

			var pairs = [];

			for (var i = 0; i < indexes.length; i++) {

				pairs.push({
					i: indexes[i],
					w: weights[i]
				});
			}

			pairs.sort(function (a, b) {

				return b.w - a.w;
			});

			while (pairs.length < 4) {

				pairs.push({
					i: 0,
					w: 0
				});
			}

			if (pairs.length > 4) pairs.length = 4;
			var sum = 0;

			for (var i = 0; i < 4; i++) {

				sum += pairs[i].w * pairs[i].w;
			}

			sum = Math.sqrt(sum);

			for (var i = 0; i < 4; i++) {

				pairs[i].w = pairs[i].w / sum;
				indexes[i] = pairs[i].i;
				weights[i] = pairs[i].w;
			}
		}

		function findMatchingBone(root, name) {

			if (root.name.indexOf("bone_" + name) == 0) return root;

			for (var i in root.children) {

				var ret = findMatchingBone(root.children[i], name);

				if (ret) return ret;
			}

			return undefined;
		}

		function aiMesh() {

			this.mPrimitiveTypes = 0;
			this.mNumVertices = 0;
			this.mNumFaces = 0;
			this.mNumBones = 0;
			this.mMaterialIndex = 0;
			this.mVertices = [];
			this.mNormals = [];
			this.mTangents = [];
			this.mBitangents = [];
			this.mColors = [[]];
			this.mTextureCoords = [[]];
			this.mFaces = [];
			this.mBones = [];
			this.hookupSkeletons = function (scene, threeScene) {

				if (this.mBones.length == 0) return;

				var allBones = [];
				var offsetMatrix = [];
				var skeletonRoot = scene.findNode(this.mBones[0].mName);

				while (skeletonRoot.mParent && skeletonRoot.mParent.isBone) {

					skeletonRoot = skeletonRoot.mParent;
				}

				var threeSkeletonRoot = skeletonRoot.toTHREE(scene);
				var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);
				this.threeNode.add(threeSkeletonRootBone);

				for (var i = 0; i < this.mBones.length; i++) {

					var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);

					if (bone) {

						var tbone = bone;
						allBones.push(tbone);
						//tbone.matrixAutoUpdate = false;
						offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());
					} else {

						var skeletonRoot = scene.findNode(this.mBones[i].mName);
						if (!skeletonRoot) return;
						var threeSkeletonRoot = skeletonRoot.toTHREE(scene);
						var threeSkeletonRootParent = threeSkeletonRoot.parent;
						var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);
						this.threeNode.add(threeSkeletonRootBone);
						var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);
						var tbone = bone;
						allBones.push(tbone);
						//tbone.matrixAutoUpdate = false;
						offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());
					}
				}
				var skeleton = new THREE.Skeleton(allBones, offsetMatrix);

				this.threeNode.bind(skeleton, new THREE.Matrix4());
				this.threeNode.material.skinning = true;
			};

			this.toTHREE = function (scene) {

				if (this.threeNode) return this.threeNode;
				var geometry = new THREE.BufferGeometry();
				var mat;
				if (scene.mMaterials[this.mMaterialIndex]) mat = scene.mMaterials[this.mMaterialIndex].toTHREE(scene);else mat = new THREE.MeshLambertMaterial();
				geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(this.mIndexArray), 1));
				geometry.addAttribute('position', new THREE.BufferAttribute(this.mVertexBuffer, 3));
				if (this.mNormalBuffer && this.mNormalBuffer.length > 0) geometry.addAttribute('normal', new THREE.BufferAttribute(this.mNormalBuffer, 3));
				if (this.mColorBuffer && this.mColorBuffer.length > 0) geometry.addAttribute('color', new THREE.BufferAttribute(this.mColorBuffer, 4));
				if (this.mTexCoordsBuffers[0] && this.mTexCoordsBuffers[0].length > 0) geometry.addAttribute('uv', new THREE.BufferAttribute(new Float32Array(this.mTexCoordsBuffers[0]), 2));
				if (this.mTexCoordsBuffers[1] && this.mTexCoordsBuffers[1].length > 0) geometry.addAttribute('uv1', new THREE.BufferAttribute(new Float32Array(this.mTexCoordsBuffers[1]), 2));
				if (this.mTangentBuffer && this.mTangentBuffer.length > 0) geometry.addAttribute('tangents', new THREE.BufferAttribute(this.mTangentBuffer, 3));
				if (this.mBitangentBuffer && this.mBitangentBuffer.length > 0) geometry.addAttribute('bitangents', new THREE.BufferAttribute(this.mBitangentBuffer, 3));
				if (this.mBones.length > 0) {

					var weights = [];
					var bones = [];

					for (var i = 0; i < this.mBones.length; i++) {

						for (var j = 0; j < this.mBones[i].mWeights.length; j++) {

							var weight = this.mBones[i].mWeights[j];
							if (weight) {

								if (!weights[weight.mVertexId]) weights[weight.mVertexId] = [];
								if (!bones[weight.mVertexId]) bones[weight.mVertexId] = [];
								weights[weight.mVertexId].push(weight.mWeight);
								bones[weight.mVertexId].push(parseInt(i));
							}
						}
					}

					for (var i in bones) {

						sortWeights(bones[i], weights[i]);
					}

					var _weights = [];
					var _bones = [];

					for (var i = 0; i < weights.length; i++) {

						for (var j = 0; j < 4; j++) {

							if (weights[i] && bones[i]) {

								_weights.push(weights[i][j]);
								_bones.push(bones[i][j]);
							} else {

								_weights.push(0);
								_bones.push(0);
							}
						}
					}

					geometry.addAttribute('skinWeight', new THREE.BufferAttribute(new Float32Array(_weights), BONESPERVERT));
					geometry.addAttribute('skinIndex', new THREE.BufferAttribute(new Float32Array(_bones), BONESPERVERT));
				}

				var mesh;

				if (this.mBones.length == 0) mesh = new THREE.Mesh(geometry, mat);

				if (this.mBones.length > 0) mesh = new THREE.SkinnedMesh(geometry, mat);

				this.threeNode = mesh;
				//mesh.matrixAutoUpdate = false;
				return mesh;
			};
		}

		function aiFace() {

			this.mNumIndices = 0;
			this.mIndices = [];
		}

		function aiVector3D() {

			this.x = 0;
			this.y = 0;
			this.z = 0;

			this.toTHREE = function () {

				return new THREE.Vector3(this.x, this.y, this.z);
			};
		}

		function aiVector2D() {

			this.x = 0;
			this.y = 0;
			this.toTHREE = function () {

				return new THREE.Vector2(this.x, this.y);
			};
		}

		function aiVector4D() {

			this.w = 0;
			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.toTHREE = function () {

				return new THREE.Vector4(this.w, this.x, this.y, this.z);
			};
		}

		function aiColor4D() {

			this.r = 0;
			this.g = 0;
			this.b = 0;
			this.a = 0;
			this.toTHREE = function () {

				return new THREE.Color(this.r, this.g, this.b, this.a);
			};
		}

		function aiColor3D() {

			this.r = 0;
			this.g = 0;
			this.b = 0;
			this.a = 0;
			this.toTHREE = function () {

				return new THREE.Color(this.r, this.g, this.b, 1);
			};
		}

		function aiQuaternion() {

			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 0;
			this.toTHREE = function () {

				return new THREE.Quaternion(this.x, this.y, this.z, this.w);
			};
		}

		function aiVertexWeight() {

			this.mVertexId = 0;
			this.mWeight = 0;
		}

		function aiString() {

			this.data = [];
			this.toString = function () {

				var str = '';
				this.data.forEach(function (i) {

					str += String.fromCharCode(i);
				});
				return str.replace(/[^\x20-\x7E]+/g, '');
			};
		}

		function aiVectorKey() {

			this.mTime = 0;
			this.mValue = null;
		}

		function aiQuatKey() {

			this.mTime = 0;
			this.mValue = null;
		}

		function aiNode() {

			this.mName = '';
			this.mTransformation = [];
			this.mNumChildren = 0;
			this.mNumMeshes = 0;
			this.mMeshes = [];
			this.mChildren = [];
			this.toTHREE = function (scene) {

				if (this.threeNode) return this.threeNode;
				var o = new THREE.Object3D();
				o.name = this.mName;
				o.matrix = this.mTransformation.toTHREE();

				for (var i = 0; i < this.mChildren.length; i++) {

					o.add(this.mChildren[i].toTHREE(scene));
				}

				for (var i = 0; i < this.mMeshes.length; i++) {

					o.add(scene.mMeshes[this.mMeshes[i]].toTHREE(scene));
				}

				this.threeNode = o;
				//o.matrixAutoUpdate = false;
				o.matrix.decompose(o.position, o.quaternion, o.scale);
				return o;
			};
		}

		function aiBone() {

			this.mName = '';
			this.mNumWeights = 0;
			this.mOffsetMatrix = 0;
		}

		function aiMaterialProperty() {

			this.mKey = "";
			this.mSemantic = 0;
			this.mIndex = 0;
			this.mData = [];
			this.mDataLength = 0;
			this.mType = 0;
			this.dataAsColor = function () {

				var array = new Uint8Array(this.mData).buffer;
				var reader = new DataView(array);
				var r = reader.getFloat32(0, true);
				var g = reader.getFloat32(4, true);
				var b = reader.getFloat32(8, true);
				//var a = reader.getFloat32(12, true);
				return new THREE.Color(r, g, b);
			};

			this.dataAsFloat = function () {

				var array = new Uint8Array(this.mData).buffer;
				var reader = new DataView(array);
				var r = reader.getFloat32(0, true);
				return r;
			};

			this.dataAsBool = function () {

				var array = new Uint8Array(this.mData).buffer;
				var reader = new DataView(array);
				var r = reader.getFloat32(0, true);
				return !!r;
			};

			this.dataAsString = function () {

				var s = new aiString();
				s.data = this.mData;
				return s.toString();
			};

			this.dataAsMap = function () {

				var s = new aiString();
				s.data = this.mData;
				var path = s.toString();
				path = path.replace(/\\/g, '/');

				if (path.indexOf('/') != -1) {

					path = path.substr(path.lastIndexOf('/') + 1);
				}

				return textureLoader.load(path);
			};
		}
		var namePropMapping = {

			"?mat.name": "name",
			"$mat.shadingm": "shading",
			"$mat.twosided": "twoSided",
			"$mat.wireframe": "wireframe",
			"$clr.ambient": "ambient",
			"$clr.diffuse": "color",
			"$clr.specular": "specular",
			"$clr.emissive": "emissive",
			"$clr.transparent": "transparent",
			"$clr.reflective": "reflect",
			"$mat.shininess": "shininess",
			"$mat.reflectivity": "reflectivity",
			"$mat.refracti": "refraction",
			"$tex.file": "map"

		};

		var nameTypeMapping = {

			"?mat.name": "string",
			"$mat.shadingm": "bool",
			"$mat.twosided": "bool",
			"$mat.wireframe": "bool",
			"$clr.ambient": "color",
			"$clr.diffuse": "color",
			"$clr.specular": "color",
			"$clr.emissive": "color",
			"$clr.transparent": "color",
			"$clr.reflective": "color",
			"$mat.shininess": "float",
			"$mat.reflectivity": "float",
			"$mat.refracti": "float",
			"$tex.file": "map"

		};

		function aiMaterial() {

			this.mNumAllocated = 0;
			this.mNumProperties = 0;
			this.mProperties = [];
			this.toTHREE = function (scene) {

				var name = this.mProperties[0].dataAsString();
				var mat = new THREE.MeshPhongMaterial();

				for (var i = 0; i < this.mProperties.length; i++) {

					if (nameTypeMapping[this.mProperties[i].mKey] == 'float') mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsFloat();
					if (nameTypeMapping[this.mProperties[i].mKey] == 'color') mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsColor();
					if (nameTypeMapping[this.mProperties[i].mKey] == 'bool') mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsBool();
					if (nameTypeMapping[this.mProperties[i].mKey] == 'string') mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsString();
					if (nameTypeMapping[this.mProperties[i].mKey] == 'map') {

						var prop = this.mProperties[i];
						if (prop.mSemantic == aiTextureType_DIFFUSE) mat.map = this.mProperties[i].dataAsMap();
						if (prop.mSemantic == aiTextureType_NORMALS) mat.normalMap = this.mProperties[i].dataAsMap();
						if (prop.mSemantic == aiTextureType_LIGHTMAP) mat.lightMap = this.mProperties[i].dataAsMap();
						if (prop.mSemantic == aiTextureType_OPACITY) mat.alphaMap = this.mProperties[i].dataAsMap();
					}
				}

				mat.ambient.r = .53;
				mat.ambient.g = .53;
				mat.ambient.b = .53;
				mat.color.r = 1;
				mat.color.g = 1;
				mat.color.b = 1;
				return mat;
			};
		}

		function veclerp(v1, v2, l) {

			var v = new THREE.Vector3();
			var lm1 = 1 - l;
			v.x = v1.x * l + v2.x * lm1;
			v.y = v1.y * l + v2.y * lm1;
			v.z = v1.z * l + v2.z * lm1;
			return v;
		}

		function quatlerp(q1, q2, l) {

			return q1.clone().slerp(q2, 1 - l);
		}

		function sampleTrack(keys, time, lne, lerp) {

			if (keys.length == 1) return keys[0].mValue.toTHREE();

			var dist = Infinity;
			var key = null;
			var nextKey = null;

			for (var i = 0; i < keys.length; i++) {

				var timeDist = Math.abs(keys[i].mTime - time);

				if (timeDist < dist && keys[i].mTime <= time) {

					dist = timeDist;
					key = keys[i];
					nextKey = keys[i + 1];
				}
			}

			if (!key) {

				return null;
			} else if (nextKey) {

				var dT = nextKey.mTime - key.mTime;
				var T = key.mTime - time;
				var l = T / dT;

				return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);
			} else {

				nextKey = keys[0].clone();
				nextKey.mTime += lne;

				var dT = nextKey.mTime - key.mTime;
				var T = key.mTime - time;
				var l = T / dT;

				return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);
			}
		}

		function aiNodeAnim() {

			this.mNodeName = "";
			this.mNumPositionKeys = 0;
			this.mNumRotationKeys = 0;
			this.mNumScalingKeys = 0;
			this.mPositionKeys = [];
			this.mRotationKeys = [];
			this.mScalingKeys = [];
			this.mPreState = "";
			this.mPostState = "";
			this.init = function (tps) {

				if (!tps) tps = 1;

				function t(t) {

					t.mTime /= tps;
				}

				this.mPositionKeys.forEach(t);
				this.mRotationKeys.forEach(t);
				this.mScalingKeys.forEach(t);
			};

			this.sortKeys = function () {

				function comp(a, b) {

					return a.mTime - b.mTime;
				}

				this.mPositionKeys.sort(comp);
				this.mRotationKeys.sort(comp);
				this.mScalingKeys.sort(comp);
			};

			this.getLength = function () {

				return Math.max(Math.max.apply(null, this.mPositionKeys.map(function (a) {

					return a.mTime;
				})), Math.max.apply(null, this.mRotationKeys.map(function (a) {

					return a.mTime;
				})), Math.max.apply(null, this.mScalingKeys.map(function (a) {

					return a.mTime;
				})));
			};

			this.toTHREE = function (o, tps) {

				this.sortKeys();
				var length = this.getLength();
				var track = new Virtulous.KeyFrameTrack();

				for (var i = 0; i < length; i += .05) {

					var matrix = new THREE.Matrix4();
					var time = i;
					var pos = sampleTrack(this.mPositionKeys, time, length, veclerp);
					var scale = sampleTrack(this.mScalingKeys, time, length, veclerp);
					var rotation = sampleTrack(this.mRotationKeys, time, length, quatlerp);
					matrix.compose(pos, rotation, scale);

					var key = new Virtulous.KeyFrame(time, matrix);
					track.addKey(key);
				}

				track.target = o.findNode(this.mNodeName).toTHREE();

				var tracks = [track];

				if (o.nodeToBoneMap[this.mNodeName]) {

					for (var i = 0; i < o.nodeToBoneMap[this.mNodeName].length; i++) {

						var t2 = track.clone();
						t2.target = o.nodeToBoneMap[this.mNodeName][i];
						tracks.push(t2);
					}
				}

				return tracks;
			};
		}

		function aiAnimation() {

			this.mName = "";
			this.mDuration = 0;
			this.mTicksPerSecond = 0;
			this.mNumChannels = 0;
			this.mChannels = [];
			this.toTHREE = function (root) {

				var animationHandle = new Virtulous.Animation();

				for (var i in this.mChannels) {

					this.mChannels[i].init(this.mTicksPerSecond);

					var tracks = this.mChannels[i].toTHREE(root);

					for (var j in tracks) {

						tracks[j].init();
						animationHandle.addTrack(tracks[j]);
					}
				}

				animationHandle.length = Math.max.apply(null, animationHandle.tracks.map(function (e) {

					return e.length;
				}));
				return animationHandle;
			};
		}

		function aiTexture() {

			this.mWidth = 0;
			this.mHeight = 0;
			this.texAchFormatHint = [];
			this.pcData = [];
		}

		function aiLight() {

			this.mName = '';
			this.mType = 0;
			this.mAttenuationConstant = 0;
			this.mAttenuationLinear = 0;
			this.mAttenuationQuadratic = 0;
			this.mAngleInnerCone = 0;
			this.mAngleOuterCone = 0;
			this.mColorDiffuse = null;
			this.mColorSpecular = null;
			this.mColorAmbient = null;
		}

		function aiCamera() {

			this.mName = '';
			this.mPosition = null;
			this.mLookAt = null;
			this.mUp = null;
			this.mHorizontalFOV = 0;
			this.mClipPlaneNear = 0;
			this.mClipPlaneFar = 0;
			this.mAspect = 0;
		}

		function aiScene() {

			this.mFlags = 0;
			this.mNumMeshes = 0;
			this.mNumMaterials = 0;
			this.mNumAnimations = 0;
			this.mNumTextures = 0;
			this.mNumLights = 0;
			this.mNumCameras = 0;
			this.mRootNode = null;
			this.mMeshes = [];
			this.mMaterials = [];
			this.mAnimations = [];
			this.mLights = [];
			this.mCameras = [];
			this.nodeToBoneMap = {};
			this.findNode = function (name, root) {

				if (!root) {

					root = this.mRootNode;
				}

				if (root.mName == name) {

					return root;
				}

				for (var i = 0; i < root.mChildren.length; i++) {

					var ret = this.findNode(name, root.mChildren[i]);
					if (ret) return ret;
				}

				return null;
			};

			this.toTHREE = function () {

				this.nodeCount = 0;

				markBones(this);

				var o = this.mRootNode.toTHREE(this);

				for (var i in this.mMeshes) {
					this.mMeshes[i].hookupSkeletons(this, o);
				}if (this.mAnimations.length > 0) {

					var a = this.mAnimations[0].toTHREE(this);
				}

				return { object: o, animation: a };
			};
		}

		function aiMatrix4() {

			this.elements = [[], [], [], []];
			this.toTHREE = function () {

				var m = new THREE.Matrix4();

				for (var i = 0; i < 4; ++i) {

					for (var i2 = 0; i2 < 4; ++i2) {

						m.elements[i * 4 + i2] = this.elements[i2][i];
					}
				}

				return m;
			};
		}

		var littleEndian = true;

		function readFloat(dataview) {

			var val = dataview.getFloat32(dataview.readOffset, littleEndian);
			dataview.readOffset += 4;
			return val;
		}

		function Read_double(dataview) {

			var val = dataview.getFloat64(dataview.readOffset, littleEndian);
			dataview.readOffset += 8;
			return val;
		}

		function Read_uint8_t(dataview) {

			var val = dataview.getUint8(dataview.readOffset);
			dataview.readOffset += 1;
			return val;
		}

		function Read_uint16_t(dataview) {

			var val = dataview.getUint16(dataview.readOffset, littleEndian);
			dataview.readOffset += 2;
			return val;
		}

		function Read_unsigned_int(dataview) {

			var val = dataview.getUint32(dataview.readOffset, littleEndian);
			dataview.readOffset += 4;
			return val;
		}

		function Read_uint32_t(dataview) {

			var val = dataview.getUint32(dataview.readOffset, littleEndian);
			dataview.readOffset += 4;
			return val;
		}

		function Read_aiVector3D(stream) {

			var v = new aiVector3D();
			v.x = readFloat(stream);
			v.y = readFloat(stream);
			v.z = readFloat(stream);
			return v;
		}

		function Read_aiVector2D(stream) {

			var v = new aiVector2D();
			v.x = readFloat(stream);
			v.y = readFloat(stream);
			return v;
		}

		function Read_aiVector4D(stream) {

			var v = new aiVector4D();
			v.w = readFloat(stream);
			v.x = readFloat(stream);
			v.y = readFloat(stream);
			v.z = readFloat(stream);
			return v;
		}

		function Read_aiColor3D(stream) {

			var c = new aiColor3D();
			c.r = readFloat(stream);
			c.g = readFloat(stream);
			c.b = readFloat(stream);
			return c;
		}

		function Read_aiColor4D(stream) {

			var c = new aiColor4D();
			c.r = readFloat(stream);
			c.g = readFloat(stream);
			c.b = readFloat(stream);
			c.a = readFloat(stream);
			return c;
		}

		function Read_aiQuaternion(stream) {

			var v = new aiQuaternion();
			v.w = readFloat(stream);
			v.x = readFloat(stream);
			v.y = readFloat(stream);
			v.z = readFloat(stream);
			return v;
		}

		function Read_aiString(stream) {

			var s = new aiString();
			var stringlengthbytes = Read_unsigned_int(stream);
			stream.ReadBytes(s.data, 1, stringlengthbytes);
			return s.toString();
		}

		function Read_aiVertexWeight(stream) {

			var w = new aiVertexWeight();
			w.mVertexId = Read_unsigned_int(stream);
			w.mWeight = readFloat(stream);
			return w;
		}

		function Read_aiMatrix4x4(stream) {

			var m = new aiMatrix4();

			for (var i = 0; i < 4; ++i) {

				for (var i2 = 0; i2 < 4; ++i2) {

					m.elements[i][i2] = readFloat(stream);
				}
			}

			return m;
		}

		function Read_aiVectorKey(stream) {

			var v = new aiVectorKey();
			v.mTime = Read_double(stream);
			v.mValue = Read_aiVector3D(stream);
			return v;
		}

		function Read_aiQuatKey(stream) {

			var v = new aiQuatKey();
			v.mTime = Read_double(stream);
			v.mValue = Read_aiQuaternion(stream);
			return v;
		}

		function ReadArray(stream, data, size) {

			for (var i = 0; i < size; i++) {
				data[i] = Read(stream);
			}
		}

		function ReadArray_aiVector2D(stream, data, size) {

			for (var i = 0; i < size; i++) {
				data[i] = Read_aiVector2D(stream);
			}
		}

		function ReadArray_aiVector3D(stream, data, size) {

			for (var i = 0; i < size; i++) {
				data[i] = Read_aiVector3D(stream);
			}
		}

		function ReadArray_aiVector4D(stream, data, size) {

			for (var i = 0; i < size; i++) {
				data[i] = Read_aiVector4D(stream);
			}
		}

		function ReadArray_aiVertexWeight(stream, data, size) {

			for (var i = 0; i < size; i++) {
				data[i] = Read_aiVertexWeight(stream);
			}
		}

		function ReadArray_aiColor4D(stream, data, size) {

			for (var i = 0; i < size; i++) {
				data[i] = Read_aiColor4D(stream);
			}
		}

		function ReadArray_aiVectorKey(stream, data, size) {

			for (var i = 0; i < size; i++) {
				data[i] = Read_aiVectorKey(stream);
			}
		}

		function ReadArray_aiQuatKey(stream, data, size) {

			for (var i = 0; i < size; i++) {
				data[i] = Read_aiQuatKey(stream);
			}
		}

		function ReadBounds(stream, T /*p*/, n) {

			// not sure what to do here, the data isn't really useful.
			return stream.Seek(sizeof(T) * n, aiOrigin_CUR);
		}

		function ai_assert(bool) {

			if (!bool) throw "asset failed";
		}

		function ReadBinaryNode(stream, parent, depth) {

			var chunkID = Read_uint32_t(stream);
			ai_assert(chunkID == ASSBIN_CHUNK_AINODE);
			/*uint32_t size =*/
			Read_uint32_t(stream);
			var node = new aiNode();
			node.mParent = parent;
			node.mDepth = depth;
			node.mName = Read_aiString(stream);
			node.mTransformation = Read_aiMatrix4x4(stream);
			node.mNumChildren = Read_unsigned_int(stream);
			node.mNumMeshes = Read_unsigned_int(stream);

			if (node.mNumMeshes) {

				node.mMeshes = [];

				for (var i = 0; i < node.mNumMeshes; ++i) {

					node.mMeshes[i] = Read_unsigned_int(stream);
				}
			}

			if (node.mNumChildren) {

				node.mChildren = [];

				for (var i = 0; i < node.mNumChildren; ++i) {

					var node2 = ReadBinaryNode(stream, node, depth++);
					node.mChildren[i] = node2;
				}
			}

			return node;
		}

		// -----------------------------------------------------------------------------------

		function ReadBinaryBone(stream, b) {

			var chunkID = Read_uint32_t(stream);
			ai_assert(chunkID == ASSBIN_CHUNK_AIBONE);
			/*uint32_t size =*/
			Read_uint32_t(stream);
			b.mName = Read_aiString(stream);
			b.mNumWeights = Read_unsigned_int(stream);
			b.mOffsetMatrix = Read_aiMatrix4x4(stream);
			// for the moment we write dumb min/max values for the bones, too.
			// maybe I'll add a better, hash-like solution later
			if (shortened) {

				ReadBounds(stream, b.mWeights, b.mNumWeights);
			} else {

				// else write as usual

				b.mWeights = [];
				ReadArray_aiVertexWeight(stream, b.mWeights, b.mNumWeights);
			}

			return b;
		}

		function ReadBinaryMesh(stream, mesh) {

			var chunkID = Read_uint32_t(stream);
			ai_assert(chunkID == ASSBIN_CHUNK_AIMESH);
			/*uint32_t size =*/
			Read_uint32_t(stream);
			mesh.mPrimitiveTypes = Read_unsigned_int(stream);
			mesh.mNumVertices = Read_unsigned_int(stream);
			mesh.mNumFaces = Read_unsigned_int(stream);
			mesh.mNumBones = Read_unsigned_int(stream);
			mesh.mMaterialIndex = Read_unsigned_int(stream);
			mesh.mNumUVComponents = [];
			// first of all, write bits for all existent vertex components
			var c = Read_unsigned_int(stream);

			if (c & ASSBIN_MESH_HAS_POSITIONS) {

				if (shortened) {

					ReadBounds(stream, mesh.mVertices, mesh.mNumVertices);
				} else {

					// else write as usual

					mesh.mVertices = [];
					mesh.mVertexBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);
					stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);
				}
			}

			if (c & ASSBIN_MESH_HAS_NORMALS) {

				if (shortened) {

					ReadBounds(stream, mesh.mNormals, mesh.mNumVertices);
				} else {

					// else write as usual

					mesh.mNormals = [];
					mesh.mNormalBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);
					stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);
				}
			}

			if (c & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS) {

				if (shortened) {

					ReadBounds(stream, mesh.mTangents, mesh.mNumVertices);
					ReadBounds(stream, mesh.mBitangents, mesh.mNumVertices);
				} else {

					// else write as usual

					mesh.mTangents = [];
					mesh.mTangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);
					stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);
					mesh.mBitangents = [];
					mesh.mBitangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);
					stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);
				}
			}

			for (var n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++n) {

				if (!(c & ASSBIN_MESH_HAS_COLOR(n))) break;

				if (shortened) {

					ReadBounds(stream, mesh.mColors[n], mesh.mNumVertices);
				} else {

					// else write as usual

					mesh.mColors[n] = [];
					mesh.mColorBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4);
					stream.Seek(mesh.mNumVertices * 4 * 4, aiOrigin_CUR);
				}
			}

			mesh.mTexCoordsBuffers = [];

			for (var n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++n) {

				if (!(c & ASSBIN_MESH_HAS_TEXCOORD(n))) break;

				// write number of UV components
				mesh.mNumUVComponents[n] = Read_unsigned_int(stream);

				if (shortened) {

					ReadBounds(stream, mesh.mTextureCoords[n], mesh.mNumVertices);
				} else {

					// else write as usual

					mesh.mTextureCoords[n] = [];
					//note that assbin always writes 3d texcoords
					mesh.mTexCoordsBuffers[n] = [];

					for (var uv = 0; uv < mesh.mNumVertices; uv++) {

						mesh.mTexCoordsBuffers[n].push(readFloat(stream));
						mesh.mTexCoordsBuffers[n].push(readFloat(stream));
						readFloat(stream);
					}
				}
			}
			// write faces. There are no floating-point calculations involved
			// in these, so we can write a simple hash over the face data
			// to the dump file. We generate a single 32 Bit hash for 512 faces
			// using Assimp's standard hashing function.
			if (shortened) {

				Read_unsigned_int(stream);
			} else {

				// else write as usual

				// if there are less than 2^16 vertices, we can simply use 16 bit integers ...
				mesh.mFaces = [];

				var indexCounter = 0;
				mesh.mIndexArray = [];

				for (var i = 0; i < mesh.mNumFaces; ++i) {

					var f = mesh.mFaces[i] = new aiFace();
					// BOOST_STATIC_ASSERT(AI_MAX_FACE_INDICES <= 0xffff);
					f.mNumIndices = Read_uint16_t(stream);
					f.mIndices = [];

					for (var a = 0; a < f.mNumIndices; ++a) {

						if (mesh.mNumVertices < 1 << 16) {

							f.mIndices[a] = Read_uint16_t(stream);
						} else {

							f.mIndices[a] = Read_unsigned_int(stream);
						}
					}

					if (f.mNumIndices === 3) {

						mesh.mIndexArray.push(f.mIndices[0]);
						mesh.mIndexArray.push(f.mIndices[1]);
						mesh.mIndexArray.push(f.mIndices[2]);
					} else if (f.mNumIndices === 4) {

						mesh.mIndexArray.push(f.mIndices[0]);
						mesh.mIndexArray.push(f.mIndices[1]);
						mesh.mIndexArray.push(f.mIndices[2]);
						mesh.mIndexArray.push(f.mIndices[2]);
						mesh.mIndexArray.push(f.mIndices[3]);
						mesh.mIndexArray.push(f.mIndices[0]);
					} else {

						throw new Error("Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.");
					}
				}
			}
			// write bones
			if (mesh.mNumBones) {

				mesh.mBones = [];

				for (var a = 0; a < mesh.mNumBones; ++a) {

					mesh.mBones[a] = new aiBone();
					ReadBinaryBone(stream, mesh.mBones[a]);
				}
			}
		}

		function ReadBinaryMaterialProperty(stream, prop) {

			var chunkID = Read_uint32_t(stream);
			ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY);
			/*uint32_t size =*/
			Read_uint32_t(stream);
			prop.mKey = Read_aiString(stream);
			prop.mSemantic = Read_unsigned_int(stream);
			prop.mIndex = Read_unsigned_int(stream);
			prop.mDataLength = Read_unsigned_int(stream);
			prop.mType = Read_unsigned_int(stream);
			prop.mData = [];
			stream.ReadBytes(prop.mData, 1, prop.mDataLength);
		}

		// -----------------------------------------------------------------------------------

		function ReadBinaryMaterial(stream, mat) {

			var chunkID = Read_uint32_t(stream);
			ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIAL);
			/*uint32_t size =*/
			Read_uint32_t(stream);
			mat.mNumAllocated = mat.mNumProperties = Read_unsigned_int(stream);

			if (mat.mNumProperties) {

				if (mat.mProperties) {

					delete mat.mProperties;
				}

				mat.mProperties = [];

				for (var i = 0; i < mat.mNumProperties; ++i) {

					mat.mProperties[i] = new aiMaterialProperty();
					ReadBinaryMaterialProperty(stream, mat.mProperties[i]);
				}
			}
		}
		// -----------------------------------------------------------------------------------
		function ReadBinaryNodeAnim(stream, nd) {

			var chunkID = Read_uint32_t(stream);
			ai_assert(chunkID == ASSBIN_CHUNK_AINODEANIM);
			/*uint32_t size =*/
			Read_uint32_t(stream);
			nd.mNodeName = Read_aiString(stream);
			nd.mNumPositionKeys = Read_unsigned_int(stream);
			nd.mNumRotationKeys = Read_unsigned_int(stream);
			nd.mNumScalingKeys = Read_unsigned_int(stream);
			nd.mPreState = Read_unsigned_int(stream);
			nd.mPostState = Read_unsigned_int(stream);

			if (nd.mNumPositionKeys) {

				if (shortened) {

					ReadBounds(stream, nd.mPositionKeys, nd.mNumPositionKeys);
				} else {

					// else write as usual

					nd.mPositionKeys = [];
					ReadArray_aiVectorKey(stream, nd.mPositionKeys, nd.mNumPositionKeys);
				}
			}

			if (nd.mNumRotationKeys) {

				if (shortened) {

					ReadBounds(stream, nd.mRotationKeys, nd.mNumRotationKeys);
				} else {

					// else write as usual

					nd.mRotationKeys = [];
					ReadArray_aiQuatKey(stream, nd.mRotationKeys, nd.mNumRotationKeys);
				}
			}

			if (nd.mNumScalingKeys) {

				if (shortened) {

					ReadBounds(stream, nd.mScalingKeys, nd.mNumScalingKeys);
				} else {

					// else write as usual

					nd.mScalingKeys = [];
					ReadArray_aiVectorKey(stream, nd.mScalingKeys, nd.mNumScalingKeys);
				}
			}
		}
		// -----------------------------------------------------------------------------------
		function ReadBinaryAnim(stream, anim) {

			var chunkID = Read_uint32_t(stream);
			ai_assert(chunkID == ASSBIN_CHUNK_AIANIMATION);
			/*uint32_t size =*/
			Read_uint32_t(stream);
			anim.mName = Read_aiString(stream);
			anim.mDuration = Read_double(stream);
			anim.mTicksPerSecond = Read_double(stream);
			anim.mNumChannels = Read_unsigned_int(stream);

			if (anim.mNumChannels) {

				anim.mChannels = [];

				for (var a = 0; a < anim.mNumChannels; ++a) {

					anim.mChannels[a] = new aiNodeAnim();
					ReadBinaryNodeAnim(stream, anim.mChannels[a]);
				}
			}
		}

		function ReadBinaryTexture(stream, tex) {

			var chunkID = Read_uint32_t(stream);
			ai_assert(chunkID == ASSBIN_CHUNK_AITEXTURE);
			/*uint32_t size =*/
			Read_uint32_t(stream);
			tex.mWidth = Read_unsigned_int(stream);
			tex.mHeight = Read_unsigned_int(stream);
			stream.ReadBytes(tex.achFormatHint, 1, 4);

			if (!shortened) {

				if (!tex.mHeight) {

					tex.pcData = [];
					stream.ReadBytes(tex.pcData, 1, tex.mWidth);
				} else {

					tex.pcData = [];
					stream.ReadBytes(tex.pcData, 1, tex.mWidth * tex.mHeight * 4);
				}
			}
		}
		// -----------------------------------------------------------------------------------
		function ReadBinaryLight(stream, l) {

			var chunkID = Read_uint32_t(stream);
			ai_assert(chunkID == ASSBIN_CHUNK_AILIGHT);
			/*uint32_t size =*/
			Read_uint32_t(stream);
			l.mName = Read_aiString(stream);
			l.mType = Read_unsigned_int(stream);

			if (l.mType != aiLightSource_DIRECTIONAL) {

				l.mAttenuationConstant = readFloat(stream);
				l.mAttenuationLinear = readFloat(stream);
				l.mAttenuationQuadratic = readFloat(stream);
			}

			l.mColorDiffuse = Read_aiColor3D(stream);
			l.mColorSpecular = Read_aiColor3D(stream);
			l.mColorAmbient = Read_aiColor3D(stream);

			if (l.mType == aiLightSource_SPOT) {

				l.mAngleInnerCone = readFloat(stream);
				l.mAngleOuterCone = readFloat(stream);
			}
		}
		// -----------------------------------------------------------------------------------
		function ReadBinaryCamera(stream, cam) {

			var chunkID = Read_uint32_t(stream);
			ai_assert(chunkID == ASSBIN_CHUNK_AICAMERA);
			/*uint32_t size =*/
			Read_uint32_t(stream);
			cam.mName = Read_aiString(stream);
			cam.mPosition = Read_aiVector3D(stream);
			cam.mLookAt = Read_aiVector3D(stream);
			cam.mUp = Read_aiVector3D(stream);
			cam.mHorizontalFOV = readFloat(stream);
			cam.mClipPlaneNear = readFloat(stream);
			cam.mClipPlaneFar = readFloat(stream);
			cam.mAspect = readFloat(stream);
		}

		function ReadBinaryScene(stream, scene) {

			var chunkID = Read_uint32_t(stream);
			ai_assert(chunkID == ASSBIN_CHUNK_AISCENE);
			/*uint32_t size =*/
			Read_uint32_t(stream);
			scene.mFlags = Read_unsigned_int(stream);
			scene.mNumMeshes = Read_unsigned_int(stream);
			scene.mNumMaterials = Read_unsigned_int(stream);
			scene.mNumAnimations = Read_unsigned_int(stream);
			scene.mNumTextures = Read_unsigned_int(stream);
			scene.mNumLights = Read_unsigned_int(stream);
			scene.mNumCameras = Read_unsigned_int(stream);
			// Read node graph
			scene.mRootNode = new aiNode();
			scene.mRootNode = ReadBinaryNode(stream, null, 0);
			// Read all meshes
			if (scene.mNumMeshes) {

				scene.mMeshes = [];

				for (var i = 0; i < scene.mNumMeshes; ++i) {

					scene.mMeshes[i] = new aiMesh();
					ReadBinaryMesh(stream, scene.mMeshes[i]);
				}
			}
			// Read materials
			if (scene.mNumMaterials) {

				scene.mMaterials = [];

				for (var i = 0; i < scene.mNumMaterials; ++i) {

					scene.mMaterials[i] = new aiMaterial();
					ReadBinaryMaterial(stream, scene.mMaterials[i]);
				}
			}
			// Read all animations
			if (scene.mNumAnimations) {

				scene.mAnimations = [];

				for (var i = 0; i < scene.mNumAnimations; ++i) {

					scene.mAnimations[i] = new aiAnimation();
					ReadBinaryAnim(stream, scene.mAnimations[i]);
				}
			}
			// Read all textures
			if (scene.mNumTextures) {

				scene.mTextures = [];

				for (var i = 0; i < scene.mNumTextures; ++i) {

					scene.mTextures[i] = new aiTexture();
					ReadBinaryTexture(stream, scene.mTextures[i]);
				}
			}
			// Read lights
			if (scene.mNumLights) {

				scene.mLights = [];

				for (var i = 0; i < scene.mNumLights; ++i) {

					scene.mLights[i] = new aiLight();
					ReadBinaryLight(stream, scene.mLights[i]);
				}
			}
			// Read cameras
			if (scene.mNumCameras) {

				scene.mCameras = [];

				for (var i = 0; i < scene.mNumCameras; ++i) {

					scene.mCameras[i] = new aiCamera();
					ReadBinaryCamera(stream, scene.mCameras[i]);
				}
			}
		}
		var aiOrigin_CUR = 0;
		var aiOrigin_BEG = 1;

		function extendStream(stream) {

			stream.readOffset = 0;
			stream.Seek = function (off, ori) {

				if (ori == aiOrigin_CUR) {

					stream.readOffset += off;
				}
				if (ori == aiOrigin_BEG) {

					stream.readOffset = off;
				}
			};

			stream.ReadBytes = function (buff, size, n) {

				var bytes = size * n;
				for (var i = 0; i < bytes; i++) {
					buff[i] = Read_uint8_t(this);
				}
			};

			stream.subArray32 = function (start, end) {

				var buff = this.buffer;
				var newbuff = buff.slice(start, end);
				return new Float32Array(newbuff);
			};

			stream.subArrayUint16 = function (start, end) {

				var buff = this.buffer;
				var newbuff = buff.slice(start, end);
				return new Uint16Array(newbuff);
			};

			stream.subArrayUint8 = function (start, end) {

				var buff = this.buffer;
				var newbuff = buff.slice(start, end);
				return new Uint8Array(newbuff);
			};

			stream.subArrayUint32 = function (start, end) {

				var buff = this.buffer;
				var newbuff = buff.slice(start, end);
				return new Uint32Array(newbuff);
			};
		}

		var shortened, compressed;

		function InternReadFile(pFiledata) {

			var pScene = new aiScene();
			var stream = new DataView(pFiledata);
			extendStream(stream);
			stream.Seek(44, aiOrigin_CUR); // signature
			/*unsigned int versionMajor =*/
			var versionMajor = Read_unsigned_int(stream);
			/*unsigned int versionMinor =*/
			var versionMinor = Read_unsigned_int(stream);
			/*unsigned int versionRevision =*/
			var versionRevision = Read_unsigned_int(stream);
			/*unsigned int compileFlags =*/
			var compileFlags = Read_unsigned_int(stream);
			shortened = Read_uint16_t(stream) > 0;
			compressed = Read_uint16_t(stream) > 0;
			if (shortened) throw "Shortened binaries are not supported!";
			stream.Seek(256, aiOrigin_CUR); // original filename
			stream.Seek(128, aiOrigin_CUR); // options
			stream.Seek(64, aiOrigin_CUR); // padding
			if (compressed) {

				var uncompressedSize = Read_uint32_t(stream);
				var compressedSize = stream.FileSize() - stream.Tell();
				var compressedData = [];
				stream.Read(compressedData, 1, compressedSize);
				var uncompressedData = [];
				uncompress(uncompressedData, uncompressedSize, compressedData, compressedSize);
				var buff = new ArrayBuffer(uncompressedData);
				ReadBinaryScene(buff, pScene);
			} else {

				ReadBinaryScene(stream, pScene);
				return pScene.toTHREE();
			}
		}

		return InternReadFile(buffer);
	}

};

exports.default = AssimpLoader;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Author: Pierre Lepers
 * Date: 09/12/2013 17:21
 */

exports.default = function () {

	var UNCOMPRESSED = 0,
	    DEFLATE = 1,
	    LZMA = 2,
	    AWD_FIELD_INT8 = 1,
	    AWD_FIELD_INT16 = 2,
	    AWD_FIELD_INT32 = 3,
	    AWD_FIELD_UINT8 = 4,
	    AWD_FIELD_UINT16 = 5,
	    AWD_FIELD_UINT32 = 6,
	    AWD_FIELD_FLOAT32 = 7,
	    AWD_FIELD_FLOAT64 = 8,
	    AWD_FIELD_BOOL = 21,
	    AWD_FIELD_COLOR = 22,
	    AWD_FIELD_BADDR = 23,
	    AWD_FIELD_STRING = 31,
	    AWD_FIELD_BYTEARRAY = 32,
	    AWD_FIELD_VECTOR2x1 = 41,
	    AWD_FIELD_VECTOR3x1 = 42,
	    AWD_FIELD_VECTOR4x1 = 43,
	    AWD_FIELD_MTX3x2 = 44,
	    AWD_FIELD_MTX3x3 = 45,
	    AWD_FIELD_MTX4x3 = 46,
	    AWD_FIELD_MTX4x4 = 47,
	    BOOL = 21,
	    COLOR = 22,
	    BADDR = 23,
	    INT8 = 1,
	    INT16 = 2,
	    INT32 = 3,
	    UINT8 = 4,
	    UINT16 = 5,
	    UINT32 = 6,
	    FLOAT32 = 7,
	    FLOAT64 = 8;

	var littleEndian = true;

	function Block() {

		this.id = 0;
		this.data = null;
	}

	function AWDProperties() {}

	AWDProperties.prototype = {
		set: function set(key, value) {

			this[key] = value;
		},

		get: function get(key, fallback) {

			if (this.hasOwnProperty(key)) {

				return this[key];
			} else {

				return fallback;
			}
		}
	};

	var AWDLoader = function AWDLoader(manager) {

		this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;

		this.trunk = new THREE.Object3D();

		this.materialFactory = undefined;

		this._url = '';
		this._baseDir = '';

		this._data = undefined;
		this._ptr = 0;

		this._version = [];
		this._streaming = false;
		this._optimized_for_accuracy = false;
		this._compression = 0;
		this._bodylen = 0xFFFFFFFF;

		this._blocks = [new Block()];

		this._accuracyMatrix = false;
		this._accuracyGeo = false;
		this._accuracyProps = false;
	};

	AWDLoader.prototype = {

		constructor: AWDLoader,

		load: function load(url, onLoad, onProgress, onError) {

			var scope = this;

			this._url = url;
			this._baseDir = url.substr(0, url.lastIndexOf('/') + 1);

			var loader = new THREE.FileLoader(this.manager);
			loader.setResponseType('arraybuffer');
			loader.load(url, function (text) {

				onLoad(scope.parse(text));
			}, onProgress, onError);
		},

		parse: function parse(data) {

			var blen = data.byteLength;

			this._ptr = 0;
			this._data = new DataView(data);

			this._parseHeader();

			if (this._compression != 0) {

				console.error('compressed AWD not supported');
			}

			if (!this._streaming && this._bodylen != data.byteLength - this._ptr) {

				console.error('AWDLoader: body len does not match file length', this._bodylen, blen - this._ptr);
			}

			while (this._ptr < blen) {

				this.parseNextBlock();
			}

			return this.trunk;
		},

		parseNextBlock: function parseNextBlock() {

			var assetData,
			    ns,
			    type,
			    len,
			    block,
			    blockId = this.readU32(),
			    ns = this.readU8(),
			    type = this.readU8(),
			    flags = this.readU8(),
			    len = this.readU32();

			switch (type) {

				case 1:
					assetData = this.parseMeshData(len);
					break;

				case 22:
					assetData = this.parseContainer(len);
					break;

				case 23:
					assetData = this.parseMeshInstance(len);
					break;

				case 81:
					assetData = this.parseMaterial(len);
					break;

				case 82:
					assetData = this.parseTexture(len);
					break;

				case 101:
					assetData = this.parseSkeleton(len);
					break;

				//  case 111:
				//    assetData = this.parseMeshPoseAnimation(len, true);
				//    break;

				case 112:
					assetData = this.parseMeshPoseAnimation(len, false);
					break;

				case 113:
					assetData = this.parseVertexAnimationSet(len);
					break;

				case 102:
					assetData = this.parseSkeletonPose(len);
					break;

				case 103:
					assetData = this.parseSkeletonAnimation(len);
					break;

				case 122:
					assetData = this.parseAnimatorSet(len);
					break;

				// case 121:
				//  assetData = parseUVAnimation(len);
				//  break;

				default:
					//debug('Ignoring block!',type, len);
					this._ptr += len;
					break;

			}

			// Store block reference for later use
			this._blocks[blockId] = block = new Block();
			block.data = assetData;
			block.id = blockId;
		},

		_parseHeader: function _parseHeader() {

			var version = this._version,
			    awdmagic = this.readU8() << 16 | this.readU8() << 8 | this.readU8();

			if (awdmagic != 4282180) throw new Error("AWDLoader - bad magic");

			version[0] = this.readU8();
			version[1] = this.readU8();

			var flags = this.readU16();

			this._streaming = (flags & 0x1) == 0x1;

			if (version[0] === 2 && version[1] === 1) {

				this._accuracyMatrix = (flags & 0x2) === 0x2;
				this._accuracyGeo = (flags & 0x4) === 0x4;
				this._accuracyProps = (flags & 0x8) === 0x8;
			}

			this._geoNrType = this._accuracyGeo ? FLOAT64 : FLOAT32;
			this._matrixNrType = this._accuracyMatrix ? FLOAT64 : FLOAT32;
			this._propsNrType = this._accuracyProps ? FLOAT64 : FLOAT32;

			this._optimized_for_accuracy = (flags & 0x2) === 0x2;

			this._compression = this.readU8();
			this._bodylen = this.readU32();
		},

		parseContainer: function parseContainer(len) {

			var parent,
			    ctr = new THREE.Object3D(),
			    par_id = this.readU32(),
			    mtx = this.parseMatrix4();

			ctr.name = this.readUTF();
			ctr.applyMatrix(mtx);

			parent = this._blocks[par_id].data || this.trunk;
			parent.add(ctr);

			this.parseProperties({
				1: this._matrixNrType,
				2: this._matrixNrType,
				3: this._matrixNrType,
				4: UINT8
			});

			ctr.extra = this.parseUserAttributes();

			return ctr;
		},

		parseMeshInstance: function parseMeshInstance(len) {

			var name, mesh, geometries, meshLen, meshes, par_id, data_id, mtx, materials, mat, mat_id, num_materials, parent, i;

			par_id = this.readU32();
			mtx = this.parseMatrix4();
			name = this.readUTF();
			data_id = this.readU32();
			num_materials = this.readU16();

			geometries = this.getBlock(data_id);

			materials = [];

			for (i = 0; i < num_materials; i++) {

				mat_id = this.readU32();
				mat = this.getBlock(mat_id);
				materials.push(mat);
			}

			meshLen = geometries.length;
			meshes = [];

			// TODO : BufferGeometry don't support "geometryGroups" for now.
			// so we create sub meshes for each groups
			if (meshLen > 1) {

				mesh = new THREE.Object3D();
				for (i = 0; i < meshLen; i++) {

					var sm = new THREE.Mesh(geometries[i]);
					meshes.push(sm);
					mesh.add(sm);
				}
			} else {

				mesh = new THREE.Mesh(geometries[0]);
				meshes.push(mesh);
			}

			mesh.applyMatrix(mtx);
			mesh.name = name;

			parent = this.getBlock(par_id) || this.trunk;
			parent.add(mesh);

			var matLen = materials.length;
			var maxLen = Math.max(meshLen, matLen);
			for (i = 0; i < maxLen; i++) {
				meshes[i % meshLen].material = materials[i % matLen];
			} // Ignore for now
			this.parseProperties(null);
			mesh.extra = this.parseUserAttributes();

			return mesh;
		},

		parseMaterial: function parseMaterial(len) {

			var name, type, props, mat, attributes, finalize, num_methods, methods_parsed;

			name = this.readUTF();
			type = this.readU8();
			num_methods = this.readU8();

			//log( "AWDLoader parseMaterial ",name )

			// Read material numerical properties
			// (1=color, 2=bitmap url, 11=alpha_blending, 12=alpha_threshold, 13=repeat)
			props = this.parseProperties({
				1: AWD_FIELD_INT32,
				2: AWD_FIELD_BADDR,
				11: AWD_FIELD_BOOL,
				12: AWD_FIELD_FLOAT32,
				13: AWD_FIELD_BOOL
			});

			methods_parsed = 0;

			while (methods_parsed < num_methods) {

				var method_type = this.readU16();
				this.parseProperties(null);
				this.parseUserAttributes();
			}

			attributes = this.parseUserAttributes();

			if (this.materialFactory !== undefined) {

				mat = this.materialFactory(name);
				if (mat) return mat;
			}

			mat = new THREE.MeshPhongMaterial();

			if (type === 1) {

				// Color material
				mat.color.setHex(props.get(1, 0xcccccc));
			} else if (type === 2) {

				// Bitmap material
				var tex_addr = props.get(2, 0);
				mat.map = this.getBlock(tex_addr);
			}

			mat.extra = attributes;
			mat.alphaThreshold = props.get(12, 0.0);
			mat.repeat = props.get(13, false);

			return mat;
		},

		parseTexture: function parseTexture(len) {

			var name = this.readUTF(),
			    type = this.readU8(),
			    asset,
			    data_len;

			// External
			if (type === 0) {

				data_len = this.readU32();
				var url = this.readUTFBytes(data_len);
				console.log(url);

				asset = this.loadTexture(url);
			} else {}
			// embed texture not supported

			// Ignore for now
			this.parseProperties(null);

			this.parseUserAttributes();
			return asset;
		},

		loadTexture: function loadTexture(url) {

			var tex = new THREE.Texture();

			var loader = new THREE.ImageLoader(this.manager);

			loader.load(this._baseDir + url, function (image) {

				tex.image = image;
				tex.needsUpdate = true;
			});

			return tex;
		},

		parseSkeleton: function parseSkeleton(len) {

			// Array<Bone>
			var name = this.readUTF(),
			    num_joints = this.readU16(),
			    skeleton = [],
			    joints_parsed = 0;

			this.parseProperties(null);

			while (joints_parsed < num_joints) {

				var joint, ibp;

				// Ignore joint id
				this.readU16();

				joint = new THREE.Bone();
				joint.parent = this.readU16() - 1; // 0=null in AWD
				joint.name = this.readUTF();

				ibp = this.parseMatrix4();
				joint.skinMatrix = ibp;

				// Ignore joint props/attributes for now
				this.parseProperties(null);
				this.parseUserAttributes();

				skeleton.push(joint);
				joints_parsed++;
			}

			// Discard attributes for now
			this.parseUserAttributes();

			return skeleton;
		},

		parseSkeletonPose: function parseSkeletonPose(blockID) {

			var name = this.readUTF();

			var num_joints = this.readU16();
			this.parseProperties(null);

			// debug( 'parse Skeleton Pose. joints : ' + num_joints);

			var pose = [];

			var joints_parsed = 0;

			while (joints_parsed < num_joints) {

				var joint_pose;

				var has_transform; //:uint;
				var mtx_data;

				has_transform = this.readU8();

				if (has_transform === 1) {

					mtx_data = this.parseMatrix4();
				} else {

					mtx_data = new THREE.Matrix4();
				}
				pose[joints_parsed] = mtx_data;
				joints_parsed++;
			}

			// Skip attributes for now
			this.parseUserAttributes();

			return pose;
		},

		parseSkeletonAnimation: function parseSkeletonAnimation(blockID) {

			var frame_dur;
			var pose_addr;
			var pose;

			var name = this.readUTF();

			var clip = [];

			var num_frames = this.readU16();
			this.parseProperties(null);

			var frames_parsed = 0;
			var returnedArray;

			// debug( 'parse Skeleton Animation. frames : ' + num_frames);

			while (frames_parsed < num_frames) {

				pose_addr = this.readU32();
				frame_dur = this.readU16();

				pose = this._blocks[pose_addr].data;
				// debug( 'pose address ',pose[2].elements[12],pose[2].elements[13],pose[2].elements[14] );
				clip.push({
					pose: pose,
					duration: frame_dur
				});

				frames_parsed++;
			}

			if (clip.length === 0) {

				// debug("Could not this SkeletonClipNode, because no Frames where set.");
				return;
			}
			// Ignore attributes for now
			this.parseUserAttributes();
			return clip;
		},

		parseVertexAnimationSet: function parseVertexAnimationSet(len) {

			var poseBlockAdress,
			    name = this.readUTF(),
			    num_frames = this.readU16(),
			    props = this.parseProperties({ 1: UINT16 }),
			    frames_parsed = 0,
			    skeletonFrames = [];

			while (frames_parsed < num_frames) {

				poseBlockAdress = this.readU32();
				skeletonFrames.push(this._blocks[poseBlockAdress].data);
				frames_parsed++;
			}

			this.parseUserAttributes();

			return skeletonFrames;
		},

		parseAnimatorSet: function parseAnimatorSet(len) {

			var targetMesh;

			var animSetBlockAdress; //:int

			var targetAnimationSet; //:AnimationSetBase;
			var outputString = ""; //:String = "";
			var name = this.readUTF();
			var type = this.readU16();

			var props = this.parseProperties({ 1: BADDR });

			animSetBlockAdress = this.readU32();
			var targetMeshLength = this.readU16();

			var meshAdresses = []; //:Vector.<uint> = new Vector.<uint>;

			for (var i = 0; i < targetMeshLength; i++) {
				meshAdresses.push(this.readU32());
			}var activeState = this.readU16();
			var autoplay = Boolean(this.readU8());
			this.parseUserAttributes();
			this.parseUserAttributes();

			var returnedArray;
			var targetMeshes = []; //:Vector.<Mesh> = new Vector.<Mesh>;

			for (i = 0; i < meshAdresses.length; i++) {

				//      returnedArray = getAssetByID(meshAdresses[i], [AssetType.MESH]);
				//      if (returnedArray[0])
				targetMeshes.push(this._blocks[meshAdresses[i]].data);
			}

			targetAnimationSet = this._blocks[animSetBlockAdress].data;
			var thisAnimator;

			if (type == 1) {

				thisAnimator = {
					animationSet: targetAnimationSet,
					skeleton: this._blocks[props.get(1, 0)].data
				};
			} else if (type == 2) {
				// debug( "vertex Anim???");
			}

			for (i = 0; i < targetMeshes.length; i++) {

				targetMeshes[i].animator = thisAnimator;
			}
			// debug("Parsed a Animator: Name = " + name);

			return thisAnimator;
		},

		parseMeshData: function parseMeshData(len) {

			var name = this.readUTF(),
			    num_subs = this.readU16(),
			    geom,
			    subs_parsed = 0,
			    buffer,
			    skinW,
			    skinI,
			    geometries = [];

			// Ignore for now
			this.parseProperties({ 1: this._geoNrType, 2: this._geoNrType });

			// Loop through sub meshes
			while (subs_parsed < num_subs) {

				var sm_len, sm_end, attrib;

				geom = new THREE.BufferGeometry();
				geom.name = name;
				geometries.push(geom);

				sm_len = this.readU32();
				sm_end = this._ptr + sm_len;

				// Ignore for now
				this.parseProperties({ 1: this._geoNrType, 2: this._geoNrType });

				// Loop through data streams
				while (this._ptr < sm_end) {

					var idx = 0,
					    str_type = this.readU8(),
					    str_ftype = this.readU8(),
					    str_len = this.readU32(),
					    str_end = str_len + this._ptr;

					if (str_type === 1) {

						// VERTICES

						buffer = new Float32Array(str_len / 12 * 3);
						attrib = new THREE.BufferAttribute(buffer, 3);

						geom.addAttribute('position', attrib);
						idx = 0;

						while (this._ptr < str_end) {

							buffer[idx] = -this.readF32();
							buffer[idx + 1] = this.readF32();
							buffer[idx + 2] = this.readF32();
							idx += 3;
						}
					} else if (str_type === 2) {

						// INDICES

						buffer = new Uint16Array(str_len / 2);
						attrib = new THREE.BufferAttribute(buffer, 1);
						geom.setIndex(attrib);

						idx = 0;

						while (this._ptr < str_end) {

							buffer[idx + 1] = this.readU16();
							buffer[idx] = this.readU16();
							buffer[idx + 2] = this.readU16();
							idx += 3;
						}
					} else if (str_type === 3) {

						// UVS

						buffer = new Float32Array(str_len / 8 * 2);
						attrib = new THREE.BufferAttribute(buffer, 2);

						geom.addAttribute('uv', attrib);
						idx = 0;

						while (this._ptr < str_end) {

							buffer[idx] = this.readF32();
							buffer[idx + 1] = 1.0 - this.readF32();
							idx += 2;
						}
					} else if (str_type === 4) {

						// NORMALS

						buffer = new Float32Array(str_len / 12 * 3);
						attrib = new THREE.BufferAttribute(buffer, 3);
						geom.addAttribute('normal', attrib);
						idx = 0;

						while (this._ptr < str_end) {

							buffer[idx] = -this.readF32();
							buffer[idx + 1] = this.readF32();
							buffer[idx + 2] = this.readF32();
							idx += 3;
						}
					} else {

						this._ptr = str_end;
					}
				}

				this.parseUserAttributes();

				geom.computeBoundingSphere();
				subs_parsed++;
			}

			//geom.computeFaceNormals();

			this.parseUserAttributes();
			//finalizeAsset(geom, name);

			return geometries;
		},

		parseMeshPoseAnimation: function parseMeshPoseAnimation(len, poseOnly) {

			var num_frames = 1,
			    num_submeshes,
			    frames_parsed,
			    subMeshParsed,
			    frame_dur,
			    x,
			    y,
			    z,
			    str_len,
			    str_end,
			    geom,
			    subGeom,
			    idx = 0,
			    clip = {},
			    indices,
			    verts,
			    num_Streams,
			    streamsParsed,
			    streamtypes = [],
			    props,
			    thisGeo,
			    name = this.readUTF(),
			    geoAdress = this.readU32();

			var mesh = this.getBlock(geoAdress);

			if (mesh === null) {

				console.log("parseMeshPoseAnimation target mesh not found at:", geoAdress);
				return;
			}

			geom = mesh.geometry;
			geom.morphTargets = [];

			if (!poseOnly) num_frames = this.readU16();

			num_submeshes = this.readU16();
			num_Streams = this.readU16();

			// debug("VA num_frames : ", num_frames );
			// debug("VA num_submeshes : ", num_submeshes );
			// debug("VA numstreams : ", num_Streams );

			streamsParsed = 0;
			while (streamsParsed < num_Streams) {

				streamtypes.push(this.readU16());
				streamsParsed++;
			}
			props = this.parseProperties({ 1: BOOL, 2: BOOL });

			clip.looping = props.get(1, true);
			clip.stitchFinalFrame = props.get(2, false);

			frames_parsed = 0;

			while (frames_parsed < num_frames) {

				frame_dur = this.readU16();
				subMeshParsed = 0;

				while (subMeshParsed < num_submeshes) {

					streamsParsed = 0;
					str_len = this.readU32();
					str_end = this._ptr + str_len;

					while (streamsParsed < num_Streams) {

						if (streamtypes[streamsParsed] === 1) {

							//geom.addAttribute( 'morphTarget'+frames_parsed, Float32Array, str_len/12, 3 );
							var buffer = new Float32Array(str_len / 4);
							geom.morphTargets.push({
								array: buffer
							});

							//buffer = geom.attributes['morphTarget'+frames_parsed].array
							idx = 0;

							while (this._ptr < str_end) {

								buffer[idx] = this.readF32();
								buffer[idx + 1] = this.readF32();
								buffer[idx + 2] = this.readF32();
								idx += 3;
							}

							subMeshParsed++;
						} else this._ptr = str_end;
						streamsParsed++;
					}
				}

				frames_parsed++;
			}

			this.parseUserAttributes();

			return null;
		},

		getBlock: function getBlock(id) {

			return this._blocks[id].data;
		},

		parseMatrix4: function parseMatrix4() {

			var mtx = new THREE.Matrix4();
			var e = mtx.elements;

			e[0] = this.readF32();
			e[1] = this.readF32();
			e[2] = this.readF32();
			e[3] = 0.0;
			//e[3] = 0.0;

			e[4] = this.readF32();
			e[5] = this.readF32();
			e[6] = this.readF32();
			//e[7] = this.readF32();
			e[7] = 0.0;

			e[8] = this.readF32();
			e[9] = this.readF32();
			e[10] = this.readF32();
			//e[11] = this.readF32();
			e[11] = 0.0;

			e[12] = -this.readF32();
			e[13] = this.readF32();
			e[14] = this.readF32();
			//e[15] = this.readF32();
			e[15] = 1.0;
			return mtx;
		},

		parseProperties: function parseProperties(expected) {

			var list_len = this.readU32();
			var list_end = this._ptr + list_len;

			var props = new AWDProperties();

			if (expected) {

				while (this._ptr < list_end) {

					var key = this.readU16();
					var len = this.readU32();
					var type;

					if (expected.hasOwnProperty(key)) {

						type = expected[key];
						props.set(key, this.parseAttrValue(type, len));
					} else {

						this._ptr += len;
					}
				}
			}

			return props;
		},

		parseUserAttributes: function parseUserAttributes() {

			// skip for now
			this._ptr = this.readU32() + this._ptr;
			return null;
		},

		parseAttrValue: function parseAttrValue(type, len) {

			var elem_len;
			var read_func;

			switch (type) {

				case AWD_FIELD_INT8:
					elem_len = 1;
					read_func = this.readI8;
					break;

				case AWD_FIELD_INT16:
					elem_len = 2;
					read_func = this.readI16;
					break;

				case AWD_FIELD_INT32:
					elem_len = 4;
					read_func = this.readI32;
					break;

				case AWD_FIELD_BOOL:
				case AWD_FIELD_UINT8:
					elem_len = 1;
					read_func = this.readU8;
					break;

				case AWD_FIELD_UINT16:
					elem_len = 2;
					read_func = this.readU16;
					break;

				case AWD_FIELD_UINT32:
				case AWD_FIELD_BADDR:
					elem_len = 4;
					read_func = this.readU32;
					break;

				case AWD_FIELD_FLOAT32:
					elem_len = 4;
					read_func = this.readF32;
					break;

				case AWD_FIELD_FLOAT64:
					elem_len = 8;
					read_func = this.readF64;
					break;

				case AWD_FIELD_VECTOR2x1:
				case AWD_FIELD_VECTOR3x1:
				case AWD_FIELD_VECTOR4x1:
				case AWD_FIELD_MTX3x2:
				case AWD_FIELD_MTX3x3:
				case AWD_FIELD_MTX4x3:
				case AWD_FIELD_MTX4x4:
					elem_len = 8;
					read_func = this.readF64;
					break;

			}

			if (elem_len < len) {

				var list;
				var num_read;
				var num_elems;

				list = [];
				num_read = 0;
				num_elems = len / elem_len;

				while (num_read < num_elems) {

					list.push(read_func.call(this));
					num_read++;
				}

				return list;
			} else {

				return read_func.call(this);
			}
		},

		readU8: function readU8() {

			return this._data.getUint8(this._ptr++);
		},
		readI8: function readI8() {

			return this._data.getInt8(this._ptr++);
		},
		readU16: function readU16() {

			var a = this._data.getUint16(this._ptr, littleEndian);
			this._ptr += 2;
			return a;
		},
		readI16: function readI16() {

			var a = this._data.getInt16(this._ptr, littleEndian);
			this._ptr += 2;
			return a;
		},
		readU32: function readU32() {

			var a = this._data.getUint32(this._ptr, littleEndian);
			this._ptr += 4;
			return a;
		},
		readI32: function readI32() {

			var a = this._data.getInt32(this._ptr, littleEndian);
			this._ptr += 4;
			return a;
		},
		readF32: function readF32() {

			var a = this._data.getFloat32(this._ptr, littleEndian);
			this._ptr += 4;
			return a;
		},
		readF64: function readF64() {

			var a = this._data.getFloat64(this._ptr, littleEndian);
			this._ptr += 8;
			return a;
		},

		/**
  * Converts a UTF-8 byte array to JavaScript's 16-bit Unicode.
  * @param {Array.<number>} bytes UTF-8 byte array.
  * @return {string} 16-bit Unicode string.
  */
		readUTF: function readUTF() {

			var len = this.readU16();
			return this.readUTFBytes(len);
		},

		/**
   * Converts a UTF-8 byte array to JavaScript's 16-bit Unicode.
   * @param {Array.<number>} bytes UTF-8 byte array.
   * @return {string} 16-bit Unicode string.
   */
		readUTFBytes: function readUTFBytes(len) {

			// TODO(user): Use native implementations if/when available
			var out = [],
			    c = 0;

			while (out.length < len) {

				var c1 = this._data.getUint8(this._ptr++, littleEndian);
				if (c1 < 128) {

					out[c++] = String.fromCharCode(c1);
				} else if (c1 > 191 && c1 < 224) {

					var c2 = this._data.getUint8(this._ptr++, littleEndian);
					out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);
				} else {

					var c2 = this._data.getUint8(this._ptr++, littleEndian);
					var c3 = this._data.getUint8(this._ptr++, littleEndian);
					out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
				}
			}
			return out.join('');
		}

	};

	return AWDLoader;
}();

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

var BabylonLoader = function BabylonLoader(manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};

BabylonLoader.prototype = {

	constructor: BabylonLoader,

	load: function load(url, onLoad, onProgress, onError) {

		var scope = this;

		var loader = new THREE.FileLoader(scope.manager);
		loader.load(url, function (text) {

			onLoad(scope.parse(JSON.parse(text)));
		}, onProgress, onError);
	},

	parse: function parse(json) {

		function parseMaterials(json) {

			var materials = {};

			for (var i = 0, l = json.materials.length; i < l; i++) {

				var data = json.materials[i];

				var material = new THREE.MeshPhongMaterial();
				material.name = data.name;
				material.color.fromArray(data.diffuse);
				material.emissive.fromArray(data.emissive);
				material.specular.fromArray(data.specular);
				material.shininess = data.specularPower;
				material.opacity = data.alpha;

				materials[data.id] = material;
			}

			if (json.multiMaterials) {

				for (var i = 0, l = json.multiMaterials.length; i < l; i++) {

					var data = json.multiMaterials[i];

					console.warn('THREE.BabylonLoader: Multi materials not yet supported.');

					materials[data.id] = new THREE.MeshPhongMaterial();
				}
			}

			return materials;
		}

		function parseGeometry(json) {

			var geometry = new THREE.BufferGeometry();

			var indices = json.indices;
			var positions = json.positions;
			var normals = json.normals;
			var uvs = json.uvs;

			// indices

			geometry.setIndex(indices);

			// positions

			for (var j = 2, jl = positions.length; j < jl; j += 3) {

				positions[j] = -positions[j];
			}

			geometry.addAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

			// normals

			if (normals) {

				for (var j = 2, jl = normals.length; j < jl; j += 3) {

					normals[j] = -normals[j];
				}

				geometry.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
			}

			// uvs

			if (uvs) {

				geometry.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
			}

			// offsets

			var subMeshes = json.subMeshes;

			if (subMeshes) {

				for (var j = 0, jl = subMeshes.length; j < jl; j++) {

					var subMesh = subMeshes[j];

					geometry.addGroup(subMesh.indexStart, subMesh.indexCount);
				}
			}

			return geometry;
		}

		function parseObjects(json, materials) {

			var objects = {};
			var scene = new THREE.Scene();

			var cameras = json.cameras;

			for (var i = 0, l = cameras.length; i < l; i++) {

				var data = cameras[i];

				var camera = new THREE.PerspectiveCamera(data.fov / Math.PI * 180, 1.33, data.minZ, data.maxZ);

				camera.name = data.name;
				camera.position.fromArray(data.position);
				if (data.rotation) camera.rotation.fromArray(data.rotation);

				objects[data.id] = camera;
			}

			var lights = json.lights;

			for (var i = 0, l = lights.length; i < l; i++) {

				var data = lights[i];

				var light;

				switch (data.type) {

					case 0:
						light = new THREE.PointLight();
						break;

					case 1:
						light = new THREE.DirectionalLight();
						break;

					case 2:
						light = new THREE.SpotLight();
						break;

					case 3:
						light = new THREE.HemisphereLight();
						break;

				}

				light.name = data.name;
				if (data.position) light.position.set(data.position[0], data.position[1], -data.position[2]);
				light.color.fromArray(data.diffuse);
				if (data.groundColor) light.groundColor.fromArray(data.groundColor);
				if (data.intensity) light.intensity = data.intensity;

				objects[data.id] = light;

				scene.add(light);
			}

			var meshes = json.meshes;

			for (var i = 0, l = meshes.length; i < l; i++) {

				var data = meshes[i];

				var object;

				if (data.indices) {

					var geometry = parseGeometry(data);

					object = new THREE.Mesh(geometry, materials[data.materialId]);
				} else {

					object = new THREE.Group();
				}

				object.name = data.name;
				object.position.set(data.position[0], data.position[1], -data.position[2]);
				object.rotation.fromArray(data.rotation);
				if (data.rotationQuaternion) object.quaternion.fromArray(data.rotationQuaternion);
				object.scale.fromArray(data.scaling);
				// object.visible = data.isVisible;

				if (data.parentId) {

					objects[data.parentId].add(object);
				} else {

					scene.add(object);
				}

				objects[data.id] = object;
			}

			return scene;
		}

		var materials = parseMaterials(json);
		var scene = parseObjects(json, materials);

		return scene;
	}

};

exports.default = BabylonLoader;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author alteredq / http://alteredqualia.com/
 */

var BinaryLoader = function BinaryLoader(manager) {

	if (typeof manager === 'boolean') {

		console.warn('THREE.BinaryLoader: showStatus parameter has been removed from constructor.');
		manager = undefined;
	}

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};

BinaryLoader.prototype = {

	constructor: BinaryLoader,

	crossOrigin: 'Anonymous',

	// Load models generated by slim OBJ converter with BINARY option (converter_obj_three_slim.py -t binary)
	//  - binary models consist of two files: JS and BIN
	//  - parameters
	//		- url (required)
	//		- callback (required)
	//		- texturePath (optional: if not specified, textures will be assumed to be in the same folder as JS model file)
	//		- binaryPath (optional: if not specified, binary file will be assumed to be in the same folder as JS model file)
	load: function load(url, onLoad, onProgress, onError) {

		// todo: unify load API to for easier SceneLoader use

		var texturePath = this.texturePath || THREE.LoaderUtils.extractUrlBase(url);
		var binaryPath = this.binaryPath || THREE.LoaderUtils.extractUrlBase(url);

		// #1 load JS part via web worker

		var scope = this;

		var jsonloader = new THREE.FileLoader(this.manager);
		jsonloader.load(url, function (data) {

			var json = JSON.parse(data);

			var bufferUrl = binaryPath + json.buffers;

			var bufferLoader = new THREE.FileLoader(scope.manager);
			bufferLoader.setResponseType('arraybuffer');
			bufferLoader.load(bufferUrl, function (bufData) {

				// IEWEBGL needs this ???
				//buffer = ( new Uint8Array( xhr.responseBody ) ).buffer;

				//// iOS and other XMLHttpRequest level 1 ???

				scope.parse(bufData, onLoad, texturePath, json.materials);
			}, onProgress, onError);
		}, onProgress, onError);
	},

	setBinaryPath: function setBinaryPath(value) {

		this.binaryPath = value;
	},

	setCrossOrigin: function setCrossOrigin(value) {

		this.crossOrigin = value;
	},

	setTexturePath: function setTexturePath(value) {

		this.texturePath = value;
	},

	parse: function parse(data, callback, texturePath, jsonMaterials) {

		var Model = function Model() {

			var scope = this,
			    currentOffset = 0,
			    md,
			    normals = [],
			    uvs = [],
			    start_tri_flat,
			    start_tri_smooth,
			    start_tri_flat_uv,
			    start_tri_smooth_uv,
			    start_quad_flat,
			    start_quad_smooth,
			    start_quad_flat_uv,
			    start_quad_smooth_uv,
			    tri_size,
			    quad_size,
			    len_tri_flat,
			    len_tri_smooth,
			    len_tri_flat_uv,
			    len_tri_smooth_uv,
			    len_quad_flat,
			    len_quad_smooth,
			    len_quad_flat_uv;

			THREE.Geometry.call(this);

			md = parseMetaData(data, currentOffset);

			currentOffset += md.header_bytes;
			/*
   		md.vertex_index_bytes = Uint32Array.BYTES_PER_ELEMENT;
   		md.material_index_bytes = Uint16Array.BYTES_PER_ELEMENT;
   		md.normal_index_bytes = Uint32Array.BYTES_PER_ELEMENT;
   		md.uv_index_bytes = Uint32Array.BYTES_PER_ELEMENT;
   */
			// buffers sizes

			tri_size = md.vertex_index_bytes * 3 + md.material_index_bytes;
			quad_size = md.vertex_index_bytes * 4 + md.material_index_bytes;

			len_tri_flat = md.ntri_flat * tri_size;
			len_tri_smooth = md.ntri_smooth * (tri_size + md.normal_index_bytes * 3);
			len_tri_flat_uv = md.ntri_flat_uv * (tri_size + md.uv_index_bytes * 3);
			len_tri_smooth_uv = md.ntri_smooth_uv * (tri_size + md.normal_index_bytes * 3 + md.uv_index_bytes * 3);

			len_quad_flat = md.nquad_flat * quad_size;
			len_quad_smooth = md.nquad_smooth * (quad_size + md.normal_index_bytes * 4);
			len_quad_flat_uv = md.nquad_flat_uv * (quad_size + md.uv_index_bytes * 4);

			// read buffers

			currentOffset += init_vertices(currentOffset);

			currentOffset += init_normals(currentOffset);
			currentOffset += handlePadding(md.nnormals * 3);

			currentOffset += init_uvs(currentOffset);

			start_tri_flat = currentOffset;
			start_tri_smooth = start_tri_flat + len_tri_flat + handlePadding(md.ntri_flat * 2);
			start_tri_flat_uv = start_tri_smooth + len_tri_smooth + handlePadding(md.ntri_smooth * 2);
			start_tri_smooth_uv = start_tri_flat_uv + len_tri_flat_uv + handlePadding(md.ntri_flat_uv * 2);

			start_quad_flat = start_tri_smooth_uv + len_tri_smooth_uv + handlePadding(md.ntri_smooth_uv * 2);
			start_quad_smooth = start_quad_flat + len_quad_flat + handlePadding(md.nquad_flat * 2);
			start_quad_flat_uv = start_quad_smooth + len_quad_smooth + handlePadding(md.nquad_smooth * 2);
			start_quad_smooth_uv = start_quad_flat_uv + len_quad_flat_uv + handlePadding(md.nquad_flat_uv * 2);

			// have to first process faces with uvs
			// so that face and uv indices match

			init_triangles_flat_uv(start_tri_flat_uv);
			init_triangles_smooth_uv(start_tri_smooth_uv);

			init_quads_flat_uv(start_quad_flat_uv);
			init_quads_smooth_uv(start_quad_smooth_uv);

			// now we can process untextured faces

			init_triangles_flat(start_tri_flat);
			init_triangles_smooth(start_tri_smooth);

			init_quads_flat(start_quad_flat);
			init_quads_smooth(start_quad_smooth);

			this.computeFaceNormals();

			function handlePadding(n) {

				return n % 4 ? 4 - n % 4 : 0;
			}

			function parseMetaData(data, offset) {

				var metaData = {

					'signature': parseString(data, offset, 12),
					'header_bytes': parseUChar8(data, offset + 12),

					'vertex_coordinate_bytes': parseUChar8(data, offset + 13),
					'normal_coordinate_bytes': parseUChar8(data, offset + 14),
					'uv_coordinate_bytes': parseUChar8(data, offset + 15),

					'vertex_index_bytes': parseUChar8(data, offset + 16),
					'normal_index_bytes': parseUChar8(data, offset + 17),
					'uv_index_bytes': parseUChar8(data, offset + 18),
					'material_index_bytes': parseUChar8(data, offset + 19),

					'nvertices': parseUInt32(data, offset + 20),
					'nnormals': parseUInt32(data, offset + 20 + 4 * 1),
					'nuvs': parseUInt32(data, offset + 20 + 4 * 2),

					'ntri_flat': parseUInt32(data, offset + 20 + 4 * 3),
					'ntri_smooth': parseUInt32(data, offset + 20 + 4 * 4),
					'ntri_flat_uv': parseUInt32(data, offset + 20 + 4 * 5),
					'ntri_smooth_uv': parseUInt32(data, offset + 20 + 4 * 6),

					'nquad_flat': parseUInt32(data, offset + 20 + 4 * 7),
					'nquad_smooth': parseUInt32(data, offset + 20 + 4 * 8),
					'nquad_flat_uv': parseUInt32(data, offset + 20 + 4 * 9),
					'nquad_smooth_uv': parseUInt32(data, offset + 20 + 4 * 10)

				};
				/*
    			console.log( "signature: " + metaData.signature );
    				console.log( "header_bytes: " + metaData.header_bytes );
    			console.log( "vertex_coordinate_bytes: " + metaData.vertex_coordinate_bytes );
    			console.log( "normal_coordinate_bytes: " + metaData.normal_coordinate_bytes );
    			console.log( "uv_coordinate_bytes: " + metaData.uv_coordinate_bytes );
    				console.log( "vertex_index_bytes: " + metaData.vertex_index_bytes );
    			console.log( "normal_index_bytes: " + metaData.normal_index_bytes );
    			console.log( "uv_index_bytes: " + metaData.uv_index_bytes );
    			console.log( "material_index_bytes: " + metaData.material_index_bytes );
    				console.log( "nvertices: " + metaData.nvertices );
    			console.log( "nnormals: " + metaData.nnormals );
    			console.log( "nuvs: " + metaData.nuvs );
    				console.log( "ntri_flat: " + metaData.ntri_flat );
    			console.log( "ntri_smooth: " + metaData.ntri_smooth );
    			console.log( "ntri_flat_uv: " + metaData.ntri_flat_uv );
    			console.log( "ntri_smooth_uv: " + metaData.ntri_smooth_uv );
    				console.log( "nquad_flat: " + metaData.nquad_flat );
    			console.log( "nquad_smooth: " + metaData.nquad_smooth );
    			console.log( "nquad_flat_uv: " + metaData.nquad_flat_uv );
    			console.log( "nquad_smooth_uv: " + metaData.nquad_smooth_uv );
    				var total = metaData.header_bytes
    					  + metaData.nvertices * metaData.vertex_coordinate_bytes * 3
    					  + metaData.nnormals * metaData.normal_coordinate_bytes * 3
    					  + metaData.nuvs * metaData.uv_coordinate_bytes * 2
    					  + metaData.ntri_flat * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes )
    					  + metaData.ntri_smooth * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes + metaData.normal_index_bytes*3 )
    					  + metaData.ntri_flat_uv * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes + metaData.uv_index_bytes*3 )
    					  + metaData.ntri_smooth_uv * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes + metaData.normal_index_bytes*3 + metaData.uv_index_bytes*3 )
    					  + metaData.nquad_flat * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes )
    					  + metaData.nquad_smooth * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes + metaData.normal_index_bytes*4 )
    					  + metaData.nquad_flat_uv * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes + metaData.uv_index_bytes*4 )
    					  + metaData.nquad_smooth_uv * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes + metaData.normal_index_bytes*4 + metaData.uv_index_bytes*4 );
    			console.log( "total bytes: " + total );
    */

				return metaData;
			}

			function parseString(data, offset, length) {

				return THREE.LoaderUtils.decodeText(new Uint8Array(data, offset, length));
			}

			function parseUChar8(data, offset) {

				var charArray = new Uint8Array(data, offset, 1);

				return charArray[0];
			}

			function parseUInt32(data, offset) {

				var intArray = new Uint32Array(data, offset, 1);

				return intArray[0];
			}

			function init_vertices(start) {

				var nElements = md.nvertices;

				var coordArray = new Float32Array(data, start, nElements * 3);

				var i, x, y, z;

				for (i = 0; i < nElements; i++) {

					x = coordArray[i * 3];
					y = coordArray[i * 3 + 1];
					z = coordArray[i * 3 + 2];

					scope.vertices.push(new THREE.Vector3(x, y, z));
				}

				return nElements * 3 * Float32Array.BYTES_PER_ELEMENT;
			}

			function init_normals(start) {

				var nElements = md.nnormals;

				if (nElements) {

					var normalArray = new Int8Array(data, start, nElements * 3);

					var i, x, y, z;

					for (i = 0; i < nElements; i++) {

						x = normalArray[i * 3];
						y = normalArray[i * 3 + 1];
						z = normalArray[i * 3 + 2];

						normals.push(x / 127, y / 127, z / 127);
					}
				}

				return nElements * 3 * Int8Array.BYTES_PER_ELEMENT;
			}

			function init_uvs(start) {

				var nElements = md.nuvs;

				if (nElements) {

					var uvArray = new Float32Array(data, start, nElements * 2);

					var i, u, v;

					for (i = 0; i < nElements; i++) {

						u = uvArray[i * 2];
						v = uvArray[i * 2 + 1];

						uvs.push(u, v);
					}
				}

				return nElements * 2 * Float32Array.BYTES_PER_ELEMENT;
			}

			function init_uvs3(nElements, offset) {

				var i, uva, uvb, uvc, u1, u2, u3, v1, v2, v3;

				var uvIndexBuffer = new Uint32Array(data, offset, 3 * nElements);

				for (i = 0; i < nElements; i++) {

					uva = uvIndexBuffer[i * 3];
					uvb = uvIndexBuffer[i * 3 + 1];
					uvc = uvIndexBuffer[i * 3 + 2];

					u1 = uvs[uva * 2];
					v1 = uvs[uva * 2 + 1];

					u2 = uvs[uvb * 2];
					v2 = uvs[uvb * 2 + 1];

					u3 = uvs[uvc * 2];
					v3 = uvs[uvc * 2 + 1];

					scope.faceVertexUvs[0].push([new THREE.Vector2(u1, v1), new THREE.Vector2(u2, v2), new THREE.Vector2(u3, v3)]);
				}
			}

			function init_uvs4(nElements, offset) {

				var i, uva, uvb, uvc, uvd, u1, u2, u3, u4, v1, v2, v3, v4;

				var uvIndexBuffer = new Uint32Array(data, offset, 4 * nElements);

				for (i = 0; i < nElements; i++) {

					uva = uvIndexBuffer[i * 4];
					uvb = uvIndexBuffer[i * 4 + 1];
					uvc = uvIndexBuffer[i * 4 + 2];
					uvd = uvIndexBuffer[i * 4 + 3];

					u1 = uvs[uva * 2];
					v1 = uvs[uva * 2 + 1];

					u2 = uvs[uvb * 2];
					v2 = uvs[uvb * 2 + 1];

					u3 = uvs[uvc * 2];
					v3 = uvs[uvc * 2 + 1];

					u4 = uvs[uvd * 2];
					v4 = uvs[uvd * 2 + 1];

					scope.faceVertexUvs[0].push([new THREE.Vector2(u1, v1), new THREE.Vector2(u2, v2), new THREE.Vector2(u4, v4)]);

					scope.faceVertexUvs[0].push([new THREE.Vector2(u2, v2), new THREE.Vector2(u3, v3), new THREE.Vector2(u4, v4)]);
				}
			}

			function init_faces3_flat(nElements, offsetVertices, offsetMaterials) {

				var i, a, b, c, m;

				var vertexIndexBuffer = new Uint32Array(data, offsetVertices, 3 * nElements);
				var materialIndexBuffer = new Uint16Array(data, offsetMaterials, nElements);

				for (i = 0; i < nElements; i++) {

					a = vertexIndexBuffer[i * 3];
					b = vertexIndexBuffer[i * 3 + 1];
					c = vertexIndexBuffer[i * 3 + 2];

					m = materialIndexBuffer[i];

					scope.faces.push(new THREE.Face3(a, b, c, null, null, m));
				}
			}

			function init_faces4_flat(nElements, offsetVertices, offsetMaterials) {

				var i, a, b, c, d, m;

				var vertexIndexBuffer = new Uint32Array(data, offsetVertices, 4 * nElements);
				var materialIndexBuffer = new Uint16Array(data, offsetMaterials, nElements);

				for (i = 0; i < nElements; i++) {

					a = vertexIndexBuffer[i * 4];
					b = vertexIndexBuffer[i * 4 + 1];
					c = vertexIndexBuffer[i * 4 + 2];
					d = vertexIndexBuffer[i * 4 + 3];

					m = materialIndexBuffer[i];

					scope.faces.push(new THREE.Face3(a, b, d, null, null, m));
					scope.faces.push(new THREE.Face3(b, c, d, null, null, m));
				}
			}

			function init_faces3_smooth(nElements, offsetVertices, offsetNormals, offsetMaterials) {

				var i, a, b, c, m;
				var na, nb, nc;

				var vertexIndexBuffer = new Uint32Array(data, offsetVertices, 3 * nElements);
				var normalIndexBuffer = new Uint32Array(data, offsetNormals, 3 * nElements);
				var materialIndexBuffer = new Uint16Array(data, offsetMaterials, nElements);

				for (i = 0; i < nElements; i++) {

					a = vertexIndexBuffer[i * 3];
					b = vertexIndexBuffer[i * 3 + 1];
					c = vertexIndexBuffer[i * 3 + 2];

					na = normalIndexBuffer[i * 3];
					nb = normalIndexBuffer[i * 3 + 1];
					nc = normalIndexBuffer[i * 3 + 2];

					m = materialIndexBuffer[i];

					var nax = normals[na * 3],
					    nay = normals[na * 3 + 1],
					    naz = normals[na * 3 + 2],
					    nbx = normals[nb * 3],
					    nby = normals[nb * 3 + 1],
					    nbz = normals[nb * 3 + 2],
					    ncx = normals[nc * 3],
					    ncy = normals[nc * 3 + 1],
					    ncz = normals[nc * 3 + 2];

					scope.faces.push(new THREE.Face3(a, b, c, [new THREE.Vector3(nax, nay, naz), new THREE.Vector3(nbx, nby, nbz), new THREE.Vector3(ncx, ncy, ncz)], null, m));
				}
			}

			function init_faces4_smooth(nElements, offsetVertices, offsetNormals, offsetMaterials) {

				var i, a, b, c, d, m;
				var na, nb, nc, nd;

				var vertexIndexBuffer = new Uint32Array(data, offsetVertices, 4 * nElements);
				var normalIndexBuffer = new Uint32Array(data, offsetNormals, 4 * nElements);
				var materialIndexBuffer = new Uint16Array(data, offsetMaterials, nElements);

				for (i = 0; i < nElements; i++) {

					a = vertexIndexBuffer[i * 4];
					b = vertexIndexBuffer[i * 4 + 1];
					c = vertexIndexBuffer[i * 4 + 2];
					d = vertexIndexBuffer[i * 4 + 3];

					na = normalIndexBuffer[i * 4];
					nb = normalIndexBuffer[i * 4 + 1];
					nc = normalIndexBuffer[i * 4 + 2];
					nd = normalIndexBuffer[i * 4 + 3];

					m = materialIndexBuffer[i];

					var nax = normals[na * 3],
					    nay = normals[na * 3 + 1],
					    naz = normals[na * 3 + 2],
					    nbx = normals[nb * 3],
					    nby = normals[nb * 3 + 1],
					    nbz = normals[nb * 3 + 2],
					    ncx = normals[nc * 3],
					    ncy = normals[nc * 3 + 1],
					    ncz = normals[nc * 3 + 2],
					    ndx = normals[nd * 3],
					    ndy = normals[nd * 3 + 1],
					    ndz = normals[nd * 3 + 2];

					scope.faces.push(new THREE.Face3(a, b, d, [new THREE.Vector3(nax, nay, naz), new THREE.Vector3(nbx, nby, nbz), new THREE.Vector3(ndx, ndy, ndz)], null, m));

					scope.faces.push(new THREE.Face3(b, c, d, [new THREE.Vector3(nbx, nby, nbz), new THREE.Vector3(ncx, ncy, ncz), new THREE.Vector3(ndx, ndy, ndz)], null, m));
				}
			}

			function init_triangles_flat(start) {

				var nElements = md.ntri_flat;

				if (nElements) {

					var offsetMaterials = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;
					init_faces3_flat(nElements, start, offsetMaterials);
				}
			}

			function init_triangles_flat_uv(start) {

				var nElements = md.ntri_flat_uv;

				if (nElements) {

					var offsetUvs = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;
					var offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;

					init_faces3_flat(nElements, start, offsetMaterials);
					init_uvs3(nElements, offsetUvs);
				}
			}

			function init_triangles_smooth(start) {

				var nElements = md.ntri_smooth;

				if (nElements) {

					var offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;
					var offsetMaterials = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;

					init_faces3_smooth(nElements, start, offsetNormals, offsetMaterials);
				}
			}

			function init_triangles_smooth_uv(start) {

				var nElements = md.ntri_smooth_uv;

				if (nElements) {

					var offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;
					var offsetUvs = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;
					var offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;

					init_faces3_smooth(nElements, start, offsetNormals, offsetMaterials);
					init_uvs3(nElements, offsetUvs);
				}
			}

			function init_quads_flat(start) {

				var nElements = md.nquad_flat;

				if (nElements) {

					var offsetMaterials = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;
					init_faces4_flat(nElements, start, offsetMaterials);
				}
			}

			function init_quads_flat_uv(start) {

				var nElements = md.nquad_flat_uv;

				if (nElements) {

					var offsetUvs = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;
					var offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;

					init_faces4_flat(nElements, start, offsetMaterials);
					init_uvs4(nElements, offsetUvs);
				}
			}

			function init_quads_smooth(start) {

				var nElements = md.nquad_smooth;

				if (nElements) {

					var offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;
					var offsetMaterials = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;

					init_faces4_smooth(nElements, start, offsetNormals, offsetMaterials);
				}
			}

			function init_quads_smooth_uv(start) {

				var nElements = md.nquad_smooth_uv;

				if (nElements) {

					var offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;
					var offsetUvs = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;
					var offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;

					init_faces4_smooth(nElements, start, offsetNormals, offsetMaterials);
					init_uvs4(nElements, offsetUvs);
				}
			}
		};

		Model.prototype = Object.create(THREE.Geometry.prototype);
		Model.prototype.constructor = Model;

		var geometry = new Model();
		var materials = THREE.Loader.prototype.initMaterials(jsonMaterials, texturePath, this.crossOrigin);

		callback(geometry, materials);
	}

};

exports.default = BinaryLoader;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author herzig / http://github.com/herzig
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Description: reads BVH files and outputs a single THREE.Skeleton and an THREE.AnimationClip
 *
 * Currently only supports bvh files containing a single root.
 *
 */

var BVHLoader = function BVHLoader(manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;

	this.animateBonePositions = true;
	this.animateBoneRotations = true;
};

BVHLoader.prototype = {

	constructor: BVHLoader,

	load: function load(url, onLoad, onProgress, onError) {

		var scope = this;

		var loader = new THREE.FileLoader(scope.manager);
		loader.load(url, function (text) {

			onLoad(scope.parse(text));
		}, onProgress, onError);
	},

	parse: function parse(text) {

		/*
  	reads a string array (lines) from a BVH file
  	and outputs a skeleton structure including motion data
  		returns thee root node:
  	{ name: '', channels: [], children: [] }
  */
		function readBvh(lines) {

			// read model structure

			if (nextLine(lines) !== 'HIERARCHY') {

				console.error('THREE.BVHLoader: HIERARCHY expected.');
			}

			var list = []; // collects flat array of all bones
			var root = readNode(lines, nextLine(lines), list);

			// read motion data

			if (nextLine(lines) !== 'MOTION') {

				console.error('THREE.BVHLoader: MOTION expected.');
			}

			// number of frames

			var tokens = nextLine(lines).split(/[\s]+/);
			var numFrames = parseInt(tokens[1]);

			if (isNaN(numFrames)) {

				console.error('THREE.BVHLoader: Failed to read number of frames.');
			}

			// frame time

			tokens = nextLine(lines).split(/[\s]+/);
			var frameTime = parseFloat(tokens[2]);

			if (isNaN(frameTime)) {

				console.error('THREE.BVHLoader: Failed to read frame time.');
			}

			// read frame data line by line

			for (var i = 0; i < numFrames; i++) {

				tokens = nextLine(lines).split(/[\s]+/);
				readFrameData(tokens, i * frameTime, root);
			}

			return list;
		}

		/*
  	Recursively reads data from a single frame into the bone hierarchy.
  	The passed bone hierarchy has to be structured in the same order as the BVH file.
  	keyframe data is stored in bone.frames.
  		- data: splitted string array (frame values), values are shift()ed so
  	this should be empty after parsing the whole hierarchy.
  	- frameTime: playback time for this keyframe.
  	- bone: the bone to read frame data from.
  */
		function readFrameData(data, frameTime, bone) {

			// end sites have no motion data

			if (bone.type === 'ENDSITE') return;

			// add keyframe

			var keyframe = {
				time: frameTime,
				position: new THREE.Vector3(),
				rotation: new THREE.Quaternion()
			};

			bone.frames.push(keyframe);

			var quat = new THREE.Quaternion();

			var vx = new THREE.Vector3(1, 0, 0);
			var vy = new THREE.Vector3(0, 1, 0);
			var vz = new THREE.Vector3(0, 0, 1);

			// parse values for each channel in node

			for (var i = 0; i < bone.channels.length; i++) {

				switch (bone.channels[i]) {

					case 'Xposition':
						keyframe.position.x = parseFloat(data.shift().trim());
						break;
					case 'Yposition':
						keyframe.position.y = parseFloat(data.shift().trim());
						break;
					case 'Zposition':
						keyframe.position.z = parseFloat(data.shift().trim());
						break;
					case 'Xrotation':
						quat.setFromAxisAngle(vx, parseFloat(data.shift().trim()) * Math.PI / 180);
						keyframe.rotation.multiply(quat);
						break;
					case 'Yrotation':
						quat.setFromAxisAngle(vy, parseFloat(data.shift().trim()) * Math.PI / 180);
						keyframe.rotation.multiply(quat);
						break;
					case 'Zrotation':
						quat.setFromAxisAngle(vz, parseFloat(data.shift().trim()) * Math.PI / 180);
						keyframe.rotation.multiply(quat);
						break;
					default:
						console.warn('THREE.BVHLoader: Invalid channel type.');

				}
			}

			// parse child nodes

			for (var i = 0; i < bone.children.length; i++) {

				readFrameData(data, frameTime, bone.children[i]);
			}
		}

		/*
   Recursively parses the HIERACHY section of the BVH file
  	 - lines: all lines of the file. lines are consumed as we go along.
   - firstline: line containing the node type and name e.g. 'JOINT hip'
   - list: collects a flat list of nodes
  	 returns: a BVH node including children
  */
		function readNode(lines, firstline, list) {

			var node = { name: '', type: '', frames: [] };
			list.push(node);

			// parse node type and name

			var tokens = firstline.split(/[\s]+/);

			if (tokens[0].toUpperCase() === 'END' && tokens[1].toUpperCase() === 'SITE') {

				node.type = 'ENDSITE';
				node.name = 'ENDSITE'; // bvh end sites have no name
			} else {

				node.name = tokens[1];
				node.type = tokens[0].toUpperCase();
			}

			if (nextLine(lines) !== '{') {

				console.error('THREE.BVHLoader: Expected opening { after type & name');
			}

			// parse OFFSET

			tokens = nextLine(lines).split(/[\s]+/);

			if (tokens[0] !== 'OFFSET') {

				console.error('THREE.BVHLoader: Expected OFFSET but got: ' + tokens[0]);
			}

			if (tokens.length !== 4) {

				console.error('THREE.BVHLoader: Invalid number of values for OFFSET.');
			}

			var offset = new THREE.Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]));

			if (isNaN(offset.x) || isNaN(offset.y) || isNaN(offset.z)) {

				console.error('THREE.BVHLoader: Invalid values of OFFSET.');
			}

			node.offset = offset;

			// parse CHANNELS definitions

			if (node.type !== 'ENDSITE') {

				tokens = nextLine(lines).split(/[\s]+/);

				if (tokens[0] !== 'CHANNELS') {

					console.error('THREE.BVHLoader: Expected CHANNELS definition.');
				}

				var numChannels = parseInt(tokens[1]);
				node.channels = tokens.splice(2, numChannels);
				node.children = [];
			}

			// read children

			while (true) {

				var line = nextLine(lines);

				if (line === '}') {

					return node;
				} else {

					node.children.push(readNode(lines, line, list));
				}
			}
		}

		/*
  	recursively converts the internal bvh node structure to a THREE.Bone hierarchy
  		source: the bvh root node
  	list: pass an empty array, collects a flat list of all converted THREE.Bones
  		returns the root THREE.Bone
  */
		function toTHREEBone(source, list) {

			var bone = new THREE.Bone();
			list.push(bone);

			bone.position.add(source.offset);
			bone.name = source.name;

			if (source.type !== 'ENDSITE') {

				for (var i = 0; i < source.children.length; i++) {

					bone.add(toTHREEBone(source.children[i], list));
				}
			}

			return bone;
		}

		/*
  	builds a THREE.AnimationClip from the keyframe data saved in each bone.
  		bone: bvh root node
  		returns: a THREE.AnimationClip containing position and quaternion tracks
  */
		function toTHREEAnimation(bones) {

			var tracks = [];

			// create a position and quaternion animation track for each node

			for (var i = 0; i < bones.length; i++) {

				var bone = bones[i];

				if (bone.type === 'ENDSITE') continue;

				// track data

				var times = [];
				var positions = [];
				var rotations = [];

				for (var j = 0; j < bone.frames.length; j++) {

					var frame = bone.frames[j];

					times.push(frame.time);

					// the animation system animates the position property,
					// so we have to add the joint offset to all values

					positions.push(frame.position.x + bone.offset.x);
					positions.push(frame.position.y + bone.offset.y);
					positions.push(frame.position.z + bone.offset.z);

					rotations.push(frame.rotation.x);
					rotations.push(frame.rotation.y);
					rotations.push(frame.rotation.z);
					rotations.push(frame.rotation.w);
				}

				if (scope.animateBonePositions) {

					tracks.push(new THREE.VectorKeyframeTrack('.bones[' + bone.name + '].position', times, positions));
				}

				if (scope.animateBoneRotations) {

					tracks.push(new THREE.QuaternionKeyframeTrack('.bones[' + bone.name + '].quaternion', times, rotations));
				}
			}

			return new THREE.AnimationClip('animation', -1, tracks);
		}

		/*
  	returns the next non-empty line in lines
  */
		function nextLine(lines) {

			var line;
			// skip empty lines
			while ((line = lines.shift().trim()).length === 0) {}
			return line;
		}

		var scope = this;

		var lines = text.split(/[\r\n]+/g);

		var bones = readBvh(lines);

		var threeBones = [];
		toTHREEBone(bones[0], threeBones);

		var threeClip = toTHREEAnimation(bones);

		return {
			skeleton: new THREE.Skeleton(threeBones),
			clip: threeClip
		};
	}

};

exports.default = BVHLoader;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

var ColladaLoader = function ColladaLoader(manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};

ColladaLoader.prototype = {

	constructor: ColladaLoader,

	crossOrigin: 'Anonymous',

	load: function load(url, onLoad, onProgress, onError) {

		var scope = this;

		var path = scope.path === undefined ? THREE.LoaderUtils.extractUrlBase(url) : scope.path;

		var loader = new THREE.FileLoader(scope.manager);
		loader.load(url, function (text) {

			onLoad(scope.parse(text, path));
		}, onProgress, onError);
	},

	setPath: function setPath(value) {

		this.path = value;
	},

	options: {

		set convertUpAxis(value) {

			console.warn('THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.');
		}

	},

	setCrossOrigin: function setCrossOrigin(value) {

		this.crossOrigin = value;
	},

	parse: function parse(text, path) {

		function getElementsByTagName(xml, name) {

			// Non recursive xml.getElementsByTagName() ...

			var array = [];
			var childNodes = xml.childNodes;

			for (var i = 0, l = childNodes.length; i < l; i++) {

				var child = childNodes[i];

				if (child.nodeName === name) {

					array.push(child);
				}
			}

			return array;
		}

		function parseStrings(text) {

			if (text.length === 0) return [];

			var parts = text.trim().split(/\s+/);
			var array = new Array(parts.length);

			for (var i = 0, l = parts.length; i < l; i++) {

				array[i] = parts[i];
			}

			return array;
		}

		function parseFloats(text) {

			if (text.length === 0) return [];

			var parts = text.trim().split(/\s+/);
			var array = new Array(parts.length);

			for (var i = 0, l = parts.length; i < l; i++) {

				array[i] = parseFloat(parts[i]);
			}

			return array;
		}

		function parseInts(text) {

			if (text.length === 0) return [];

			var parts = text.trim().split(/\s+/);
			var array = new Array(parts.length);

			for (var i = 0, l = parts.length; i < l; i++) {

				array[i] = parseInt(parts[i]);
			}

			return array;
		}

		function parseId(text) {

			return text.substring(1);
		}

		function generateId() {

			return 'three_default_' + count++;
		}

		function isEmpty(object) {

			return Object.keys(object).length === 0;
		}

		// asset

		function parseAsset(xml) {

			return {
				unit: parseAssetUnit(getElementsByTagName(xml, 'unit')[0]),
				upAxis: parseAssetUpAxis(getElementsByTagName(xml, 'up_axis')[0])
			};
		}

		function parseAssetUnit(xml) {

			if (xml !== undefined && xml.hasAttribute('meter') === true) {

				return parseFloat(xml.getAttribute('meter'));
			} else {

				return 1; // default 1 meter
			}
		}

		function parseAssetUpAxis(xml) {

			return xml !== undefined ? xml.textContent : 'Y_UP';
		}

		// library

		function parseLibrary(xml, libraryName, nodeName, parser) {

			var library = getElementsByTagName(xml, libraryName)[0];

			if (library !== undefined) {

				var elements = getElementsByTagName(library, nodeName);

				for (var i = 0; i < elements.length; i++) {

					parser(elements[i]);
				}
			}
		}

		function buildLibrary(data, builder) {

			for (var name in data) {

				var object = data[name];
				object.build = builder(data[name]);
			}
		}

		// get

		function getBuild(data, builder) {

			if (data.build !== undefined) return data.build;

			data.build = builder(data);

			return data.build;
		}

		// animation

		function parseAnimation(xml) {

			var data = {
				sources: {},
				samplers: {},
				channels: {}
			};

			for (var i = 0, l = xml.childNodes.length; i < l; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				var id;

				switch (child.nodeName) {

					case 'source':
						id = child.getAttribute('id');
						data.sources[id] = parseSource(child);
						break;

					case 'sampler':
						id = child.getAttribute('id');
						data.samplers[id] = parseAnimationSampler(child);
						break;

					case 'channel':
						id = child.getAttribute('target');
						data.channels[id] = parseAnimationChannel(child);
						break;

					default:
						console.log(child);

				}
			}

			library.animations[xml.getAttribute('id')] = data;
		}

		function parseAnimationSampler(xml) {

			var data = {
				inputs: {}
			};

			for (var i = 0, l = xml.childNodes.length; i < l; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'input':
						var id = parseId(child.getAttribute('source'));
						var semantic = child.getAttribute('semantic');
						data.inputs[semantic] = id;
						break;

				}
			}

			return data;
		}

		function parseAnimationChannel(xml) {

			var data = {};

			var target = xml.getAttribute('target');

			// parsing SID Addressing Syntax

			var parts = target.split('/');

			var id = parts.shift();
			var sid = parts.shift();

			// check selection syntax

			var arraySyntax = sid.indexOf('(') !== -1;
			var memberSyntax = sid.indexOf('.') !== -1;

			if (memberSyntax) {

				//  member selection access

				parts = sid.split('.');
				sid = parts.shift();
				data.member = parts.shift();
			} else if (arraySyntax) {

				// array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.

				var indices = sid.split('(');
				sid = indices.shift();

				for (var i = 0; i < indices.length; i++) {

					indices[i] = parseInt(indices[i].replace(/\)/, ''));
				}

				data.indices = indices;
			}

			data.id = id;
			data.sid = sid;

			data.arraySyntax = arraySyntax;
			data.memberSyntax = memberSyntax;

			data.sampler = parseId(xml.getAttribute('source'));

			return data;
		}

		function buildAnimation(data) {

			var tracks = [];

			var channels = data.channels;
			var samplers = data.samplers;
			var sources = data.sources;

			for (var target in channels) {

				if (channels.hasOwnProperty(target)) {

					var channel = channels[target];
					var sampler = samplers[channel.sampler];

					var inputId = sampler.inputs.INPUT;
					var outputId = sampler.inputs.OUTPUT;

					var inputSource = sources[inputId];
					var outputSource = sources[outputId];

					var animation = buildAnimationChannel(channel, inputSource, outputSource);

					createKeyframeTracks(animation, tracks);
				}
			}

			return tracks;
		}

		function getAnimation(id) {

			return getBuild(library.animations[id], buildAnimation);
		}

		function buildAnimationChannel(channel, inputSource, outputSource) {

			var node = library.nodes[channel.id];
			var object3D = getNode(node.id);

			var transform = node.transforms[channel.sid];
			var defaultMatrix = node.matrix.clone().transpose();

			var time, stride;
			var i, il, j, jl;

			var data = {};

			// the collada spec allows the animation of data in various ways.
			// depending on the transform type (matrix, translate, rotate, scale), we execute different logic

			switch (transform) {

				case 'matrix':

					for (i = 0, il = inputSource.array.length; i < il; i++) {

						time = inputSource.array[i];
						stride = i * outputSource.stride;

						if (data[time] === undefined) data[time] = {};

						if (channel.arraySyntax === true) {

							var value = outputSource.array[stride];
							var index = channel.indices[0] + 4 * channel.indices[1];

							data[time][index] = value;
						} else {

							for (j = 0, jl = outputSource.stride; j < jl; j++) {

								data[time][j] = outputSource.array[stride + j];
							}
						}
					}

					break;

				case 'translate':
					console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform);
					break;

				case 'rotate':
					console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform);
					break;

				case 'scale':
					console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform);
					break;

			}

			var keyframes = prepareAnimationData(data, defaultMatrix);

			var animation = {
				name: object3D.uuid,
				keyframes: keyframes
			};

			return animation;
		}

		function prepareAnimationData(data, defaultMatrix) {

			var keyframes = [];

			// transfer data into a sortable array

			for (var time in data) {

				keyframes.push({ time: parseFloat(time), value: data[time] });
			}

			// ensure keyframes are sorted by time

			keyframes.sort(ascending);

			// now we clean up all animation data, so we can use them for keyframe tracks

			for (var i = 0; i < 16; i++) {

				transformAnimationData(keyframes, i, defaultMatrix.elements[i]);
			}

			return keyframes;

			// array sort function

			function ascending(a, b) {

				return a.time - b.time;
			}
		}

		var position = new THREE.Vector3();
		var scale = new THREE.Vector3();
		var quaternion = new THREE.Quaternion();

		function createKeyframeTracks(animation, tracks) {

			var keyframes = animation.keyframes;
			var name = animation.name;

			var times = [];
			var positionData = [];
			var quaternionData = [];
			var scaleData = [];

			for (var i = 0, l = keyframes.length; i < l; i++) {

				var keyframe = keyframes[i];

				var time = keyframe.time;
				var value = keyframe.value;

				matrix.fromArray(value).transpose();
				matrix.decompose(position, quaternion, scale);

				times.push(time);
				positionData.push(position.x, position.y, position.z);
				quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
				scaleData.push(scale.x, scale.y, scale.z);
			}

			if (positionData.length > 0) tracks.push(new THREE.VectorKeyframeTrack(name + '.position', times, positionData));
			if (quaternionData.length > 0) tracks.push(new THREE.QuaternionKeyframeTrack(name + '.quaternion', times, quaternionData));
			if (scaleData.length > 0) tracks.push(new THREE.VectorKeyframeTrack(name + '.scale', times, scaleData));

			return tracks;
		}

		function transformAnimationData(keyframes, property, defaultValue) {

			var keyframe;

			var empty = true;
			var i, l;

			// check, if values of a property are missing in our keyframes

			for (i = 0, l = keyframes.length; i < l; i++) {

				keyframe = keyframes[i];

				if (keyframe.value[property] === undefined) {

					keyframe.value[property] = null; // mark as missing
				} else {

					empty = false;
				}
			}

			if (empty === true) {

				// no values at all, so we set a default value

				for (i = 0, l = keyframes.length; i < l; i++) {

					keyframe = keyframes[i];

					keyframe.value[property] = defaultValue;
				}
			} else {

				// filling gaps

				createMissingKeyframes(keyframes, property);
			}
		}

		function createMissingKeyframes(keyframes, property) {

			var prev, next;

			for (var i = 0, l = keyframes.length; i < l; i++) {

				var keyframe = keyframes[i];

				if (keyframe.value[property] === null) {

					prev = getPrev(keyframes, i, property);
					next = getNext(keyframes, i, property);

					if (prev === null) {

						keyframe.value[property] = next.value[property];
						continue;
					}

					if (next === null) {

						keyframe.value[property] = prev.value[property];
						continue;
					}

					interpolate(keyframe, prev, next, property);
				}
			}
		}

		function getPrev(keyframes, i, property) {

			while (i >= 0) {

				var keyframe = keyframes[i];

				if (keyframe.value[property] !== null) return keyframe;

				i--;
			}

			return null;
		}

		function getNext(keyframes, i, property) {

			while (i < keyframes.length) {

				var keyframe = keyframes[i];

				if (keyframe.value[property] !== null) return keyframe;

				i++;
			}

			return null;
		}

		function interpolate(key, prev, next, property) {

			if (next.time - prev.time === 0) {

				key.value[property] = prev.value[property];
				return;
			}

			key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];
		}

		// animation clips

		function parseAnimationClip(xml) {

			var data = {
				name: xml.getAttribute('id') || 'default',
				start: parseFloat(xml.getAttribute('start') || 0),
				end: parseFloat(xml.getAttribute('end') || 0),
				animations: []
			};

			for (var i = 0, l = xml.childNodes.length; i < l; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'instance_animation':
						data.animations.push(parseId(child.getAttribute('url')));
						break;

				}
			}

			library.clips[xml.getAttribute('id')] = data;
		}

		function buildAnimationClip(data) {

			var tracks = [];

			var name = data.name;
			var duration = data.end - data.start || -1;
			var animations = data.animations;

			for (var i = 0, il = animations.length; i < il; i++) {

				var animationTracks = getAnimation(animations[i]);

				for (var j = 0, jl = animationTracks.length; j < jl; j++) {

					tracks.push(animationTracks[j]);
				}
			}

			return new THREE.AnimationClip(name, duration, tracks);
		}

		function getAnimationClip(id) {

			return getBuild(library.clips[id], buildAnimationClip);
		}

		// controller

		function parseController(xml) {

			var data = {};

			for (var i = 0, l = xml.childNodes.length; i < l; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'skin':
						// there is exactly one skin per controller
						data.id = parseId(child.getAttribute('source'));
						data.skin = parseSkin(child);
						break;

					case 'morph':
						data.id = parseId(child.getAttribute('source'));
						console.warn('THREE.ColladaLoader: Morph target animation not supported yet.');
						break;

				}
			}

			library.controllers[xml.getAttribute('id')] = data;
		}

		function parseSkin(xml) {

			var data = {
				sources: {}
			};

			for (var i = 0, l = xml.childNodes.length; i < l; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'bind_shape_matrix':
						data.bindShapeMatrix = parseFloats(child.textContent);
						break;

					case 'source':
						var id = child.getAttribute('id');
						data.sources[id] = parseSource(child);
						break;

					case 'joints':
						data.joints = parseJoints(child);
						break;

					case 'vertex_weights':
						data.vertexWeights = parseVertexWeights(child);
						break;

				}
			}

			return data;
		}

		function parseJoints(xml) {

			var data = {
				inputs: {}
			};

			for (var i = 0, l = xml.childNodes.length; i < l; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'input':
						var semantic = child.getAttribute('semantic');
						var id = parseId(child.getAttribute('source'));
						data.inputs[semantic] = id;
						break;

				}
			}

			return data;
		}

		function parseVertexWeights(xml) {

			var data = {
				inputs: {}
			};

			for (var i = 0, l = xml.childNodes.length; i < l; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'input':
						var semantic = child.getAttribute('semantic');
						var id = parseId(child.getAttribute('source'));
						var offset = parseInt(child.getAttribute('offset'));
						data.inputs[semantic] = { id: id, offset: offset };
						break;

					case 'vcount':
						data.vcount = parseInts(child.textContent);
						break;

					case 'v':
						data.v = parseInts(child.textContent);
						break;

				}
			}

			return data;
		}

		function buildController(data) {

			var build = {
				id: data.id
			};

			var geometry = library.geometries[build.id];

			if (data.skin !== undefined) {

				build.skin = buildSkin(data.skin);

				// we enhance the 'sources' property of the corresponding geometry with our skin data

				geometry.sources.skinIndices = build.skin.indices;
				geometry.sources.skinWeights = build.skin.weights;
			}

			return build;
		}

		function buildSkin(data) {

			var BONE_LIMIT = 4;

			var build = {
				joints: [], // this must be an array to preserve the joint order
				indices: {
					array: [],
					stride: BONE_LIMIT
				},
				weights: {
					array: [],
					stride: BONE_LIMIT
				}
			};

			var sources = data.sources;
			var vertexWeights = data.vertexWeights;

			var vcount = vertexWeights.vcount;
			var v = vertexWeights.v;
			var jointOffset = vertexWeights.inputs.JOINT.offset;
			var weightOffset = vertexWeights.inputs.WEIGHT.offset;

			var jointSource = data.sources[data.joints.inputs.JOINT];
			var inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];

			var weights = sources[vertexWeights.inputs.WEIGHT.id].array;
			var stride = 0;

			var i, j, l;

			// procces skin data for each vertex

			for (i = 0, l = vcount.length; i < l; i++) {

				var jointCount = vcount[i]; // this is the amount of joints that affect a single vertex
				var vertexSkinData = [];

				for (j = 0; j < jointCount; j++) {

					var skinIndex = v[stride + jointOffset];
					var weightId = v[stride + weightOffset];
					var skinWeight = weights[weightId];

					vertexSkinData.push({ index: skinIndex, weight: skinWeight });

					stride += 2;
				}

				// we sort the joints in descending order based on the weights.
				// this ensures, we only procced the most important joints of the vertex

				vertexSkinData.sort(descending);

				// now we provide for each vertex a set of four index and weight values.
				// the order of the skin data matches the order of vertices

				for (j = 0; j < BONE_LIMIT; j++) {

					var d = vertexSkinData[j];

					if (d !== undefined) {

						build.indices.array.push(d.index);
						build.weights.array.push(d.weight);
					} else {

						build.indices.array.push(0);
						build.weights.array.push(0);
					}
				}
			}

			// setup bind matrix

			build.bindMatrix = new THREE.Matrix4().fromArray(data.bindShapeMatrix).transpose();

			// process bones and inverse bind matrix data

			for (i = 0, l = jointSource.array.length; i < l; i++) {

				var name = jointSource.array[i];
				var boneInverse = new THREE.Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();

				build.joints.push({ name: name, boneInverse: boneInverse });
			}

			return build;

			// array sort function

			function descending(a, b) {

				return b.weight - a.weight;
			}
		}

		function getController(id) {

			return getBuild(library.controllers[id], buildController);
		}

		// image

		function parseImage(xml) {

			var data = {
				init_from: getElementsByTagName(xml, 'init_from')[0].textContent
			};

			library.images[xml.getAttribute('id')] = data;
		}

		function buildImage(data) {

			if (data.build !== undefined) return data.build;

			return data.init_from;
		}

		function getImage(id) {

			var data = library.images[id];

			if (data !== undefined) {

				return getBuild(data, buildImage);
			}

			console.warn('THREE.ColladaLoader: Couldn\'t find image with ID:', id);

			return null;
		}

		// effect

		function parseEffect(xml) {

			var data = {};

			for (var i = 0, l = xml.childNodes.length; i < l; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'profile_COMMON':
						data.profile = parseEffectProfileCOMMON(child);
						break;

				}
			}

			library.effects[xml.getAttribute('id')] = data;
		}

		function parseEffectProfileCOMMON(xml) {

			var data = {
				surfaces: {},
				samplers: {}
			};

			for (var i = 0, l = xml.childNodes.length; i < l; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'newparam':
						parseEffectNewparam(child, data);
						break;

					case 'technique':
						data.technique = parseEffectTechnique(child);
						break;

					case 'extra':
						data.extra = parseEffectExtra(child);
						break;

				}
			}

			return data;
		}

		function parseEffectNewparam(xml, data) {

			var sid = xml.getAttribute('sid');

			for (var i = 0, l = xml.childNodes.length; i < l; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'surface':
						data.surfaces[sid] = parseEffectSurface(child);
						break;

					case 'sampler2D':
						data.samplers[sid] = parseEffectSampler(child);
						break;

				}
			}
		}

		function parseEffectSurface(xml) {

			var data = {};

			for (var i = 0, l = xml.childNodes.length; i < l; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'init_from':
						data.init_from = child.textContent;
						break;

				}
			}

			return data;
		}

		function parseEffectSampler(xml) {

			var data = {};

			for (var i = 0, l = xml.childNodes.length; i < l; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'source':
						data.source = child.textContent;
						break;

				}
			}

			return data;
		}

		function parseEffectTechnique(xml) {

			var data = {};

			for (var i = 0, l = xml.childNodes.length; i < l; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'constant':
					case 'lambert':
					case 'blinn':
					case 'phong':
						data.type = child.nodeName;
						data.parameters = parseEffectParameters(child);
						break;

				}
			}

			return data;
		}

		function parseEffectParameters(xml) {

			var data = {};

			for (var i = 0, l = xml.childNodes.length; i < l; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'emission':
					case 'diffuse':
					case 'specular':
					case 'shininess':
					case 'transparency':
						data[child.nodeName] = parseEffectParameter(child);
						break;
					case 'transparent':
						data[child.nodeName] = {
							opaque: child.getAttribute('opaque'),
							data: parseEffectParameter(child)
						};
						break;

				}
			}

			return data;
		}

		function parseEffectParameter(xml) {

			var data = {};

			for (var i = 0, l = xml.childNodes.length; i < l; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'color':
						data[child.nodeName] = parseFloats(child.textContent);
						break;

					case 'float':
						data[child.nodeName] = parseFloat(child.textContent);
						break;

					case 'texture':
						data[child.nodeName] = { id: child.getAttribute('texture'), extra: parseEffectParameterTexture(child) };
						break;

				}
			}

			return data;
		}

		function parseEffectParameterTexture(xml) {

			var data = {
				technique: {}
			};

			for (var i = 0, l = xml.childNodes.length; i < l; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'extra':
						parseEffectParameterTextureExtra(child, data);
						break;

				}
			}

			return data;
		}

		function parseEffectParameterTextureExtra(xml, data) {

			for (var i = 0, l = xml.childNodes.length; i < l; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'technique':
						parseEffectParameterTextureExtraTechnique(child, data);
						break;

				}
			}
		}

		function parseEffectParameterTextureExtraTechnique(xml, data) {

			for (var i = 0, l = xml.childNodes.length; i < l; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'repeatU':
					case 'repeatV':
					case 'offsetU':
					case 'offsetV':
						data.technique[child.nodeName] = parseFloat(child.textContent);
						break;

					case 'wrapU':
					case 'wrapV':

						// some files have values for wrapU/wrapV which become NaN via parseInt

						if (child.textContent.toUpperCase() === 'TRUE') {

							data.technique[child.nodeName] = 1;
						} else if (child.textContent.toUpperCase() === 'FALSE') {

							data.technique[child.nodeName] = 0;
						} else {

							data.technique[child.nodeName] = parseInt(child.textContent);
						}

						break;

				}
			}
		}

		function parseEffectExtra(xml) {

			var data = {};

			for (var i = 0, l = xml.childNodes.length; i < l; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'technique':
						data.technique = parseEffectExtraTechnique(child);
						break;

				}
			}

			return data;
		}

		function parseEffectExtraTechnique(xml) {

			var data = {};

			for (var i = 0, l = xml.childNodes.length; i < l; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'double_sided':
						data[child.nodeName] = parseInt(child.textContent);
						break;

				}
			}

			return data;
		}

		function buildEffect(data) {

			return data;
		}

		function getEffect(id) {

			return getBuild(library.effects[id], buildEffect);
		}

		// material

		function parseMaterial(xml) {

			var data = {
				name: xml.getAttribute('name')
			};

			for (var i = 0, l = xml.childNodes.length; i < l; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'instance_effect':
						data.url = parseId(child.getAttribute('url'));
						break;

				}
			}

			library.materials[xml.getAttribute('id')] = data;
		}

		function buildMaterial(data) {

			var effect = getEffect(data.url);
			var technique = effect.profile.technique;
			var extra = effect.profile.extra;

			var material;

			switch (technique.type) {

				case 'phong':
				case 'blinn':
					material = new THREE.MeshPhongMaterial();
					break;

				case 'lambert':
					material = new THREE.MeshLambertMaterial();
					break;

				default:
					material = new THREE.MeshBasicMaterial();
					break;

			}

			material.name = data.name;

			function getTexture(textureObject) {

				var sampler = effect.profile.samplers[textureObject.id];
				var image = null;

				// get image

				if (sampler !== undefined) {

					var surface = effect.profile.surfaces[sampler.source];
					image = getImage(surface.init_from);
				} else {

					console.warn('THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).');
					image = getImage(textureObject.id);
				}

				// create texture if image is avaiable

				if (image !== null) {

					var texture = textureLoader.load(image);

					var extra = textureObject.extra;

					if (extra !== undefined && extra.technique !== undefined && isEmpty(extra.technique) === false) {

						var technique = extra.technique;

						texture.wrapS = technique.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
						texture.wrapT = technique.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;

						texture.offset.set(technique.offsetU || 0, technique.offsetV || 0);
						texture.repeat.set(technique.repeatU || 1, technique.repeatV || 1);
					} else {

						texture.wrapS = THREE.RepeatWrapping;
						texture.wrapT = THREE.RepeatWrapping;
					}

					return texture;
				} else {

					console.warn('THREE.ColladaLoader: Couldn\'t create texture with ID:', textureObject.id);

					return null;
				}
			}

			var parameters = technique.parameters;

			for (var key in parameters) {

				var parameter = parameters[key];

				switch (key) {

					case 'diffuse':
						if (parameter.color) material.color.fromArray(parameter.color);
						if (parameter.texture) material.map = getTexture(parameter.texture);
						break;
					case 'specular':
						if (parameter.color && material.specular) material.specular.fromArray(parameter.color);
						if (parameter.texture) material.specularMap = getTexture(parameter.texture);
						break;
					case 'shininess':
						if (parameter.float && material.shininess) material.shininess = parameter.float;
						break;
					case 'emission':
						if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);
						if (parameter.texture) material.emissiveMap = getTexture(parameter.texture);
						break;

				}
			}

			//

			var transparent = parameters['transparent'];
			var transparency = parameters['transparency'];

			// <transparency> does not exist but <transparent>

			if (transparency === undefined && transparent) {

				transparency = {
					float: 1
				};
			}

			// <transparent> does not exist but <transparency>

			if (transparent === undefined && transparency) {

				transparent = {
					opaque: 'A_ONE',
					data: {
						color: [1, 1, 1, 1]
					} };
			}

			if (transparent && transparency) {

				// handle case if a texture exists but no color

				if (transparent.data.texture) {

					// we do not set an alpha map (see #13792)

					material.transparent = true;
				} else {

					var color = transparent.data.color;

					switch (transparent.opaque) {

						case 'A_ONE':
							material.opacity = color[3] * transparency.float;
							break;
						case 'RGB_ZERO':
							material.opacity = 1 - color[0] * transparency.float;
							break;
						case 'A_ZERO':
							material.opacity = 1 - color[3] * transparency.float;
							break;
						case 'RGB_ONE':
							material.opacity = color[0] * transparency.float;
							break;
						default:
							console.warn('THREE.ColladaLoader: Invalid opaque type "%s" of transparent tag.', transparent.opaque);

					}

					if (material.opacity < 1) material.transparent = true;
				}
			}

			//

			if (extra !== undefined && extra.technique !== undefined && extra.technique.double_sided === 1) {

				material.side = THREE.DoubleSide;
			}

			return material;
		}

		function getMaterial(id) {

			return getBuild(library.materials[id], buildMaterial);
		}

		// camera

		function parseCamera(xml) {

			var data = {
				name: xml.getAttribute('name')
			};

			for (var i = 0, l = xml.childNodes.length; i < l; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'optics':
						data.optics = parseCameraOptics(child);
						break;

				}
			}

			library.cameras[xml.getAttribute('id')] = data;
		}

		function parseCameraOptics(xml) {

			for (var i = 0; i < xml.childNodes.length; i++) {

				var child = xml.childNodes[i];

				switch (child.nodeName) {

					case 'technique_common':
						return parseCameraTechnique(child);

				}
			}

			return {};
		}

		function parseCameraTechnique(xml) {

			var data = {};

			for (var i = 0; i < xml.childNodes.length; i++) {

				var child = xml.childNodes[i];

				switch (child.nodeName) {

					case 'perspective':
					case 'orthographic':

						data.technique = child.nodeName;
						data.parameters = parseCameraParameters(child);

						break;

				}
			}

			return data;
		}

		function parseCameraParameters(xml) {

			var data = {};

			for (var i = 0; i < xml.childNodes.length; i++) {

				var child = xml.childNodes[i];

				switch (child.nodeName) {

					case 'xfov':
					case 'yfov':
					case 'xmag':
					case 'ymag':
					case 'znear':
					case 'zfar':
					case 'aspect_ratio':
						data[child.nodeName] = parseFloat(child.textContent);
						break;

				}
			}

			return data;
		}

		function buildCamera(data) {

			var camera;

			switch (data.optics.technique) {

				case 'perspective':
					camera = new THREE.PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);
					break;

				case 'orthographic':
					var ymag = data.optics.parameters.ymag;
					var xmag = data.optics.parameters.xmag;
					var aspectRatio = data.optics.parameters.aspect_ratio;

					xmag = xmag === undefined ? ymag * aspectRatio : xmag;
					ymag = ymag === undefined ? xmag / aspectRatio : ymag;

					xmag *= 0.5;
					ymag *= 0.5;

					camera = new THREE.OrthographicCamera(-xmag, xmag, ymag, -ymag, // left, right, top, bottom
					data.optics.parameters.znear, data.optics.parameters.zfar);
					break;

				default:
					camera = new THREE.PerspectiveCamera();
					break;

			}

			camera.name = data.name;

			return camera;
		}

		function getCamera(id) {

			var data = library.cameras[id];

			if (data !== undefined) {

				return getBuild(data, buildCamera);
			}

			console.warn('THREE.ColladaLoader: Couldn\'t find camera with ID:', id);

			return null;
		}

		// light

		function parseLight(xml) {

			var data = {};

			for (var i = 0, l = xml.childNodes.length; i < l; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'technique_common':
						data = parseLightTechnique(child);
						break;

				}
			}

			library.lights[xml.getAttribute('id')] = data;
		}

		function parseLightTechnique(xml) {

			var data = {};

			for (var i = 0, l = xml.childNodes.length; i < l; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'directional':
					case 'point':
					case 'spot':
					case 'ambient':

						data.technique = child.nodeName;
						data.parameters = parseLightParameters(child);

				}
			}

			return data;
		}

		function parseLightParameters(xml) {

			var data = {};

			for (var i = 0, l = xml.childNodes.length; i < l; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'color':
						var array = parseFloats(child.textContent);
						data.color = new THREE.Color().fromArray(array);
						break;

					case 'falloff_angle':
						data.falloffAngle = parseFloat(child.textContent);
						break;

					case 'quadratic_attenuation':
						var f = parseFloat(child.textContent);
						data.distance = f ? Math.sqrt(1 / f) : 0;
						break;

				}
			}

			return data;
		}

		function buildLight(data) {

			var light;

			switch (data.technique) {

				case 'directional':
					light = new THREE.DirectionalLight();
					break;

				case 'point':
					light = new THREE.PointLight();
					break;

				case 'spot':
					light = new THREE.SpotLight();
					break;

				case 'ambient':
					light = new THREE.AmbientLight();
					break;

			}

			if (data.parameters.color) light.color.copy(data.parameters.color);
			if (data.parameters.distance) light.distance = data.parameters.distance;

			return light;
		}

		function getLight(id) {

			var data = library.lights[id];

			if (data !== undefined) {

				return getBuild(data, buildLight);
			}

			console.warn('THREE.ColladaLoader: Couldn\'t find light with ID:', id);

			return null;
		}

		// geometry

		function parseGeometry(xml) {

			var data = {
				name: xml.getAttribute('name'),
				sources: {},
				vertices: {},
				primitives: []
			};

			var mesh = getElementsByTagName(xml, 'mesh')[0];

			// the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep
			if (mesh === undefined) return;

			for (var i = 0; i < mesh.childNodes.length; i++) {

				var child = mesh.childNodes[i];

				if (child.nodeType !== 1) continue;

				var id = child.getAttribute('id');

				switch (child.nodeName) {

					case 'source':
						data.sources[id] = parseSource(child);
						break;

					case 'vertices':
						// data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];
						data.vertices = parseGeometryVertices(child);
						break;

					case 'polygons':
						console.warn('THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName);
						break;

					case 'lines':
					case 'linestrips':
					case 'polylist':
					case 'triangles':
						data.primitives.push(parseGeometryPrimitive(child));
						break;

					default:
						console.log(child);

				}
			}

			library.geometries[xml.getAttribute('id')] = data;
		}

		function parseSource(xml) {

			var data = {
				array: [],
				stride: 3
			};

			for (var i = 0; i < xml.childNodes.length; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'float_array':
						data.array = parseFloats(child.textContent);
						break;

					case 'Name_array':
						data.array = parseStrings(child.textContent);
						break;

					case 'technique_common':
						var accessor = getElementsByTagName(child, 'accessor')[0];

						if (accessor !== undefined) {

							data.stride = parseInt(accessor.getAttribute('stride'));
						}
						break;

				}
			}

			return data;
		}

		function parseGeometryVertices(xml) {

			var data = {};

			for (var i = 0; i < xml.childNodes.length; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				data[child.getAttribute('semantic')] = parseId(child.getAttribute('source'));
			}

			return data;
		}

		function parseGeometryPrimitive(xml) {

			var primitive = {
				type: xml.nodeName,
				material: xml.getAttribute('material'),
				count: parseInt(xml.getAttribute('count')),
				inputs: {},
				stride: 0,
				hasUV: false
			};

			for (var i = 0, l = xml.childNodes.length; i < l; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'input':
						var id = parseId(child.getAttribute('source'));
						var semantic = child.getAttribute('semantic');
						var offset = parseInt(child.getAttribute('offset'));
						primitive.inputs[semantic] = { id: id, offset: offset };
						primitive.stride = Math.max(primitive.stride, offset + 1);
						if (semantic === 'TEXCOORD') primitive.hasUV = true;
						break;

					case 'vcount':
						primitive.vcount = parseInts(child.textContent);
						break;

					case 'p':
						primitive.p = parseInts(child.textContent);
						break;

				}
			}

			return primitive;
		}

		function groupPrimitives(primitives) {

			var build = {};

			for (var i = 0; i < primitives.length; i++) {

				var primitive = primitives[i];

				if (build[primitive.type] === undefined) build[primitive.type] = [];

				build[primitive.type].push(primitive);
			}

			return build;
		}

		function checkUVCoordinates(primitives) {

			var count = 0;

			for (var i = 0, l = primitives.length; i < l; i++) {

				var primitive = primitives[i];

				if (primitive.hasUV === true) {

					count++;
				}
			}

			if (count > 0 && count < primitives.length) {

				primitives.uvsNeedsFix = true;
			}
		}

		function buildGeometry(data) {

			var build = {};

			var sources = data.sources;
			var vertices = data.vertices;
			var primitives = data.primitives;

			if (primitives.length === 0) return {};

			// our goal is to create one buffer geometry for a single type of primitives
			// first, we group all primitives by their type

			var groupedPrimitives = groupPrimitives(primitives);

			for (var type in groupedPrimitives) {

				var primitiveType = groupedPrimitives[type];

				// second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)

				checkUVCoordinates(primitiveType);

				// third, create a buffer geometry for each type of primitives

				build[type] = buildGeometryType(primitiveType, sources, vertices);
			}

			return build;
		}

		function buildGeometryType(primitives, sources, vertices) {

			var build = {};

			var position = { array: [], stride: 0 };
			var normal = { array: [], stride: 0 };
			var uv = { array: [], stride: 0 };
			var color = { array: [], stride: 0 };

			var skinIndex = { array: [], stride: 4 };
			var skinWeight = { array: [], stride: 4 };

			var geometry = new THREE.BufferGeometry();

			var materialKeys = [];

			var start = 0;

			for (var p = 0; p < primitives.length; p++) {

				var primitive = primitives[p];
				var inputs = primitive.inputs;

				// groups

				var count = 0;

				switch (primitive.type) {

					case 'lines':
					case 'linestrips':
						count = primitive.count * 2;
						break;

					case 'triangles':
						count = primitive.count * 3;
						break;

					case 'polylist':

						for (var g = 0; g < primitive.count; g++) {

							var vc = primitive.vcount[g];

							switch (vc) {

								case 3:
									count += 3; // single triangle
									break;

								case 4:
									count += 6; // quad, subdivided into two triangles
									break;

								default:
									count += (vc - 2) * 3; // polylist with more than four vertices
									break;

							}
						}

						break;

					default:
						console.warn('THREE.ColladaLoader: Unknow primitive type:', primitive.type);

				}

				geometry.addGroup(start, count, p);
				start += count;

				// material

				if (primitive.material) {

					materialKeys.push(primitive.material);
				}

				// geometry data

				for (var name in inputs) {

					var input = inputs[name];

					switch (name) {

						case 'VERTEX':
							for (var key in vertices) {

								var id = vertices[key];

								switch (key) {

									case 'POSITION':
										var prevLength = position.array.length;
										buildGeometryData(primitive, sources[id], input.offset, position.array);
										position.stride = sources[id].stride;

										if (sources.skinWeights && sources.skinIndices) {

											buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);
											buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);
										}

										// see #3803

										if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {

											var count = (position.array.length - prevLength) / position.stride;

											for (var i = 0; i < count; i++) {

												// fill missing uv coordinates

												uv.array.push(0, 0);
											}
										}
										break;

									case 'NORMAL':
										buildGeometryData(primitive, sources[id], input.offset, normal.array);
										normal.stride = sources[id].stride;
										break;

									case 'COLOR':
										buildGeometryData(primitive, sources[id], input.offset, color.array);
										color.stride = sources[id].stride;
										break;

									case 'TEXCOORD':
										buildGeometryData(primitive, sources[id], input.offset, uv.array);
										uv.stride = sources[id].stride;
										break;

									default:
										console.warn('THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.', key);

								}
							}
							break;

						case 'NORMAL':
							buildGeometryData(primitive, sources[input.id], input.offset, normal.array);
							normal.stride = sources[input.id].stride;
							break;

						case 'COLOR':
							buildGeometryData(primitive, sources[input.id], input.offset, color.array);
							color.stride = sources[input.id].stride;
							break;

						case 'TEXCOORD':
							buildGeometryData(primitive, sources[input.id], input.offset, uv.array);
							uv.stride = sources[input.id].stride;
							break;

					}
				}
			}

			// build geometry

			if (position.array.length > 0) geometry.addAttribute('position', new THREE.Float32BufferAttribute(position.array, position.stride));
			if (normal.array.length > 0) geometry.addAttribute('normal', new THREE.Float32BufferAttribute(normal.array, normal.stride));
			if (color.array.length > 0) geometry.addAttribute('color', new THREE.Float32BufferAttribute(color.array, color.stride));
			if (uv.array.length > 0) geometry.addAttribute('uv', new THREE.Float32BufferAttribute(uv.array, uv.stride));

			if (skinIndex.array.length > 0) geometry.addAttribute('skinIndex', new THREE.Float32BufferAttribute(skinIndex.array, skinIndex.stride));
			if (skinWeight.array.length > 0) geometry.addAttribute('skinWeight', new THREE.Float32BufferAttribute(skinWeight.array, skinWeight.stride));

			build.data = geometry;
			build.type = primitives[0].type;
			build.materialKeys = materialKeys;

			return build;
		}

		function buildGeometryData(primitive, source, offset, array) {

			var indices = primitive.p;
			var stride = primitive.stride;
			var vcount = primitive.vcount;

			function pushVector(i) {

				var index = indices[i + offset] * sourceStride;
				var length = index + sourceStride;

				for (; index < length; index++) {

					array.push(sourceArray[index]);
				}
			}

			var sourceArray = source.array;
			var sourceStride = source.stride;

			if (primitive.vcount !== undefined) {

				var index = 0;

				for (var i = 0, l = vcount.length; i < l; i++) {

					var count = vcount[i];

					if (count === 4) {

						var a = index + stride * 0;
						var b = index + stride * 1;
						var c = index + stride * 2;
						var d = index + stride * 3;

						pushVector(a);pushVector(b);pushVector(d);
						pushVector(b);pushVector(c);pushVector(d);
					} else if (count === 3) {

						var a = index + stride * 0;
						var b = index + stride * 1;
						var c = index + stride * 2;

						pushVector(a);pushVector(b);pushVector(c);
					} else if (count > 4) {

						for (var k = 1, kl = count - 2; k <= kl; k++) {

							var a = index + stride * 0;
							var b = index + stride * k;
							var c = index + stride * (k + 1);

							pushVector(a);pushVector(b);pushVector(c);
						}
					}

					index += stride * count;
				}
			} else {

				for (var i = 0, l = indices.length; i < l; i += stride) {

					pushVector(i);
				}
			}
		}

		function getGeometry(id) {

			return getBuild(library.geometries[id], buildGeometry);
		}

		// kinematics

		function parseKinematicsModel(xml) {

			var data = {
				name: xml.getAttribute('name') || '',
				joints: {},
				links: []
			};

			for (var i = 0; i < xml.childNodes.length; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'technique_common':
						parseKinematicsTechniqueCommon(child, data);
						break;

				}
			}

			library.kinematicsModels[xml.getAttribute('id')] = data;
		}

		function buildKinematicsModel(data) {

			if (data.build !== undefined) return data.build;

			return data;
		}

		function getKinematicsModel(id) {

			return getBuild(library.kinematicsModels[id], buildKinematicsModel);
		}

		function parseKinematicsTechniqueCommon(xml, data) {

			for (var i = 0; i < xml.childNodes.length; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'joint':
						data.joints[child.getAttribute('sid')] = parseKinematicsJoint(child);
						break;

					case 'link':
						data.links.push(parseKinematicsLink(child));
						break;

				}
			}
		}

		function parseKinematicsJoint(xml) {

			var data;

			for (var i = 0; i < xml.childNodes.length; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'prismatic':
					case 'revolute':
						data = parseKinematicsJointParameter(child);
						break;

				}
			}

			return data;
		}

		function parseKinematicsJointParameter(xml, data) {

			var data = {
				sid: xml.getAttribute('sid'),
				name: xml.getAttribute('name') || '',
				axis: new THREE.Vector3(),
				limits: {
					min: 0,
					max: 0
				},
				type: xml.nodeName,
				static: false,
				zeroPosition: 0,
				middlePosition: 0
			};

			for (var i = 0; i < xml.childNodes.length; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'axis':
						var array = parseFloats(child.textContent);
						data.axis.fromArray(array);
						break;
					case 'limits':
						var max = child.getElementsByTagName('max')[0];
						var min = child.getElementsByTagName('min')[0];

						data.limits.max = parseFloat(max.textContent);
						data.limits.min = parseFloat(min.textContent);
						break;

				}
			}

			// if min is equal to or greater than max, consider the joint static

			if (data.limits.min >= data.limits.max) {

				data.static = true;
			}

			// calculate middle position

			data.middlePosition = (data.limits.min + data.limits.max) / 2.0;

			return data;
		}

		function parseKinematicsLink(xml) {

			var data = {
				sid: xml.getAttribute('sid'),
				name: xml.getAttribute('name') || '',
				attachments: [],
				transforms: []
			};

			for (var i = 0; i < xml.childNodes.length; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'attachment_full':
						data.attachments.push(parseKinematicsAttachment(child));
						break;

					case 'matrix':
					case 'translate':
					case 'rotate':
						data.transforms.push(parseKinematicsTransform(child));
						break;

				}
			}

			return data;
		}

		function parseKinematicsAttachment(xml) {

			var data = {
				joint: xml.getAttribute('joint').split('/').pop(),
				transforms: [],
				links: []
			};

			for (var i = 0; i < xml.childNodes.length; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'link':
						data.links.push(parseKinematicsLink(child));
						break;

					case 'matrix':
					case 'translate':
					case 'rotate':
						data.transforms.push(parseKinematicsTransform(child));
						break;

				}
			}

			return data;
		}

		function parseKinematicsTransform(xml) {

			var data = {
				type: xml.nodeName
			};

			var array = parseFloats(xml.textContent);

			switch (data.type) {

				case 'matrix':
					data.obj = new THREE.Matrix4();
					data.obj.fromArray(array).transpose();
					break;

				case 'translate':
					data.obj = new THREE.Vector3();
					data.obj.fromArray(array);
					break;

				case 'rotate':
					data.obj = new THREE.Vector3();
					data.obj.fromArray(array);
					data.angle = THREE.Math.degToRad(array[3]);
					break;

			}

			return data;
		}

		function parseKinematicsScene(xml) {

			var data = {
				bindJointAxis: []
			};

			for (var i = 0; i < xml.childNodes.length; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'bind_joint_axis':
						data.bindJointAxis.push(parseKinematicsBindJointAxis(child));
						break;

				}
			}

			library.kinematicsScenes[parseId(xml.getAttribute('url'))] = data;
		}

		function parseKinematicsBindJointAxis(xml) {

			var data = {
				target: xml.getAttribute('target').split('/').pop()
			};

			for (var i = 0; i < xml.childNodes.length; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'axis':
						var param = child.getElementsByTagName('param')[0];
						data.axis = param.textContent;
						var tmpJointIndex = data.axis.split('inst_').pop().split('axis')[0];
						data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);
						break;

				}
			}

			return data;
		}

		function buildKinematicsScene(data) {

			if (data.build !== undefined) return data.build;

			return data;
		}

		function getKinematicsScene(id) {

			return getBuild(library.kinematicsScenes[id], buildKinematicsScene);
		}

		function setupKinematics() {

			var kinematicsModelId = Object.keys(library.kinematicsModels)[0];
			var kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];
			var visualSceneId = Object.keys(library.visualScenes)[0];

			if (kinematicsModelId === undefined || kinematicsSceneId === undefined) return;

			var kinematicsModel = getKinematicsModel(kinematicsModelId);
			var kinematicsScene = getKinematicsScene(kinematicsSceneId);
			var visualScene = getVisualScene(visualSceneId);

			var bindJointAxis = kinematicsScene.bindJointAxis;
			var jointMap = {};

			for (var i = 0, l = bindJointAxis.length; i < l; i++) {

				var axis = bindJointAxis[i];

				// the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'

				var targetElement = collada.querySelector('[sid="' + axis.target + '"]');

				if (targetElement) {

					// get the parent of the transfrom element

					var parentVisualElement = targetElement.parentElement;

					// connect the joint of the kinematics model with the element in the visual scene

					connect(axis.jointIndex, parentVisualElement);
				}
			}

			function connect(jointIndex, visualElement) {

				var visualElementName = visualElement.getAttribute('name');
				var joint = kinematicsModel.joints[jointIndex];

				visualScene.traverse(function (object) {

					if (object.name === visualElementName) {

						jointMap[jointIndex] = {
							object: object,
							transforms: buildTransformList(visualElement),
							joint: joint,
							position: joint.zeroPosition
						};
					}
				});
			}

			var m0 = new THREE.Matrix4();

			kinematics = {

				joints: kinematicsModel && kinematicsModel.joints,

				getJointValue: function getJointValue(jointIndex) {

					var jointData = jointMap[jointIndex];

					if (jointData) {

						return jointData.position;
					} else {

						console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' doesn\'t exist.');
					}
				},

				setJointValue: function setJointValue(jointIndex, value) {

					var jointData = jointMap[jointIndex];

					if (jointData) {

						var joint = jointData.joint;

						if (value > joint.limits.max || value < joint.limits.min) {

							console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').');
						} else if (joint.static) {

							console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' is static.');
						} else {

							var object = jointData.object;
							var axis = joint.axis;
							var transforms = jointData.transforms;

							matrix.identity();

							// each update, we have to apply all transforms in the correct order

							for (var i = 0; i < transforms.length; i++) {

								var transform = transforms[i];

								// if there is a connection of the transform node with a joint, apply the joint value

								if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {

									switch (joint.type) {

										case 'revolute':
											matrix.multiply(m0.makeRotationAxis(axis, THREE.Math.degToRad(value)));
											break;

										case 'prismatic':
											matrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));
											break;

										default:
											console.warn('THREE.ColladaLoader: Unknown joint type: ' + joint.type);
											break;

									}
								} else {

									switch (transform.type) {

										case 'matrix':
											matrix.multiply(transform.obj);
											break;

										case 'translate':
											matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));
											break;

										case 'scale':
											matrix.scale(transform.obj);
											break;

										case 'rotate':
											matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));
											break;

									}
								}
							}

							object.matrix.copy(matrix);
							object.matrix.decompose(object.position, object.quaternion, object.scale);

							jointMap[jointIndex].position = value;
						}
					} else {

						console.log('THREE.ColladaLoader: ' + jointIndex + ' does not exist.');
					}
				}

			};
		}

		function buildTransformList(node) {

			var transforms = [];

			var xml = collada.querySelector('[id="' + node.id + '"]');

			for (var i = 0; i < xml.childNodes.length; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'matrix':
						var array = parseFloats(child.textContent);
						var matrix = new THREE.Matrix4().fromArray(array).transpose();
						transforms.push({
							sid: child.getAttribute('sid'),
							type: child.nodeName,
							obj: matrix
						});
						break;

					case 'translate':
					case 'scale':
						var array = parseFloats(child.textContent);
						var vector = new THREE.Vector3().fromArray(array);
						transforms.push({
							sid: child.getAttribute('sid'),
							type: child.nodeName,
							obj: vector
						});
						break;

					case 'rotate':
						var array = parseFloats(child.textContent);
						var vector = new THREE.Vector3().fromArray(array);
						var angle = THREE.Math.degToRad(array[3]);
						transforms.push({
							sid: child.getAttribute('sid'),
							type: child.nodeName,
							obj: vector,
							angle: angle
						});
						break;

				}
			}

			return transforms;
		}

		// nodes

		function prepareNodes(xml) {

			var elements = xml.getElementsByTagName('node');

			// ensure all node elements have id attributes

			for (var i = 0; i < elements.length; i++) {

				var element = elements[i];

				if (element.hasAttribute('id') === false) {

					element.setAttribute('id', generateId());
				}
			}
		}

		var matrix = new THREE.Matrix4();
		var vector = new THREE.Vector3();

		function parseNode(xml) {

			var data = {
				name: xml.getAttribute('name') || '',
				type: xml.getAttribute('type'),
				id: xml.getAttribute('id'),
				sid: xml.getAttribute('sid'),
				matrix: new THREE.Matrix4(),
				nodes: [],
				instanceCameras: [],
				instanceControllers: [],
				instanceLights: [],
				instanceGeometries: [],
				instanceNodes: [],
				transforms: {}
			};

			for (var i = 0; i < xml.childNodes.length; i++) {

				var child = xml.childNodes[i];

				if (child.nodeType !== 1) continue;

				switch (child.nodeName) {

					case 'node':
						data.nodes.push(child.getAttribute('id'));
						parseNode(child);
						break;

					case 'instance_camera':
						data.instanceCameras.push(parseId(child.getAttribute('url')));
						break;

					case 'instance_controller':
						data.instanceControllers.push(parseNodeInstance(child));
						break;

					case 'instance_light':
						data.instanceLights.push(parseId(child.getAttribute('url')));
						break;

					case 'instance_geometry':
						data.instanceGeometries.push(parseNodeInstance(child));
						break;

					case 'instance_node':
						data.instanceNodes.push(parseId(child.getAttribute('url')));
						break;

					case 'matrix':
						var array = parseFloats(child.textContent);
						data.matrix.multiply(matrix.fromArray(array).transpose());
						data.transforms[child.getAttribute('sid')] = child.nodeName;
						break;

					case 'translate':
						var array = parseFloats(child.textContent);
						vector.fromArray(array);
						data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));
						data.transforms[child.getAttribute('sid')] = child.nodeName;
						break;

					case 'rotate':
						var array = parseFloats(child.textContent);
						var angle = THREE.Math.degToRad(array[3]);
						data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));
						data.transforms[child.getAttribute('sid')] = child.nodeName;
						break;

					case 'scale':
						var array = parseFloats(child.textContent);
						data.matrix.scale(vector.fromArray(array));
						data.transforms[child.getAttribute('sid')] = child.nodeName;
						break;

					case 'extra':
						break;

					default:
						console.log(child);

				}
			}

			library.nodes[data.id] = data;

			return data;
		}

		function parseNodeInstance(xml) {

			var data = {
				id: parseId(xml.getAttribute('url')),
				materials: {},
				skeletons: []
			};

			for (var i = 0; i < xml.childNodes.length; i++) {

				var child = xml.childNodes[i];

				switch (child.nodeName) {

					case 'bind_material':
						var instances = child.getElementsByTagName('instance_material');

						for (var j = 0; j < instances.length; j++) {

							var instance = instances[j];
							var symbol = instance.getAttribute('symbol');
							var target = instance.getAttribute('target');

							data.materials[symbol] = parseId(target);
						}

						break;

					case 'skeleton':
						data.skeletons.push(parseId(child.textContent));
						break;

					default:
						break;

				}
			}

			return data;
		}

		function buildSkeleton(skeletons, joints) {

			var boneData = [];
			var sortedBoneData = [];

			var i, j, data;

			// a skeleton can have multiple root bones. collada expresses this
			// situtation with multiple "skeleton" tags per controller instance

			for (i = 0; i < skeletons.length; i++) {

				var skeleton = skeletons[i];

				var root;

				if (hasNode(skeleton)) {

					root = getNode(skeleton);
					buildBoneHierarchy(root, joints, boneData);
				} else if (hasVisualScene(skeleton)) {

					// handle case where the skeleton refers to the visual scene (#13335)

					var visualScene = library.visualScenes[skeleton];
					var children = visualScene.children;

					for (var j = 0; j < children.length; j++) {

						var child = children[j];

						if (child.type === 'JOINT') {

							var root = getNode(child.id);
							buildBoneHierarchy(root, joints, boneData);
						}
					}
				} else {

					console.error('THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton);
				}
			}

			// sort bone data (the order is defined in the corresponding controller)

			for (i = 0; i < joints.length; i++) {

				for (j = 0; j < boneData.length; j++) {

					data = boneData[j];

					if (data.bone.name === joints[i].name) {

						sortedBoneData[i] = data;
						data.processed = true;
						break;
					}
				}
			}

			// add unprocessed bone data at the end of the list

			for (i = 0; i < boneData.length; i++) {

				data = boneData[i];

				if (data.processed === false) {

					sortedBoneData.push(data);
					data.processed = true;
				}
			}

			// setup arrays for skeleton creation

			var bones = [];
			var boneInverses = [];

			for (i = 0; i < sortedBoneData.length; i++) {

				data = sortedBoneData[i];

				bones.push(data.bone);
				boneInverses.push(data.boneInverse);
			}

			return new THREE.Skeleton(bones, boneInverses);
		}

		function buildBoneHierarchy(root, joints, boneData) {

			// setup bone data from visual scene

			root.traverse(function (object) {

				if (object.isBone === true) {

					var boneInverse;

					// retrieve the boneInverse from the controller data

					for (var i = 0; i < joints.length; i++) {

						var joint = joints[i];

						if (joint.name === object.name) {

							boneInverse = joint.boneInverse;
							break;
						}
					}

					if (boneInverse === undefined) {

						// Unfortunately, there can be joints in the visual scene that are not part of the
						// corresponding controller. In this case, we have to create a dummy boneInverse matrix
						// for the respective bone. This bone won't affect any vertices, because there are no skin indices
						// and weights defined for it. But we still have to add the bone to the sorted bone list in order to
						// ensure a correct animation of the model.

						boneInverse = new THREE.Matrix4();
					}

					boneData.push({ bone: object, boneInverse: boneInverse, processed: false });
				}
			});
		}

		function buildNode(data) {

			var objects = [];

			var matrix = data.matrix;
			var nodes = data.nodes;
			var type = data.type;
			var instanceCameras = data.instanceCameras;
			var instanceControllers = data.instanceControllers;
			var instanceLights = data.instanceLights;
			var instanceGeometries = data.instanceGeometries;
			var instanceNodes = data.instanceNodes;

			// nodes

			for (var i = 0, l = nodes.length; i < l; i++) {

				objects.push(getNode(nodes[i]));
			}

			// instance cameras

			for (var i = 0, l = instanceCameras.length; i < l; i++) {

				var instanceCamera = getCamera(instanceCameras[i]);

				if (instanceCamera !== null) {

					objects.push(instanceCamera.clone());
				}
			}

			// instance controllers

			for (var i = 0, l = instanceControllers.length; i < l; i++) {

				var instance = instanceControllers[i];
				var controller = getController(instance.id);
				var geometries = getGeometry(controller.id);
				var newObjects = buildObjects(geometries, instance.materials);

				var skeletons = instance.skeletons;
				var joints = controller.skin.joints;

				var skeleton = buildSkeleton(skeletons, joints);

				for (var j = 0, jl = newObjects.length; j < jl; j++) {

					var object = newObjects[j];

					if (object.isSkinnedMesh) {

						object.bind(skeleton, controller.skin.bindMatrix);
						object.normalizeSkinWeights();
					}

					objects.push(object);
				}
			}

			// instance lights

			for (var i = 0, l = instanceLights.length; i < l; i++) {

				var instanceLight = getLight(instanceLights[i]);

				if (instanceLight !== null) {

					objects.push(instanceLight.clone());
				}
			}

			// instance geometries

			for (var i = 0, l = instanceGeometries.length; i < l; i++) {

				var instance = instanceGeometries[i];

				// a single geometry instance in collada can lead to multiple object3Ds.
				// this is the case when primitives are combined like triangles and lines

				var geometries = getGeometry(instance.id);
				var newObjects = buildObjects(geometries, instance.materials);

				for (var j = 0, jl = newObjects.length; j < jl; j++) {

					objects.push(newObjects[j]);
				}
			}

			// instance nodes

			for (var i = 0, l = instanceNodes.length; i < l; i++) {

				objects.push(getNode(instanceNodes[i]).clone());
			}

			var object;

			if (nodes.length === 0 && objects.length === 1) {

				object = objects[0];
			} else {

				object = type === 'JOINT' ? new THREE.Bone() : new THREE.Group();

				for (var i = 0; i < objects.length; i++) {

					object.add(objects[i]);
				}
			}

			if (object.name === '') {

				object.name = type === 'JOINT' ? data.sid : data.name;
			}

			object.matrix.copy(matrix);
			object.matrix.decompose(object.position, object.quaternion, object.scale);

			return object;
		}

		function resolveMaterialBinding(keys, instanceMaterials) {

			var materials = [];

			for (var i = 0, l = keys.length; i < l; i++) {

				var id = instanceMaterials[keys[i]];
				materials.push(getMaterial(id));
			}

			return materials;
		}

		function buildObjects(geometries, instanceMaterials) {

			var objects = [];

			for (var type in geometries) {

				var geometry = geometries[type];

				var materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials);

				// handle case if no materials are defined

				if (materials.length === 0) {

					if (type === 'lines' || type === 'linestrips') {

						materials.push(new THREE.LineBasicMaterial());
					} else {

						materials.push(new THREE.MeshPhongMaterial());
					}
				}

				// regard skinning

				var skinning = geometry.data.attributes.skinIndex !== undefined;

				if (skinning) {

					for (var i = 0, l = materials.length; i < l; i++) {

						materials[i].skinning = true;
					}
				}

				// choose between a single or multi materials (material array)

				var material = materials.length === 1 ? materials[0] : materials;

				// now create a specific 3D object

				var object;

				switch (type) {

					case 'lines':
						object = new THREE.LineSegments(geometry.data, material);
						break;

					case 'linestrips':
						object = new THREE.Line(geometry.data, material);
						break;

					case 'triangles':
					case 'polylist':
						if (skinning) {

							object = new THREE.SkinnedMesh(geometry.data, material);
						} else {

							object = new THREE.Mesh(geometry.data, material);
						}
						break;

				}

				objects.push(object);
			}

			return objects;
		}

		function hasNode(id) {

			return library.nodes[id] !== undefined;
		}

		function getNode(id) {

			return getBuild(library.nodes[id], buildNode);
		}

		// visual scenes

		function parseVisualScene(xml) {

			var data = {
				name: xml.getAttribute('name'),
				children: []
			};

			prepareNodes(xml);

			var elements = getElementsByTagName(xml, 'node');

			for (var i = 0; i < elements.length; i++) {

				data.children.push(parseNode(elements[i]));
			}

			library.visualScenes[xml.getAttribute('id')] = data;
		}

		function buildVisualScene(data) {

			var group = new THREE.Group();
			group.name = data.name;

			var children = data.children;

			for (var i = 0; i < children.length; i++) {

				var child = children[i];

				group.add(getNode(child.id));
			}

			return group;
		}

		function hasVisualScene(id) {

			return library.visualScenes[id] !== undefined;
		}

		function getVisualScene(id) {

			return getBuild(library.visualScenes[id], buildVisualScene);
		}

		// scenes

		function parseScene(xml) {

			var instance = getElementsByTagName(xml, 'instance_visual_scene')[0];
			return getVisualScene(parseId(instance.getAttribute('url')));
		}

		function setupAnimations() {

			var clips = library.clips;

			if (isEmpty(clips) === true) {

				if (isEmpty(library.animations) === false) {

					// if there are animations but no clips, we create a default clip for playback

					var tracks = [];

					for (var id in library.animations) {

						var animationTracks = getAnimation(id);

						for (var i = 0, l = animationTracks.length; i < l; i++) {

							tracks.push(animationTracks[i]);
						}
					}

					animations.push(new THREE.AnimationClip('default', -1, tracks));
				}
			} else {

				for (var id in clips) {

					animations.push(getAnimationClip(id));
				}
			}
		}

		if (text.length === 0) {

			return { scene: new THREE.Scene() };
		}

		var xml = new DOMParser().parseFromString(text, 'application/xml');

		var collada = getElementsByTagName(xml, 'COLLADA')[0];

		// metadata

		var version = collada.getAttribute('version');
		console.log('THREE.ColladaLoader: File version', version);

		var asset = parseAsset(getElementsByTagName(collada, 'asset')[0]);
		var textureLoader = new THREE.TextureLoader(this.manager);
		textureLoader.setPath(path).setCrossOrigin(this.crossOrigin);

		//

		var animations = [];
		var kinematics = {};
		var count = 0;

		//

		var library = {
			animations: {},
			clips: {},
			controllers: {},
			images: {},
			effects: {},
			materials: {},
			cameras: {},
			lights: {},
			geometries: {},
			nodes: {},
			visualScenes: {},
			kinematicsModels: {},
			kinematicsScenes: {}
		};

		parseLibrary(collada, 'library_animations', 'animation', parseAnimation);
		parseLibrary(collada, 'library_animation_clips', 'animation_clip', parseAnimationClip);
		parseLibrary(collada, 'library_controllers', 'controller', parseController);
		parseLibrary(collada, 'library_images', 'image', parseImage);
		parseLibrary(collada, 'library_effects', 'effect', parseEffect);
		parseLibrary(collada, 'library_materials', 'material', parseMaterial);
		parseLibrary(collada, 'library_cameras', 'camera', parseCamera);
		parseLibrary(collada, 'library_lights', 'light', parseLight);
		parseLibrary(collada, 'library_geometries', 'geometry', parseGeometry);
		parseLibrary(collada, 'library_nodes', 'node', parseNode);
		parseLibrary(collada, 'library_visual_scenes', 'visual_scene', parseVisualScene);
		parseLibrary(collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel);
		parseLibrary(collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene);

		buildLibrary(library.animations, buildAnimation);
		buildLibrary(library.clips, buildAnimationClip);
		buildLibrary(library.controllers, buildController);
		buildLibrary(library.images, buildImage);
		buildLibrary(library.effects, buildEffect);
		buildLibrary(library.materials, buildMaterial);
		buildLibrary(library.cameras, buildCamera);
		buildLibrary(library.lights, buildLight);
		buildLibrary(library.geometries, buildGeometry);
		buildLibrary(library.visualScenes, buildVisualScene);

		setupAnimations();
		setupKinematics();

		var scene = parseScene(getElementsByTagName(collada, 'scene')[0]);

		if (asset.upAxis === 'Z_UP') {

			scene.quaternion.setFromEuler(new THREE.Euler(-Math.PI / 2, 0, 0));
		}

		scene.scale.multiplyScalar(asset.unit);

		return {
			animations: animations,
			kinematics: kinematics,
			library: library,
			scene: scene
		};
	}

};

exports.default = ColladaLoader;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @author mrdoob / http://mrdoob.com/
 */

var DDSLoader = function DDSLoader() {

	this._parser = DDSLoader.parse;
};

DDSLoader.prototype = Object.create(THREE.CompressedTextureLoader.prototype);
DDSLoader.prototype.constructor = DDSLoader;

DDSLoader.parse = function (buffer, loadMipmaps) {

	var dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };

	// Adapted from @toji's DDS utils
	// https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js

	// All values and structures referenced from:
	// http://msdn.microsoft.com/en-us/library/bb943991.aspx/

	var DDS_MAGIC = 0x20534444;

	var DDSD_CAPS = 0x1,
	    DDSD_HEIGHT = 0x2,
	    DDSD_WIDTH = 0x4,
	    DDSD_PITCH = 0x8,
	    DDSD_PIXELFORMAT = 0x1000,
	    DDSD_MIPMAPCOUNT = 0x20000,
	    DDSD_LINEARSIZE = 0x80000,
	    DDSD_DEPTH = 0x800000;

	var DDSCAPS_COMPLEX = 0x8,
	    DDSCAPS_MIPMAP = 0x400000,
	    DDSCAPS_TEXTURE = 0x1000;

	var DDSCAPS2_CUBEMAP = 0x200,
	    DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,
	    DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,
	    DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,
	    DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,
	    DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,
	    DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,
	    DDSCAPS2_VOLUME = 0x200000;

	var DDPF_ALPHAPIXELS = 0x1,
	    DDPF_ALPHA = 0x2,
	    DDPF_FOURCC = 0x4,
	    DDPF_RGB = 0x40,
	    DDPF_YUV = 0x200,
	    DDPF_LUMINANCE = 0x20000;

	function fourCCToInt32(value) {

		return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);
	}

	function int32ToFourCC(value) {

		return String.fromCharCode(value & 0xff, value >> 8 & 0xff, value >> 16 & 0xff, value >> 24 & 0xff);
	}

	function loadARGBMip(buffer, dataOffset, width, height) {

		var dataLength = width * height * 4;
		var srcBuffer = new Uint8Array(buffer, dataOffset, dataLength);
		var byteArray = new Uint8Array(dataLength);
		var dst = 0;
		var src = 0;
		for (var y = 0; y < height; y++) {

			for (var x = 0; x < width; x++) {

				var b = srcBuffer[src];src++;
				var g = srcBuffer[src];src++;
				var r = srcBuffer[src];src++;
				var a = srcBuffer[src];src++;
				byteArray[dst] = r;dst++; //r
				byteArray[dst] = g;dst++; //g
				byteArray[dst] = b;dst++; //b
				byteArray[dst] = a;dst++; //a
			}
		}
		return byteArray;
	}

	var FOURCC_DXT1 = fourCCToInt32("DXT1");
	var FOURCC_DXT3 = fourCCToInt32("DXT3");
	var FOURCC_DXT5 = fourCCToInt32("DXT5");
	var FOURCC_ETC1 = fourCCToInt32("ETC1");

	var headerLengthInt = 31; // The header length in 32 bit ints

	// Offsets into the header array

	var off_magic = 0;

	var off_size = 1;
	var off_flags = 2;
	var off_height = 3;
	var off_width = 4;

	var off_mipmapCount = 7;

	var off_pfFlags = 20;
	var off_pfFourCC = 21;
	var off_RGBBitCount = 22;
	var off_RBitMask = 23;
	var off_GBitMask = 24;
	var off_BBitMask = 25;
	var off_ABitMask = 26;

	var off_caps = 27;
	var off_caps2 = 28;
	var off_caps3 = 29;
	var off_caps4 = 30;

	// Parse header

	var header = new Int32Array(buffer, 0, headerLengthInt);

	if (header[off_magic] !== DDS_MAGIC) {

		console.error('THREE.DDSLoader.parse: Invalid magic number in DDS header.');
		return dds;
	}

	if (!header[off_pfFlags] & DDPF_FOURCC) {

		console.error('THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code.');
		return dds;
	}

	var blockBytes;

	var fourCC = header[off_pfFourCC];

	var isRGBAUncompressed = false;

	switch (fourCC) {

		case FOURCC_DXT1:

			blockBytes = 8;
			dds.format = THREE.RGB_S3TC_DXT1_Format;
			break;

		case FOURCC_DXT3:

			blockBytes = 16;
			dds.format = THREE.RGBA_S3TC_DXT3_Format;
			break;

		case FOURCC_DXT5:

			blockBytes = 16;
			dds.format = THREE.RGBA_S3TC_DXT5_Format;
			break;

		case FOURCC_ETC1:

			blockBytes = 8;
			dds.format = THREE.RGB_ETC1_Format;
			break;

		default:

			if (header[off_RGBBitCount] === 32 && header[off_RBitMask] & 0xff0000 && header[off_GBitMask] & 0xff00 && header[off_BBitMask] & 0xff && header[off_ABitMask] & 0xff000000) {

				isRGBAUncompressed = true;
				blockBytes = 64;
				dds.format = THREE.RGBAFormat;
			} else {

				console.error('THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC(fourCC));
				return dds;
			}

	}

	dds.mipmapCount = 1;

	if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {

		dds.mipmapCount = Math.max(1, header[off_mipmapCount]);
	}

	var caps2 = header[off_caps2];
	dds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;
	if (dds.isCubemap && (!(caps2 & DDSCAPS2_CUBEMAP_POSITIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ))) {

		console.error('THREE.DDSLoader.parse: Incomplete cubemap faces');
		return dds;
	}

	dds.width = header[off_width];
	dds.height = header[off_height];

	var dataOffset = header[off_size] + 4;

	// Extract mipmaps buffers

	var faces = dds.isCubemap ? 6 : 1;

	for (var face = 0; face < faces; face++) {

		var width = dds.width;
		var height = dds.height;

		for (var i = 0; i < dds.mipmapCount; i++) {

			if (isRGBAUncompressed) {

				var byteArray = loadARGBMip(buffer, dataOffset, width, height);
				var dataLength = byteArray.length;
			} else {

				var dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;
				var byteArray = new Uint8Array(buffer, dataOffset, dataLength);
			}

			var mipmap = { "data": byteArray, "width": width, "height": height };
			dds.mipmaps.push(mipmap);

			dataOffset += dataLength;

			width = Math.max(width >> 1, 1);
			height = Math.max(height >> 1, 1);
		}
	}

	return dds;
};

exports.default = DDSLoader;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Copyright 2016 The Draco Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
'use strict';

/**
 * @param {THREE.LoadingManager} manager
 */
var DRACOLoader = function DRACOLoader(manager) {
  this.timeLoaded = 0;
  this.manager = manager || THREE.DefaultLoadingManager;
  this.materials = null;
  this.verbosity = 0;
  this.attributeOptions = {};
  this.drawMode = THREE.TrianglesDrawMode;
  // Native Draco attribute type to Three.JS attribute type.
  this.nativeAttributeMap = {
    'position': 'POSITION',
    'normal': 'NORMAL',
    'color': 'COLOR',
    'uv': 'TEX_COORD'
  };
};

DRACOLoader.prototype = {

  constructor: DRACOLoader,

  load: function load(url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new THREE.FileLoader(scope.manager);
    loader.setPath(this.path);
    loader.setResponseType('arraybuffer');
    if (this.crossOrigin !== undefined) {
      loader.crossOrigin = this.crossOrigin;
    }
    loader.load(url, function (blob) {
      scope.decodeDracoFile(blob, onLoad);
    }, onProgress, onError);
  },

  setPath: function setPath(value) {
    this.path = value;
  },

  setCrossOrigin: function setCrossOrigin(value) {
    this.crossOrigin = value;
  },

  setVerbosity: function setVerbosity(level) {
    this.verbosity = level;
  },

  /**
   *  Sets desired mode for generated geometry indices.
   *  Can be either:
   *      THREE.TrianglesDrawMode
   *      THREE.TriangleStripDrawMode
   */
  setDrawMode: function setDrawMode(drawMode) {
    this.drawMode = drawMode;
  },

  /**
   * Skips dequantization for a specific attribute.
   * |attributeName| is the THREE.js name of the given attribute type.
   * The only currently supported |attributeName| is 'position', more may be
   * added in future.
   */
  setSkipDequantization: function setSkipDequantization(attributeName, skip) {
    var skipDequantization = true;
    if (typeof skip !== 'undefined') skipDequantization = skip;
    this.getAttributeOptions(attributeName).skipDequantization = skipDequantization;
  },

  /**
   * |attributeUniqueIdMap| specifies attribute unique id for an attribute in
   * the geometry to be decoded. The name of the attribute must be one of the
   * supported attribute type in Three.JS, including:
   *     'position',
   *     'color',
   *     'normal',
   *     'uv',
   *     'uv2',
   *     'skinIndex',
   *     'skinWeight'.
   * The format is:
   *     attributeUniqueIdMap[attributeName] = attributeId
   */
  decodeDracoFile: function decodeDracoFile(rawBuffer, callback, attributeUniqueIdMap) {
    var scope = this;
    DRACOLoader.getDecoderModule().then(function (module) {
      scope.decodeDracoFileInternal(rawBuffer, module.decoder, callback, attributeUniqueIdMap || {});
    });
  },

  decodeDracoFileInternal: function decodeDracoFileInternal(rawBuffer, dracoDecoder, callback, attributeUniqueIdMap) {
    /*
     * Here is how to use Draco Javascript decoder and get the geometry.
     */
    var buffer = new dracoDecoder.DecoderBuffer();
    buffer.Init(new Int8Array(rawBuffer), rawBuffer.byteLength);
    var decoder = new dracoDecoder.Decoder();

    /*
     * Determine what type is this file: mesh or point cloud.
     */
    var geometryType = decoder.GetEncodedGeometryType(buffer);
    if (geometryType == dracoDecoder.TRIANGULAR_MESH) {
      if (this.verbosity > 0) {
        console.log('Loaded a mesh.');
      }
    } else if (geometryType == dracoDecoder.POINT_CLOUD) {
      if (this.verbosity > 0) {
        console.log('Loaded a point cloud.');
      }
    } else {
      var errorMsg = 'THREE.DRACOLoader: Unknown geometry type.';
      console.error(errorMsg);
      throw new Error(errorMsg);
    }
    callback(this.convertDracoGeometryTo3JS(dracoDecoder, decoder, geometryType, buffer, attributeUniqueIdMap));
  },

  addAttributeToGeometry: function addAttributeToGeometry(dracoDecoder, decoder, dracoGeometry, attributeName, attribute, geometry, geometryBuffer) {
    if (attribute.ptr === 0) {
      var errorMsg = 'THREE.DRACOLoader: No attribute ' + attributeName;
      console.error(errorMsg);
      throw new Error(errorMsg);
    }
    var numComponents = attribute.num_components();
    var attributeData = new dracoDecoder.DracoFloat32Array();
    decoder.GetAttributeFloatForAllPoints(dracoGeometry, attribute, attributeData);
    var numPoints = dracoGeometry.num_points();
    var numValues = numPoints * numComponents;
    // Allocate space for attribute.
    geometryBuffer[attributeName] = new Float32Array(numValues);
    // Copy data from decoder.
    for (var i = 0; i < numValues; i++) {
      geometryBuffer[attributeName][i] = attributeData.GetValue(i);
    }
    // Add attribute to THREEJS geometry for rendering.
    geometry.addAttribute(attributeName, new THREE.Float32BufferAttribute(geometryBuffer[attributeName], numComponents));
    dracoDecoder.destroy(attributeData);
  },

  convertDracoGeometryTo3JS: function convertDracoGeometryTo3JS(dracoDecoder, decoder, geometryType, buffer, attributeUniqueIdMap) {
    if (this.getAttributeOptions('position').skipDequantization === true) {
      decoder.SkipAttributeTransform(dracoDecoder.POSITION);
    }
    var dracoGeometry;
    var decodingStatus;
    var start_time = performance.now();
    if (geometryType === dracoDecoder.TRIANGULAR_MESH) {
      dracoGeometry = new dracoDecoder.Mesh();
      decodingStatus = decoder.DecodeBufferToMesh(buffer, dracoGeometry);
    } else {
      dracoGeometry = new dracoDecoder.PointCloud();
      decodingStatus = decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);
    }
    if (!decodingStatus.ok() || dracoGeometry.ptr == 0) {
      var errorMsg = 'THREE.DRACOLoader: Decoding failed: ';
      errorMsg += decodingStatus.error_msg();
      console.error(errorMsg);
      dracoDecoder.destroy(decoder);
      dracoDecoder.destroy(dracoGeometry);
      throw new Error(errorMsg);
    }

    var decode_end = performance.now();
    dracoDecoder.destroy(buffer);
    /*
     * Example on how to retrieve mesh and attributes.
     */
    var numFaces;
    if (geometryType == dracoDecoder.TRIANGULAR_MESH) {
      numFaces = dracoGeometry.num_faces();
      if (this.verbosity > 0) {
        console.log('Number of faces loaded: ' + numFaces.toString());
      }
    } else {
      numFaces = 0;
    }

    var numPoints = dracoGeometry.num_points();
    var numAttributes = dracoGeometry.num_attributes();
    if (this.verbosity > 0) {
      console.log('Number of points loaded: ' + numPoints.toString());
      console.log('Number of attributes loaded: ' + numAttributes.toString());
    }

    // Verify if there is position attribute.
    var posAttId = decoder.GetAttributeId(dracoGeometry, dracoDecoder.POSITION);
    if (posAttId == -1) {
      var errorMsg = 'THREE.DRACOLoader: No position attribute found.';
      console.error(errorMsg);
      dracoDecoder.destroy(decoder);
      dracoDecoder.destroy(dracoGeometry);
      throw new Error(errorMsg);
    }
    var posAttribute = decoder.GetAttribute(dracoGeometry, posAttId);

    // Structure for converting to THREEJS geometry later.
    var geometryBuffer = {};
    // Import data to Three JS geometry.
    var geometry = new THREE.BufferGeometry();

    // Add native Draco attribute type to geometry.
    for (var attributeName in this.nativeAttributeMap) {
      // The native attribute type is only used when no unique Id is
      // provided. For example, loading .drc files.
      if (attributeUniqueIdMap[attributeName] === undefined) {
        var attId = decoder.GetAttributeId(dracoGeometry, dracoDecoder[this.nativeAttributeMap[attributeName]]);
        if (attId !== -1) {
          if (this.verbosity > 0) {
            console.log('Loaded ' + attributeName + ' attribute.');
          }
          var attribute = decoder.GetAttribute(dracoGeometry, attId);
          this.addAttributeToGeometry(dracoDecoder, decoder, dracoGeometry, attributeName, attribute, geometry, geometryBuffer);
        }
      }
    }

    // Add attributes of user specified unique id. E.g. GLTF models.
    for (var attributeName in attributeUniqueIdMap) {
      var attributeId = attributeUniqueIdMap[attributeName];
      var attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeId);
      this.addAttributeToGeometry(dracoDecoder, decoder, dracoGeometry, attributeName, attribute, geometry, geometryBuffer);
    }

    // For mesh, we need to generate the faces.
    if (geometryType == dracoDecoder.TRIANGULAR_MESH) {
      if (this.drawMode === THREE.TriangleStripDrawMode) {
        var stripsArray = new dracoDecoder.DracoInt32Array();
        var numStrips = decoder.GetTriangleStripsFromMesh(dracoGeometry, stripsArray);
        geometryBuffer.indices = new Uint32Array(stripsArray.size());
        for (var i = 0; i < stripsArray.size(); ++i) {
          geometryBuffer.indices[i] = stripsArray.GetValue(i);
        }
        dracoDecoder.destroy(stripsArray);
      } else {
        var numIndices = numFaces * 3;
        geometryBuffer.indices = new Uint32Array(numIndices);
        var ia = new dracoDecoder.DracoInt32Array();
        for (var i = 0; i < numFaces; ++i) {
          decoder.GetFaceFromMesh(dracoGeometry, i, ia);
          var index = i * 3;
          geometryBuffer.indices[index] = ia.GetValue(0);
          geometryBuffer.indices[index + 1] = ia.GetValue(1);
          geometryBuffer.indices[index + 2] = ia.GetValue(2);
        }
        dracoDecoder.destroy(ia);
      }
    }

    geometry.drawMode = this.drawMode;
    if (geometryType == dracoDecoder.TRIANGULAR_MESH) {
      geometry.setIndex(new (geometryBuffer.indices.length > 65535 ? THREE.Uint32BufferAttribute : THREE.Uint16BufferAttribute)(geometryBuffer.indices, 1));
    }
    var posTransform = new dracoDecoder.AttributeQuantizationTransform();
    if (posTransform.InitFromAttribute(posAttribute)) {
      // Quantized attribute. Store the quantization parameters into the
      // THREE.js attribute.
      geometry.attributes['position'].isQuantized = true;
      geometry.attributes['position'].maxRange = posTransform.range();
      geometry.attributes['position'].numQuantizationBits = posTransform.quantization_bits();
      geometry.attributes['position'].minValues = new Float32Array(3);
      for (var i = 0; i < 3; ++i) {
        geometry.attributes['position'].minValues[i] = posTransform.min_value(i);
      }
    }
    dracoDecoder.destroy(posTransform);
    dracoDecoder.destroy(decoder);
    dracoDecoder.destroy(dracoGeometry);

    this.decode_time = decode_end - start_time;
    this.import_time = performance.now() - decode_end;

    if (this.verbosity > 0) {
      console.log('Decode time: ' + this.decode_time);
      console.log('Import time: ' + this.import_time);
    }
    return geometry;
  },

  isVersionSupported: function isVersionSupported(version, callback) {
    DRACOLoader.getDecoderModule().then(function (module) {
      callback(module.decoder.isVersionSupported(version));
    });
  },

  getAttributeOptions: function getAttributeOptions(attributeName) {
    if (typeof this.attributeOptions[attributeName] === 'undefined') this.attributeOptions[attributeName] = {};
    return this.attributeOptions[attributeName];
  }
};

DRACOLoader.decoderPath = './';
DRACOLoader.decoderConfig = {};
DRACOLoader.decoderModulePromise = null;

/**
 * Sets the base path for decoder source files.
 * @param {string} path
 */
DRACOLoader.setDecoderPath = function (path) {
  DRACOLoader.decoderPath = path;
};

/**
 * Sets decoder configuration and releases singleton decoder module. Module
 * will be recreated with the next decoding call.
 * @param {Object} config
 */
DRACOLoader.setDecoderConfig = function (config) {
  var wasmBinary = DRACOLoader.decoderConfig.wasmBinary;
  DRACOLoader.decoderConfig = config || {};
  DRACOLoader.releaseDecoderModule();

  // Reuse WASM binary.
  if (wasmBinary) DRACOLoader.decoderConfig.wasmBinary = wasmBinary;
};

/**
 * Releases the singleton DracoDecoderModule instance. Module will be recreated
 * with the next decoding call.
 */
DRACOLoader.releaseDecoderModule = function () {
  DRACOLoader.decoderModulePromise = null;
};

/**
 * Gets WebAssembly or asm.js singleton instance of DracoDecoderModule
 * after testing for browser support. Returns Promise that resolves when
 * module is available.
 * @return {Promise<{decoder: DracoDecoderModule}>}
 */
DRACOLoader.getDecoderModule = function () {
  var scope = this;
  var path = DRACOLoader.decoderPath;
  var config = DRACOLoader.decoderConfig;
  var promise = DRACOLoader.decoderModulePromise;

  if (promise) return promise;

  // Load source files.
  if (typeof DracoDecoderModule !== 'undefined') {
    // Loaded externally.
    promise = Promise.resolve();
  } else if ((typeof WebAssembly === 'undefined' ? 'undefined' : _typeof(WebAssembly)) !== 'object' || config.type === 'js') {
    // Load with asm.js.
    promise = DRACOLoader._loadScript(path + 'draco_decoder.js');
  } else {
    // Load with WebAssembly.
    config.wasmBinaryFile = path + 'draco_decoder.wasm';
    promise = DRACOLoader._loadScript(path + 'draco_wasm_wrapper.js').then(function () {
      return DRACOLoader._loadArrayBuffer(config.wasmBinaryFile);
    }).then(function (wasmBinary) {
      config.wasmBinary = wasmBinary;
    });
  }

  // Wait for source files, then create and return a decoder.
  promise = promise.then(function () {
    return new Promise(function (resolve) {
      config.onModuleLoaded = function (decoder) {
        scope.timeLoaded = performance.now();
        // Module is Promise-like. Wrap before resolving to avoid loop.
        resolve({ decoder: decoder });
      };
      DracoDecoderModule(config);
    });
  });

  DRACOLoader.decoderModulePromise = promise;
  return promise;
};

/**
 * @param {string} src
 * @return {Promise}
 */
DRACOLoader._loadScript = function (src) {
  var prevScript = document.getElementById('decoder_script');
  if (prevScript !== null) {
    prevScript.parentNode.removeChild(prevScript);
  }
  var head = document.getElementsByTagName('head')[0];
  var script = document.createElement('script');
  script.id = 'decoder_script';
  script.type = 'text/javascript';
  script.src = src;
  return new Promise(function (resolve) {
    script.onload = resolve;
    head.appendChild(script);
  });
};

/**
 * @param {string} src
 * @return {Promise}
 */
DRACOLoader._loadArrayBuffer = function (src) {
  var loader = new THREE.FileLoader();
  loader.setResponseType('arraybuffer');
  return new Promise(function (resolve, reject) {
    loader.load(src, resolve, undefined, reject);
  });
};

exports.default = DRACOLoader;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
* @author Richard M. / https://github.com/richardmonette
*/

var EquiangularToCubeGenerator = function EquiangularToCubeGenerator(sourceTexture, resolution) {

	this.sourceTexture = sourceTexture;
	this.resolution = resolution;

	this.views = [{ t: [1, 0, 0], u: [0, -1, 0] }, { t: [-1, 0, 0], u: [0, -1, 0] }, { t: [0, 1, 0], u: [0, 0, 1] }, { t: [0, -1, 0], u: [0, 0, -1] }, { t: [0, 0, 1], u: [0, -1, 0] }, { t: [0, 0, -1], u: [0, -1, 0] }];

	this.camera = new THREE.PerspectiveCamera(90, 1, 0.1, 10);
	this.boxMesh = new THREE.Mesh(new THREE.BoxBufferGeometry(1, 1, 1), this.getShader());
	this.boxMesh.material.side = THREE.BackSide;
	this.scene = new THREE.Scene();
	this.scene.add(this.boxMesh);

	var params = {
		format: THREE.RGBAFormat,
		magFilter: this.sourceTexture.magFilter,
		minFilter: this.sourceTexture.minFilter,
		type: this.sourceTexture.type,
		generateMipmaps: this.sourceTexture.generateMipmaps,
		anisotropy: this.sourceTexture.anisotropy,
		encoding: this.sourceTexture.encoding
	};

	this.renderTarget = new THREE.WebGLRenderTargetCube(this.resolution, this.resolution, params);
};

EquiangularToCubeGenerator.prototype = {

	constructor: EquiangularToCubeGenerator,

	update: function update(renderer) {

		for (var i = 0; i < 6; i++) {

			this.renderTarget.activeCubeFace = i;

			var v = this.views[i];

			this.camera.position.set(0, 0, 0);
			this.camera.up.set(v.u[0], v.u[1], v.u[2]);
			this.camera.lookAt(v.t[0], v.t[1], v.t[2]);

			renderer.render(this.scene, this.camera, this.renderTarget, true);
		}

		return this.renderTarget.texture;
	},

	getShader: function getShader() {

		var shaderMaterial = new THREE.ShaderMaterial({

			uniforms: {
				"equirectangularMap": { value: this.sourceTexture }
			},

			vertexShader: "varying vec3 localPosition;\n\
				\n\
				void main() {\n\
					localPosition = position;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader: "#include <common>\n\
				varying vec3 localPosition;\n\
				uniform sampler2D equirectangularMap;\n\
				\n\
				vec2 EquiangularSampleUV(vec3 v) {\n\
			    vec2 uv = vec2(atan(v.z, v.x), asin(v.y));\n\
			    uv *= vec2(0.1591, 0.3183); // inverse atan\n\
			    uv += 0.5;\n\
			    return uv;\n\
				}\n\
				\n\
				void main() {\n\
					vec2 uv = EquiangularSampleUV(normalize(localPosition));\n\
    			vec3 color = texture2D(equirectangularMap, uv).rgb;\n\
    			\n\
					gl_FragColor = vec4( color, 1.0 );\n\
				}",

			blending: THREE.CustomBlending,
			premultipliedAlpha: false,
			blendSrc: THREE.OneFactor,
			blendDst: THREE.ZeroFactor,
			blendSrcAlpha: THREE.OneFactor,
			blendDstAlpha: THREE.ZeroFactor,
			blendEquation: THREE.AddEquation

		});

		shaderMaterial.type = 'EquiangularToCubeGenerator';

		return shaderMaterial;
	},

	dispose: function dispose() {

		this.boxMesh.geometry.dispose();
		this.boxMesh.material.dispose();
		this.renderTarget.dispose();
	}

};

exports.default = EquiangularToCubeGenerator;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author Richard M. / https://github.com/richardmonette
 *
 * OpenEXR loader which, currently, supports reading 16 bit half data, in either
 * uncompressed or PIZ wavelet compressed form.
 *
 * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita
 * implementation, so I have preserved their copyright notices.
 */

// /*
// Copyright (c) 2014 - 2017, Syoyo Fujita
// All rights reserved.

// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Syoyo Fujita nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// */

// // TinyEXR contains some OpenEXR code, which is licensed under ------------

// ///////////////////////////////////////////////////////////////////////////
// //
// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas
// // Digital Ltd. LLC
// //
// // All rights reserved.
// //
// // Redistribution and use in source and binary forms, with or without
// // modification, are permitted provided that the following conditions are
// // met:
// // *       Redistributions of source code must retain the above copyright
// // notice, this list of conditions and the following disclaimer.
// // *       Redistributions in binary form must reproduce the above
// // copyright notice, this list of conditions and the following disclaimer
// // in the documentation and/or other materials provided with the
// // distribution.
// // *       Neither the name of Industrial Light & Magic nor the names of
// // its contributors may be used to endorse or promote products derived
// // from this software without specific prior written permission.
// //
// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// //
// ///////////////////////////////////////////////////////////////////////////

// // End of OpenEXR license -------------------------------------------------

var EXRLoader = function EXRLoader(manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};

EXRLoader.prototype = Object.create(THREE.DataTextureLoader.prototype);

EXRLoader.prototype._parser = function (buffer) {

	var USHORT_RANGE = 1 << 16;
	var BITMAP_SIZE = USHORT_RANGE >> 3;

	var HUF_ENCBITS = 16; // literal (value) bit length
	var HUF_DECBITS = 14; // decoding bit size (>= 8)

	var HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1; // encoding table size
	var HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size
	var HUF_DECMASK = HUF_DECSIZE - 1;

	var SHORT_ZEROCODE_RUN = 59;
	var LONG_ZEROCODE_RUN = 63;
	var SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;
	var LONGEST_LONG_RUN = 255 + SHORTEST_LONG_RUN;

	var BYTES_PER_HALF = 2;

	var ULONG_SIZE = 8;
	var FLOAT32_SIZE = 4;
	var INT32_SIZE = 4;
	var INT16_SIZE = 2;
	var INT8_SIZE = 1;

	function reverseLutFromBitmap(bitmap, lut) {

		var k = 0;

		for (var i = 0; i < USHORT_RANGE; ++i) {

			if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {

				lut[k++] = i;
			}
		}

		var n = k - 1;

		while (k < USHORT_RANGE) {
			lut[k++] = 0;
		}return n;
	}

	function hufClearDecTable(hdec) {

		for (var i = 0; i < HUF_DECSIZE; i++) {

			hdec[i] = {};
			hdec[i].len = 0;
			hdec[i].lit = 0;
			hdec[i].p = null;
		}
	}

	var getBitsReturn = { l: 0, c: 0, lc: 0 };

	function getBits(nBits, c, lc, uInt8Array, inOffset) {

		while (lc < nBits) {

			c = c << 8 | parseUint8Array(uInt8Array, inOffset);
			lc += 8;
		}

		lc -= nBits;

		getBitsReturn.l = c >> lc & (1 << nBits) - 1;
		getBitsReturn.c = c;
		getBitsReturn.lc = lc;
	}

	var hufTableBuffer = new Array(59);

	function hufCanonicalCodeTable(hcode) {

		for (var i = 0; i <= 58; ++i) {
			hufTableBuffer[i] = 0;
		}for (var i = 0; i < HUF_ENCSIZE; ++i) {
			hufTableBuffer[hcode[i]] += 1;
		}var c = 0;

		for (var i = 58; i > 0; --i) {

			var nc = c + hufTableBuffer[i] >> 1;
			hufTableBuffer[i] = c;
			c = nc;
		}

		for (var i = 0; i < HUF_ENCSIZE; ++i) {

			var l = hcode[i];
			if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;
		}
	}

	function hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, hcode) {

		var p = inOffset;
		var c = 0;
		var lc = 0;

		for (; im <= iM; im++) {

			if (p.value - inOffset.value > ni) return false;

			getBits(6, c, lc, uInt8Array, p);

			var l = getBitsReturn.l;
			c = getBitsReturn.c;
			lc = getBitsReturn.lc;

			hcode[im] = l;

			if (l == LONG_ZEROCODE_RUN) {

				if (p.value - inOffset.value > ni) {

					throw 'Something wrong with hufUnpackEncTable';
				}

				getBits(8, c, lc, uInt8Array, p);

				var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;
				c = getBitsReturn.c;
				lc = getBitsReturn.lc;

				if (im + zerun > iM + 1) {

					throw 'Something wrong with hufUnpackEncTable';
				}

				while (zerun--) {
					hcode[im++] = 0;
				}im--;
			} else if (l >= SHORT_ZEROCODE_RUN) {

				var zerun = l - SHORT_ZEROCODE_RUN + 2;

				if (im + zerun > iM + 1) {

					throw 'Something wrong with hufUnpackEncTable';
				}

				while (zerun--) {
					hcode[im++] = 0;
				}im--;
			}
		}

		hufCanonicalCodeTable(hcode);
	}

	function hufLength(code) {
		return code & 63;
	}

	function hufCode(code) {
		return code >> 6;
	}

	function hufBuildDecTable(hcode, im, iM, hdecod) {

		for (; im <= iM; im++) {

			var c = hufCode(hcode[im]);
			var l = hufLength(hcode[im]);

			if (c >> l) {

				throw 'Invalid table entry';
			}

			if (l > HUF_DECBITS) {

				var pl = hdecod[c >> l - HUF_DECBITS];

				if (pl.len) {

					throw 'Invalid table entry';
				}

				pl.lit++;

				if (pl.p) {

					var p = pl.p;
					pl.p = new Array(pl.lit);

					for (var i = 0; i < pl.lit - 1; ++i) {

						pl.p[i] = p[i];
					}
				} else {

					pl.p = new Array(1);
				}

				pl.p[pl.lit - 1] = im;
			} else if (l) {

				var plOffset = 0;

				for (var i = 1 << HUF_DECBITS - l; i > 0; i--) {

					var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];

					if (pl.len || pl.p) {

						throw 'Invalid table entry';
					}

					pl.len = l;
					pl.lit = im;

					plOffset++;
				}
			}
		}

		return true;
	}

	var getCharReturn = { c: 0, lc: 0 };

	function getChar(c, lc, uInt8Array, inOffset) {

		c = c << 8 | parseUint8Array(uInt8Array, inOffset);
		lc += 8;

		getCharReturn.c = c;
		getCharReturn.lc = lc;
	}

	var getCodeReturn = { c: 0, lc: 0 };

	function getCode(po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {

		if (po == rlc) {

			if (lc < 8) {

				getChar(c, lc, uInt8Array, inOffset);
				c = getCharReturn.c;
				lc = getCharReturn.lc;
			}

			lc -= 8;

			var cs = c >> lc;

			if (out + cs > oe) {

				throw 'Issue with getCode';
			}

			var s = out[-1];

			while (cs-- > 0) {

				outBuffer[outBufferOffset.value++] = s;
			}
		} else if (outBufferOffset.value < outBufferEndOffset) {

			outBuffer[outBufferOffset.value++] = po;
		} else {

			throw 'Issue with getCode';
		}

		getCodeReturn.c = c;
		getCodeReturn.lc = lc;
	}

	var NBITS = 16;
	var A_OFFSET = 1 << NBITS - 1;
	var M_OFFSET = 1 << NBITS - 1;
	var MOD_MASK = (1 << NBITS) - 1;

	function UInt16(value) {

		return value & 0xFFFF;
	}

	function Int16(value) {

		var ref = UInt16(value);
		return ref > 0x7FFF ? ref - 0x10000 : ref;
	}

	var wdec14Return = { a: 0, b: 0 };

	function wdec14(l, h) {

		var ls = Int16(l);
		var hs = Int16(h);

		var hi = hs;
		var ai = ls + (hi & 1) + (hi >> 1);

		var as = ai;
		var bs = ai - hi;

		wdec14Return.a = as;
		wdec14Return.b = bs;
	}

	function wav2Decode(j, buffer, nx, ox, ny, oy, mx) {

		var n = nx > ny ? ny : nx;
		var p = 1;
		var p2;

		while (p <= n) {
			p <<= 1;
		}p >>= 1;
		p2 = p;
		p >>= 1;

		while (p >= 1) {

			var py = 0;
			var ey = py + oy * (ny - p2);
			var oy1 = oy * p;
			var oy2 = oy * p2;
			var ox1 = ox * p;
			var ox2 = ox * p2;
			var i00, i01, i10, i11;

			for (; py <= ey; py += oy2) {

				var px = py;
				var ex = py + ox * (nx - p2);

				for (; px <= ex; px += ox2) {

					var p01 = px + ox1;
					var p10 = px + oy1;
					var p11 = p10 + ox1;

					wdec14(buffer[px + j], buffer[p10 + j]);

					i00 = wdec14Return.a;
					i10 = wdec14Return.b;

					wdec14(buffer[p01 + j], buffer[p11 + j]);

					i01 = wdec14Return.a;
					i11 = wdec14Return.b;

					wdec14(i00, i01);

					buffer[px + j] = wdec14Return.a;
					buffer[p01 + j] = wdec14Return.b;

					wdec14(i10, i11);

					buffer[p10 + j] = wdec14Return.a;
					buffer[p11 + j] = wdec14Return.b;
				}

				if (nx & p) {

					var p10 = px + oy1;

					wdec14(buffer[px + j], buffer[p10 + j]);

					i00 = wdec14Return.a;
					buffer[p10 + j] = wdec14Return.b;

					buffer[px + j] = i00;
				}
			}

			if (ny & p) {

				var px = py;
				var ex = py + ox * (nx - p2);

				for (; px <= ex; px += ox2) {

					var p01 = px + ox1;

					wdec14(buffer[px + j], buffer[p01 + j]);

					i00 = wdec14Return.a;
					buffer[p01 + j] = wdec14Return.b;

					buffer[px + j] = i00;
				}
			}

			p2 = p;
			p >>= 1;
		}

		return py;
	}

	function hufDecode(encodingTable, decodingTable, uInt8Array, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {

		var c = 0;
		var lc = 0;
		var outBufferEndOffset = no;
		var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);

		while (inOffset.value < inOffsetEnd) {

			getChar(c, lc, uInt8Array, inOffset);

			c = getCharReturn.c;
			lc = getCharReturn.lc;

			while (lc >= HUF_DECBITS) {

				var index = c >> lc - HUF_DECBITS & HUF_DECMASK;
				var pl = decodingTable[index];

				if (pl.len) {

					lc -= pl.len;

					getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);

					c = getCodeReturn.c;
					lc = getCodeReturn.lc;
				} else {

					if (!pl.p) {

						throw 'hufDecode issues';
					}

					var j;

					for (j = 0; j < pl.lit; j++) {

						var l = hufLength(encodingTable[pl.p[j]]);

						while (lc < l && inOffset.value < inOffsetEnd) {

							getChar(c, lc, uInt8Array, inOffset);

							c = getCharReturn.c;
							lc = getCharReturn.lc;
						}

						if (lc >= l) {

							if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {

								lc -= l;

								getCode(pl.p[j], rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);

								c = getCodeReturn.c;
								lc = getCodeReturn.lc;

								break;
							}
						}
					}

					if (j == pl.lit) {

						throw 'hufDecode issues';
					}
				}
			}
		}

		var i = 8 - ni & 7;

		c >>= i;
		lc -= i;

		while (lc > 0) {

			var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];

			if (pl.len) {

				lc -= pl.len;

				getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);

				c = getCodeReturn.c;
				lc = getCodeReturn.lc;
			} else {

				throw 'hufDecode issues';
			}
		}

		return true;
	}

	function hufUncompress(uInt8Array, inDataView, inOffset, nCompressed, outBuffer, outOffset, nRaw) {

		var initialInOffset = inOffset.value;

		var im = parseUint32(inDataView, inOffset);
		var iM = parseUint32(inDataView, inOffset);

		inOffset.value += 4;

		var nBits = parseUint32(inDataView, inOffset);

		inOffset.value += 4;

		if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {

			throw 'Something wrong with HUF_ENCSIZE';
		}

		var freq = new Array(HUF_ENCSIZE);
		var hdec = new Array(HUF_DECSIZE);

		hufClearDecTable(hdec);

		var ni = nCompressed - (inOffset.value - initialInOffset);

		hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, freq);

		if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {

			throw 'Something wrong with hufUncompress';
		}

		hufBuildDecTable(freq, im, iM, hdec);

		hufDecode(freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);
	}

	function applyLut(lut, data, nData) {

		for (var i = 0; i < nData; ++i) {

			data[i] = lut[data[i]];
		}
	}

	function decompressPIZ(outBuffer, outOffset, uInt8Array, inDataView, inOffset, tmpBufSize, num_channels, exrChannelInfos, dataWidth, num_lines) {

		var bitmap = new Uint8Array(BITMAP_SIZE);

		var minNonZero = parseUint16(inDataView, inOffset);
		var maxNonZero = parseUint16(inDataView, inOffset);

		if (maxNonZero >= BITMAP_SIZE) {

			throw 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE';
		}

		if (minNonZero <= maxNonZero) {

			for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {

				bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);
			}
		}

		var lut = new Uint16Array(USHORT_RANGE);
		var maxValue = reverseLutFromBitmap(bitmap, lut);

		var length = parseUint32(inDataView, inOffset);

		hufUncompress(uInt8Array, inDataView, inOffset, length, outBuffer, outOffset, tmpBufSize);

		var pizChannelData = new Array(num_channels);

		var outBufferEnd = 0;

		for (var i = 0; i < num_channels; i++) {

			var exrChannelInfo = exrChannelInfos[i];

			var pixelSize = 2; // assumes HALF_FLOAT

			pizChannelData[i] = {};
			pizChannelData[i]['start'] = outBufferEnd;
			pizChannelData[i]['end'] = pizChannelData[i]['start'];
			pizChannelData[i]['nx'] = dataWidth;
			pizChannelData[i]['ny'] = num_lines;
			pizChannelData[i]['size'] = 1;

			outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;
		}

		var fooOffset = 0;

		for (var i = 0; i < num_channels; i++) {

			for (var j = 0; j < pizChannelData[i].size; ++j) {

				fooOffset += wav2Decode(j + fooOffset, outBuffer, pizChannelData[i].nx, pizChannelData[i].size, pizChannelData[i].ny, pizChannelData[i].nx * pizChannelData[i].size, maxValue);
			}
		}

		applyLut(lut, outBuffer, outBufferEnd);

		return true;
	}

	function parseNullTerminatedString(buffer, offset) {

		var uintBuffer = new Uint8Array(buffer);
		var endOffset = 0;

		while (uintBuffer[offset.value + endOffset] != 0) {

			endOffset += 1;
		}

		var stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset));

		offset.value = offset.value + endOffset + 1;

		return stringValue;
	}

	function parseFixedLengthString(buffer, offset, size) {

		var stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size));

		offset.value = offset.value + size;

		return stringValue;
	}

	function parseUlong(dataView, offset) {

		var uLong = dataView.getUint32(0, true);

		offset.value = offset.value + ULONG_SIZE;

		return uLong;
	}

	function parseUint32(dataView, offset) {

		var Uint32 = dataView.getUint32(offset.value, true);

		offset.value = offset.value + INT32_SIZE;

		return Uint32;
	}

	function parseUint8Array(uInt8Array, offset) {

		var Uint8 = uInt8Array[offset.value];

		offset.value = offset.value + INT8_SIZE;

		return Uint8;
	}

	function parseUint8(dataView, offset) {

		var Uint8 = dataView.getUint8(offset.value);

		offset.value = offset.value + INT8_SIZE;

		return Uint8;
	}

	function parseFloat32(dataView, offset) {

		var float = dataView.getFloat32(offset.value, true);

		offset.value += FLOAT32_SIZE;

		return float;
	}

	// https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript
	function decodeFloat16(binary) {

		var exponent = (binary & 0x7C00) >> 10,
		    fraction = binary & 0x03FF;

		return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 0x1F ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 0x400) : 6.103515625e-5 * (fraction / 0x400));
	}

	function parseUint16(dataView, offset) {

		var Uint16 = dataView.getUint16(offset.value, true);

		offset.value += INT16_SIZE;

		return Uint16;
	}

	function parseFloat16(buffer, offset) {

		return decodeFloat16(parseUint16(buffer, offset));
	}

	function parseChlist(dataView, buffer, offset, size) {

		var startOffset = offset.value;
		var channels = [];

		while (offset.value < startOffset + size - 1) {

			var name = parseNullTerminatedString(buffer, offset);
			var pixelType = parseUint32(dataView, offset); // TODO: Cast this to UINT, HALF or FLOAT
			var pLinear = parseUint8(dataView, offset);
			offset.value += 3; // reserved, three chars
			var xSampling = parseUint32(dataView, offset);
			var ySampling = parseUint32(dataView, offset);

			channels.push({
				name: name,
				pixelType: pixelType,
				pLinear: pLinear,
				xSampling: xSampling,
				ySampling: ySampling
			});
		}

		offset.value += 1;

		return channels;
	}

	function parseChromaticities(dataView, offset) {

		var redX = parseFloat32(dataView, offset);
		var redY = parseFloat32(dataView, offset);
		var greenX = parseFloat32(dataView, offset);
		var greenY = parseFloat32(dataView, offset);
		var blueX = parseFloat32(dataView, offset);
		var blueY = parseFloat32(dataView, offset);
		var whiteX = parseFloat32(dataView, offset);
		var whiteY = parseFloat32(dataView, offset);

		return { redX: redX, redY: redY, greenX: greenX, greenY: greenY, blueX: blueX, blueY: blueY, whiteX: whiteX, whiteY: whiteY };
	}

	function parseCompression(dataView, offset) {

		var compressionCodes = ['NO_COMPRESSION', 'RLE_COMPRESSION', 'ZIPS_COMPRESSION', 'ZIP_COMPRESSION', 'PIZ_COMPRESSION'];

		var compression = parseUint8(dataView, offset);

		return compressionCodes[compression];
	}

	function parseBox2i(dataView, offset) {

		var xMin = parseUint32(dataView, offset);
		var yMin = parseUint32(dataView, offset);
		var xMax = parseUint32(dataView, offset);
		var yMax = parseUint32(dataView, offset);

		return { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax };
	}

	function parseLineOrder(dataView, offset) {

		var lineOrders = ['INCREASING_Y'];

		var lineOrder = parseUint8(dataView, offset);

		return lineOrders[lineOrder];
	}

	function parseV2f(dataView, offset) {

		var x = parseFloat32(dataView, offset);
		var y = parseFloat32(dataView, offset);

		return [x, y];
	}

	function parseValue(dataView, buffer, offset, type, size) {

		if (type === 'string' || type === 'iccProfile') {

			return parseFixedLengthString(buffer, offset, size);
		} else if (type === 'chlist') {

			return parseChlist(dataView, buffer, offset, size);
		} else if (type === 'chromaticities') {

			return parseChromaticities(dataView, offset);
		} else if (type === 'compression') {

			return parseCompression(dataView, offset);
		} else if (type === 'box2i') {

			return parseBox2i(dataView, offset);
		} else if (type === 'lineOrder') {

			return parseLineOrder(dataView, offset);
		} else if (type === 'float') {

			return parseFloat32(dataView, offset);
		} else if (type === 'v2f') {

			return parseV2f(dataView, offset);
		} else if (type === 'int') {

			return parseUint32(dataView, offset);
		} else {

			throw 'Cannot parse value for unsupported type: ' + type;
		}
	}

	var bufferDataView = new DataView(buffer);
	var uInt8Array = new Uint8Array(buffer);

	var EXRHeader = {};

	var magic = bufferDataView.getUint32(0, true);
	var versionByteZero = bufferDataView.getUint8(4, true);
	var fullMask = bufferDataView.getUint8(5, true);

	// start of header

	var offset = { value: 8 }; // start at 8, after magic stuff

	var keepReading = true;

	while (keepReading) {

		var attributeName = parseNullTerminatedString(buffer, offset);

		if (attributeName == 0) {

			keepReading = false;
		} else {

			var attributeType = parseNullTerminatedString(buffer, offset);
			var attributeSize = parseUint32(bufferDataView, offset);
			var attributeValue = parseValue(bufferDataView, buffer, offset, attributeType, attributeSize);

			EXRHeader[attributeName] = attributeValue;
		}
	}

	// offsets

	var dataWindowHeight = EXRHeader.dataWindow.yMax + 1;
	var scanlineBlockSize = 1; // 1 for NO_COMPRESSION

	if (EXRHeader.compression === 'PIZ_COMPRESSION') {

		scanlineBlockSize = 32;
	}

	var numBlocks = dataWindowHeight / scanlineBlockSize;

	for (var i = 0; i < numBlocks; i++) {

		var scanlineOffset = parseUlong(bufferDataView, offset);
	}

	// we should be passed the scanline offset table, start reading pixel data

	var width = EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1;
	var height = EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1;
	var numChannels = EXRHeader.channels.length;

	var byteArray = new Float32Array(width * height * numChannels);

	var channelOffsets = {
		R: 0,
		G: 1,
		B: 2,
		A: 3
	};

	if (EXRHeader.compression === 'NO_COMPRESSION') {

		for (var y = 0; y < height; y++) {

			var y_scanline = parseUint32(bufferDataView, offset);
			var dataSize = parseUint32(bufferDataView, offset);

			for (var channelID = 0; channelID < EXRHeader.channels.length; channelID++) {

				var cOff = channelOffsets[EXRHeader.channels[channelID].name];

				if (EXRHeader.channels[channelID].pixelType === 1) {

					// HALF
					for (var x = 0; x < width; x++) {

						var val = parseFloat16(bufferDataView, offset);

						byteArray[(height - y_scanline) * (width * numChannels) + x * numChannels + cOff] = val;
					}
				} else {

					throw 'Only supported pixel format is HALF';
				}
			}
		}
	} else if (EXRHeader.compression === 'PIZ_COMPRESSION') {

		for (var scanlineBlockIdx = 0; scanlineBlockIdx < height / scanlineBlockSize; scanlineBlockIdx++) {

			var line_no = parseUint32(bufferDataView, offset);
			var data_len = parseUint32(bufferDataView, offset);

			var tmpBufferSize = width * scanlineBlockSize * (EXRHeader.channels.length * BYTES_PER_HALF);
			var tmpBuffer = new Uint16Array(tmpBufferSize);
			var tmpOffset = { value: 0 };

			decompressPIZ(tmpBuffer, tmpOffset, uInt8Array, bufferDataView, offset, tmpBufferSize, numChannels, EXRHeader.channels, width, scanlineBlockSize);

			for (var line_y = 0; line_y < scanlineBlockSize; line_y++) {

				for (var channelID = 0; channelID < EXRHeader.channels.length; channelID++) {

					var cOff = channelOffsets[EXRHeader.channels[channelID].name];

					if (EXRHeader.channels[channelID].pixelType === 1) {

						// HALF
						for (var x = 0; x < width; x++) {

							var val = decodeFloat16(tmpBuffer[channelID * (scanlineBlockSize * width) + line_y * width + x]);

							var true_y = line_y + scanlineBlockIdx * scanlineBlockSize;

							byteArray[(height - true_y) * (width * numChannels) + x * numChannels + cOff] = val;
						}
					} else {

						throw 'Only supported pixel format is HALF';
					}
				}
			}
		}
	} else {

		throw 'Cannot decompress unsupported compression';
	}

	return {
		header: EXRHeader,
		width: width,
		height: height,
		data: byteArray,
		format: THREE.RGBFormat,
		type: THREE.FloatType
	};
};

exports.default = EXRLoader;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author Kyle-Larson https://github.com/Kyle-Larson
 * @author Takahiro https://github.com/takahirox
 * @author Lewy Blue https://github.com/looeee
 *
 * Loader loads FBX file and generates Group representing FBX scene.
 * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format
 * Versions lower than this may load but will probably have errors
 *
 * Needs Support:
 *  Morph normals / blend shape normals
 *  Animation tracks for morph targets
 *
 *	Euler rotation order
 *
 * FBX format references:
 * 	https://wiki.blender.org/index.php/User:Mont29/Foundation/FBX_File_Structure
 * 	http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)
 *
 * 	Binary format specification:
 *		https://code.blender.org/2013/08/fbx-binary-file-format-specification/
 */

exports.default = function () {

	var FBXLoader = function FBXLoader(manager) {

		this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
	};

	Object.assign(FBXLoader.prototype, {

		load: function load(url, onLoad, onProgress, onError) {

			var self = this;

			var resourceDirectory = THREE.LoaderUtils.extractUrlBase(url);

			var loader = new THREE.FileLoader(this.manager);
			loader.setResponseType('arraybuffer');
			loader.load(url, function (buffer) {

				try {

					var scene = self.parse(buffer, resourceDirectory);
					onLoad(scene);
				} catch (error) {

					window.setTimeout(function () {

						if (onError) onError(error);

						self.manager.itemError(url);
					}, 0);
				}
			}, onProgress, onError);
		},

		parse: function parse(FBXBuffer, resourceDirectory) {

			var FBXTree;

			if (isFbxFormatBinary(FBXBuffer)) {

				FBXTree = new BinaryParser().parse(FBXBuffer);
			} else {

				var FBXText = convertArrayBufferToString(FBXBuffer);

				if (!isFbxFormatASCII(FBXText)) {

					throw new Error('THREE.FBXLoader: Unknown format.');
				}

				if (getFbxVersion(FBXText) < 7000) {

					throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion(FBXText));
				}

				FBXTree = new TextParser().parse(FBXText);
			}

			// console.log( FBXTree );

			var connections = parseConnections(FBXTree);
			var images = parseImages(FBXTree);
			var textures = parseTextures(FBXTree, new THREE.TextureLoader(this.manager).setPath(resourceDirectory), images, connections);
			var materials = parseMaterials(FBXTree, textures, connections);
			var deformers = parseDeformers(FBXTree, connections);
			var geometryMap = parseGeometries(FBXTree, connections, deformers);
			var sceneGraph = parseScene(FBXTree, connections, deformers.skeletons, geometryMap, materials);

			return sceneGraph;
		}

	});

	// Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
	// and details the connection type
	function parseConnections(FBXTree) {

		var connectionMap = new Map();

		if ('Connections' in FBXTree) {

			var rawConnections = FBXTree.Connections.connections;

			rawConnections.forEach(function (rawConnection) {

				var fromID = rawConnection[0];
				var toID = rawConnection[1];
				var relationship = rawConnection[2];

				if (!connectionMap.has(fromID)) {

					connectionMap.set(fromID, {
						parents: [],
						children: []
					});
				}

				var parentRelationship = { ID: toID, relationship: relationship };
				connectionMap.get(fromID).parents.push(parentRelationship);

				if (!connectionMap.has(toID)) {

					connectionMap.set(toID, {
						parents: [],
						children: []
					});
				}

				var childRelationship = { ID: fromID, relationship: relationship };
				connectionMap.get(toID).children.push(childRelationship);
			});
		}

		return connectionMap;
	}

	// Parse FBXTree.Objects.Video for embedded image data
	// These images are connected to textures in FBXTree.Objects.Textures
	// via FBXTree.Connections.
	function parseImages(FBXTree) {

		var images = {};
		var blobs = {};

		if ('Video' in FBXTree.Objects) {

			var videoNodes = FBXTree.Objects.Video;

			for (var nodeID in videoNodes) {

				var videoNode = videoNodes[nodeID];

				var id = parseInt(nodeID);

				images[id] = videoNode.RelativeFilename || videoNode.Filename;

				// raw image data is in videoNode.Content
				if ('Content' in videoNode) {

					var arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;
					var base64Content = typeof videoNode.Content === 'string' && videoNode.Content !== '';

					if (arrayBufferContent || base64Content) {

						var image = parseImage(videoNodes[nodeID]);

						blobs[videoNode.RelativeFilename || videoNode.Filename] = image;
					}
				}
			}
		}

		for (var id in images) {

			var filename = images[id];

			if (blobs[filename] !== undefined) images[id] = blobs[filename];else images[id] = images[id].split('\\').pop();
		}

		return images;
	}

	// Parse embedded image data in FBXTree.Video.Content
	function parseImage(videoNode) {

		var content = videoNode.Content;
		var fileName = videoNode.RelativeFilename || videoNode.Filename;
		var extension = fileName.slice(fileName.lastIndexOf('.') + 1).toLowerCase();

		var type;

		switch (extension) {

			case 'bmp':

				type = 'image/bmp';
				break;

			case 'jpg':
			case 'jpeg':

				type = 'image/jpeg';
				break;

			case 'png':

				type = 'image/png';
				break;

			case 'tif':

				type = 'image/tiff';
				break;

			case 'tga':

				if (typeof THREE.TGALoader !== 'function') {

					console.warn('FBXLoader: THREE.TGALoader is required to load TGA textures');
					return;
				} else {

					if (THREE.Loader.Handlers.get('.tga') === null) {

						THREE.Loader.Handlers.add(/\.tga$/i, new THREE.TGALoader());
					}

					type = 'image/tga';
					break;
				}

			default:

				console.warn('FBXLoader: Image type "' + extension + '" is not supported.');
				return;

		}

		if (typeof content === 'string') {
			// ASCII format

			return 'data:' + type + ';base64,' + content;
		} else {
			// Binary Format

			var array = new Uint8Array(content);
			return window.URL.createObjectURL(new Blob([array], { type: type }));
		}
	}

	// Parse nodes in FBXTree.Objects.Texture
	// These contain details such as UV scaling, cropping, rotation etc and are connected
	// to images in FBXTree.Objects.Video
	function parseTextures(FBXTree, loader, images, connections) {

		var textureMap = new Map();

		if ('Texture' in FBXTree.Objects) {

			var textureNodes = FBXTree.Objects.Texture;
			for (var nodeID in textureNodes) {

				var texture = parseTexture(textureNodes[nodeID], loader, images, connections);
				textureMap.set(parseInt(nodeID), texture);
			}
		}

		return textureMap;
	}

	// Parse individual node in FBXTree.Objects.Texture
	function parseTexture(textureNode, loader, images, connections) {

		var texture = loadTexture(textureNode, loader, images, connections);

		texture.ID = textureNode.id;

		texture.name = textureNode.attrName;

		var wrapModeU = textureNode.WrapModeU;
		var wrapModeV = textureNode.WrapModeV;

		var valueU = wrapModeU !== undefined ? wrapModeU.value : 0;
		var valueV = wrapModeV !== undefined ? wrapModeV.value : 0;

		// http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a
		// 0: repeat(default), 1: clamp

		texture.wrapS = valueU === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
		texture.wrapT = valueV === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;

		if ('Scaling' in textureNode) {

			var values = textureNode.Scaling.value;

			texture.repeat.x = values[0];
			texture.repeat.y = values[1];
		}

		return texture;
	}

	// load a texture specified as a blob or data URI, or via an external URL using THREE.TextureLoader
	function loadTexture(textureNode, loader, images, connections) {

		var fileName;

		var currentPath = loader.path;

		var children = connections.get(textureNode.id).children;

		if (children !== undefined && children.length > 0 && images[children[0].ID] !== undefined) {

			fileName = images[children[0].ID];

			if (fileName.indexOf('blob:') === 0 || fileName.indexOf('data:') === 0) {

				loader.setPath(undefined);
			}
		}

		var texture;

		if (textureNode.FileName.slice(-3).toLowerCase() === 'tga') {

			texture = THREE.Loader.Handlers.get('.tga').load(fileName);
		} else {

			texture = loader.load(fileName);
		}

		loader.setPath(currentPath);

		return texture;
	}

	// Parse nodes in FBXTree.Objects.Material
	function parseMaterials(FBXTree, textureMap, connections) {

		var materialMap = new Map();

		if ('Material' in FBXTree.Objects) {

			var materialNodes = FBXTree.Objects.Material;

			for (var nodeID in materialNodes) {

				var material = parseMaterial(FBXTree, materialNodes[nodeID], textureMap, connections);

				if (material !== null) materialMap.set(parseInt(nodeID), material);
			}
		}

		return materialMap;
	}

	// Parse single node in FBXTree.Objects.Material
	// Materials are connected to texture maps in FBXTree.Objects.Textures
	// FBX format currently only supports Lambert and Phong shading models
	function parseMaterial(FBXTree, materialNode, textureMap, connections) {

		var ID = materialNode.id;
		var name = materialNode.attrName;
		var type = materialNode.ShadingModel;

		//Case where FBX wraps shading model in property object.
		if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object') {

			type = type.value;
		}

		// Ignore unused materials which don't have any connections.
		if (!connections.has(ID)) return null;

		var parameters = parseParameters(FBXTree, materialNode, textureMap, ID, connections);

		var material;

		switch (type.toLowerCase()) {

			case 'phong':
				material = new THREE.MeshPhongMaterial();
				break;
			case 'lambert':
				material = new THREE.MeshLambertMaterial();
				break;
			default:
				console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', type);
				material = new THREE.MeshPhongMaterial({ color: 0x3300ff });
				break;

		}

		material.setValues(parameters);
		material.name = name;

		return material;
	}

	// Parse FBX material and return parameters suitable for a three.js material
	// Also parse the texture map and return any textures associated with the material
	function parseParameters(FBXTree, properties, textureMap, ID, connections) {

		var parameters = {};

		if (properties.BumpFactor) {

			parameters.bumpScale = properties.BumpFactor.value;
		}
		if (properties.Diffuse) {

			parameters.color = new THREE.Color().fromArray(properties.Diffuse.value);
		} else if (properties.DiffuseColor && properties.DiffuseColor.type === 'Color') {

			// The blender exporter exports diffuse here instead of in properties.Diffuse
			parameters.color = new THREE.Color().fromArray(properties.DiffuseColor.value);
		}
		if (properties.DisplacementFactor) {

			parameters.displacementScale = properties.DisplacementFactor.value;
		}
		if (properties.Emissive) {

			parameters.emissive = new THREE.Color().fromArray(properties.Emissive.value);
		} else if (properties.EmissiveColor && properties.EmissiveColor.type === 'Color') {

			// The blender exporter exports emissive color here instead of in properties.Emissive
			parameters.emissive = new THREE.Color().fromArray(properties.EmissiveColor.value);
		}
		if (properties.EmissiveFactor) {

			parameters.emissiveIntensity = parseFloat(properties.EmissiveFactor.value);
		}
		if (properties.Opacity) {

			parameters.opacity = parseFloat(properties.Opacity.value);
		}
		if (parameters.opacity < 1.0) {

			parameters.transparent = true;
		}
		if (properties.ReflectionFactor) {

			parameters.reflectivity = properties.ReflectionFactor.value;
		}
		if (properties.Shininess) {

			parameters.shininess = properties.Shininess.value;
		}
		if (properties.Specular) {

			parameters.specular = new THREE.Color().fromArray(properties.Specular.value);
		} else if (properties.SpecularColor && properties.SpecularColor.type === 'Color') {

			// The blender exporter exports specular color here instead of in properties.Specular
			parameters.specular = new THREE.Color().fromArray(properties.SpecularColor.value);
		}

		connections.get(ID).children.forEach(function (child) {

			var type = child.relationship;

			switch (type) {

				case 'Bump':
					parameters.bumpMap = textureMap.get(child.ID);
					break;

				case 'DiffuseColor':
					parameters.map = getTexture(FBXTree, textureMap, child.ID, connections);
					break;

				case 'DisplacementColor':
					parameters.displacementMap = getTexture(FBXTree, textureMap, child.ID, connections);
					break;

				case 'EmissiveColor':
					parameters.emissiveMap = getTexture(FBXTree, textureMap, child.ID, connections);
					break;

				case 'NormalMap':
					parameters.normalMap = getTexture(FBXTree, textureMap, child.ID, connections);
					break;

				case 'ReflectionColor':
					parameters.envMap = getTexture(FBXTree, textureMap, child.ID, connections);
					parameters.envMap.mapping = THREE.EquirectangularReflectionMapping;
					break;

				case 'SpecularColor':
					parameters.specularMap = getTexture(FBXTree, textureMap, child.ID, connections);
					break;

				case 'TransparentColor':
					parameters.alphaMap = getTexture(FBXTree, textureMap, child.ID, connections);
					parameters.transparent = true;
					break;

				case 'AmbientColor':
				case 'ShininessExponent': // AKA glossiness map
				case 'SpecularFactor': // AKA specularLevel
				case 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor
				default:
					console.warn('THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type);
					break;

			}
		});

		return parameters;
	}

	// get a texture from the textureMap for use by a material.
	function getTexture(FBXTree, textureMap, id, connections) {

		// if the texture is a layered texture, just use the first layer and issue a warning
		if ('LayeredTexture' in FBXTree.Objects && id in FBXTree.Objects.LayeredTexture) {

			console.warn('THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.');
			id = connections.get(id).children[0].ID;
		}

		return textureMap.get(id);
	}

	// Parse nodes in FBXTree.Objects.Deformer
	// Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
	// Generates map of Skeleton-like objects for use later when generating and binding skeletons.
	function parseDeformers(FBXTree, connections) {

		var skeletons = {};
		var morphTargets = {};

		if ('Deformer' in FBXTree.Objects) {

			var DeformerNodes = FBXTree.Objects.Deformer;

			for (var nodeID in DeformerNodes) {

				var deformerNode = DeformerNodes[nodeID];

				var relationships = connections.get(parseInt(nodeID));

				if (deformerNode.attrType === 'Skin') {

					var skeleton = parseSkeleton(relationships, DeformerNodes);
					skeleton.ID = nodeID;

					if (relationships.parents.length > 1) console.warn('THREE.FBXLoader: skeleton attached to more than one geometry is not supported.');
					skeleton.geometryID = relationships.parents[0].ID;

					skeletons[nodeID] = skeleton;
				} else if (deformerNode.attrType === 'BlendShape') {

					var morphTarget = {
						id: nodeID
					};

					morphTarget.rawTargets = parseMorphTargets(relationships, deformerNode, DeformerNodes, connections, FBXTree);
					morphTarget.id = nodeID;

					if (relationships.parents.length > 1) console.warn('THREE.FBXLoader: morph target attached to more than one geometry is not supported.');
					morphTarget.parentGeoID = relationships.parents[0].ID;

					morphTargets[nodeID] = morphTarget;
				}
			}
		}

		return {

			skeletons: skeletons,
			morphTargets: morphTargets

		};
	}

	// Parse single nodes in FBXTree.Objects.Deformer
	// The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
	// Each skin node represents a skeleton and each cluster node represents a bone
	function parseSkeleton(connections, deformerNodes) {

		var rawBones = [];

		connections.children.forEach(function (child) {

			var boneNode = deformerNodes[child.ID];

			if (boneNode.attrType !== 'Cluster') return;

			var rawBone = {

				ID: child.ID,
				indices: [],
				weights: [],
				transform: new THREE.Matrix4().fromArray(boneNode.Transform.a),
				transformLink: new THREE.Matrix4().fromArray(boneNode.TransformLink.a),
				linkMode: boneNode.Mode

			};

			if ('Indexes' in boneNode) {

				rawBone.indices = boneNode.Indexes.a;
				rawBone.weights = boneNode.Weights.a;
			}

			rawBones.push(rawBone);
		});

		return {

			rawBones: rawBones,
			bones: []

		};
	}

	// The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
	function parseMorphTargets(relationships, deformerNode, deformerNodes, connections) {

		var rawMorphTargets = [];

		for (var i = 0; i < relationships.children.length; i++) {

			if (i === 8) {

				console.warn('FBXLoader: maximum of 8 morph targets supported. Ignoring additional targets.');

				break;
			}

			var child = relationships.children[i];

			var morphTargetNode = deformerNodes[child.ID];

			var rawMorphTarget = {

				name: morphTargetNode.attrName,
				initialWeight: morphTargetNode.DeformPercent,
				id: morphTargetNode.id,
				fullWeights: morphTargetNode.FullWeights.a

			};

			if (morphTargetNode.attrType !== 'BlendShapeChannel') return;

			var targetRelationships = connections.get(parseInt(child.ID));

			targetRelationships.children.forEach(function (child) {

				if (child.relationship === 'DeformPercent') {

					// TODO: animation of morph targets is currently unsupported
					rawMorphTarget.weightCurveID = child.ID;
					// weightCurve = FBXTree.Objects.AnimationCurveNode[ weightCurveID ];
				} else {

					rawMorphTarget.geoID = child.ID;
					// morphGeo = FBXTree.Objects.Geometry[ geoID ];
				}
			});

			rawMorphTargets.push(rawMorphTarget);
		}

		return rawMorphTargets;
	}

	// Parse nodes in FBXTree.Objects.Geometry
	function parseGeometries(FBXTree, connections, deformers) {

		var geometryMap = new Map();

		if ('Geometry' in FBXTree.Objects) {

			var geoNodes = FBXTree.Objects.Geometry;

			for (var nodeID in geoNodes) {

				var relationships = connections.get(parseInt(nodeID));
				var geo = parseGeometry(FBXTree, relationships, geoNodes[nodeID], deformers);

				geometryMap.set(parseInt(nodeID), geo);
			}
		}

		return geometryMap;
	}

	// Parse single node in FBXTree.Objects.Geometry
	function parseGeometry(FBXTree, relationships, geoNode, deformers) {

		switch (geoNode.attrType) {

			case 'Mesh':
				return parseMeshGeometry(FBXTree, relationships, geoNode, deformers);
				break;

			case 'NurbsCurve':
				return parseNurbsGeometry(geoNode);
				break;

		}
	}

	// Parse single node mesh geometry in FBXTree.Objects.Geometry
	function parseMeshGeometry(FBXTree, relationships, geoNode, deformers) {

		var skeletons = deformers.skeletons;
		var morphTargets = deformers.morphTargets;

		var modelNodes = relationships.parents.map(function (parent) {

			return FBXTree.Objects.Model[parent.ID];
		});

		// don't create geometry if it is not associated with any models
		if (modelNodes.length === 0) return;

		var skeleton = relationships.children.reduce(function (skeleton, child) {

			if (skeletons[child.ID] !== undefined) skeleton = skeletons[child.ID];

			return skeleton;
		}, null);

		var morphTarget = relationships.children.reduce(function (morphTarget, child) {

			if (morphTargets[child.ID] !== undefined) morphTarget = morphTargets[child.ID];

			return morphTarget;
		}, null);

		var preTransform = new THREE.Matrix4();

		// TODO: if there is more than one model associated with the geometry, AND the models have
		// different geometric transforms, then this will cause problems
		// if ( modelNodes.length > 1 ) { }

		// For now just assume one model and get the preRotations from that
		var modelNode = modelNodes[0];

		if ('GeometricRotation' in modelNode) {

			var array = modelNode.GeometricRotation.value.map(THREE.Math.degToRad);
			array[3] = 'ZYX';

			preTransform.makeRotationFromEuler(new THREE.Euler().fromArray(array));
		}

		if ('GeometricTranslation' in modelNode) {

			preTransform.setPosition(new THREE.Vector3().fromArray(modelNode.GeometricTranslation.value));
		}

		if ('GeometricScaling' in modelNode) {

			preTransform.scale(new THREE.Vector3().fromArray(modelNode.GeometricScaling.value));
		}

		return genGeometry(FBXTree, geoNode, skeleton, morphTarget, preTransform);
	}

	// Generate a THREE.BufferGeometry from a node in FBXTree.Objects.Geometry
	function genGeometry(FBXTree, geoNode, skeleton, morphTarget, preTransform) {

		var geo = new THREE.BufferGeometry();
		if (geoNode.attrName) geo.name = geoNode.attrName;

		var geoInfo = getGeoInfo(geoNode, skeleton);

		var buffers = genBuffers(geoInfo);

		var positionAttribute = new THREE.Float32BufferAttribute(buffers.vertex, 3);

		preTransform.applyToBufferAttribute(positionAttribute);

		geo.addAttribute('position', positionAttribute);

		if (buffers.colors.length > 0) {

			geo.addAttribute('color', new THREE.Float32BufferAttribute(buffers.colors, 3));
		}

		if (skeleton) {

			geo.addAttribute('skinIndex', new THREE.Uint16BufferAttribute(buffers.weightsIndices, 4));

			geo.addAttribute('skinWeight', new THREE.Float32BufferAttribute(buffers.vertexWeights, 4));

			// used later to bind the skeleton to the model
			geo.FBX_Deformer = skeleton;
		}

		if (buffers.normal.length > 0) {

			var normalAttribute = new THREE.Float32BufferAttribute(buffers.normal, 3);

			var normalMatrix = new THREE.Matrix3().getNormalMatrix(preTransform);
			normalMatrix.applyToBufferAttribute(normalAttribute);

			geo.addAttribute('normal', normalAttribute);
		}

		buffers.uvs.forEach(function (uvBuffer, i) {

			// subsequent uv buffers are called 'uv1', 'uv2', ...
			var name = 'uv' + (i + 1).toString();

			// the first uv buffer is just called 'uv'
			if (i === 0) {

				name = 'uv';
			}

			geo.addAttribute(name, new THREE.Float32BufferAttribute(buffers.uvs[i], 2));
		});

		if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {

			// Convert the material indices of each vertex into rendering groups on the geometry.
			var prevMaterialIndex = buffers.materialIndex[0];
			var startIndex = 0;

			buffers.materialIndex.forEach(function (currentIndex, i) {

				if (currentIndex !== prevMaterialIndex) {

					geo.addGroup(startIndex, i - startIndex, prevMaterialIndex);

					prevMaterialIndex = currentIndex;
					startIndex = i;
				}
			});

			// the loop above doesn't add the last group, do that here.
			if (geo.groups.length > 0) {

				var lastGroup = geo.groups[geo.groups.length - 1];
				var lastIndex = lastGroup.start + lastGroup.count;

				if (lastIndex !== buffers.materialIndex.length) {

					geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);
				}
			}

			// case where there are multiple materials but the whole geometry is only
			// using one of them
			if (geo.groups.length === 0) {

				geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);
			}
		}

		addMorphTargets(FBXTree, geo, geoNode, morphTarget, preTransform);

		return geo;
	}

	function getGeoInfo(geoNode, skeleton) {

		var geoInfo = {};

		geoInfo.vertexPositions = geoNode.Vertices !== undefined ? geoNode.Vertices.a : [];
		geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== undefined ? geoNode.PolygonVertexIndex.a : [];

		if (geoNode.LayerElementColor) {

			geoInfo.color = getColors(geoNode.LayerElementColor[0]);
		}

		if (geoNode.LayerElementMaterial) {

			geoInfo.material = getMaterials(geoNode.LayerElementMaterial[0]);
		}

		if (geoNode.LayerElementNormal) {

			geoInfo.normal = getNormals(geoNode.LayerElementNormal[0]);
		}

		if (geoNode.LayerElementUV) {

			geoInfo.uv = [];

			var i = 0;
			while (geoNode.LayerElementUV[i]) {

				geoInfo.uv.push(getUVs(geoNode.LayerElementUV[i]));
				i++;
			}
		}

		geoInfo.weightTable = {};

		if (skeleton !== null) {

			geoInfo.skeleton = skeleton;

			skeleton.rawBones.forEach(function (rawBone, i) {

				// loop over the bone's vertex indices and weights
				rawBone.indices.forEach(function (index, j) {

					if (geoInfo.weightTable[index] === undefined) geoInfo.weightTable[index] = [];

					geoInfo.weightTable[index].push({

						id: i,
						weight: rawBone.weights[j]

					});
				});
			});
		}

		return geoInfo;
	}

	function genBuffers(geoInfo) {

		var buffers = {
			vertex: [],
			normal: [],
			colors: [],
			uvs: [],
			materialIndex: [],
			vertexWeights: [],
			weightsIndices: []
		};

		var polygonIndex = 0;
		var faceLength = 0;
		var displayedWeightsWarning = false;

		// these will hold data for a single face
		var facePositionIndexes = [];
		var faceNormals = [];
		var faceColors = [];
		var faceUVs = [];
		var faceWeights = [];
		var faceWeightIndices = [];

		geoInfo.vertexIndices.forEach(function (vertexIndex, polygonVertexIndex) {

			var endOfFace = false;

			// Face index and vertex index arrays are combined in a single array
			// A cube with quad faces looks like this:
			// PolygonVertexIndex: *24 {
			//  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5
			//  }
			// Negative numbers mark the end of a face - first face here is 0, 1, 3, -3
			// to find index of last vertex bit shift the index: ^ - 1
			if (vertexIndex < 0) {

				vertexIndex = vertexIndex ^ -1; // equivalent to ( x * -1 ) - 1
				endOfFace = true;
			}

			var weightIndices = [];
			var weights = [];

			facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);

			if (geoInfo.color) {

				var data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);

				faceColors.push(data[0], data[1], data[2]);
			}

			if (geoInfo.skeleton) {

				if (geoInfo.weightTable[vertexIndex] !== undefined) {

					geoInfo.weightTable[vertexIndex].forEach(function (wt) {

						weights.push(wt.weight);
						weightIndices.push(wt.id);
					});
				}

				if (weights.length > 4) {

					if (!displayedWeightsWarning) {

						console.warn('THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.');
						displayedWeightsWarning = true;
					}

					var wIndex = [0, 0, 0, 0];
					var Weight = [0, 0, 0, 0];

					weights.forEach(function (weight, weightIndex) {

						var currentWeight = weight;
						var currentIndex = weightIndices[weightIndex];

						Weight.forEach(function (comparedWeight, comparedWeightIndex, comparedWeightArray) {

							if (currentWeight > comparedWeight) {

								comparedWeightArray[comparedWeightIndex] = currentWeight;
								currentWeight = comparedWeight;

								var tmp = wIndex[comparedWeightIndex];
								wIndex[comparedWeightIndex] = currentIndex;
								currentIndex = tmp;
							}
						});
					});

					weightIndices = wIndex;
					weights = Weight;
				}

				// if the weight array is shorter than 4 pad with 0s
				while (weights.length < 4) {

					weights.push(0);
					weightIndices.push(0);
				}

				for (var i = 0; i < 4; ++i) {

					faceWeights.push(weights[i]);
					faceWeightIndices.push(weightIndices[i]);
				}
			}

			if (geoInfo.normal) {

				var data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);

				faceNormals.push(data[0], data[1], data[2]);
			}

			if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {

				var materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];
			}

			if (geoInfo.uv) {

				geoInfo.uv.forEach(function (uv, i) {

					var data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv);

					if (faceUVs[i] === undefined) {

						faceUVs[i] = [];
					}

					faceUVs[i].push(data[0]);
					faceUVs[i].push(data[1]);
				});
			}

			faceLength++;

			if (endOfFace) {

				genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);

				polygonIndex++;
				faceLength = 0;

				// reset arrays for the next face
				facePositionIndexes = [];
				faceNormals = [];
				faceColors = [];
				faceUVs = [];
				faceWeights = [];
				faceWeightIndices = [];
			}
		});

		return buffers;
	}

	// Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
	function genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {

		for (var i = 2; i < faceLength; i++) {

			buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]]);
			buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]]);
			buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]]);

			buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3]]);
			buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 1]]);
			buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 2]]);

			buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3]]);
			buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 1]]);
			buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 2]]);

			if (geoInfo.skeleton) {

				buffers.vertexWeights.push(faceWeights[0]);
				buffers.vertexWeights.push(faceWeights[1]);
				buffers.vertexWeights.push(faceWeights[2]);
				buffers.vertexWeights.push(faceWeights[3]);

				buffers.vertexWeights.push(faceWeights[(i - 1) * 4]);
				buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 1]);
				buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 2]);
				buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 3]);

				buffers.vertexWeights.push(faceWeights[i * 4]);
				buffers.vertexWeights.push(faceWeights[i * 4 + 1]);
				buffers.vertexWeights.push(faceWeights[i * 4 + 2]);
				buffers.vertexWeights.push(faceWeights[i * 4 + 3]);

				buffers.weightsIndices.push(faceWeightIndices[0]);
				buffers.weightsIndices.push(faceWeightIndices[1]);
				buffers.weightsIndices.push(faceWeightIndices[2]);
				buffers.weightsIndices.push(faceWeightIndices[3]);

				buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4]);
				buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 1]);
				buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 2]);
				buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 3]);

				buffers.weightsIndices.push(faceWeightIndices[i * 4]);
				buffers.weightsIndices.push(faceWeightIndices[i * 4 + 1]);
				buffers.weightsIndices.push(faceWeightIndices[i * 4 + 2]);
				buffers.weightsIndices.push(faceWeightIndices[i * 4 + 3]);
			}

			if (geoInfo.color) {

				buffers.colors.push(faceColors[0]);
				buffers.colors.push(faceColors[1]);
				buffers.colors.push(faceColors[2]);

				buffers.colors.push(faceColors[(i - 1) * 3]);
				buffers.colors.push(faceColors[(i - 1) * 3 + 1]);
				buffers.colors.push(faceColors[(i - 1) * 3 + 2]);

				buffers.colors.push(faceColors[i * 3]);
				buffers.colors.push(faceColors[i * 3 + 1]);
				buffers.colors.push(faceColors[i * 3 + 2]);
			}

			if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {

				buffers.materialIndex.push(materialIndex);
				buffers.materialIndex.push(materialIndex);
				buffers.materialIndex.push(materialIndex);
			}

			if (geoInfo.normal) {

				buffers.normal.push(faceNormals[0]);
				buffers.normal.push(faceNormals[1]);
				buffers.normal.push(faceNormals[2]);

				buffers.normal.push(faceNormals[(i - 1) * 3]);
				buffers.normal.push(faceNormals[(i - 1) * 3 + 1]);
				buffers.normal.push(faceNormals[(i - 1) * 3 + 2]);

				buffers.normal.push(faceNormals[i * 3]);
				buffers.normal.push(faceNormals[i * 3 + 1]);
				buffers.normal.push(faceNormals[i * 3 + 2]);
			}

			if (geoInfo.uv) {

				geoInfo.uv.forEach(function (uv, j) {

					if (buffers.uvs[j] === undefined) buffers.uvs[j] = [];

					buffers.uvs[j].push(faceUVs[j][0]);
					buffers.uvs[j].push(faceUVs[j][1]);

					buffers.uvs[j].push(faceUVs[j][(i - 1) * 2]);
					buffers.uvs[j].push(faceUVs[j][(i - 1) * 2 + 1]);

					buffers.uvs[j].push(faceUVs[j][i * 2]);
					buffers.uvs[j].push(faceUVs[j][i * 2 + 1]);
				});
			}
		}
	}

	function addMorphTargets(FBXTree, parentGeo, parentGeoNode, morphTarget, preTransform) {

		if (morphTarget === null) return;

		parentGeo.morphAttributes.position = [];
		parentGeo.morphAttributes.normal = [];

		morphTarget.rawTargets.forEach(function (rawTarget) {

			var morphGeoNode = FBXTree.Objects.Geometry[rawTarget.geoID];

			if (morphGeoNode !== undefined) {

				genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform);
			}
		});
	}

	// a morph geometry node is similar to a standard  node, and the node is also contained
	// in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
	// and a special attribute Index defining which vertices of the original geometry are affected
	// Normal and position attributes only have data for the vertices that are affected by the morph
	function genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform) {

		var morphGeo = new THREE.BufferGeometry();
		if (morphGeoNode.attrName) morphGeo.name = morphGeoNode.attrName;

		var vertexIndices = parentGeoNode.PolygonVertexIndex !== undefined ? parentGeoNode.PolygonVertexIndex.a : [];

		// make a copy of the parent's vertex positions
		var vertexPositions = parentGeoNode.Vertices !== undefined ? parentGeoNode.Vertices.a.slice() : [];

		var morphPositions = morphGeoNode.Vertices !== undefined ? morphGeoNode.Vertices.a : [];
		var indices = morphGeoNode.Indexes !== undefined ? morphGeoNode.Indexes.a : [];

		for (var i = 0; i < indices.length; i++) {

			var morphIndex = indices[i] * 3;

			// FBX format uses blend shapes rather than morph targets. This can be converted
			// by additively combining the blend shape positions with the original geometry's positions
			vertexPositions[morphIndex] += morphPositions[i * 3];
			vertexPositions[morphIndex + 1] += morphPositions[i * 3 + 1];
			vertexPositions[morphIndex + 2] += morphPositions[i * 3 + 2];
		}

		// TODO: add morph normal support
		var morphGeoInfo = {
			vertexIndices: vertexIndices,
			vertexPositions: vertexPositions
		};

		var morphBuffers = genBuffers(morphGeoInfo);

		var positionAttribute = new THREE.Float32BufferAttribute(morphBuffers.vertex, 3);
		positionAttribute.name = morphGeoNode.attrName;

		preTransform.applyToBufferAttribute(positionAttribute);

		parentGeo.morphAttributes.position.push(positionAttribute);
	}

	// Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
	function getNormals(NormalNode) {

		var mappingType = NormalNode.MappingInformationType;
		var referenceType = NormalNode.ReferenceInformationType;
		var buffer = NormalNode.Normals.a;
		var indexBuffer = [];
		if (referenceType === 'IndexToDirect') {

			if ('NormalIndex' in NormalNode) {

				indexBuffer = NormalNode.NormalIndex.a;
			} else if ('NormalsIndex' in NormalNode) {

				indexBuffer = NormalNode.NormalsIndex.a;
			}
		}

		return {
			dataSize: 3,
			buffer: buffer,
			indices: indexBuffer,
			mappingType: mappingType,
			referenceType: referenceType
		};
	}

	// Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
	function getUVs(UVNode) {

		var mappingType = UVNode.MappingInformationType;
		var referenceType = UVNode.ReferenceInformationType;
		var buffer = UVNode.UV.a;
		var indexBuffer = [];
		if (referenceType === 'IndexToDirect') {

			indexBuffer = UVNode.UVIndex.a;
		}

		return {
			dataSize: 2,
			buffer: buffer,
			indices: indexBuffer,
			mappingType: mappingType,
			referenceType: referenceType
		};
	}

	// Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
	function getColors(ColorNode) {

		var mappingType = ColorNode.MappingInformationType;
		var referenceType = ColorNode.ReferenceInformationType;
		var buffer = ColorNode.Colors.a;
		var indexBuffer = [];
		if (referenceType === 'IndexToDirect') {

			indexBuffer = ColorNode.ColorIndex.a;
		}

		return {
			dataSize: 4,
			buffer: buffer,
			indices: indexBuffer,
			mappingType: mappingType,
			referenceType: referenceType
		};
	}

	// Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
	function getMaterials(MaterialNode) {

		var mappingType = MaterialNode.MappingInformationType;
		var referenceType = MaterialNode.ReferenceInformationType;

		if (mappingType === 'NoMappingInformation') {

			return {
				dataSize: 1,
				buffer: [0],
				indices: [0],
				mappingType: 'AllSame',
				referenceType: referenceType
			};
		}

		var materialIndexBuffer = MaterialNode.Materials.a;

		// Since materials are stored as indices, there's a bit of a mismatch between FBX and what
		// we expect.So we create an intermediate buffer that points to the index in the buffer,
		// for conforming with the other functions we've written for other data.
		var materialIndices = [];

		for (var i = 0; i < materialIndexBuffer.length; ++i) {

			materialIndices.push(i);
		}

		return {
			dataSize: 1,
			buffer: materialIndexBuffer,
			indices: materialIndices,
			mappingType: mappingType,
			referenceType: referenceType
		};
	}

	var dataArray = [];

	function getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {

		var index;

		switch (infoObject.mappingType) {

			case 'ByPolygonVertex':
				index = polygonVertexIndex;
				break;
			case 'ByPolygon':
				index = polygonIndex;
				break;
			case 'ByVertice':
				index = vertexIndex;
				break;
			case 'AllSame':
				index = infoObject.indices[0];
				break;
			default:
				console.warn('THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType);

		}

		if (infoObject.referenceType === 'IndexToDirect') index = infoObject.indices[index];

		var from = index * infoObject.dataSize;
		var to = from + infoObject.dataSize;

		return slice(dataArray, infoObject.buffer, from, to);
	}

	// Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
	function parseNurbsGeometry(geoNode) {

		if (THREE.NURBSCurve === undefined) {

			console.error('THREE.FBXLoader: The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.');
			return new THREE.BufferGeometry();
		}

		var order = parseInt(geoNode.Order);

		if (isNaN(order)) {

			console.error('THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id);
			return new THREE.BufferGeometry();
		}

		var degree = order - 1;

		var knots = geoNode.KnotVector.a;
		var controlPoints = [];
		var pointsValues = geoNode.Points.a;

		for (var i = 0, l = pointsValues.length; i < l; i += 4) {

			controlPoints.push(new THREE.Vector4().fromArray(pointsValues, i));
		}

		var startKnot, endKnot;

		if (geoNode.Form === 'Closed') {

			controlPoints.push(controlPoints[0]);
		} else if (geoNode.Form === 'Periodic') {

			startKnot = degree;
			endKnot = knots.length - 1 - startKnot;

			for (var i = 0; i < degree; ++i) {

				controlPoints.push(controlPoints[i]);
			}
		}

		var curve = new THREE.NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);
		var vertices = curve.getPoints(controlPoints.length * 7);

		var positions = new Float32Array(vertices.length * 3);

		vertices.forEach(function (vertex, i) {

			vertex.toArray(positions, i * 3);
		});

		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));

		return geometry;
	}

	// create the main THREE.Group() to be returned by the loader
	function parseScene(FBXTree, connections, skeletons, geometryMap, materialMap) {

		var sceneGraph = new THREE.Group();

		var modelMap = parseModels(FBXTree, skeletons, geometryMap, materialMap, connections);

		var modelNodes = FBXTree.Objects.Model;

		modelMap.forEach(function (model) {

			var modelNode = modelNodes[model.ID];
			setLookAtProperties(FBXTree, model, modelNode, connections, sceneGraph);

			var parentConnections = connections.get(model.ID).parents;

			parentConnections.forEach(function (connection) {

				var parent = modelMap.get(connection.ID);
				if (parent !== undefined) parent.add(model);
			});

			if (model.parent === null) {

				sceneGraph.add(model);
			}
		});

		bindSkeleton(FBXTree, skeletons, geometryMap, modelMap, connections);

		addAnimations(FBXTree, connections, sceneGraph);

		createAmbientLight(FBXTree, sceneGraph);

		return sceneGraph;
	}

	// parse nodes in FBXTree.Objects.Model
	function parseModels(FBXTree, skeletons, geometryMap, materialMap, connections) {

		var modelMap = new Map();
		var modelNodes = FBXTree.Objects.Model;

		for (var nodeID in modelNodes) {

			var id = parseInt(nodeID);
			var node = modelNodes[nodeID];
			var relationships = connections.get(id);

			var model = buildSkeleton(relationships, skeletons, id, node.attrName);

			if (!model) {

				switch (node.attrType) {

					case 'Camera':
						model = createCamera(FBXTree, relationships);
						break;
					case 'Light':
						model = createLight(FBXTree, relationships);
						break;
					case 'Mesh':
						model = createMesh(FBXTree, relationships, geometryMap, materialMap);
						break;
					case 'NurbsCurve':
						model = createCurve(relationships, geometryMap);
						break;
					case 'LimbNode': // usually associated with a Bone, however if a Bone was not created we'll make a Group instead
					case 'Null':
					default:
						model = new THREE.Group();
						break;

				}

				model.name = THREE.PropertyBinding.sanitizeNodeName(node.attrName);
				model.ID = id;
			}

			setModelTransforms(FBXTree, model, node);
			modelMap.set(id, model);
		}

		return modelMap;
	}

	function buildSkeleton(relationships, skeletons, id, name) {

		var bone = null;

		relationships.parents.forEach(function (parent) {

			for (var ID in skeletons) {

				var skeleton = skeletons[ID];

				skeleton.rawBones.forEach(function (rawBone, i) {

					if (rawBone.ID === parent.ID) {

						var subBone = bone;
						bone = new THREE.Bone();
						bone.matrixWorld.copy(rawBone.transformLink);

						// set name and id here - otherwise in cases where "subBone" is created it will not have a name / id
						bone.name = THREE.PropertyBinding.sanitizeNodeName(name);
						bone.ID = id;

						skeleton.bones[i] = bone;

						// In cases where a bone is shared between multiple meshes
						// duplicate the bone here and and it as a child of the first bone
						if (subBone !== null) {

							bone.add(subBone);
						}
					}
				});
			}
		});

		return bone;
	}

	// create a THREE.PerspectiveCamera or THREE.OrthographicCamera
	function createCamera(FBXTree, relationships) {

		var model;
		var cameraAttribute;

		relationships.children.forEach(function (child) {

			var attr = FBXTree.Objects.NodeAttribute[child.ID];

			if (attr !== undefined) {

				cameraAttribute = attr;
			}
		});

		if (cameraAttribute === undefined) {

			model = new THREE.Object3D();
		} else {

			var type = 0;
			if (cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1) {

				type = 1;
			}

			var nearClippingPlane = 1;
			if (cameraAttribute.NearPlane !== undefined) {

				nearClippingPlane = cameraAttribute.NearPlane.value / 1000;
			}

			var farClippingPlane = 1000;
			if (cameraAttribute.FarPlane !== undefined) {

				farClippingPlane = cameraAttribute.FarPlane.value / 1000;
			}

			var width = window.innerWidth;
			var height = window.innerHeight;

			if (cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined) {

				width = cameraAttribute.AspectWidth.value;
				height = cameraAttribute.AspectHeight.value;
			}

			var aspect = width / height;

			var fov = 45;
			if (cameraAttribute.FieldOfView !== undefined) {

				fov = cameraAttribute.FieldOfView.value;
			}

			var focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;

			switch (type) {

				case 0:
					// Perspective
					model = new THREE.PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane);
					if (focalLength !== null) model.setFocalLength(focalLength);
					break;

				case 1:
					// Orthographic
					model = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, nearClippingPlane, farClippingPlane);
					break;

				default:
					console.warn('THREE.FBXLoader: Unknown camera type ' + type + '.');
					model = new THREE.Object3D();
					break;

			}
		}

		return model;
	}

	// Create a THREE.DirectionalLight, THREE.PointLight or THREE.SpotLight
	function createLight(FBXTree, relationships) {

		var model;
		var lightAttribute;

		relationships.children.forEach(function (child) {

			var attr = FBXTree.Objects.NodeAttribute[child.ID];

			if (attr !== undefined) {

				lightAttribute = attr;
			}
		});

		if (lightAttribute === undefined) {

			model = new THREE.Object3D();
		} else {

			var type;

			// LightType can be undefined for Point lights
			if (lightAttribute.LightType === undefined) {

				type = 0;
			} else {

				type = lightAttribute.LightType.value;
			}

			var color = 0xffffff;

			if (lightAttribute.Color !== undefined) {

				color = new THREE.Color().fromArray(lightAttribute.Color.value);
			}

			var intensity = lightAttribute.Intensity === undefined ? 1 : lightAttribute.Intensity.value / 100;

			// light disabled
			if (lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0) {

				intensity = 0;
			}

			var distance = 0;
			if (lightAttribute.FarAttenuationEnd !== undefined) {

				if (lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0) {

					distance = 0;
				} else {

					distance = lightAttribute.FarAttenuationEnd.value;
				}
			}

			// TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?
			var decay = 1;

			switch (type) {

				case 0:
					// Point
					model = new THREE.PointLight(color, intensity, distance, decay);
					break;

				case 1:
					// Directional
					model = new THREE.DirectionalLight(color, intensity);
					break;

				case 2:
					// Spot
					var angle = Math.PI / 3;

					if (lightAttribute.InnerAngle !== undefined) {

						angle = THREE.Math.degToRad(lightAttribute.InnerAngle.value);
					}

					var penumbra = 0;
					if (lightAttribute.OuterAngle !== undefined) {

						// TODO: this is not correct - FBX calculates outer and inner angle in degrees
						// with OuterAngle > InnerAngle && OuterAngle <= Math.PI
						// while three.js uses a penumbra between (0, 1) to attenuate the inner angle
						penumbra = THREE.Math.degToRad(lightAttribute.OuterAngle.value);
						penumbra = Math.max(penumbra, 1);
					}

					model = new THREE.SpotLight(color, intensity, distance, angle, penumbra, decay);
					break;

				default:
					console.warn('THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a THREE.PointLight.');
					model = new THREE.PointLight(color, intensity);
					break;

			}

			if (lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1) {

				model.castShadow = true;
			}
		}

		return model;
	}

	function createMesh(FBXTree, relationships, geometryMap, materialMap) {

		var model;
		var geometry = null;
		var material = null;
		var materials = [];

		// get geometry and materials(s) from connections
		relationships.children.forEach(function (child) {

			if (geometryMap.has(child.ID)) {

				geometry = geometryMap.get(child.ID);
			}

			if (materialMap.has(child.ID)) {

				materials.push(materialMap.get(child.ID));
			}
		});

		if (materials.length > 1) {

			material = materials;
		} else if (materials.length > 0) {

			material = materials[0];
		} else {

			material = new THREE.MeshPhongMaterial({ color: 0xcccccc });
			materials.push(material);
		}

		if ('color' in geometry.attributes) {

			materials.forEach(function (material) {

				material.vertexColors = THREE.VertexColors;
			});
		}

		if (geometry.FBX_Deformer) {

			materials.forEach(function (material) {

				material.skinning = true;
			});

			model = new THREE.SkinnedMesh(geometry, material);
		} else {

			model = new THREE.Mesh(geometry, material);
		}

		return model;
	}

	function createCurve(relationships, geometryMap) {

		var geometry = relationships.children.reduce(function (geo, child) {

			if (geometryMap.has(child.ID)) geo = geometryMap.get(child.ID);

			return geo;
		}, null);

		// FBX does not list materials for Nurbs lines, so we'll just put our own in here.
		var material = new THREE.LineBasicMaterial({ color: 0x3300ff, linewidth: 1 });
		return new THREE.Line(geometry, material);
	}

	// Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light
	function createAmbientLight(FBXTree, sceneGraph) {

		if ('GlobalSettings' in FBXTree && 'AmbientColor' in FBXTree.GlobalSettings) {

			var ambientColor = FBXTree.GlobalSettings.AmbientColor.value;
			var r = ambientColor[0];
			var g = ambientColor[1];
			var b = ambientColor[2];

			if (r !== 0 || g !== 0 || b !== 0) {

				var color = new THREE.Color(r, g, b);
				sceneGraph.add(new THREE.AmbientLight(color, 1));
			}
		}
	}

	function setLookAtProperties(FBXTree, model, modelNode, connections, sceneGraph) {

		if ('LookAtProperty' in modelNode) {

			var children = connections.get(model.ID).children;

			children.forEach(function (child) {

				if (child.relationship === 'LookAtProperty') {

					var lookAtTarget = FBXTree.Objects.Model[child.ID];

					if ('Lcl_Translation' in lookAtTarget) {

						var pos = lookAtTarget.Lcl_Translation.value;

						// DirectionalLight, SpotLight
						if (model.target !== undefined) {

							model.target.position.fromArray(pos);
							sceneGraph.add(model.target);
						} else {
							// Cameras and other Object3Ds

							model.lookAt(new THREE.Vector3().fromArray(pos));
						}
					}
				}
			});
		}
	}

	// parse the model node for transform details and apply them to the model
	function setModelTransforms(FBXTree, model, modelNode) {

		// http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html
		if ('RotationOrder' in modelNode) {

			var enums = ['XYZ', // default
			'XZY', 'YZX', 'ZXY', 'YXZ', 'ZYX', 'SphericXYZ'];

			var value = parseInt(modelNode.RotationOrder.value, 10);

			if (value > 0 && value < 6) {

				// model.rotation.order = enums[ value ];

				// Note: Euler order other than XYZ is currently not supported, so just display a warning for now
				console.warn('THREE.FBXLoader: unsupported Euler Order: %s. Currently only XYZ order is supported. Animations and rotations may be incorrect.', enums[value]);
			} else if (value === 6) {

				console.warn('THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.');
			}
		}

		if ('Lcl_Translation' in modelNode) {

			model.position.fromArray(modelNode.Lcl_Translation.value);
		}

		if ('Lcl_Rotation' in modelNode) {

			var rotation = modelNode.Lcl_Rotation.value.map(THREE.Math.degToRad);
			rotation.push('ZYX');
			model.quaternion.setFromEuler(new THREE.Euler().fromArray(rotation));
		}

		if ('Lcl_Scaling' in modelNode) {

			model.scale.fromArray(modelNode.Lcl_Scaling.value);
		}

		if ('PreRotation' in modelNode) {

			var array = modelNode.PreRotation.value.map(THREE.Math.degToRad);
			array[3] = 'ZYX';

			var preRotations = new THREE.Euler().fromArray(array);

			preRotations = new THREE.Quaternion().setFromEuler(preRotations);
			model.quaternion.premultiply(preRotations);
		}
	}

	function bindSkeleton(FBXTree, skeletons, geometryMap, modelMap, connections) {

		var bindMatrices = parsePoseNodes(FBXTree);

		for (var ID in skeletons) {

			var skeleton = skeletons[ID];

			var parents = connections.get(parseInt(skeleton.ID)).parents;

			parents.forEach(function (parent) {

				if (geometryMap.has(parent.ID)) {

					var geoID = parent.ID;
					var geoRelationships = connections.get(geoID);

					geoRelationships.parents.forEach(function (geoConnParent) {

						if (modelMap.has(geoConnParent.ID)) {

							var model = modelMap.get(geoConnParent.ID);

							model.bind(new THREE.Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID]);
						}
					});
				}
			});
		}
	}

	function parsePoseNodes(FBXTree) {

		var bindMatrices = {};

		if ('Pose' in FBXTree.Objects) {

			var BindPoseNode = FBXTree.Objects.Pose;

			for (var nodeID in BindPoseNode) {

				if (BindPoseNode[nodeID].attrType === 'BindPose') {

					var poseNodes = BindPoseNode[nodeID].PoseNode;

					if (Array.isArray(poseNodes)) {

						poseNodes.forEach(function (poseNode) {

							bindMatrices[poseNode.Node] = new THREE.Matrix4().fromArray(poseNode.Matrix.a);
						});
					} else {

						bindMatrices[poseNodes.Node] = new THREE.Matrix4().fromArray(poseNodes.Matrix.a);
					}
				}
			}
		}

		return bindMatrices;
	}

	function parseAnimations(FBXTree, connections) {

		// since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,
		// if this is undefined we can safely assume there are no animations
		if (FBXTree.Objects.AnimationCurve === undefined) return undefined;

		var curveNodesMap = parseAnimationCurveNodes(FBXTree);

		parseAnimationCurves(FBXTree, connections, curveNodesMap);

		var layersMap = parseAnimationLayers(FBXTree, connections, curveNodesMap);
		var rawClips = parseAnimStacks(FBXTree, connections, layersMap);

		return rawClips;
	}

	// parse nodes in FBXTree.Objects.AnimationCurveNode
	// each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
	// and is referenced by an AnimationLayer
	function parseAnimationCurveNodes(FBXTree) {

		var rawCurveNodes = FBXTree.Objects.AnimationCurveNode;

		var curveNodesMap = new Map();

		for (var nodeID in rawCurveNodes) {

			var rawCurveNode = rawCurveNodes[nodeID];

			if (rawCurveNode.attrName.match(/S|R|T/) !== null) {

				var curveNode = {

					id: rawCurveNode.id,
					attr: rawCurveNode.attrName,
					curves: {}

				};

				curveNodesMap.set(curveNode.id, curveNode);
			}
		}

		return curveNodesMap;
	}

	// parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
	// previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
	// axis ( e.g. times and values of x rotation)
	function parseAnimationCurves(FBXTree, connections, curveNodesMap) {

		var rawCurves = FBXTree.Objects.AnimationCurve;

		for (var nodeID in rawCurves) {

			var animationCurve = {

				id: rawCurves[nodeID].id,
				times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),
				values: rawCurves[nodeID].KeyValueFloat.a

			};

			var relationships = connections.get(animationCurve.id);

			if (relationships !== undefined) {

				var animationCurveID = relationships.parents[0].ID;
				var animationCurveRelationship = relationships.parents[0].relationship;

				if (animationCurveRelationship.match(/X/)) {

					curveNodesMap.get(animationCurveID).curves['x'] = animationCurve;
				} else if (animationCurveRelationship.match(/Y/)) {

					curveNodesMap.get(animationCurveID).curves['y'] = animationCurve;
				} else if (animationCurveRelationship.match(/Z/)) {

					curveNodesMap.get(animationCurveID).curves['z'] = animationCurve;
				}
			}
		}
	}

	// parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
	// to various AnimationCurveNodes and is referenced by an AnimationStack node
	// note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
	function parseAnimationLayers(FBXTree, connections, curveNodesMap) {

		var rawLayers = FBXTree.Objects.AnimationLayer;

		var layersMap = new Map();

		for (var nodeID in rawLayers) {

			var layerCurveNodes = [];

			var connection = connections.get(parseInt(nodeID));

			if (connection !== undefined) {

				// all the animationCurveNodes used in the layer
				var children = connection.children;

				children.forEach(function (child, i) {

					if (curveNodesMap.has(child.ID)) {

						var curveNode = curveNodesMap.get(child.ID);

						// check that the curves are defined for at least one axis, otherwise ignore the curveNode
						if (curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined) {

							if (layerCurveNodes[i] === undefined) {

								var modelID;

								connections.get(child.ID).parents.forEach(function (parent) {

									if (parent.relationship !== undefined) modelID = parent.ID;
								});

								var rawModel = FBXTree.Objects.Model[modelID.toString()];

								var node = {

									modelName: THREE.PropertyBinding.sanitizeNodeName(rawModel.attrName),
									initialPosition: [0, 0, 0],
									initialRotation: [0, 0, 0],
									initialScale: [1, 1, 1]

								};

								if ('Lcl_Translation' in rawModel) node.initialPosition = rawModel.Lcl_Translation.value;

								if ('Lcl_Rotation' in rawModel) node.initialRotation = rawModel.Lcl_Rotation.value;

								if ('Lcl_Scaling' in rawModel) node.initialScale = rawModel.Lcl_Scaling.value;

								// if the animated model is pre rotated, we'll have to apply the pre rotations to every
								// animation value as well
								if ('PreRotation' in rawModel) node.preRotations = rawModel.PreRotation.value;

								layerCurveNodes[i] = node;
							}

							layerCurveNodes[i][curveNode.attr] = curveNode;
						}
					}
				});

				layersMap.set(parseInt(nodeID), layerCurveNodes);
			}
		}

		return layersMap;
	}

	// parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
	// hierarchy. Each Stack node will be used to create a THREE.AnimationClip
	function parseAnimStacks(FBXTree, connections, layersMap) {

		var rawStacks = FBXTree.Objects.AnimationStack;

		// connect the stacks (clips) up to the layers
		var rawClips = {};

		for (var nodeID in rawStacks) {

			var children = connections.get(parseInt(nodeID)).children;

			if (children.length > 1) {

				// it seems like stacks will always be associated with a single layer. But just in case there are files
				// where there are multiple layers per stack, we'll display a warning
				console.warn('THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.');
			}

			var layer = layersMap.get(children[0].ID);

			rawClips[nodeID] = {

				name: rawStacks[nodeID].attrName,
				layer: layer

			};
		}

		return rawClips;
	}

	// take raw animation data from parseAnimations and connect it up to the loaded models
	function addAnimations(FBXTree, connections, sceneGraph) {

		sceneGraph.animations = [];

		var rawClips = parseAnimations(FBXTree, connections);

		if (rawClips === undefined) return;

		for (var key in rawClips) {

			var rawClip = rawClips[key];

			var clip = addClip(rawClip);

			sceneGraph.animations.push(clip);
		}
	}

	function addClip(rawClip) {

		var tracks = [];

		rawClip.layer.forEach(function (rawTracks) {

			tracks = tracks.concat(generateTracks(rawTracks));
		});

		return new THREE.AnimationClip(rawClip.name, -1, tracks);
	}

	function generateTracks(rawTracks) {

		var tracks = [];

		if (rawTracks.T !== undefined && Object.keys(rawTracks.T.curves).length > 0) {

			var positionTrack = generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, rawTracks.initialPosition, 'position');
			if (positionTrack !== undefined) tracks.push(positionTrack);
		}

		if (rawTracks.R !== undefined && Object.keys(rawTracks.R.curves).length > 0) {

			var rotationTrack = generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, rawTracks.initialRotation, rawTracks.preRotations);
			if (rotationTrack !== undefined) tracks.push(rotationTrack);
		}

		if (rawTracks.S !== undefined && Object.keys(rawTracks.S.curves).length > 0) {

			var scaleTrack = generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, rawTracks.initialScale, 'scale');
			if (scaleTrack !== undefined) tracks.push(scaleTrack);
		}

		return tracks;
	}

	function generateVectorTrack(modelName, curves, initialValue, type) {

		var times = getTimesForAllAxes(curves);
		var values = getKeyframeTrackValues(times, curves, initialValue);

		return new THREE.VectorKeyframeTrack(modelName + '.' + type, times, values);
	}

	function generateRotationTrack(modelName, curves, initialValue, preRotations) {

		if (curves.x !== undefined) {

			interpolateRotations(curves.x);
			curves.x.values = curves.x.values.map(THREE.Math.degToRad);
		}
		if (curves.y !== undefined) {

			interpolateRotations(curves.y);
			curves.y.values = curves.y.values.map(THREE.Math.degToRad);
		}
		if (curves.z !== undefined) {

			interpolateRotations(curves.z);
			curves.z.values = curves.z.values.map(THREE.Math.degToRad);
		}

		var times = getTimesForAllAxes(curves);
		var values = getKeyframeTrackValues(times, curves, initialValue);

		if (preRotations !== undefined) {

			preRotations = preRotations.map(THREE.Math.degToRad);
			preRotations.push('ZYX');

			preRotations = new THREE.Euler().fromArray(preRotations);
			preRotations = new THREE.Quaternion().setFromEuler(preRotations);
		}

		var quaternion = new THREE.Quaternion();
		var euler = new THREE.Euler();

		var quaternionValues = [];

		for (var i = 0; i < values.length; i += 3) {

			euler.set(values[i], values[i + 1], values[i + 2], 'ZYX');

			quaternion.setFromEuler(euler);

			if (preRotations !== undefined) quaternion.premultiply(preRotations);

			quaternion.toArray(quaternionValues, i / 3 * 4);
		}

		return new THREE.QuaternionKeyframeTrack(modelName + '.quaternion', times, quaternionValues);
	}

	function getKeyframeTrackValues(times, curves, initialValue) {

		var prevValue = initialValue;

		var values = [];

		var xIndex = -1;
		var yIndex = -1;
		var zIndex = -1;

		times.forEach(function (time) {

			if (curves.x) xIndex = curves.x.times.indexOf(time);
			if (curves.y) yIndex = curves.y.times.indexOf(time);
			if (curves.z) zIndex = curves.z.times.indexOf(time);

			// if there is an x value defined for this frame, use that
			if (xIndex !== -1) {

				var xValue = curves.x.values[xIndex];
				values.push(xValue);
				prevValue[0] = xValue;
			} else {

				// otherwise use the x value from the previous frame
				values.push(prevValue[0]);
			}

			if (yIndex !== -1) {

				var yValue = curves.y.values[yIndex];
				values.push(yValue);
				prevValue[1] = yValue;
			} else {

				values.push(prevValue[1]);
			}

			if (zIndex !== -1) {

				var zValue = curves.z.values[zIndex];
				values.push(zValue);
				prevValue[2] = zValue;
			} else {

				values.push(prevValue[2]);
			}
		});

		return values;
	}

	// For all animated objects, times are defined separately for each axis
	// Here we'll combine the times into one sorted array without duplicates
	function getTimesForAllAxes(curves) {

		var times = [];

		// first join together the times for each axis, if defined
		if (curves.x !== undefined) times = times.concat(curves.x.times);
		if (curves.y !== undefined) times = times.concat(curves.y.times);
		if (curves.z !== undefined) times = times.concat(curves.z.times);

		// then sort them and remove duplicates
		times = times.sort(function (a, b) {

			return a - b;
		}).filter(function (elem, index, array) {

			return array.indexOf(elem) == index;
		});

		return times;
	}

	// Rotations are defined as Euler angles which can have values  of any size
	// These will be converted to quaternions which don't support values greater than
	// PI, so we'll interpolate large rotations
	function interpolateRotations(curve) {

		for (var i = 1; i < curve.values.length; i++) {

			var initialValue = curve.values[i - 1];
			var valuesSpan = curve.values[i] - initialValue;

			var absoluteSpan = Math.abs(valuesSpan);

			if (absoluteSpan >= 180) {

				var numSubIntervals = absoluteSpan / 180;

				var step = valuesSpan / numSubIntervals;
				var nextValue = initialValue + step;

				var initialTime = curve.times[i - 1];
				var timeSpan = curve.times[i] - initialTime;
				var interval = timeSpan / numSubIntervals;
				var nextTime = initialTime + interval;

				var interpolatedTimes = [];
				var interpolatedValues = [];

				while (nextTime < curve.times[i]) {

					interpolatedTimes.push(nextTime);
					nextTime += interval;

					interpolatedValues.push(nextValue);
					nextValue += step;
				}

				curve.times = inject(curve.times, i, interpolatedTimes);
				curve.values = inject(curve.values, i, interpolatedValues);
			}
		}
	}

	// parse an FBX file in ASCII format
	function TextParser() {}

	Object.assign(TextParser.prototype, {

		getPrevNode: function getPrevNode() {

			return this.nodeStack[this.currentIndent - 2];
		},

		getCurrentNode: function getCurrentNode() {

			return this.nodeStack[this.currentIndent - 1];
		},

		getCurrentProp: function getCurrentProp() {

			return this.currentProp;
		},

		pushStack: function pushStack(node) {

			this.nodeStack.push(node);
			this.currentIndent += 1;
		},

		popStack: function popStack() {

			this.nodeStack.pop();
			this.currentIndent -= 1;
		},

		setCurrentProp: function setCurrentProp(val, name) {

			this.currentProp = val;
			this.currentPropName = name;
		},

		parse: function parse(text) {

			this.currentIndent = 0;
			this.allNodes = new FBXTree();
			this.nodeStack = [];
			this.currentProp = [];
			this.currentPropName = '';

			var self = this;

			var split = text.split('\n');

			split.forEach(function (line, i) {

				var matchComment = line.match(/^[\s\t]*;/);
				var matchEmpty = line.match(/^[\s\t]*$/);

				if (matchComment || matchEmpty) return;

				var matchBeginning = line.match('^\\t{' + self.currentIndent + '}(\\w+):(.*){', '');
				var matchProperty = line.match('^\\t{' + self.currentIndent + '}(\\w+):[\\s\\t\\r\\n](.*)');
				var matchEnd = line.match('^\\t{' + (self.currentIndent - 1) + '}}');

				if (matchBeginning) {

					self.parseNodeBegin(line, matchBeginning);
				} else if (matchProperty) {

					self.parseNodeProperty(line, matchProperty, split[++i]);
				} else if (matchEnd) {

					self.popStack();
				} else if (line.match(/^[^\s\t}]/)) {

					// large arrays are split over multiple lines terminated with a ',' character
					// if this is encountered the line needs to be joined to the previous line
					self.parseNodePropertyContinued(line);
				}
			});

			return this.allNodes;
		},

		parseNodeBegin: function parseNodeBegin(line, property) {

			var nodeName = property[1].trim().replace(/^"/, '').replace(/"$/, '');

			var nodeAttrs = property[2].split(',').map(function (attr) {

				return attr.trim().replace(/^"/, '').replace(/"$/, '');
			});

			var node = { name: nodeName };
			var attrs = this.parseNodeAttr(nodeAttrs);

			var currentNode = this.getCurrentNode();

			// a top node
			if (this.currentIndent === 0) {

				this.allNodes.add(nodeName, node);
			} else {
				// a subnode

				// if the subnode already exists, append it
				if (nodeName in currentNode) {

					// special case Pose needs PoseNodes as an array
					if (nodeName === 'PoseNode') {

						currentNode.PoseNode.push(node);
					} else if (currentNode[nodeName].id !== undefined) {

						currentNode[nodeName] = {};
						currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];
					}

					if (attrs.id !== '') currentNode[nodeName][attrs.id] = node;
				} else if (typeof attrs.id === 'number') {

					currentNode[nodeName] = {};
					currentNode[nodeName][attrs.id] = node;
				} else if (nodeName !== 'Properties70') {

					if (nodeName === 'PoseNode') currentNode[nodeName] = [node];else currentNode[nodeName] = node;
				}
			}

			if (typeof attrs.id === 'number') node.id = attrs.id;
			if (attrs.name !== '') node.attrName = attrs.name;
			if (attrs.type !== '') node.attrType = attrs.type;

			this.pushStack(node);
		},

		parseNodeAttr: function parseNodeAttr(attrs) {

			var id = attrs[0];

			if (attrs[0] !== '') {

				id = parseInt(attrs[0]);

				if (isNaN(id)) {

					id = attrs[0];
				}
			}

			var name = '',
			    type = '';

			if (attrs.length > 1) {

				name = attrs[1].replace(/^(\w+)::/, '');
				type = attrs[2];
			}

			return { id: id, name: name, type: type };
		},

		parseNodeProperty: function parseNodeProperty(line, property, contentLine) {

			var propName = property[1].replace(/^"/, '').replace(/"$/, '').trim();
			var propValue = property[2].replace(/^"/, '').replace(/"$/, '').trim();

			// for special case: base64 image data follows "Content: ," line
			//	Content: ,
			//	 "/9j/4RDaRXhpZgAATU0A..."
			if (propName === 'Content' && propValue === ',') {

				propValue = contentLine.replace(/"/g, '').replace(/,$/, '').trim();
			}

			var currentNode = this.getCurrentNode();
			var parentName = currentNode.name;

			if (parentName === 'Properties70') {

				this.parseNodeSpecialProperty(line, propName, propValue);
				return;
			}

			// Connections
			if (propName === 'C') {

				var connProps = propValue.split(',').slice(1);
				var from = parseInt(connProps[0]);
				var to = parseInt(connProps[1]);

				var rest = propValue.split(',').slice(3);

				rest = rest.map(function (elem) {

					return elem.trim().replace(/^"/, '');
				});

				propName = 'connections';
				propValue = [from, to];
				append(propValue, rest);

				if (currentNode[propName] === undefined) {

					currentNode[propName] = [];
				}
			}

			// Node
			if (propName === 'Node') currentNode.id = propValue;

			// connections
			if (propName in currentNode && Array.isArray(currentNode[propName])) {

				currentNode[propName].push(propValue);
			} else {

				if (propName !== 'a') currentNode[propName] = propValue;else currentNode.a = propValue;
			}

			this.setCurrentProp(currentNode, propName);

			// convert string to array, unless it ends in ',' in which case more will be added to it
			if (propName === 'a' && propValue.slice(-1) !== ',') {

				currentNode.a = parseNumberArray(propValue);
			}
		},

		parseNodePropertyContinued: function parseNodePropertyContinued(line) {

			var currentNode = this.getCurrentNode();

			currentNode.a += line;

			// if the line doesn't end in ',' we have reached the end of the property value
			// so convert the string to an array
			if (line.slice(-1) !== ',') {

				currentNode.a = parseNumberArray(currentNode.a);
			}
		},

		// parse "Property70"
		parseNodeSpecialProperty: function parseNodeSpecialProperty(line, propName, propValue) {

			// split this
			// P: "Lcl Scaling", "Lcl Scaling", "", "A",1,1,1
			// into array like below
			// ["Lcl Scaling", "Lcl Scaling", "", "A", "1,1,1" ]
			var props = propValue.split('",').map(function (prop) {

				return prop.trim().replace(/^\"/, '').replace(/\s/, '_');
			});

			var innerPropName = props[0];
			var innerPropType1 = props[1];
			var innerPropType2 = props[2];
			var innerPropFlag = props[3];
			var innerPropValue = props[4];

			// cast values where needed, otherwise leave as strings
			switch (innerPropType1) {

				case 'int':
				case 'enum':
				case 'bool':
				case 'ULongLong':
				case 'double':
				case 'Number':
				case 'FieldOfView':
					innerPropValue = parseFloat(innerPropValue);
					break;

				case 'Color':
				case 'ColorRGB':
				case 'Vector3D':
				case 'Lcl_Translation':
				case 'Lcl_Rotation':
				case 'Lcl_Scaling':
					innerPropValue = parseNumberArray(innerPropValue);
					break;

			}

			// CAUTION: these props must append to parent's parent
			this.getPrevNode()[innerPropName] = {

				'type': innerPropType1,
				'type2': innerPropType2,
				'flag': innerPropFlag,
				'value': innerPropValue

			};

			this.setCurrentProp(this.getPrevNode(), innerPropName);
		}

	});

	// Parse an FBX file in Binary format
	function BinaryParser() {}

	Object.assign(BinaryParser.prototype, {

		parse: function parse(buffer) {

			var reader = new BinaryReader(buffer);
			reader.skip(23); // skip magic 23 bytes

			var version = reader.getUint32();

			console.log('THREE.FBXLoader: FBX binary version: ' + version);

			var allNodes = new FBXTree();

			while (!this.endOfContent(reader)) {

				var node = this.parseNode(reader, version);
				if (node !== null) allNodes.add(node.name, node);
			}

			return allNodes;
		},

		// Check if reader has reached the end of content.
		endOfContent: function endOfContent(reader) {

			// footer size: 160bytes + 16-byte alignment padding
			// - 16bytes: magic
			// - padding til 16-byte alignment (at least 1byte?)
			//	(seems like some exporters embed fixed 15 or 16bytes?)
			// - 4bytes: magic
			// - 4bytes: version
			// - 120bytes: zero
			// - 16bytes: magic
			if (reader.size() % 16 === 0) {

				return (reader.getOffset() + 160 + 16 & ~0xf) >= reader.size();
			} else {

				return reader.getOffset() + 160 + 16 >= reader.size();
			}
		},

		// recursively parse nodes until the end of the file is reached
		parseNode: function parseNode(reader, version) {

			var node = {};

			// The first three data sizes depends on version.
			var endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();
			var numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32();

			// note: do not remove this even if you get a linter warning as it moves the buffer forward
			var propertyListLen = version >= 7500 ? reader.getUint64() : reader.getUint32();

			var nameLen = reader.getUint8();
			var name = reader.getString(nameLen);

			// Regards this node as NULL-record if endOffset is zero
			if (endOffset === 0) return null;

			var propertyList = [];

			for (var i = 0; i < numProperties; i++) {

				propertyList.push(this.parseProperty(reader));
			}

			// Regards the first three elements in propertyList as id, attrName, and attrType
			var id = propertyList.length > 0 ? propertyList[0] : '';
			var attrName = propertyList.length > 1 ? propertyList[1] : '';
			var attrType = propertyList.length > 2 ? propertyList[2] : '';

			// check if this node represents just a single property
			// like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}
			node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;

			while (endOffset > reader.getOffset()) {

				var subNode = this.parseNode(reader, version);

				if (subNode !== null) this.parseSubNode(name, node, subNode);
			}

			node.propertyList = propertyList; // raw property list used by parent

			if (typeof id === 'number') node.id = id;
			if (attrName !== '') node.attrName = attrName;
			if (attrType !== '') node.attrType = attrType;
			if (name !== '') node.name = name;

			return node;
		},

		parseSubNode: function parseSubNode(name, node, subNode) {

			// special case: child node is single property
			if (subNode.singleProperty === true) {

				var value = subNode.propertyList[0];

				if (Array.isArray(value)) {

					node[subNode.name] = subNode;

					subNode.a = value;
				} else {

					node[subNode.name] = value;
				}
			} else if (name === 'Connections' && subNode.name === 'C') {

				var array = [];

				subNode.propertyList.forEach(function (property, i) {

					// first Connection is FBX type (OO, OP, etc.). We'll discard these
					if (i !== 0) array.push(property);
				});

				if (node.connections === undefined) {

					node.connections = [];
				}

				node.connections.push(array);
			} else if (subNode.name === 'Properties70') {

				var keys = Object.keys(subNode);

				keys.forEach(function (key) {

					node[key] = subNode[key];
				});
			} else if (name === 'Properties70' && subNode.name === 'P') {

				var innerPropName = subNode.propertyList[0];
				var innerPropType1 = subNode.propertyList[1];
				var innerPropType2 = subNode.propertyList[2];
				var innerPropFlag = subNode.propertyList[3];
				var innerPropValue;

				if (innerPropName.indexOf('Lcl ') === 0) innerPropName = innerPropName.replace('Lcl ', 'Lcl_');
				if (innerPropType1.indexOf('Lcl ') === 0) innerPropType1 = innerPropType1.replace('Lcl ', 'Lcl_');

				if (innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf('Lcl_') === 0) {

					innerPropValue = [subNode.propertyList[4], subNode.propertyList[5], subNode.propertyList[6]];
				} else {

					innerPropValue = subNode.propertyList[4];
				}

				// this will be copied to parent, see above
				node[innerPropName] = {

					'type': innerPropType1,
					'type2': innerPropType2,
					'flag': innerPropFlag,
					'value': innerPropValue

				};
			} else if (node[subNode.name] === undefined) {

				if (typeof subNode.id === 'number') {

					node[subNode.name] = {};
					node[subNode.name][subNode.id] = subNode;
				} else {

					node[subNode.name] = subNode;
				}
			} else {

				if (subNode.name === 'PoseNode') {

					if (!Array.isArray(node[subNode.name])) {

						node[subNode.name] = [node[subNode.name]];
					}

					node[subNode.name].push(subNode);
				} else if (node[subNode.name][subNode.id] === undefined) {

					node[subNode.name][subNode.id] = subNode;
				}
			}
		},

		parseProperty: function parseProperty(reader) {

			var type = reader.getString(1);

			switch (type) {

				case 'C':
					return reader.getBoolean();

				case 'D':
					return reader.getFloat64();

				case 'F':
					return reader.getFloat32();

				case 'I':
					return reader.getInt32();

				case 'L':
					return reader.getInt64();

				case 'R':
					var length = reader.getUint32();
					return reader.getArrayBuffer(length);

				case 'S':
					var length = reader.getUint32();
					return reader.getString(length);

				case 'Y':
					return reader.getInt16();

				case 'b':
				case 'c':
				case 'd':
				case 'f':
				case 'i':
				case 'l':

					var arrayLength = reader.getUint32();
					var encoding = reader.getUint32(); // 0: non-compressed, 1: compressed
					var compressedLength = reader.getUint32();

					if (encoding === 0) {

						switch (type) {

							case 'b':
							case 'c':
								return reader.getBooleanArray(arrayLength);

							case 'd':
								return reader.getFloat64Array(arrayLength);

							case 'f':
								return reader.getFloat32Array(arrayLength);

							case 'i':
								return reader.getInt32Array(arrayLength);

							case 'l':
								return reader.getInt64Array(arrayLength);

						}
					}

					if (window.Zlib === undefined) {

						console.error('THREE.FBXLoader: External library Inflate.min.js required, obtain or import from https://github.com/imaya/zlib.js');
					}

					var inflate = new Zlib.Inflate(new Uint8Array(reader.getArrayBuffer(compressedLength))); // eslint-disable-line no-undef
					var reader2 = new BinaryReader(inflate.decompress().buffer);

					switch (type) {

						case 'b':
						case 'c':
							return reader2.getBooleanArray(arrayLength);

						case 'd':
							return reader2.getFloat64Array(arrayLength);

						case 'f':
							return reader2.getFloat32Array(arrayLength);

						case 'i':
							return reader2.getInt32Array(arrayLength);

						case 'l':
							return reader2.getInt64Array(arrayLength);

					}

				default:
					throw new Error('THREE.FBXLoader: Unknown property type ' + type);

			}
		}

	});

	function BinaryReader(buffer, littleEndian) {

		this.dv = new DataView(buffer);
		this.offset = 0;
		this.littleEndian = littleEndian !== undefined ? littleEndian : true;
	}

	Object.assign(BinaryReader.prototype, {

		getOffset: function getOffset() {

			return this.offset;
		},

		size: function size() {

			return this.dv.buffer.byteLength;
		},

		skip: function skip(length) {

			this.offset += length;
		},

		// seems like true/false representation depends on exporter.
		// true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
		// then sees LSB.
		getBoolean: function getBoolean() {

			return (this.getUint8() & 1) === 1;
		},

		getBooleanArray: function getBooleanArray(size) {

			var a = [];

			for (var i = 0; i < size; i++) {

				a.push(this.getBoolean());
			}

			return a;
		},

		getUint8: function getUint8() {

			var value = this.dv.getUint8(this.offset);
			this.offset += 1;
			return value;
		},

		getInt16: function getInt16() {

			var value = this.dv.getInt16(this.offset, this.littleEndian);
			this.offset += 2;
			return value;
		},

		getInt32: function getInt32() {

			var value = this.dv.getInt32(this.offset, this.littleEndian);
			this.offset += 4;
			return value;
		},

		getInt32Array: function getInt32Array(size) {

			var a = [];

			for (var i = 0; i < size; i++) {

				a.push(this.getInt32());
			}

			return a;
		},

		getUint32: function getUint32() {

			var value = this.dv.getUint32(this.offset, this.littleEndian);
			this.offset += 4;
			return value;
		},

		// JavaScript doesn't support 64-bit integer so calculate this here
		// 1 << 32 will return 1 so using multiply operation instead here.
		// There's a possibility that this method returns wrong value if the value
		// is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
		// TODO: safely handle 64-bit integer
		getInt64: function getInt64() {

			var low, high;

			if (this.littleEndian) {

				low = this.getUint32();
				high = this.getUint32();
			} else {

				high = this.getUint32();
				low = this.getUint32();
			}

			// calculate negative value
			if (high & 0x80000000) {

				high = ~high & 0xFFFFFFFF;
				low = ~low & 0xFFFFFFFF;

				if (low === 0xFFFFFFFF) high = high + 1 & 0xFFFFFFFF;

				low = low + 1 & 0xFFFFFFFF;

				return -(high * 0x100000000 + low);
			}

			return high * 0x100000000 + low;
		},

		getInt64Array: function getInt64Array(size) {

			var a = [];

			for (var i = 0; i < size; i++) {

				a.push(this.getInt64());
			}

			return a;
		},

		// Note: see getInt64() comment
		getUint64: function getUint64() {

			var low, high;

			if (this.littleEndian) {

				low = this.getUint32();
				high = this.getUint32();
			} else {

				high = this.getUint32();
				low = this.getUint32();
			}

			return high * 0x100000000 + low;
		},

		getFloat32: function getFloat32() {

			var value = this.dv.getFloat32(this.offset, this.littleEndian);
			this.offset += 4;
			return value;
		},

		getFloat32Array: function getFloat32Array(size) {

			var a = [];

			for (var i = 0; i < size; i++) {

				a.push(this.getFloat32());
			}

			return a;
		},

		getFloat64: function getFloat64() {

			var value = this.dv.getFloat64(this.offset, this.littleEndian);
			this.offset += 8;
			return value;
		},

		getFloat64Array: function getFloat64Array(size) {

			var a = [];

			for (var i = 0; i < size; i++) {

				a.push(this.getFloat64());
			}

			return a;
		},

		getArrayBuffer: function getArrayBuffer(size) {

			var value = this.dv.buffer.slice(this.offset, this.offset + size);
			this.offset += size;
			return value;
		},

		getString: function getString(size) {

			var a = new Uint8Array(size);

			for (var i = 0; i < size; i++) {

				a[i] = this.getUint8();
			}

			var nullByte = a.indexOf(0);
			if (nullByte >= 0) a = a.slice(0, nullByte);

			return THREE.LoaderUtils.decodeText(a);
		}

	});

	// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)
	// and BinaryParser( FBX Binary format)
	function FBXTree() {}

	Object.assign(FBXTree.prototype, {

		add: function add(key, val) {

			this[key] = val;
		}

	});

	function isFbxFormatBinary(buffer) {

		var CORRECT = 'Kaydara FBX Binary  \0';

		return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);
	}

	function isFbxFormatASCII(text) {

		var CORRECT = ['K', 'a', 'y', 'd', 'a', 'r', 'a', '\\', 'F', 'B', 'X', '\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\', '\\'];

		var cursor = 0;

		function read(offset) {

			var result = text[offset - 1];
			text = text.slice(cursor + offset);
			cursor++;
			return result;
		}

		for (var i = 0; i < CORRECT.length; ++i) {

			var num = read(1);
			if (num === CORRECT[i]) {

				return false;
			}
		}

		return true;
	}

	function getFbxVersion(text) {

		var versionRegExp = /FBXVersion: (\d+)/;
		var match = text.match(versionRegExp);
		if (match) {

			var version = parseInt(match[1]);
			return version;
		}
		throw new Error('THREE.FBXLoader: Cannot find the version number for the file given.');
	}

	// Converts FBX ticks into real time seconds.
	function convertFBXTimeToSeconds(time) {

		return time / 46186158000;
	}

	// Parses comma separated list of numbers and returns them an array.
	// Used internally by the TextParser
	function parseNumberArray(value) {

		var array = value.split(',').map(function (val) {

			return parseFloat(val);
		});

		return array;
	}

	function convertArrayBufferToString(buffer, from, to) {

		if (from === undefined) from = 0;
		if (to === undefined) to = buffer.byteLength;

		return THREE.LoaderUtils.decodeText(new Uint8Array(buffer, from, to));
	}

	function append(a, b) {

		for (var i = 0, j = a.length, l = b.length; i < l; i++, j++) {

			a[j] = b[i];
		}
	}

	function slice(a, b, from, to) {

		for (var i = from, j = 0; i < to; i++, j++) {

			a[j] = b[i];
		}

		return a;
	}

	// inject array a2 into array a1 at index
	function inject(a1, index, a2) {

		return a1.slice(0, index).concat(a2).concat(a1.slice(index));
	}

	return FBXLoader;
}();

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

'use strict';

/**
 * THREE.GCodeLoader is used to load gcode files usually used for 3D printing or CNC applications.
 *
 * Gcode files are composed by commands used by machines to create objects.
 *
 * @class THREE.GCodeLoader
 * @param {Manager} manager Loading manager.
 * @author tentone
 * @author joewalnes
 */
var GCodeLoader = function GCodeLoader(manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;

	this.splitLayer = false;
};

GCodeLoader.prototype.load = function (url, onLoad, onProgress, onError) {

	var self = this;

	var loader = new THREE.FileLoader(self.manager);
	loader.load(url, function (text) {

		onLoad(self.parse(text));
	}, onProgress, onError);
};

GCodeLoader.prototype.parse = function (data) {

	var state = { x: 0, y: 0, z: 0, e: 0, f: 0, extruding: false, relative: false };
	var layers = [];

	var currentLayer = undefined;

	var pathMaterial = new THREE.LineBasicMaterial({ color: 0xFF0000 });
	pathMaterial.name = 'path';

	var extrudingMaterial = new THREE.LineBasicMaterial({ color: 0x00FF00 });
	extrudingMaterial.name = 'extruded';

	function newLayer(line) {

		currentLayer = { vertex: [], pathVertex: [], z: line.z };
		layers.push(currentLayer);
	}

	//Create lie segment between p1 and p2
	function addSegment(p1, p2) {

		if (currentLayer === undefined) {

			newLayer(p1);
		}

		if (line.extruding) {

			currentLayer.vertex.push(p1.x, p1.y, p1.z);
			currentLayer.vertex.push(p2.x, p2.y, p2.z);
		} else {

			currentLayer.pathVertex.push(p1.x, p1.y, p1.z);
			currentLayer.pathVertex.push(p2.x, p2.y, p2.z);
		}
	}

	function delta(v1, v2) {

		return state.relative ? v2 : v2 - v1;
	}

	function absolute(v1, v2) {

		return state.relative ? v1 + v2 : v2;
	}

	var lines = data.replace(/;.+/g, '').split('\n');

	for (var i = 0; i < lines.length; i++) {

		var tokens = lines[i].split(' ');
		var cmd = tokens[0].toUpperCase();

		//Argumments
		var args = {};
		tokens.splice(1).forEach(function (token) {

			if (token[0] !== undefined) {

				var key = token[0].toLowerCase();
				var value = parseFloat(token.substring(1));
				args[key] = value;
			}
		});

		//Process commands
		//G0/G1 – Linear Movement
		if (cmd === 'G0' || cmd === 'G1') {

			var line = {
				x: args.x !== undefined ? absolute(state.x, args.x) : state.x,
				y: args.y !== undefined ? absolute(state.y, args.y) : state.y,
				z: args.z !== undefined ? absolute(state.z, args.z) : state.z,
				e: args.e !== undefined ? absolute(state.e, args.e) : state.e,
				f: args.f !== undefined ? absolute(state.f, args.f) : state.f
			};

			//Layer change detection is or made by watching Z, it's made by watching when we extrude at a new Z position
			if (delta(state.e, line.e) > 0) {

				line.extruding = delta(state.e, line.e) > 0;

				if (currentLayer == undefined || line.z != currentLayer.z) {

					newLayer(line);
				}
			}

			addSegment(state, line);
			state = line;
		} else if (cmd === 'G2' || cmd === 'G3') {

			//G2/G3 - Arc Movement ( G2 clock wise and G3 counter clock wise )
			console.warn('THREE.GCodeLoader: Arc command not supported');
		} else if (cmd === 'G90') {

			//G90: Set to Absolute Positioning
			state.relative = false;
		} else if (cmd === 'G91') {

			//G91: Set to state.relative Positioning
			state.relative = true;
		} else if (cmd === 'G92') {

			//G92: Set Position
			var line = state;
			line.x = args.x !== undefined ? args.x : line.x;
			line.y = args.y !== undefined ? args.y : line.y;
			line.z = args.z !== undefined ? args.z : line.z;
			line.e = args.e !== undefined ? args.e : line.e;
			state = line;
		} else {

			console.warn('THREE.GCodeLoader: Command not supported:' + cmd);
		}
	}

	function addObject(vertex, extruding) {

		var geometry = new THREE.BufferGeometry();
		geometry.addAttribute('position', new THREE.Float32BufferAttribute(vertex, 3));

		var segments = new THREE.LineSegments(geometry, extruding ? extrudingMaterial : pathMaterial);
		segments.name = 'layer' + i;
		object.add(segments);
	}

	var object = new THREE.Group();
	object.name = 'gcode';

	if (this.splitLayer) {

		for (var i = 0; i < layers.length; i++) {

			var layer = layers[i];
			addObject(layer.vertex, true);
			addObject(layer.pathVertex, false);
		}
	} else {

		var vertex = [],
		    pathVertex = [];

		for (var i = 0; i < layers.length; i++) {

			var layer = layers[i];

			vertex = vertex.concat(layer.vertex);
			pathVertex = pathVertex.concat(layer.pathVertex);
		}

		addObject(vertex, true);
		addObject(pathVertex, false);
	}

	object.quaternion.setFromEuler(new THREE.Euler(-Math.PI / 2, 0, 0));

	return object;
};

exports.default = GCodeLoader;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _RGBELoader = __webpack_require__(6);

var _RGBELoader2 = _interopRequireDefault(_RGBELoader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
* @author Prashant Sharma / spidersharma03
* @author Ben Houston / http://clara.io / bhouston
*/

var HDRCubeTextureLoader = function HDRCubeTextureLoader(manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
	// override in sub classes
	this.hdrLoader = new _RGBELoader2.default();
};

HDRCubeTextureLoader.prototype.load = function (type, urls, onLoad, onProgress, onError) {

	var RGBEByteToRGBFloat = function RGBEByteToRGBFloat(sourceArray, sourceOffset, destArray, destOffset) {

		var e = sourceArray[sourceOffset + 3];
		var scale = Math.pow(2.0, e - 128.0) / 255.0;

		destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;
		destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;
		destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;
	};

	var RGBEByteToRGBHalf = function () {

		// Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410

		var floatView = new Float32Array(1);
		var int32View = new Int32Array(floatView.buffer);

		/* This method is faster than the OpenEXR implementation (very often
   * used, eg. in Ogre), with the additional benefit of rounding, inspired
   * by James Tursa?s half-precision code. */
		function toHalf(val) {

			floatView[0] = val;
			var x = int32View[0];

			var bits = x >> 16 & 0x8000; /* Get the sign */
			var m = x >> 12 & 0x07ff; /* Keep one extra bit for rounding */
			var e = x >> 23 & 0xff; /* Using int is faster here */

			/* If zero, or denormal, or exponent underflows too much for a denormal
    * half, return signed zero. */
			if (e < 103) return bits;

			/* If NaN, return NaN. If Inf or exponent overflow, return Inf. */
			if (e > 142) {

				bits |= 0x7c00;
				/* If exponent was 0xff and one mantissa bit was set, it means NaN,
    		 * not Inf, so make sure we set one mantissa bit too. */
				bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;
				return bits;
			}

			/* If exponent underflows but not too much, return a denormal */
			if (e < 113) {

				m |= 0x0800;
				/* Extra rounding may overflow and set mantissa to 0 and exponent
     * to 1, which is OK. */
				bits |= (m >> 114 - e) + (m >> 113 - e & 1);
				return bits;
			}

			bits |= e - 112 << 10 | m >> 1;
			/* Extra rounding. An overflow will set mantissa to 0 and increment
    * the exponent, which is OK. */
			bits += m & 1;
			return bits;
		}

		return function (sourceArray, sourceOffset, destArray, destOffset) {

			var e = sourceArray[sourceOffset + 3];
			var scale = Math.pow(2.0, e - 128.0) / 255.0;

			destArray[destOffset + 0] = toHalf(sourceArray[sourceOffset + 0] * scale);
			destArray[destOffset + 1] = toHalf(sourceArray[sourceOffset + 1] * scale);
			destArray[destOffset + 2] = toHalf(sourceArray[sourceOffset + 2] * scale);
		};
	}();

	//

	var texture = new THREE.CubeTexture();

	texture.type = type;
	texture.encoding = type === THREE.UnsignedByteType ? THREE.RGBEEncoding : THREE.LinearEncoding;
	texture.format = type === THREE.UnsignedByteType ? THREE.RGBAFormat : THREE.RGBFormat;
	texture.minFilter = texture.encoding === THREE.RGBEEncoding ? THREE.NearestFilter : THREE.LinearFilter;
	texture.magFilter = texture.encoding === THREE.RGBEEncoding ? THREE.NearestFilter : THREE.LinearFilter;
	texture.generateMipmaps = texture.encoding !== THREE.RGBEEncoding;
	texture.anisotropy = 0;

	var scope = this.hdrLoader;

	var loaded = 0;

	function loadHDRData(i, onLoad, onProgress, onError) {

		var loader = new THREE.FileLoader(this.manager);
		loader.setResponseType('arraybuffer');
		loader.load(urls[i], function (buffer) {

			loaded++;

			var texData = scope._parser(buffer);

			if (!texData) return;

			if (type === THREE.FloatType) {

				var numElements = texData.data.length / 4 * 3;
				var floatdata = new Float32Array(numElements);

				for (var j = 0; j < numElements; j++) {

					RGBEByteToRGBFloat(texData.data, j * 4, floatdata, j * 3);
				}

				texData.data = floatdata;
			} else if (type === THREE.HalfFloatType) {

				var numElements = texData.data.length / 4 * 3;
				var halfdata = new Uint16Array(numElements);

				for (var j = 0; j < numElements; j++) {

					RGBEByteToRGBHalf(texData.data, j * 4, halfdata, j * 3);
				}

				texData.data = halfdata;
			}

			if (undefined !== texData.image) {

				texture[i].images = texData.image;
			} else if (undefined !== texData.data) {

				var dataTexture = new THREE.DataTexture(texData.data, texData.width, texData.height);
				dataTexture.format = texture.format;
				dataTexture.type = texture.type;
				dataTexture.encoding = texture.encoding;
				dataTexture.minFilter = texture.minFilter;
				dataTexture.magFilter = texture.magFilter;
				dataTexture.generateMipmaps = texture.generateMipmaps;

				texture.images[i] = dataTexture;
			}

			if (loaded === 6) {

				texture.needsUpdate = true;
				if (onLoad) onLoad(texture);
			}
		}, onProgress, onError);
	}

	for (var i = 0; i < urls.length; i++) {

		loadHDRData(i, onLoad, onProgress, onError);
	}

	return texture;
};

exports.default = HDRCubeTextureLoader;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author mrdoob / http://mrdoob.com/
 */

var KMZLoader = function KMZLoader(manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};

KMZLoader.prototype = {

	constructor: KMZLoader,

	load: function load(url, onLoad, onProgress, onError) {

		var scope = this;

		var loader = new THREE.FileLoader(scope.manager);
		loader.setResponseType('arraybuffer');
		loader.load(url, function (text) {

			onLoad(scope.parse(text));
		}, onProgress, onError);
	},

	parse: function parse(data) {

		var zip = new JSZip(data); // eslint-disable-line no-undef

		// console.log( zip );

		// var xml = new DOMParser().parseFromString( zip.file( 'doc.kml' ).asText(), 'application/xml' );

		function loadImage(image) {

			var path = decodeURI(image.init_from);

			// Hack to support relative paths
			path = path.replace('../', '');

			var regex = new RegExp(path + '$');
			var files = zip.file(regex);

			// console.log( image, files );

			if (files.length) {

				var file = files[0];
				var blob = new Blob([file.asArrayBuffer()], { type: 'application/octet-binary' });
				image.build.src = URL.createObjectURL(blob);
			}
		}

		// load collada

		var files = zip.file(/dae$/i);

		if (files.length) {

			var file = files[0];

			var collada = new THREE.ColladaLoader().parse(file.asText());

			// fix images

			var images = collada.library.images;

			for (var name in images) {

				loadImage(images[name]);
			}

			return collada;
		}

		console.error('KMZLoader: Couldn\'t find .dae file.');

		return {
			scene: new THREE.Group()
		};
	}

};

exports.default = KMZLoader;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author amakaseev / https://github.com/amakaseev
 *
 * for description see https://www.khronos.org/opengles/sdk/tools/KTX/
 * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
 *
 * ported from https://github.com/BabylonJS/Babylon.js/blob/master/src/Tools/babylon.khronosTextureContainer.ts
 */

var KTXLoader = function KTXLoader() {

	this._parser = KTXLoader.parse;
};

KTXLoader.prototype = Object.create(THREE.CompressedTextureLoader.prototype);
KTXLoader.prototype.constructor = KTXLoader;

KTXLoader.parse = function (buffer, loadMipmaps) {

	var ktx = new KhronosTextureContainer(buffer, 1);

	return {
		mipmaps: ktx.mipmaps(loadMipmaps),
		width: ktx.pixelWidth,
		height: ktx.pixelHeight,
		format: ktx.glInternalFormat,
		isCubemap: ktx.numberOfFaces === 6,
		mipmapCount: ktx.numberOfMipmapLevels
	};
};

var KhronosTextureContainer = function () {

	/**
  * @param {ArrayBuffer} arrayBuffer- contents of the KTX container file
  * @param {number} facesExpected- should be either 1 or 6, based whether a cube texture or or
  * @param {boolean} threeDExpected- provision for indicating that data should be a 3D texture, not implemented
  * @param {boolean} textureArrayExpected- provision for indicating that data should be a texture array, not implemented
  */
	function KhronosTextureContainer(arrayBuffer, facesExpected, threeDExpected, textureArrayExpected) {

		this.arrayBuffer = arrayBuffer;

		// Test that it is a ktx formatted file, based on the first 12 bytes, character representation is:
		// '´', 'K', 'T', 'X', ' ', '1', '1', 'ª', '\r', '\n', '\x1A', '\n'
		// 0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A
		var identifier = new Uint8Array(this.arrayBuffer, 0, 12);
		if (identifier[0] !== 0xAB || identifier[1] !== 0x4B || identifier[2] !== 0x54 || identifier[3] !== 0x58 || identifier[4] !== 0x20 || identifier[5] !== 0x31 || identifier[6] !== 0x31 || identifier[7] !== 0xBB || identifier[8] !== 0x0D || identifier[9] !== 0x0A || identifier[10] !== 0x1A || identifier[11] !== 0x0A) {

			console.error('texture missing KTX identifier');
			return;
		}

		// load the reset of the header in native 32 bit int
		var header = new Int32Array(this.arrayBuffer, 12, 13);
		// determine of the remaining header values are recorded in the opposite endianness & require conversion
		var oppositeEndianess = header[0] === 0x01020304;
		// read all the header elements in order they exist in the file, without modification (sans endainness)
		this.glType = oppositeEndianess ? this.switchEndainness(header[1]) : header[1]; // must be 0 for compressed textures
		this.glTypeSize = oppositeEndianess ? this.switchEndainness(header[2]) : header[2]; // must be 1 for compressed textures
		this.glFormat = oppositeEndianess ? this.switchEndainness(header[3]) : header[3]; // must be 0 for compressed textures
		this.glInternalFormat = oppositeEndianess ? this.switchEndainness(header[4]) : header[4]; // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)
		this.glBaseInternalFormat = oppositeEndianess ? this.switchEndainness(header[5]) : header[5]; // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)
		this.pixelWidth = oppositeEndianess ? this.switchEndainness(header[6]) : header[6]; // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)
		this.pixelHeight = oppositeEndianess ? this.switchEndainness(header[7]) : header[7]; // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)
		this.pixelDepth = oppositeEndianess ? this.switchEndainness(header[8]) : header[8]; // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)
		this.numberOfArrayElements = oppositeEndianess ? this.switchEndainness(header[9]) : header[9]; // used for texture arrays
		this.numberOfFaces = oppositeEndianess ? this.switchEndainness(header[10]) : header[10]; // used for cubemap textures, should either be 1 or 6
		this.numberOfMipmapLevels = oppositeEndianess ? this.switchEndainness(header[11]) : header[11]; // number of levels; disregard possibility of 0 for compressed textures
		this.bytesOfKeyValueData = oppositeEndianess ? this.switchEndainness(header[12]) : header[12]; // the amount of space after the header for meta-data

		// Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.
		if (this.glType !== 0) {

			console.warn('only compressed formats currently supported');
			return;
		} else {

			// value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.
			this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels);
		}
		if (this.pixelHeight === 0 || this.pixelDepth !== 0) {

			console.warn('only 2D textures currently supported');
			return;
		}
		if (this.numberOfArrayElements !== 0) {

			console.warn('texture arrays not currently supported');
			return;
		}
		if (this.numberOfFaces !== facesExpected) {

			console.warn('number of faces expected' + facesExpected + ', but found ' + this.numberOfFaces);
			return;
		}
		// we now have a completely validated file, so could use existence of loadType as success
		// would need to make this more elaborate & adjust checks above to support more than one load type
		this.loadType = KhronosTextureContainer.COMPRESSED_2D;
	}

	// not as fast hardware based, but will probably never need to use
	KhronosTextureContainer.prototype.switchEndainness = function (val) {

		return (val & 0xFF) << 24 | (val & 0xFF00) << 8 | val >> 8 & 0xFF00 | val >> 24 & 0xFF;
	};

	// return mipmaps for THREE.js
	KhronosTextureContainer.prototype.mipmaps = function (loadMipmaps) {

		var mipmaps = [];

		// initialize width & height for level 1
		var dataOffset = KhronosTextureContainer.HEADER_LEN + this.bytesOfKeyValueData;
		var width = this.pixelWidth;
		var height = this.pixelHeight;
		var mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;

		for (var level = 0; level < mipmapCount; level++) {

			var imageSize = new Int32Array(this.arrayBuffer, dataOffset, 1)[0]; // size per face, since not supporting array cubemaps
			for (var face = 0; face < this.numberOfFaces; face++) {

				var byteArray = new Uint8Array(this.arrayBuffer, dataOffset + 4, imageSize);

				mipmaps.push({ "data": byteArray, "width": width, "height": height });

				dataOffset += imageSize + 4; // size of the image + 4 for the imageSize field
				dataOffset += 3 - (imageSize + 3) % 4; // add padding for odd sized image
			}
			width = Math.max(1.0, width * 0.5);
			height = Math.max(1.0, height * 0.5);
		}

		return mipmaps;
	};

	KhronosTextureContainer.HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)
	// load types
	KhronosTextureContainer.COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()
	KhronosTextureContainer.COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()
	KhronosTextureContainer.TEX_2D = 2; // uses a gl.texImage2D()
	KhronosTextureContainer.TEX_3D = 3; // uses a gl.texImage3D()

	return KhronosTextureContainer;
}();

exports.default = KTXLoader;

/***/ }),
/* 67 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author mrdoob / http://mrdoob.com/
 */

var MD2Loader = function MD2Loader(manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};

MD2Loader.prototype = {

	constructor: MD2Loader,

	load: function load(url, onLoad, onProgress, onError) {

		var scope = this;

		var loader = new THREE.FileLoader(scope.manager);
		loader.setResponseType('arraybuffer');
		loader.load(url, function (buffer) {

			onLoad(scope.parse(buffer));
		}, onProgress, onError);
	},

	parse: function () {

		var normals = [[-0.525731, 0.000000, 0.850651], [-0.442863, 0.238856, 0.864188], [-0.295242, 0.000000, 0.955423], [-0.309017, 0.500000, 0.809017], [-0.162460, 0.262866, 0.951056], [0.000000, 0.000000, 1.000000], [0.000000, 0.850651, 0.525731], [-0.147621, 0.716567, 0.681718], [0.147621, 0.716567, 0.681718], [0.000000, 0.525731, 0.850651], [0.309017, 0.500000, 0.809017], [0.525731, 0.000000, 0.850651], [0.295242, 0.000000, 0.955423], [0.442863, 0.238856, 0.864188], [0.162460, 0.262866, 0.951056], [-0.681718, 0.147621, 0.716567], [-0.809017, 0.309017, 0.500000], [-0.587785, 0.425325, 0.688191], [-0.850651, 0.525731, 0.000000], [-0.864188, 0.442863, 0.238856], [-0.716567, 0.681718, 0.147621], [-0.688191, 0.587785, 0.425325], [-0.500000, 0.809017, 0.309017], [-0.238856, 0.864188, 0.442863], [-0.425325, 0.688191, 0.587785], [-0.716567, 0.681718, -0.147621], [-0.500000, 0.809017, -0.309017], [-0.525731, 0.850651, 0.000000], [0.000000, 0.850651, -0.525731], [-0.238856, 0.864188, -0.442863], [0.000000, 0.955423, -0.295242], [-0.262866, 0.951056, -0.162460], [0.000000, 1.000000, 0.000000], [0.000000, 0.955423, 0.295242], [-0.262866, 0.951056, 0.162460], [0.238856, 0.864188, 0.442863], [0.262866, 0.951056, 0.162460], [0.500000, 0.809017, 0.309017], [0.238856, 0.864188, -0.442863], [0.262866, 0.951056, -0.162460], [0.500000, 0.809017, -0.309017], [0.850651, 0.525731, 0.000000], [0.716567, 0.681718, 0.147621], [0.716567, 0.681718, -0.147621], [0.525731, 0.850651, 0.000000], [0.425325, 0.688191, 0.587785], [0.864188, 0.442863, 0.238856], [0.688191, 0.587785, 0.425325], [0.809017, 0.309017, 0.500000], [0.681718, 0.147621, 0.716567], [0.587785, 0.425325, 0.688191], [0.955423, 0.295242, 0.000000], [1.000000, 0.000000, 0.000000], [0.951056, 0.162460, 0.262866], [0.850651, -0.525731, 0.000000], [0.955423, -0.295242, 0.000000], [0.864188, -0.442863, 0.238856], [0.951056, -0.162460, 0.262866], [0.809017, -0.309017, 0.500000], [0.681718, -0.147621, 0.716567], [0.850651, 0.000000, 0.525731], [0.864188, 0.442863, -0.238856], [0.809017, 0.309017, -0.500000], [0.951056, 0.162460, -0.262866], [0.525731, 0.000000, -0.850651], [0.681718, 0.147621, -0.716567], [0.681718, -0.147621, -0.716567], [0.850651, 0.000000, -0.525731], [0.809017, -0.309017, -0.500000], [0.864188, -0.442863, -0.238856], [0.951056, -0.162460, -0.262866], [0.147621, 0.716567, -0.681718], [0.309017, 0.500000, -0.809017], [0.425325, 0.688191, -0.587785], [0.442863, 0.238856, -0.864188], [0.587785, 0.425325, -0.688191], [0.688191, 0.587785, -0.425325], [-0.147621, 0.716567, -0.681718], [-0.309017, 0.500000, -0.809017], [0.000000, 0.525731, -0.850651], [-0.525731, 0.000000, -0.850651], [-0.442863, 0.238856, -0.864188], [-0.295242, 0.000000, -0.955423], [-0.162460, 0.262866, -0.951056], [0.000000, 0.000000, -1.000000], [0.295242, 0.000000, -0.955423], [0.162460, 0.262866, -0.951056], [-0.442863, -0.238856, -0.864188], [-0.309017, -0.500000, -0.809017], [-0.162460, -0.262866, -0.951056], [0.000000, -0.850651, -0.525731], [-0.147621, -0.716567, -0.681718], [0.147621, -0.716567, -0.681718], [0.000000, -0.525731, -0.850651], [0.309017, -0.500000, -0.809017], [0.442863, -0.238856, -0.864188], [0.162460, -0.262866, -0.951056], [0.238856, -0.864188, -0.442863], [0.500000, -0.809017, -0.309017], [0.425325, -0.688191, -0.587785], [0.716567, -0.681718, -0.147621], [0.688191, -0.587785, -0.425325], [0.587785, -0.425325, -0.688191], [0.000000, -0.955423, -0.295242], [0.000000, -1.000000, 0.000000], [0.262866, -0.951056, -0.162460], [0.000000, -0.850651, 0.525731], [0.000000, -0.955423, 0.295242], [0.238856, -0.864188, 0.442863], [0.262866, -0.951056, 0.162460], [0.500000, -0.809017, 0.309017], [0.716567, -0.681718, 0.147621], [0.525731, -0.850651, 0.000000], [-0.238856, -0.864188, -0.442863], [-0.500000, -0.809017, -0.309017], [-0.262866, -0.951056, -0.162460], [-0.850651, -0.525731, 0.000000], [-0.716567, -0.681718, -0.147621], [-0.716567, -0.681718, 0.147621], [-0.525731, -0.850651, 0.000000], [-0.500000, -0.809017, 0.309017], [-0.238856, -0.864188, 0.442863], [-0.262866, -0.951056, 0.162460], [-0.864188, -0.442863, 0.238856], [-0.809017, -0.309017, 0.500000], [-0.688191, -0.587785, 0.425325], [-0.681718, -0.147621, 0.716567], [-0.442863, -0.238856, 0.864188], [-0.587785, -0.425325, 0.688191], [-0.309017, -0.500000, 0.809017], [-0.147621, -0.716567, 0.681718], [-0.425325, -0.688191, 0.587785], [-0.162460, -0.262866, 0.951056], [0.442863, -0.238856, 0.864188], [0.162460, -0.262866, 0.951056], [0.309017, -0.500000, 0.809017], [0.147621, -0.716567, 0.681718], [0.000000, -0.525731, 0.850651], [0.425325, -0.688191, 0.587785], [0.587785, -0.425325, 0.688191], [0.688191, -0.587785, 0.425325], [-0.955423, 0.295242, 0.000000], [-0.951056, 0.162460, 0.262866], [-1.000000, 0.000000, 0.000000], [-0.850651, 0.000000, 0.525731], [-0.955423, -0.295242, 0.000000], [-0.951056, -0.162460, 0.262866], [-0.864188, 0.442863, -0.238856], [-0.951056, 0.162460, -0.262866], [-0.809017, 0.309017, -0.500000], [-0.864188, -0.442863, -0.238856], [-0.951056, -0.162460, -0.262866], [-0.809017, -0.309017, -0.500000], [-0.681718, 0.147621, -0.716567], [-0.681718, -0.147621, -0.716567], [-0.850651, 0.000000, -0.525731], [-0.688191, 0.587785, -0.425325], [-0.587785, 0.425325, -0.688191], [-0.425325, 0.688191, -0.587785], [-0.425325, -0.688191, -0.587785], [-0.587785, -0.425325, -0.688191], [-0.688191, -0.587785, -0.425325]];

		return function (buffer) {

			console.time('MD2Loader');

			var data = new DataView(buffer);

			// http://tfc.duke.free.fr/coding/md2-specs-en.html

			var header = {};
			var headerNames = ['ident', 'version', 'skinwidth', 'skinheight', 'framesize', 'num_skins', 'num_vertices', 'num_st', 'num_tris', 'num_glcmds', 'num_frames', 'offset_skins', 'offset_st', 'offset_tris', 'offset_frames', 'offset_glcmds', 'offset_end'];

			for (var i = 0; i < headerNames.length; i++) {

				header[headerNames[i]] = data.getInt32(i * 4, true);
			}

			if (header.ident !== 844121161 || header.version !== 8) {

				console.error('Not a valid MD2 file');
				return;
			}

			if (header.offset_end !== data.byteLength) {

				console.error('Corrupted MD2 file');
				return;
			}

			//

			var geometry = new THREE.Geometry();

			// uvs

			var uvs = [];
			var offset = header.offset_st;

			for (var i = 0, l = header.num_st; i < l; i++) {

				var u = data.getInt16(offset + 0, true);
				var v = data.getInt16(offset + 2, true);

				uvs.push(new THREE.Vector2(u / header.skinwidth, 1 - v / header.skinheight));

				offset += 4;
			}

			// triangles

			var offset = header.offset_tris;

			for (var i = 0, l = header.num_tris; i < l; i++) {

				var a = data.getUint16(offset + 0, true);
				var b = data.getUint16(offset + 2, true);
				var c = data.getUint16(offset + 4, true);

				geometry.faces.push(new THREE.Face3(a, b, c));

				geometry.faceVertexUvs[0].push([uvs[data.getUint16(offset + 6, true)], uvs[data.getUint16(offset + 8, true)], uvs[data.getUint16(offset + 10, true)]]);

				offset += 12;
			}

			// frames

			var translation = new THREE.Vector3();
			var scale = new THREE.Vector3();
			var string = [];

			var offset = header.offset_frames;

			for (var i = 0, l = header.num_frames; i < l; i++) {

				scale.set(data.getFloat32(offset + 0, true), data.getFloat32(offset + 4, true), data.getFloat32(offset + 8, true));

				translation.set(data.getFloat32(offset + 12, true), data.getFloat32(offset + 16, true), data.getFloat32(offset + 20, true));

				offset += 24;

				for (var j = 0; j < 16; j++) {

					var character = data.getUint8(offset + j, true);
					if (character === 0) break;

					string[j] = character;
				}

				var frame = {
					name: String.fromCharCode.apply(null, string),
					vertices: [],
					normals: []
				};

				offset += 16;

				for (var j = 0; j < header.num_vertices; j++) {

					var x = data.getUint8(offset++, true);
					var y = data.getUint8(offset++, true);
					var z = data.getUint8(offset++, true);
					var n = normals[data.getUint8(offset++, true)];

					var vertex = new THREE.Vector3(x * scale.x + translation.x, z * scale.z + translation.z, y * scale.y + translation.y);

					var normal = new THREE.Vector3(n[0], n[2], n[1]);

					frame.vertices.push(vertex);
					frame.normals.push(normal);
				}

				geometry.morphTargets.push(frame);
			}

			// Static

			geometry.vertices = geometry.morphTargets[0].vertices;

			var morphTarget = geometry.morphTargets[0];

			for (var j = 0, jl = geometry.faces.length; j < jl; j++) {

				var face = geometry.faces[j];

				face.vertexNormals = [morphTarget.normals[face.a], morphTarget.normals[face.b], morphTarget.normals[face.c]];
			}

			// Convert to geometry.morphNormals

			for (var i = 0, l = geometry.morphTargets.length; i < l; i++) {

				var morphTarget = geometry.morphTargets[i];
				var vertexNormals = [];

				for (var j = 0, jl = geometry.faces.length; j < jl; j++) {

					var face = geometry.faces[j];

					vertexNormals.push({
						a: morphTarget.normals[face.a],
						b: morphTarget.normals[face.b],
						c: morphTarget.normals[face.c]
					});
				}

				geometry.morphNormals.push({ vertexNormals: vertexNormals });
			}

			geometry.animations = THREE.AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);

			console.timeEnd('MD2Loader');

			return geometry;
		};
	}()

};

exports.default = MD2Loader;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _mmdParser = __webpack_require__(4);

var MMDParser = _interopRequireWildcard(_mmdParser);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author takahiro / https://github.com/takahirox
 *
 * Dependencies
 *  - mmd-parser https://github.com/takahirox/mmd-parser
 *  - ammo.js https://github.com/kripken/ammo.js
 *  - THREE.TGALoader
 *  - THREE.MMDPhysics
 *  - THREE.CCDIKSolver
 *  - THREE.OutlineEffect
 *
 *
 * This loader loads and parses PMD/PMX and VMD binary files
 * then creates mesh for Three.js.
 *
 * PMD/PMX is a model data format and VMD is a motion data format
 * used in MMD(Miku Miku Dance).
 *
 * MMD is a 3D CG animation tool which is popular in Japan.
 *
 *
 * MMD official site
 *  http://www.geocities.jp/higuchuu4/index_e.htm
 *
 * PMD, VMD format
 *  http://blog.goo.ne.jp/torisu_tetosuki/e/209ad341d3ece2b1b4df24abf619d6e4
 *
 * PMX format
 *  http://gulshan-i-raz.geo.jp/labs/2012/10/17/pmx-format1/
 *
 *
 * TODO
 *  - light motion in vmd support.
 *  - SDEF support.
 *  - uv/material/bone morphing support.
 *  - more precise grant skinning support.
 *  - shadow support.
 */

var MMDLoader = function MMDLoader(manager) {

	THREE.Loader.call(this);
	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
	this.parser = new MMDParser.Parser();
	this.textureCrossOrigin = null;
};

MMDLoader.prototype = Object.create(THREE.Loader.prototype);
MMDLoader.prototype.constructor = MMDLoader;

/*
 * base64 encoded defalut toon textures toon00.bmp - toon10.bmp
 * Users don't need to prepare default texture files.
 *
 * This idea is from http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js
 */
MMDLoader.prototype.defaultToonTextures = ['data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII='];

/*
 * Set 'anonymous' for the the texture image file in other domain
 * even if server responds with "Access-Control-Allow-Origin: *"
 * because some image operation fails in MMDLoader.
 */
MMDLoader.prototype.setTextureCrossOrigin = function (value) {

	this.textureCrossOrigin = value;
};

MMDLoader.prototype.load = function (modelUrl, vmdUrls, callback, onProgress, onError) {

	var scope = this;

	this.loadModel(modelUrl, function (mesh) {

		scope.loadVmds(vmdUrls, function (vmd) {

			scope.pourVmdIntoModel(mesh, vmd);
			callback(mesh);
		}, onProgress, onError);
	}, onProgress, onError);
};

MMDLoader.prototype.loadModel = function (url, callback, onProgress, onError) {

	var scope = this;

	var texturePath = THREE.LoaderUtils.extractUrlBase(url);
	var modelExtension = this.extractExtension(url);

	this.loadFileAsBuffer(url, function (buffer) {

		callback(scope.createModel(buffer, modelExtension, texturePath, onProgress, onError));
	}, onProgress, onError);
};

MMDLoader.prototype.createModel = function (buffer, modelExtension, texturePath, onProgress, onError) {

	return this.createMesh(this.parseModel(buffer, modelExtension), texturePath, onProgress, onError);
};

MMDLoader.prototype.loadVmd = function (url, callback, onProgress, onError) {

	var scope = this;

	this.loadFileAsBuffer(url, function (buffer) {

		callback(scope.parseVmd(buffer));
	}, onProgress, onError);
};

MMDLoader.prototype.loadVmds = function (urls, callback, onProgress, onError) {

	var scope = this;

	var vmds = [];
	urls = urls.slice();

	function run() {

		var url = urls.shift();

		scope.loadVmd(url, function (vmd) {

			vmds.push(vmd);

			if (urls.length > 0) {

				run();
			} else {

				callback(scope.mergeVmds(vmds));
			}
		}, onProgress, onError);
	}

	run();
};

MMDLoader.prototype.loadAudio = function (url, callback, onProgress, onError) {

	var listener = new THREE.AudioListener();
	var audio = new THREE.Audio(listener);
	var loader = new THREE.AudioLoader(this.manager);

	loader.load(url, function (buffer) {

		audio.setBuffer(buffer);
		callback(audio, listener);
	}, onProgress, onError);
};

MMDLoader.prototype.loadVpd = function (url, callback, onProgress, onError, params) {

	var scope = this;

	var func = (params && params.charcode === 'unicode' ? this.loadFileAsText : this.loadFileAsShiftJISText).bind(this);

	func(url, function (text) {

		callback(scope.parseVpd(text));
	}, onProgress, onError);
};

MMDLoader.prototype.parseModel = function (buffer, modelExtension) {

	// Should I judge from model data header?
	switch (modelExtension.toLowerCase()) {

		case 'pmd':
			return this.parsePmd(buffer);

		case 'pmx':
			return this.parsePmx(buffer);

		default:
			throw 'extension ' + modelExtension + ' is not supported.';

	}
};

MMDLoader.prototype.parsePmd = function (buffer) {

	return this.parser.parsePmd(buffer, true);
};

MMDLoader.prototype.parsePmx = function (buffer) {

	return this.parser.parsePmx(buffer, true);
};

MMDLoader.prototype.parseVmd = function (buffer) {

	return this.parser.parseVmd(buffer, true);
};

MMDLoader.prototype.parseVpd = function (text) {

	return this.parser.parseVpd(text, true);
};

MMDLoader.prototype.mergeVmds = function (vmds) {

	return this.parser.mergeVmds(vmds);
};

MMDLoader.prototype.pourVmdIntoModel = function (mesh, vmd, name) {

	this.createAnimation(mesh, vmd, name);
};

MMDLoader.prototype.pourVmdIntoCamera = function (camera, vmd, name) {

	var helper = new MMDLoader.DataCreationHelper();

	var initAnimation = function initAnimation() {

		var orderedMotions = helper.createOrderedMotionArray(vmd.cameras);

		var times = [];
		var centers = [];
		var quaternions = [];
		var positions = [];
		var fovs = [];

		var cInterpolations = [];
		var qInterpolations = [];
		var pInterpolations = [];
		var fInterpolations = [];

		var quaternion = new THREE.Quaternion();
		var euler = new THREE.Euler();
		var position = new THREE.Vector3();
		var center = new THREE.Vector3();

		var pushVector3 = function pushVector3(array, vec) {

			array.push(vec.x);
			array.push(vec.y);
			array.push(vec.z);
		};

		var pushQuaternion = function pushQuaternion(array, q) {

			array.push(q.x);
			array.push(q.y);
			array.push(q.z);
			array.push(q.w);
		};

		var pushInterpolation = function pushInterpolation(array, interpolation, index) {

			array.push(interpolation[index * 4 + 0] / 127); // x1
			array.push(interpolation[index * 4 + 1] / 127); // x2
			array.push(interpolation[index * 4 + 2] / 127); // y1
			array.push(interpolation[index * 4 + 3] / 127); // y2
		};

		var createTrack = function createTrack(node, type, times, values, interpolations) {

			/*
    * optimizes here not to let KeyframeTrackPrototype optimize
    * because KeyframeTrackPrototype optimizes times and values but
    * doesn't optimize interpolations.
    */
			if (times.length > 2) {

				times = times.slice();
				values = values.slice();
				interpolations = interpolations.slice();

				var stride = values.length / times.length;
				var interpolateStride = stride === 3 ? 12 : 4; // 3: Vector3, others: Quaternion or Number

				var index = 1;

				for (var aheadIndex = 2, endIndex = times.length; aheadIndex < endIndex; aheadIndex++) {

					for (var i = 0; i < stride; i++) {

						if (values[index * stride + i] !== values[(index - 1) * stride + i] || values[index * stride + i] !== values[aheadIndex * stride + i]) {

							index++;
							break;
						}
					}

					if (aheadIndex > index) {

						times[index] = times[aheadIndex];

						for (var i = 0; i < stride; i++) {

							values[index * stride + i] = values[aheadIndex * stride + i];
						}

						for (var i = 0; i < interpolateStride; i++) {

							interpolations[index * interpolateStride + i] = interpolations[aheadIndex * interpolateStride + i];
						}
					}
				}

				times.length = index + 1;
				values.length = (index + 1) * stride;
				interpolations.length = (index + 1) * interpolateStride;
			}

			var track = new THREE[type](node, times, values);

			track.createInterpolant = function InterpolantFactoryMethodCubicBezier(result) {

				return new MMDLoader.CubicBezierInterpolation(this.times, this.values, this.getValueSize(), result, new Float32Array(interpolations));
			};

			return track;
		};

		for (var i = 0; i < orderedMotions.length; i++) {

			var m = orderedMotions[i];

			var time = m.frameNum / 30;
			var pos = m.position;
			var rot = m.rotation;
			var distance = m.distance;
			var fov = m.fov;
			var interpolation = m.interpolation;

			position.set(0, 0, -distance);
			center.set(pos[0], pos[1], pos[2]);

			euler.set(-rot[0], -rot[1], -rot[2]);
			quaternion.setFromEuler(euler);

			position.add(center);
			position.applyQuaternion(quaternion);

			times.push(time);

			pushVector3(centers, center);
			pushQuaternion(quaternions, quaternion);
			pushVector3(positions, position);

			fovs.push(fov);

			for (var j = 0; j < 3; j++) {

				pushInterpolation(cInterpolations, interpolation, j);
			}

			pushInterpolation(qInterpolations, interpolation, 3);

			// use same one parameter for x, y, z axis.
			for (var j = 0; j < 3; j++) {

				pushInterpolation(pInterpolations, interpolation, 4);
			}

			pushInterpolation(fInterpolations, interpolation, 5);
		}

		if (times.length === 0) return;

		var tracks = [];

		tracks.push(createTrack('.center', 'VectorKeyframeTrack', times, centers, cInterpolations));
		tracks.push(createTrack('.quaternion', 'QuaternionKeyframeTrack', times, quaternions, qInterpolations));
		tracks.push(createTrack('.position', 'VectorKeyframeTrack', times, positions, pInterpolations));
		tracks.push(createTrack('.fov', 'NumberKeyframeTrack', times, fovs, fInterpolations));

		var clip = new THREE.AnimationClip(name === undefined ? THREE.Math.generateUUID() : name, -1, tracks);

		if (camera.center === undefined) camera.center = new THREE.Vector3(0, 0, 0);
		if (camera.animations === undefined) camera.animations = [];
		camera.animations.push(clip);
	};

	initAnimation();
};

MMDLoader.prototype.extractExtension = function (url) {

	var index = url.lastIndexOf('.');

	if (index < 0) {

		return null;
	}

	return url.slice(index + 1);
};

MMDLoader.prototype.loadFile = function (url, onLoad, onProgress, onError, responseType, mimeType) {

	var loader = new THREE.FileLoader(this.manager);

	if (mimeType !== undefined) loader.setMimeType(mimeType);

	loader.setResponseType(responseType);

	var request = loader.load(url, function (result) {

		onLoad(result);
	}, onProgress, onError);

	return request;
};

MMDLoader.prototype.loadFileAsBuffer = function (url, onLoad, onProgress, onError) {

	this.loadFile(url, onLoad, onProgress, onError, 'arraybuffer');
};

MMDLoader.prototype.loadFileAsText = function (url, onLoad, onProgress, onError) {

	this.loadFile(url, onLoad, onProgress, onError, 'text');
};

MMDLoader.prototype.loadFileAsShiftJISText = function (url, onLoad, onProgress, onError) {

	this.loadFile(url, onLoad, onProgress, onError, 'text', 'text/plain; charset=shift_jis');
};

MMDLoader.prototype.createMesh = function (model, texturePath, onProgress, onError) {

	var scope = this;
	var geometry = new THREE.BufferGeometry();
	var materials = [];

	var buffer = {};

	buffer.vertices = [];
	buffer.uvs = [];
	buffer.normals = [];
	buffer.skinIndices = [];
	buffer.skinWeights = [];
	buffer.indices = [];

	var initVartices = function initVartices() {

		for (var i = 0; i < model.metadata.vertexCount; i++) {

			var v = model.vertices[i];

			for (var j = 0, jl = v.position.length; j < jl; j++) {

				buffer.vertices.push(v.position[j]);
			}

			for (var j = 0, jl = v.normal.length; j < jl; j++) {

				buffer.normals.push(v.normal[j]);
			}

			for (var j = 0, jl = v.uv.length; j < jl; j++) {

				buffer.uvs.push(v.uv[j]);
			}

			for (var j = 0; j < 4; j++) {

				buffer.skinIndices.push(v.skinIndices.length - 1 >= j ? v.skinIndices[j] : 0.0);
			}

			for (var j = 0; j < 4; j++) {

				buffer.skinWeights.push(v.skinWeights.length - 1 >= j ? v.skinWeights[j] : 0.0);
			}
		}
	};

	var initFaces = function initFaces() {

		for (var i = 0; i < model.metadata.faceCount; i++) {

			var f = model.faces[i];

			for (var j = 0, jl = f.indices.length; j < jl; j++) {

				buffer.indices.push(f.indices[j]);
			}
		}
	};

	var initBones = function initBones() {

		var bones = [];

		var rigidBodies = model.rigidBodies;
		var dictionary = {};

		for (var i = 0, il = rigidBodies.length; i < il; i++) {

			var body = rigidBodies[i];
			var value = dictionary[body.boneIndex];

			// keeps greater number if already value is set without any special reasons
			value = value === undefined ? body.type : Math.max(body.type, value);

			dictionary[body.boneIndex] = value;
		}

		for (var i = 0; i < model.metadata.boneCount; i++) {

			var bone = {};
			var b = model.bones[i];

			bone.parent = b.parentIndex;
			bone.name = b.name;
			bone.pos = [b.position[0], b.position[1], b.position[2]];
			bone.rotq = [0, 0, 0, 1];
			bone.scl = [1, 1, 1];

			if (bone.parent !== -1) {

				bone.pos[0] -= model.bones[bone.parent].position[0];
				bone.pos[1] -= model.bones[bone.parent].position[1];
				bone.pos[2] -= model.bones[bone.parent].position[2];
			}

			bone.rigidBodyType = dictionary[i] !== undefined ? dictionary[i] : -1;

			bones.push(bone);
		}

		geometry.bones = bones;
	};

	var initIKs = function initIKs() {

		var iks = [];

		// TODO: remove duplicated codes between PMD and PMX
		if (model.metadata.format === 'pmd') {

			for (var i = 0; i < model.metadata.ikCount; i++) {

				var ik = model.iks[i];
				var param = {};

				param.target = ik.target;
				param.effector = ik.effector;
				param.iteration = ik.iteration;
				param.maxAngle = ik.maxAngle * 4;
				param.links = [];

				for (var j = 0; j < ik.links.length; j++) {

					var link = {};
					link.index = ik.links[j].index;

					if (model.bones[link.index].name.indexOf('ひざ') >= 0) {

						link.limitation = new THREE.Vector3(1.0, 0.0, 0.0);
					}

					param.links.push(link);
				}

				iks.push(param);
			}
		} else {

			for (var i = 0; i < model.metadata.boneCount; i++) {

				var b = model.bones[i];
				var ik = b.ik;

				if (ik === undefined) {

					continue;
				}

				var param = {};

				param.target = i;
				param.effector = ik.effector;
				param.iteration = ik.iteration;
				param.maxAngle = ik.maxAngle;
				param.links = [];

				for (var j = 0; j < ik.links.length; j++) {

					var link = {};
					link.index = ik.links[j].index;
					link.enabled = true;

					if (ik.links[j].angleLimitation === 1) {

						link.limitation = new THREE.Vector3(1.0, 0.0, 0.0);
						// TODO: use limitation angles
						// link.lowerLimitationAngle;
						// link.upperLimitationAngle;
					}

					param.links.push(link);
				}

				iks.push(param);
			}
		}

		geometry.iks = iks;
	};

	var initGrants = function initGrants() {

		if (model.metadata.format === 'pmd') {

			return;
		}

		var grants = [];

		for (var i = 0; i < model.metadata.boneCount; i++) {

			var b = model.bones[i];
			var grant = b.grant;

			if (grant === undefined) {

				continue;
			}

			var param = {};

			param.index = i;
			param.parentIndex = grant.parentIndex;
			param.ratio = grant.ratio;
			param.isLocal = grant.isLocal;
			param.affectRotation = grant.affectRotation;
			param.affectPosition = grant.affectPosition;
			param.transformationClass = b.transformationClass;

			grants.push(param);
		}

		grants.sort(function (a, b) {

			return a.transformationClass - b.transformationClass;
		});

		geometry.grants = grants;
	};

	var initMorphs = function initMorphs() {

		function updateVertex(attribute, index, v, ratio) {

			attribute.array[index * 3 + 0] += v.position[0] * ratio;
			attribute.array[index * 3 + 1] += v.position[1] * ratio;
			attribute.array[index * 3 + 2] += v.position[2] * ratio;
		}

		function updateVertices(attribute, m, ratio) {

			for (var i = 0; i < m.elementCount; i++) {

				var v = m.elements[i];

				var index;

				if (model.metadata.format === 'pmd') {

					index = model.morphs[0].elements[v.index].index;
				} else {

					index = v.index;
				}

				updateVertex(attribute, index, v, ratio);
			}
		}

		var morphTargets = [];
		var attributes = [];

		for (var i = 0; i < model.metadata.morphCount; i++) {

			var m = model.morphs[i];
			var params = { name: m.name };

			var attribute = new THREE.Float32BufferAttribute(model.metadata.vertexCount * 3, 3);
			attribute.name = m.name;

			for (var j = 0; j < model.metadata.vertexCount * 3; j++) {

				attribute.array[j] = buffer.vertices[j];
			}

			if (model.metadata.format === 'pmd') {

				if (i !== 0) {

					updateVertices(attribute, m, 1.0);
				}
			} else {

				if (m.type === 0) {
					// group

					for (var j = 0; j < m.elementCount; j++) {

						var m2 = model.morphs[m.elements[j].index];
						var ratio = m.elements[j].ratio;

						if (m2.type === 1) {

							updateVertices(attribute, m2, ratio);
						} else {

							// TODO: implement

						}
					}
				} else if (m.type === 1) {
					// vertex

					updateVertices(attribute, m, 1.0);
				} else if (m.type === 2) {// bone

					// TODO: implement

				} else if (m.type === 3) {// uv

					// TODO: implement

				} else if (m.type === 4) {// additional uv1

					// TODO: implement

				} else if (m.type === 5) {// additional uv2

					// TODO: implement

				} else if (m.type === 6) {// additional uv3

					// TODO: implement

				} else if (m.type === 7) {// additional uv4

					// TODO: implement

				} else if (m.type === 8) {// material

					// TODO: implement

				}
			}

			morphTargets.push(params);
			attributes.push(attribute);
		}

		geometry.morphTargets = morphTargets;
		geometry.morphAttributes.position = attributes;
	};

	var initMaterials = function initMaterials() {

		var textures = {};
		var textureLoader = new THREE.TextureLoader(scope.manager);
		var tgaLoader = new THREE.TGALoader(scope.manager);
		var canvas = document.createElement('canvas');
		var context = canvas.getContext('2d');
		var offset = 0;
		var materialParams = [];

		if (scope.textureCrossOrigin !== null) textureLoader.setCrossOrigin(scope.textureCrossOrigin);

		function loadTexture(filePath, params) {

			if (params === undefined) {

				params = {};
			}

			var fullPath;

			if (params.defaultTexturePath === true) {

				try {

					fullPath = scope.defaultToonTextures[parseInt(filePath.match('toon([0-9]{2})\.bmp$')[1])];
				} catch (e) {

					console.warn('THREE.MMDLoader: ' + filePath + ' seems like not right default texture path. Using toon00.bmp instead.');
					fullPath = scope.defaultToonTextures[0];
				}
			} else {

				fullPath = texturePath + filePath;
			}

			if (textures[fullPath] !== undefined) return fullPath;

			var loader = THREE.Loader.Handlers.get(fullPath);

			if (loader === null) {

				loader = filePath.indexOf('.tga') >= 0 ? tgaLoader : textureLoader;
			}

			var texture = loader.load(fullPath, function (t) {

				// MMD toon texture is Axis-Y oriented
				// but Three.js gradient map is Axis-X oriented.
				// So here replaces the toon texture image with the rotated one.
				if (params.isToonTexture === true) {

					var image = t.image;
					var width = image.width;
					var height = image.height;

					canvas.width = width;
					canvas.height = height;

					context.clearRect(0, 0, width, height);
					context.translate(width / 2.0, height / 2.0);
					context.rotate(0.5 * Math.PI); // 90.0 * Math.PI / 180.0
					context.translate(-width / 2.0, -height / 2.0);
					context.drawImage(image, 0, 0);

					t.image = context.getImageData(0, 0, width, height);
				}

				t.flipY = false;
				t.wrapS = THREE.RepeatWrapping;
				t.wrapT = THREE.RepeatWrapping;

				for (var i = 0; i < texture.readyCallbacks.length; i++) {

					texture.readyCallbacks[i](texture);
				}

				delete texture.readyCallbacks;
			}, onProgress, onError);

			if (params.sphericalReflectionMapping === true) {

				texture.mapping = THREE.SphericalReflectionMapping;
			}

			texture.readyCallbacks = [];

			textures[fullPath] = texture;

			return fullPath;
		}

		function getTexture(name, textures) {

			if (textures[name] === undefined) {

				console.warn('THREE.MMDLoader: Undefined texture', name);
			}

			return textures[name];
		}

		for (var i = 0; i < model.metadata.materialCount; i++) {

			var m = model.materials[i];
			var params = {};

			params.faceOffset = offset;
			params.faceNum = m.faceCount;

			offset += m.faceCount;

			params.name = m.name;

			/*
    * Color
    *
    * MMD         MeshToonMaterial
    * diffuse  -  color
    * specular -  specular
    * ambient  -  emissive * a
    *               (a = 1.0 without map texture or 0.2 with map texture)
    *
    * MeshToonMaterial doesn't have ambient. Set it to emissive instead.
    * It'll be too bright if material has map texture so using coef 0.2.
    */
			params.color = new THREE.Color(m.diffuse[0], m.diffuse[1], m.diffuse[2]);
			params.opacity = m.diffuse[3];
			params.specular = new THREE.Color(m.specular[0], m.specular[1], m.specular[2]);
			params.shininess = m.shininess;

			if (params.opacity === 1.0) {

				params.side = THREE.FrontSide;
				params.transparent = false;
			} else {

				params.side = THREE.DoubleSide;
				params.transparent = true;
			}

			if (model.metadata.format === 'pmd') {

				if (m.fileName) {

					var fileName = m.fileName;
					var fileNames = [];

					var index = fileName.lastIndexOf('*');

					if (index >= 0) {

						fileNames.push(fileName.slice(0, index));
						fileNames.push(fileName.slice(index + 1));
					} else {

						fileNames.push(fileName);
					}

					for (var j = 0; j < fileNames.length; j++) {

						var n = fileNames[j];

						if (n.indexOf('.sph') >= 0 || n.indexOf('.spa') >= 0) {

							params.envMap = loadTexture(n, { sphericalReflectionMapping: true });

							if (n.indexOf('.sph') >= 0) {

								params.envMapType = THREE.MultiplyOperation;
							} else {

								params.envMapType = THREE.AddOperation;
							}
						} else {

							params.map = loadTexture(n);
						}
					}
				}
			} else {

				if (m.textureIndex !== -1) {

					var n = model.textures[m.textureIndex];
					params.map = loadTexture(n);
				}

				// TODO: support m.envFlag === 3
				if (m.envTextureIndex !== -1 && (m.envFlag === 1 || m.envFlag == 2)) {

					var n = model.textures[m.envTextureIndex];
					params.envMap = loadTexture(n, { sphericalReflectionMapping: true });

					if (m.envFlag === 1) {

						params.envMapType = THREE.MultiplyOperation;
					} else {

						params.envMapType = THREE.AddOperation;
					}
				}
			}

			var coef = params.map === undefined ? 1.0 : 0.2;
			params.emissive = new THREE.Color(m.ambient[0] * coef, m.ambient[1] * coef, m.ambient[2] * coef);

			materialParams.push(params);
		}

		for (var i = 0; i < materialParams.length; i++) {

			var p = materialParams[i];
			var p2 = model.materials[i];
			var m = new THREE.MeshToonMaterial();

			geometry.addGroup(p.faceOffset * 3, p.faceNum * 3, i);

			if (p.name !== undefined) m.name = p.name;

			m.skinning = geometry.bones.length > 0 ? true : false;
			m.morphTargets = geometry.morphTargets.length > 0 ? true : false;
			m.lights = true;
			m.side = model.metadata.format === 'pmx' && (p2.flag & 0x1) === 1 ? THREE.DoubleSide : p.side;
			m.transparent = p.transparent;
			m.fog = true;

			m.blending = THREE.CustomBlending;
			m.blendSrc = THREE.SrcAlphaFactor;
			m.blendDst = THREE.OneMinusSrcAlphaFactor;
			m.blendSrcAlpha = THREE.SrcAlphaFactor;
			m.blendDstAlpha = THREE.DstAlphaFactor;

			if (p.map !== undefined) {

				// Check if this part of the texture image the material uses requires transparency
				var checkTextureTransparency = function checkTextureTransparency(m) {

					m.map.readyCallbacks.push(function (t) {

						// Is there any efficient ways?
						function createImageData(image) {

							var c = document.createElement('canvas');
							c.width = image.width;
							c.height = image.height;

							var ctx = c.getContext('2d');
							ctx.drawImage(image, 0, 0);

							return ctx.getImageData(0, 0, c.width, c.height);
						}

						function detectTextureTransparency(image, uvs, indices) {

							var width = image.width;
							var height = image.height;
							var data = image.data;
							var threshold = 253;

							if (data.length / (width * height) !== 4) {

								return false;
							}

							for (var i = 0; i < indices.length; i += 3) {

								var centerUV = { x: 0.0, y: 0.0 };

								for (var j = 0; j < 3; j++) {

									var index = indices[i * 3 + j];
									var uv = { x: uvs[index * 2 + 0], y: uvs[index * 2 + 1] };

									if (getAlphaByUv(image, uv) < threshold) {

										return true;
									}

									centerUV.x += uv.x;
									centerUV.y += uv.y;
								}

								centerUV.x /= 3;
								centerUV.y /= 3;

								if (getAlphaByUv(image, centerUV) < threshold) {

									return true;
								}
							}

							return false;
						}

						/*
       * This method expects
       *   t.flipY = false
       *   t.wrapS = THREE.RepeatWrapping
       *   t.wrapT = THREE.RepeatWrapping
       * TODO: more precise
       */
						function getAlphaByUv(image, uv) {

							var width = image.width;
							var height = image.height;

							var x = Math.round(uv.x * width) % width;
							var y = Math.round(uv.y * height) % height;

							if (x < 0) {

								x += width;
							}

							if (y < 0) {

								y += height;
							}

							var index = y * width + x;

							return image.data[index * 4 + 3];
						}

						var imageData = t.image.data !== undefined ? t.image : createImageData(t.image);
						var indices = geometry.index.array.slice(m.faceOffset * 3, m.faceOffset * 3 + m.faceNum * 3);

						if (detectTextureTransparency(imageData, geometry.attributes.uv.array, indices)) m.transparent = true;

						delete m.faceOffset;
						delete m.faceNum;
					});
				};

				m.faceOffset = p.faceOffset;
				m.faceNum = p.faceNum;

				m.map = getTexture(p.map, textures);
				checkTextureTransparency(m);
			}

			if (p.envMap !== undefined) {

				m.envMap = getTexture(p.envMap, textures);
				m.combine = p.envMapType;
			}

			m.opacity = p.opacity;
			m.color = p.color;

			if (p.emissive !== undefined) {

				m.emissive = p.emissive;
			}

			m.specular = p.specular;
			m.shininess = Math.max(p.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )

			if (model.metadata.format === 'pmd') {
				var isDefaultToonTexture = function isDefaultToonTexture(n) {

					if (n.length !== 10) {

						return false;
					}

					return n.match(/toon(10|0[0-9]).bmp/) === null ? false : true;
				};

				// parameters for OutlineEffect


				m.outlineParameters = {
					thickness: p2.edgeFlag === 1 ? 0.003 : 0.0,
					color: new THREE.Color(0.0, 0.0, 0.0),
					alpha: 1.0
				};

				if (m.outlineParameters.thickness === 0.0) m.outlineParameters.visible = false;

				var toonFileName = p2.toonIndex === -1 ? 'toon00.bmp' : model.toonTextures[p2.toonIndex].fileName;
				var uuid = loadTexture(toonFileName, { isToonTexture: true, defaultTexturePath: isDefaultToonTexture(toonFileName) });
				m.gradientMap = getTexture(uuid, textures);
			} else {

				// parameters for OutlineEffect
				m.outlineParameters = {
					thickness: p2.edgeSize / 300,
					color: new THREE.Color(p2.edgeColor[0], p2.edgeColor[1], p2.edgeColor[2]),
					alpha: p2.edgeColor[3]
				};

				if ((p2.flag & 0x10) === 0 || m.outlineParameters.thickness === 0.0) m.outlineParameters.visible = false;

				var toonFileName, isDefaultToon;

				if (p2.toonIndex === -1 || p2.toonFlag !== 0) {

					var num = p2.toonIndex + 1;
					toonFileName = 'toon' + (num < 10 ? '0' + num : num) + '.bmp';
					isDefaultToon = true;
				} else {

					toonFileName = model.textures[p2.toonIndex];
					isDefaultToon = false;
				}

				var uuid = loadTexture(toonFileName, { isToonTexture: true, defaultTexturePath: isDefaultToon });
				m.gradientMap = getTexture(uuid, textures);
			}

			materials.push(m);
		}

		if (model.metadata.format === 'pmx') {
			var checkAlphaMorph = function checkAlphaMorph(morph, elements) {

				if (morph.type !== 8) {

					return;
				}

				for (var i = 0; i < elements.length; i++) {

					var e = elements[i];

					if (e.index === -1) {

						continue;
					}

					var m = materials[e.index];

					if (m.opacity !== e.diffuse[3]) {

						m.transparent = true;
					}
				}
			};

			for (var i = 0; i < model.morphs.length; i++) {

				var morph = model.morphs[i];
				var elements = morph.elements;

				if (morph.type === 0) {

					for (var j = 0; j < elements.length; j++) {

						var morph2 = model.morphs[elements[j].index];
						var elements2 = morph2.elements;

						checkAlphaMorph(morph2, elements2);
					}
				} else {

					checkAlphaMorph(morph, elements);
				}
			}
		}
	};

	var initPhysics = function initPhysics() {

		var rigidBodies = [];
		var constraints = [];

		for (var i = 0; i < model.metadata.rigidBodyCount; i++) {

			var b = model.rigidBodies[i];
			var keys = Object.keys(b);

			var p = {};

			for (var j = 0; j < keys.length; j++) {

				var key = keys[j];
				p[key] = b[key];
			}

			/*
    * RigidBody position parameter in PMX seems global position
    * while the one in PMD seems offset from corresponding bone.
    * So unify being offset.
    */
			if (model.metadata.format === 'pmx') {

				if (p.boneIndex !== -1) {

					var bone = model.bones[p.boneIndex];
					p.position[0] -= bone.position[0];
					p.position[1] -= bone.position[1];
					p.position[2] -= bone.position[2];
				}
			}

			rigidBodies.push(p);
		}

		for (var i = 0; i < model.metadata.constraintCount; i++) {

			var c = model.constraints[i];
			var keys = Object.keys(c);

			var p = {};

			for (var j = 0; j < keys.length; j++) {

				var key = keys[j];
				p[key] = c[key];
			}

			var bodyA = rigidBodies[p.rigidBodyIndex1];
			var bodyB = rigidBodies[p.rigidBodyIndex2];

			/*
    * Refer to http://www20.atpages.jp/katwat/wp/?p=4135
    */
			if (bodyA.type !== 0 && bodyB.type === 2) {

				if (bodyA.boneIndex !== -1 && bodyB.boneIndex !== -1 && model.bones[bodyB.boneIndex].parentIndex === bodyA.boneIndex) {

					bodyB.type = 1;
				}
			}

			constraints.push(p);
		}

		geometry.rigidBodies = rigidBodies;
		geometry.constraints = constraints;
	};

	var initGeometry = function initGeometry() {

		geometry.setIndex(buffer.indices);
		geometry.addAttribute('position', new THREE.Float32BufferAttribute(buffer.vertices, 3));
		geometry.addAttribute('normal', new THREE.Float32BufferAttribute(buffer.normals, 3));
		geometry.addAttribute('uv', new THREE.Float32BufferAttribute(buffer.uvs, 2));
		geometry.addAttribute('skinIndex', new THREE.Uint16BufferAttribute(buffer.skinIndices, 4));
		geometry.addAttribute('skinWeight', new THREE.Float32BufferAttribute(buffer.skinWeights, 4));

		geometry.computeBoundingSphere();
		geometry.mmdFormat = model.metadata.format;
	};

	initVartices();
	initFaces();
	initBones();
	initIKs();
	initGrants();
	initMorphs();
	initMaterials();
	initPhysics();
	initGeometry();

	var mesh = new THREE.SkinnedMesh(geometry, materials);

	// console.log( mesh ); // for console debug

	return mesh;
};

MMDLoader.prototype.createAnimation = function (mesh, vmd, name) {

	var helper = new MMDLoader.DataCreationHelper();

	var initMotionAnimations = function initMotionAnimations() {

		if (vmd.metadata.motionCount === 0) {

			return;
		}

		var bones = mesh.geometry.bones;
		var orderedMotions = helper.createOrderedMotionArrays(bones, vmd.motions, 'boneName');

		var tracks = [];

		var pushInterpolation = function pushInterpolation(array, interpolation, index) {

			array.push(interpolation[index + 0] / 127); // x1
			array.push(interpolation[index + 8] / 127); // x2
			array.push(interpolation[index + 4] / 127); // y1
			array.push(interpolation[index + 12] / 127); // y2
		};

		var createTrack = function createTrack(node, type, times, values, interpolations) {

			var track = new THREE[type](node, times, values);

			track.createInterpolant = function InterpolantFactoryMethodCubicBezier(result) {

				return new MMDLoader.CubicBezierInterpolation(this.times, this.values, this.getValueSize(), result, new Float32Array(interpolations));
			};

			return track;
		};

		for (var i = 0; i < orderedMotions.length; i++) {

			var times = [];
			var positions = [];
			var rotations = [];
			var pInterpolations = [];
			var rInterpolations = [];

			var bone = bones[i];
			var array = orderedMotions[i];

			for (var j = 0; j < array.length; j++) {

				var time = array[j].frameNum / 30;
				var pos = array[j].position;
				var rot = array[j].rotation;
				var interpolation = array[j].interpolation;

				times.push(time);

				for (var k = 0; k < 3; k++) {

					positions.push(bone.pos[k] + pos[k]);
				}

				for (var k = 0; k < 4; k++) {

					rotations.push(rot[k]);
				}

				for (var k = 0; k < 3; k++) {

					pushInterpolation(pInterpolations, interpolation, k);
				}

				pushInterpolation(rInterpolations, interpolation, 3);
			}

			if (times.length === 0) continue;

			var boneName = '.bones[' + bone.name + ']';

			tracks.push(createTrack(boneName + '.position', 'VectorKeyframeTrack', times, positions, pInterpolations));
			tracks.push(createTrack(boneName + '.quaternion', 'QuaternionKeyframeTrack', times, rotations, rInterpolations));
		}

		var clip = new THREE.AnimationClip(name === undefined ? THREE.Math.generateUUID() : name, -1, tracks);

		if (mesh.geometry.animations === undefined) mesh.geometry.animations = [];
		mesh.geometry.animations.push(clip);
	};

	var initMorphAnimations = function initMorphAnimations() {

		if (vmd.metadata.morphCount === 0) {

			return;
		}

		var orderedMorphs = helper.createOrderedMotionArrays(mesh.geometry.morphTargets, vmd.morphs, 'morphName');

		var tracks = [];

		for (var i = 0; i < orderedMorphs.length; i++) {

			var times = [];
			var values = [];
			var array = orderedMorphs[i];

			for (var j = 0; j < array.length; j++) {

				times.push(array[j].frameNum / 30);
				values.push(array[j].weight);
			}

			if (times.length === 0) continue;

			tracks.push(new THREE.NumberKeyframeTrack('.morphTargetInfluences[' + i + ']', times, values));
		}

		var clip = new THREE.AnimationClip(name === undefined ? THREE.Math.generateUUID() : name + 'Morph', -1, tracks);

		if (mesh.geometry.animations === undefined) mesh.geometry.animations = [];
		mesh.geometry.animations.push(clip);
	};

	initMotionAnimations();
	initMorphAnimations();
};

MMDLoader.DataCreationHelper = function () {};

MMDLoader.DataCreationHelper.prototype = {

	constructor: MMDLoader.DataCreationHelper,

	/*
  * Note: Sometimes to use Japanese Unicode characters runs into problems in Three.js.
  *       In such a case, use this method to convert it to Unicode hex charcode strings,
  *       like 'あいう' -> '0x30420x30440x3046'
  */

	toCharcodeStrings: function toCharcodeStrings(s) {

		var str = '';

		for (var i = 0; i < s.length; i++) {

			str += '0x' + ('0000' + s[i].charCodeAt().toString(16)).substr(-4);
		}

		return str;
	},

	createDictionary: function createDictionary(array) {

		var dict = {};

		for (var i = 0; i < array.length; i++) {

			dict[array[i].name] = i;
		}

		return dict;
	},

	initializeMotionArrays: function initializeMotionArrays(array) {

		var result = [];

		for (var i = 0; i < array.length; i++) {

			result[i] = [];
		}

		return result;
	},

	sortMotionArray: function sortMotionArray(array) {

		array.sort(function (a, b) {

			return a.frameNum - b.frameNum;
		});
	},

	sortMotionArrays: function sortMotionArrays(arrays) {

		for (var i = 0; i < arrays.length; i++) {

			this.sortMotionArray(arrays[i]);
		}
	},

	createMotionArray: function createMotionArray(array) {

		var result = [];

		for (var i = 0; i < array.length; i++) {

			result.push(array[i]);
		}

		return result;
	},

	createMotionArrays: function createMotionArrays(array, result, dict, key) {

		for (var i = 0; i < array.length; i++) {

			var a = array[i];
			var num = dict[a[key]];

			if (num === undefined) {

				continue;
			}

			result[num].push(a);
		}
	},

	createOrderedMotionArray: function createOrderedMotionArray(array) {

		var result = this.createMotionArray(array);
		this.sortMotionArray(result);
		return result;
	},

	createOrderedMotionArrays: function createOrderedMotionArrays(targetArray, motionArray, key) {

		var dict = this.createDictionary(targetArray);
		var result = this.initializeMotionArrays(targetArray);
		this.createMotionArrays(motionArray, result, dict, key);
		this.sortMotionArrays(result);

		return result;
	}

};

MMDLoader.CubicBezierInterpolation = function (parameterPositions, sampleValues, sampleSize, resultBuffer, params) {

	THREE.Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);

	this.params = params;
};

MMDLoader.CubicBezierInterpolation.prototype = Object.create(THREE.LinearInterpolant.prototype);
MMDLoader.CubicBezierInterpolation.prototype.constructor = MMDLoader.CubicBezierInterpolation;

MMDLoader.CubicBezierInterpolation.prototype.interpolate_ = function (i1, t0, t, t1) {

	var result = this.resultBuffer;
	var values = this.sampleValues;
	var stride = this.valueSize;

	var offset1 = i1 * stride;
	var offset0 = offset1 - stride;

	// No interpolation if next key frame is in one frame in 30fps. This is from MMD animation spec.
	var weight1 = t1 - t0 < 1 / 30 * 1.5 ? 0.0 : (t - t0) / (t1 - t0);

	if (stride === 4) {
		// Quaternion

		var x1 = this.params[i1 * 4 + 0];
		var x2 = this.params[i1 * 4 + 1];
		var y1 = this.params[i1 * 4 + 2];
		var y2 = this.params[i1 * 4 + 3];

		var ratio = this._calculate(x1, x2, y1, y2, weight1);

		THREE.Quaternion.slerpFlat(result, 0, values, offset0, values, offset1, ratio);
	} else if (stride === 3) {
		// Vector3

		for (var i = 0; i !== stride; ++i) {

			var x1 = this.params[i1 * 12 + i * 4 + 0];
			var x2 = this.params[i1 * 12 + i * 4 + 1];
			var y1 = this.params[i1 * 12 + i * 4 + 2];
			var y2 = this.params[i1 * 12 + i * 4 + 3];

			var ratio = this._calculate(x1, x2, y1, y2, weight1);

			result[i] = values[offset0 + i] * (1 - ratio) + values[offset1 + i] * ratio;
		}
	} else {
		// Number

		var x1 = this.params[i1 * 4 + 0];
		var x2 = this.params[i1 * 4 + 1];
		var y1 = this.params[i1 * 4 + 2];
		var y2 = this.params[i1 * 4 + 3];

		var ratio = this._calculate(x1, x2, y1, y2, weight1);

		result[0] = values[offset0] * (1 - ratio) + values[offset1] * ratio;
	}

	return result;
};

MMDLoader.CubicBezierInterpolation.prototype._calculate = function (x1, x2, y1, y2, x) {

	/*
  * Cubic Bezier curves
  *   https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Cubic_B.C3.A9zier_curves
  *
  * B(t) = ( 1 - t ) ^ 3 * P0
  *      + 3 * ( 1 - t ) ^ 2 * t * P1
  *      + 3 * ( 1 - t ) * t^2 * P2
  *      + t ^ 3 * P3
  *      ( 0 <= t <= 1 )
  *
  * MMD uses Cubic Bezier curves for bone and camera animation interpolation.
  *   http://d.hatena.ne.jp/edvakf/20111016/1318716097
  *
  *    x = ( 1 - t ) ^ 3 * x0
  *      + 3 * ( 1 - t ) ^ 2 * t * x1
  *      + 3 * ( 1 - t ) * t^2 * x2
  *      + t ^ 3 * x3
  *    y = ( 1 - t ) ^ 3 * y0
  *      + 3 * ( 1 - t ) ^ 2 * t * y1
  *      + 3 * ( 1 - t ) * t^2 * y2
  *      + t ^ 3 * y3
  *      ( x0 = 0, y0 = 0 )
  *      ( x3 = 1, y3 = 1 )
  *      ( 0 <= t, x1, x2, y1, y2 <= 1 )
  *
  * Here solves this equation with Bisection method,
  *   https://en.wikipedia.org/wiki/Bisection_method
  * gets t, and then calculate y.
  *
  * f(t) = 3 * ( 1 - t ) ^ 2 * t * x1
  *      + 3 * ( 1 - t ) * t^2 * x2
  *      + t ^ 3 - x = 0
  *
  * (Another option: Newton's method
  *    https://en.wikipedia.org/wiki/Newton%27s_method)
  */

	var c = 0.5;
	var t = c;
	var s = 1.0 - t;
	var loop = 15;
	var eps = 1e-5;
	var math = Math;

	var sst3, stt3, ttt;

	for (var i = 0; i < loop; i++) {

		sst3 = 3.0 * s * s * t;
		stt3 = 3.0 * s * t * t;
		ttt = t * t * t;

		var ft = sst3 * x1 + stt3 * x2 + ttt - x;

		if (math.abs(ft) < eps) break;

		c /= 2.0;

		t += ft < 0 ? c : -c;
		s = 1.0 - t;
	}

	return sst3 * y1 + stt3 * y2 + ttt;
};

THREE.MMDAudioManager = function (audio, listener, p) {

	var params = p === null || p === undefined ? {} : p;

	this.audio = audio;
	this.listener = listener;

	this.elapsedTime = 0.0;
	this.currentTime = 0.0;
	this.delayTime = params.delayTime !== undefined ? params.delayTime : 0.0;

	this.audioDuration = this.audio.buffer.duration;
	this.duration = this.audioDuration + this.delayTime;
};

THREE.MMDAudioManager.prototype = {

	constructor: THREE.MMDAudioManager,

	control: function control(delta) {

		this.elapsed += delta;
		this.currentTime += delta;

		if (this.checkIfStopAudio()) {

			this.audio.stop();
		}

		if (this.checkIfStartAudio()) {

			this.audio.play();
		}
	},

	checkIfStartAudio: function checkIfStartAudio() {

		if (this.audio.isPlaying) {

			return false;
		}

		while (this.currentTime >= this.duration) {

			this.currentTime -= this.duration;
		}

		if (this.currentTime < this.delayTime) {

			return false;
		}

		this.audio.startTime = this.currentTime - this.delayTime;

		return true;
	},

	checkIfStopAudio: function checkIfStopAudio() {

		if (!this.audio.isPlaying) {

			return false;
		}

		if (this.currentTime >= this.duration) {

			return true;
		}

		return false;
	}

};

THREE.MMDGrantSolver = function (mesh) {

	this.mesh = mesh;
};

THREE.MMDGrantSolver.prototype = {

	constructor: THREE.MMDGrantSolver,

	update: function () {

		var q = new THREE.Quaternion();

		return function () {

			for (var i = 0; i < this.mesh.geometry.grants.length; i++) {

				var g = this.mesh.geometry.grants[i];
				var b = this.mesh.skeleton.bones[g.index];
				var pb = this.mesh.skeleton.bones[g.parentIndex];

				if (g.isLocal) {

					// TODO: implement
					if (g.affectPosition) {}

					// TODO: implement
					if (g.affectRotation) {}
				} else {

					// TODO: implement
					if (g.affectPosition) {}

					if (g.affectRotation) {

						q.set(0, 0, 0, 1);
						q.slerp(pb.quaternion, g.ratio);
						b.quaternion.multiply(q);
					}
				}
			}
		};
	}()

};

THREE.MMDHelper = function () {

	this.meshes = [];

	this.doAnimation = true;
	this.doIk = true;
	this.doGrant = true;
	this.doPhysics = true;
	this.doCameraAnimation = true;

	this.sharedPhysics = false;
	this.masterPhysics = null;

	this.audioManager = null;
	this.camera = null;
};

THREE.MMDHelper.prototype = {

	constructor: THREE.MMDHelper,

	add: function add(mesh) {

		if (!(mesh instanceof THREE.SkinnedMesh)) {

			throw new Error('THREE.MMDHelper.add() accepts only THREE.SkinnedMesh instance.');
		}

		if (mesh.mixer === undefined) mesh.mixer = null;
		if (mesh.ikSolver === undefined) mesh.ikSolver = null;
		if (mesh.grantSolver === undefined) mesh.grantSolver = null;
		if (mesh.physics === undefined) mesh.physics = null;
		if (mesh.looped === undefined) mesh.looped = false;

		this.meshes.push(mesh);

		// workaround until I make IK and Physics Animation plugin
		this.initBackupBones(mesh);
	},

	setAudio: function setAudio(audio, listener, params) {

		this.audioManager = new THREE.MMDAudioManager(audio, listener, params);
	},

	setCamera: function setCamera(camera) {

		camera.mixer = null;
		this.camera = camera;
	},

	setPhysicses: function setPhysicses(params) {

		for (var i = 0; i < this.meshes.length; i++) {

			this.setPhysics(this.meshes[i], params);
		}
	},

	setPhysics: function setPhysics(mesh, params) {

		params = params === undefined ? {} : Object.assign({}, params);

		if (params.world === undefined && this.sharedPhysics) {

			var masterPhysics = this.getMasterPhysics();

			if (masterPhysics !== null) params.world = masterPhysics.world;
		}

		var warmup = params.warmup !== undefined ? params.warmup : 60;

		var physics = new THREE.MMDPhysics(mesh, params);

		if (mesh.mixer !== null && mesh.mixer !== undefined && params.preventAnimationWarmup !== true) {

			this.animateOneMesh(0, mesh);
			physics.reset();
		}

		physics.warmup(warmup);

		this.updateIKParametersDependingOnPhysicsEnabled(mesh, true);

		mesh.physics = physics;
	},

	getMasterPhysics: function getMasterPhysics() {

		if (this.masterPhysics !== null) return this.masterPhysics;

		for (var i = 0, il = this.meshes.length; i < il; i++) {

			var physics = this.meshes[i].physics;

			if (physics !== undefined && physics !== null) {

				this.masterPhysics = physics;
				return this.masterPhysics;
			}
		}

		return null;
	},

	enablePhysics: function enablePhysics(enabled) {

		if (enabled === true) {

			this.doPhysics = true;
		} else {

			this.doPhysics = false;
		}

		for (var i = 0, il = this.meshes.length; i < il; i++) {

			this.updateIKParametersDependingOnPhysicsEnabled(this.meshes[i], enabled);
		}
	},

	updateIKParametersDependingOnPhysicsEnabled: function updateIKParametersDependingOnPhysicsEnabled(mesh, physicsEnabled) {

		var iks = mesh.geometry.iks;
		var bones = mesh.geometry.bones;

		for (var j = 0, jl = iks.length; j < jl; j++) {

			var ik = iks[j];
			var links = ik.links;

			for (var k = 0, kl = links.length; k < kl; k++) {

				var link = links[k];

				if (physicsEnabled === true) {

					// disable IK of the bone the corresponding rigidBody type of which is 1 or 2
					// because its rotation will be overriden by physics
					link.enabled = bones[link.index].rigidBodyType > 0 ? false : true;
				} else {

					link.enabled = true;
				}
			}
		}
	},

	setAnimations: function setAnimations() {

		for (var i = 0; i < this.meshes.length; i++) {

			this.setAnimation(this.meshes[i]);
		}
	},

	setAnimation: function setAnimation(mesh) {

		if (mesh.geometry.animations !== undefined) {

			mesh.mixer = new THREE.AnimationMixer(mesh);

			// TODO: find a workaround not to access (seems like) private properties
			//       the name of them begins with "_".
			mesh.mixer.addEventListener('loop', function (e) {

				if (e.action._clip.tracks.length > 0 && e.action._clip.tracks[0].name.indexOf('.bones') !== 0) return;

				var mesh = e.target._root;
				mesh.looped = true;
			});

			var foundAnimation = false;
			var foundMorphAnimation = false;

			for (var i = 0; i < mesh.geometry.animations.length; i++) {

				var clip = mesh.geometry.animations[i];

				var action = mesh.mixer.clipAction(clip);

				if (clip.tracks.length > 0 && clip.tracks[0].name.indexOf('.morphTargetInfluences') === 0) {

					if (!foundMorphAnimation) {

						action.play();
						foundMorphAnimation = true;
					}
				} else {

					if (!foundAnimation) {

						action.play();
						foundAnimation = true;
					}
				}
			}

			if (foundAnimation) {

				mesh.ikSolver = new THREE.CCDIKSolver(mesh);

				if (mesh.geometry.grants !== undefined) {

					mesh.grantSolver = new THREE.MMDGrantSolver(mesh);
				}
			}
		}
	},

	setCameraAnimation: function setCameraAnimation(camera) {

		if (camera.animations !== undefined) {

			camera.mixer = new THREE.AnimationMixer(camera);
			camera.mixer.clipAction(camera.animations[0]).play();
		}
	},

	/*
  * detect the longest duration among model, camera, and audio animations and then
  * set it to them to sync.
  * TODO: touching private properties ( ._actions and ._clip ) so consider better way
  *       to access them for safe and modularity.
  */
	unifyAnimationDuration: function unifyAnimationDuration(params) {

		params = params === undefined ? {} : params;

		var max = 0.0;

		var camera = this.camera;
		var audioManager = this.audioManager;

		// check the longest duration
		for (var i = 0; i < this.meshes.length; i++) {

			var mesh = this.meshes[i];
			var mixer = mesh.mixer;

			if (mixer === null) {

				continue;
			}

			for (var j = 0; j < mixer._actions.length; j++) {

				var action = mixer._actions[j];
				max = Math.max(max, action._clip.duration);
			}
		}

		if (camera !== null && camera.mixer !== null) {

			var mixer = camera.mixer;

			for (var i = 0; i < mixer._actions.length; i++) {

				var action = mixer._actions[i];
				max = Math.max(max, action._clip.duration);
			}
		}

		if (audioManager !== null) {

			max = Math.max(max, audioManager.duration);
		}

		if (params.afterglow !== undefined) {

			max += params.afterglow;
		}

		// set the duration
		for (var i = 0; i < this.meshes.length; i++) {

			var mesh = this.meshes[i];
			var mixer = mesh.mixer;

			if (mixer === null) {

				continue;
			}

			for (var j = 0; j < mixer._actions.length; j++) {

				var action = mixer._actions[j];
				action._clip.duration = max;
			}
		}

		if (camera !== null && camera.mixer !== null) {

			var mixer = camera.mixer;

			for (var i = 0; i < mixer._actions.length; i++) {

				var action = mixer._actions[i];
				action._clip.duration = max;
			}
		}

		if (audioManager !== null) {

			audioManager.duration = max;
		}
	},

	controlAudio: function controlAudio(delta) {

		if (this.audioManager === null) {

			return;
		}

		this.audioManager.control(delta);
	},

	animate: function animate(delta) {

		this.controlAudio(delta);

		for (var i = 0; i < this.meshes.length; i++) {

			this.animateOneMesh(delta, this.meshes[i]);
		}

		if (this.sharedPhysics) this.updateSharedPhysics(delta);

		this.animateCamera(delta);
	},

	animateOneMesh: function animateOneMesh(delta, mesh) {

		var mixer = mesh.mixer;
		var ikSolver = mesh.ikSolver;
		var grantSolver = mesh.grantSolver;
		var physics = mesh.physics;

		if (mixer !== null && this.doAnimation === true) {

			// restore/backupBones are workaround
			// until I make IK, Grant, and Physics Animation plugin
			this.restoreBones(mesh);

			mixer.update(delta);

			this.backupBones(mesh);
		}

		if (ikSolver !== null && this.doIk === true) {

			ikSolver.update();
		}

		if (grantSolver !== null && this.doGrant === true) {

			grantSolver.update();
		}

		if (mesh.looped === true) {

			if (physics !== null) physics.reset();

			mesh.looped = false;
		}

		if (physics !== null && this.doPhysics && !this.sharedPhysics) {

			physics.update(delta);
		}
	},

	updateSharedPhysics: function updateSharedPhysics(delta) {

		if (this.meshes.length === 0 || !this.doPhysics || !this.sharedPhysics) return;

		var physics = this.getMasterPhysics();

		if (physics === null) return;

		for (var i = 0, il = this.meshes.length; i < il; i++) {

			var p = this.meshes[i].physics;

			if (p !== null && p !== undefined) {

				p.updateRigidBodies();
			}
		}

		physics.stepSimulation(delta);

		for (var i = 0, il = this.meshes.length; i < il; i++) {

			var p = this.meshes[i].physics;

			if (p !== null && p !== undefined) {

				p.updateBones();
			}
		}
	},

	animateCamera: function animateCamera(delta) {

		if (this.camera === null) {

			return;
		}

		var mixer = this.camera.mixer;

		if (mixer !== null && this.camera.center !== undefined && this.doCameraAnimation === true) {

			mixer.update(delta);

			// TODO: Let PerspectiveCamera automatically update?
			this.camera.updateProjectionMatrix();

			this.camera.up.set(0, 1, 0);
			this.camera.up.applyQuaternion(this.camera.quaternion);
			this.camera.lookAt(this.camera.center);
		}
	},

	poseAsVpd: function poseAsVpd(mesh, vpd, params) {

		if (params === undefined) params = {};

		if (params.preventResetPose !== true) mesh.pose();

		var bones = mesh.skeleton.bones;
		var bones2 = vpd.bones;

		var table = {};

		for (var i = 0; i < bones.length; i++) {

			table[bones[i].name] = i;
		}

		var thV = new THREE.Vector3();
		var thQ = new THREE.Quaternion();

		for (var i = 0; i < bones2.length; i++) {

			var b = bones2[i];
			var index = table[b.name];

			if (index === undefined) continue;

			var b2 = bones[index];
			var t = b.translation;
			var q = b.quaternion;

			thV.set(t[0], t[1], t[2]);
			thQ.set(q[0], q[1], q[2], q[3]);

			b2.position.add(thV);
			b2.quaternion.multiply(thQ);
		}

		mesh.updateMatrixWorld(true);

		if (params.preventIk !== true) {

			var solver = new THREE.CCDIKSolver(mesh);
			solver.update(params.saveOriginalBonesBeforeIK);
		}

		if (params.preventGrant !== true && mesh.geometry.grants !== undefined) {

			var solver = new THREE.MMDGrantSolver(mesh);
			solver.update();
		}
	},

	/*
  * Note: These following three functions are workaround for r74dev.
  *       THREE.PropertyMixer.apply() seems to save values into buffer cache
  *       when mixer.update() is called.
  *       ikSolver.update() and physics.update() change bone position/quaternion
  *       without mixer.update() then buffer cache will be inconsistent.
  *       So trying to avoid buffer cache inconsistency by doing
  *       backup bones position/quaternion right after mixer.update() call
  *       and then restore them after rendering.
  */
	initBackupBones: function initBackupBones(mesh) {

		mesh.skeleton.backupBones = [];

		for (var i = 0; i < mesh.skeleton.bones.length; i++) {

			mesh.skeleton.backupBones.push(mesh.skeleton.bones[i].clone());
		}
	},

	backupBones: function backupBones(mesh) {

		mesh.skeleton.backupBoneIsSaved = true;

		for (var i = 0; i < mesh.skeleton.bones.length; i++) {

			var b = mesh.skeleton.backupBones[i];
			var b2 = mesh.skeleton.bones[i];
			b.position.copy(b2.position);
			b.quaternion.copy(b2.quaternion);
		}
	},

	restoreBones: function restoreBones(mesh) {

		if (mesh.skeleton.backupBoneIsSaved !== true) {

			return;
		}

		mesh.skeleton.backupBoneIsSaved = false;

		for (var i = 0; i < mesh.skeleton.bones.length; i++) {

			var b = mesh.skeleton.bones[i];
			var b2 = mesh.skeleton.backupBones[i];
			b.position.copy(b2.position);
			b.quaternion.copy(b2.quaternion);
		}
	}

};

exports.default = MMDLoader;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author sunag / http://www.sunag.com.br/
 */

var NodeMaterialLoader = function NodeMaterialLoader(manager, library) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;

	this.nodes = {};
	this.materials = {};
	this.passes = {};
	this.names = {};
	this.library = library || {};
};

var NodeMaterialLoaderUtils = {

	replaceUUIDObject: function replaceUUIDObject(object, uuid, value, recursive) {

		recursive = recursive !== undefined ? recursive : true;

		if ((typeof uuid === "undefined" ? "undefined" : _typeof(uuid)) === "object") uuid = uuid.uuid;

		if ((typeof object === "undefined" ? "undefined" : _typeof(object)) === "object") {

			var keys = Object.keys(object);

			for (var i = 0; i < keys.length; i++) {

				var key = keys[i];

				if (recursive) {

					object[key] = this.replaceUUIDObject(object[key], uuid, value);
				}

				if (key === uuid) {

					object[uuid] = object[key];

					delete object[key];
				}
			}
		}

		return object === uuid ? value : object;
	},

	replaceUUID: function replaceUUID(json, uuid, value) {

		this.replaceUUIDObject(json, uuid, value, false);
		this.replaceUUIDObject(json.nodes, uuid, value);
		this.replaceUUIDObject(json.materials, uuid, value);
		this.replaceUUIDObject(json.passes, uuid, value);
		this.replaceUUIDObject(json.library, uuid, value, false);

		return json;
	}

};

Object.assign(NodeMaterialLoader.prototype, {

	load: function load(url, onLoad, onProgress, onError) {

		var scope = this;

		var loader = new THREE.FileLoader(scope.manager);
		loader.load(url, function (text) {

			onLoad(scope.parse(JSON.parse(text)));
		}, onProgress, onError);

		return this;
	},

	getObjectByName: function getObjectByName(uuid) {

		return this.names[uuid];
	},

	getObjectById: function getObjectById(uuid) {

		return this.library[uuid] || this.nodes[uuid] || this.names[uuid];
	},

	getNode: function getNode(uuid) {

		var object = this.getObjectById(uuid);

		if (!object) {

			console.warn("Node \"" + uuid + "\" not found.");
		}

		return object;
	},

	parse: function parse(json) {

		var uuid, node, object, prop, i;

		for (uuid in json.nodes) {

			node = json.nodes[uuid];

			object = new THREE[node.type]();

			if (node.name) {

				object.name = node.name;

				this.names[object.name] = object;
			} else {

				// ignore "uniform" shader input ( for optimization )
				object.readonly = true;
			}

			if (node.readonly !== undefined) object.readonly = node.readonly;

			this.nodes[uuid] = object;
		}

		for (uuid in json.materials) {

			node = json.materials[uuid];

			object = new THREE[node.type]();

			if (node.name) {

				object.name = node.name;

				this.names[object.name] = object;
			}

			this.materials[uuid] = object;
		}

		for (uuid in json.passes) {

			node = json.passes[uuid];

			object = new THREE[node.type]();

			if (node.name) {

				object.name = node.name;

				this.names[object.name] = object;
			}

			this.passes[uuid] = object;
		}

		if (json.material) this.material = this.materials[uuid];
		if (json.pass) this.pass = this.passes[uuid];

		for (uuid in json.nodes) {

			node = json.nodes[uuid];
			object = this.nodes[uuid];

			switch (node.type) {

				case "FloatNode":

					object.number = node.number;

					break;

				case "ColorNode":

					object.value.copy(node);

					break;

				case "Vector2Node":

					object.x = node.x;
					object.y = node.y;

					break;

				case "Vector3Node":

					object.x = node.x;
					object.y = node.y;
					object.z = node.z;

					break;

				case "Vector4Node":

					object.x = node.x;
					object.y = node.y;
					object.z = node.z;
					object.w = node.w;

					break;

				case "Matrix3Node":
				case "Matrix4Node":

					object.value.fromArray(node.elements);

					break;

				case "OperatorNode":

					object.a = this.getNode(node.a);
					object.b = this.getNode(node.b);
					object.op = node.op;

					break;

				case "Math1Node":

					object.a = this.getNode(node.a);
					object.method = node.method;

					break;

				case "Math2Node":

					object.a = this.getNode(node.a);
					object.b = this.getNode(node.b);
					object.method = node.method;

					break;

				case "Math3Node":

					object.a = this.getNode(node.a);
					object.b = this.getNode(node.b);
					object.c = this.getNode(node.c);
					object.method = node.method;

					break;

				case "UVNode":
				case "ColorsNode":

					object.index = node.index;

					break;

				case "LuminanceNode":

					object.rgb = this.getNode(node.rgb);

					break;

				case "PositionNode":
				case "NormalNode":
				case "ReflectNode":
				case "LightNode":

					object.scope = node.scope;

					break;

				case "SwitchNode":

					object.node = this.getNode(node.node);
					object.components = node.components;

					break;

				case "JoinNode":

					for (prop in node.inputs) {

						object[prop] = this.getNode(node.inputs[prop]);
					}

					break;

				case "CameraNode":

					object.setScope(node.scope);

					if (node.camera) object.setCamera(this.getNode(node.camera));

					switch (node.scope) {

						case THREE.CameraNode.DEPTH:

							object.near.number = node.near;
							object.far.number = node.far;

							break;

					}

					break;

				case "ColorAdjustmentNode":

					object.rgb = this.getNode(node.rgb);
					object.adjustment = this.getNode(node.adjustment);
					object.method = node.method;

					break;

				case "UVTransformNode":

					object.uv = this.getNode(node.uv);
					object.transform = this.getNode(node.transform);

					break;

				case "BumpNode":

					object.value = this.getNode(node.value);
					object.coord = this.getNode(node.coord);
					object.scale = this.getNode(node.scale);

					break;

				case "BlurNode":

					object.value = this.getNode(node.value);
					object.coord = this.getNode(node.coord);
					object.scale = this.getNode(node.scale);

					object.value = this.getNode(node.value);
					object.coord = this.getNode(node.coord);
					object.radius = this.getNode(node.radius);

					if (node.size !== undefined) object.size = new THREE.Vector2(node.size.x, node.size.y);

					object.blurX = node.blurX;
					object.blurY = node.blurY;

					break;

				case "ResolutionNode":

					object.renderer = this.getNode(node.renderer);

					break;

				case "ScreenUVNode":

					object.resolution = this.getNode(node.resolution);

					break;

				case "VelocityNode":

					if (node.target) object.setTarget(this.getNode(node.target));
					object.setParams(node.params);

					break;

				case "TimerNode":

					object.scope = node.scope;
					object.scale = node.scale;

					break;

				case "ConstNode":

					object.name = node.name;
					object.type = node.out;
					object.value = node.value;
					object.useDefine = node.useDefine === true;

					break;

				case "AttributeNode":
				case "VarNode":

					object.type = node.out;

					break;

				case "ReflectorNode":

					object.setMirror(this.getNode(node.mirror));

					if (node.offset) object.offset = this.getNode(node.offset);

					break;

				case "NoiseNode":

					object.coord = this.getNode(node.coord);

					break;

				case "FunctionNode":

					object.isMethod = node.isMethod;
					object.useKeywords = node.useKeywords;

					object.extensions = node.extensions;
					object.keywords = {};

					for (prop in node.keywords) {

						object.keywords[prop] = this.getNode(node.keywords[prop]);
					}

					if (node.includes) {

						for (i = 0; i < node.includes.length; i++) {

							object.includes.push(this.getNode(node.includes[i]));
						}
					}

					object.eval(node.src, object.includes, object.extensions, object.keywords);

					if (!object.isMethod) object.type = node.out;

					break;

				case "FunctionCallNode":

					for (prop in node.inputs) {

						object.inputs[prop] = this.getNode(node.inputs[prop]);
					}

					object.value = this.getNode(node.value);

					break;

				case "TextureNode":
				case "CubeTextureNode":
				case "ScreenNode":

					if (node.value) object.value = this.getNode(node.value);

					object.coord = this.getNode(node.coord);

					if (node.bias) object.bias = this.getNode(node.bias);
					if (object.project !== undefined) object.project = node.project;

					break;

				case "RoughnessToBlinnExponentNode":
					break;

				case "RawNode":

					object.value = this.getNode(node.value);

					break;

				case "StandardNode":
				case "PhongNode":
				case "SpriteNode":

					object.color = this.getNode(node.color);

					if (node.alpha) object.alpha = this.getNode(node.alpha);

					if (node.specular) object.specular = this.getNode(node.specular);
					if (node.shininess) object.shininess = this.getNode(node.shininess);

					if (node.roughness) object.roughness = this.getNode(node.roughness);
					if (node.metalness) object.metalness = this.getNode(node.metalness);

					if (node.reflectivity) object.reflectivity = this.getNode(node.reflectivity);

					if (node.clearCoat) object.clearCoat = this.getNode(node.clearCoat);
					if (node.clearCoatRoughness) object.clearCoatRoughness = this.getNode(node.clearCoatRoughness);

					if (node.normal) object.normal = this.getNode(node.normal);
					if (node.normalScale) object.normalScale = this.getNode(node.normalScale);

					if (node.emissive) object.emissive = this.getNode(node.emissive);
					if (node.ambient) object.ambient = this.getNode(node.ambient);

					if (node.shadow) object.shadow = this.getNode(node.shadow);
					if (node.light) object.light = this.getNode(node.light);

					if (node.ao) object.ao = this.getNode(node.ao);

					if (node.environment) object.environment = this.getNode(node.environment);
					if (node.environmentAlpha) object.environmentAlpha = this.getNode(node.environmentAlpha);

					if (node.transform) object.transform = this.getNode(node.transform);

					if (node.spherical === false) object.spherical = false;

					break;

				default:

					console.warn(node.type, "not supported.");

			}
		}

		for (uuid in json.materials) {

			node = json.materials[uuid];
			object = this.materials[uuid];

			if (node.name !== undefined) object.name = node.name;

			if (node.blending !== undefined) object.blending = node.blending;
			if (node.flatShading !== undefined) object.flatShading = node.flatShading;
			if (node.side !== undefined) object.side = node.side;

			object.depthFunc = node.depthFunc;
			object.depthTest = node.depthTest;
			object.depthWrite = node.depthWrite;

			if (node.wireframe !== undefined) object.wireframe = node.wireframe;
			if (node.wireframeLinewidth !== undefined) object.wireframeLinewidth = node.wireframeLinewidth;
			if (node.wireframeLinecap !== undefined) object.wireframeLinecap = node.wireframeLinecap;
			if (node.wireframeLinejoin !== undefined) object.wireframeLinejoin = node.wireframeLinejoin;

			if (node.skinning !== undefined) object.skinning = node.skinning;
			if (node.morphTargets !== undefined) object.morphTargets = node.morphTargets;

			if (node.visible !== undefined) object.visible = node.visible;
			if (node.userData !== undefined) object.userData = node.userData;

			object.vertex = this.getNode(node.vertex);
			object.fragment = this.getNode(node.fragment);

			if (object.vertex === object.fragment) {

				// replace main node

				object.node = object.vertex;
			}

			object.build();

			if (node.fog !== undefined) object.fog = node.fog;
			if (node.lights !== undefined) object.lights = node.lights;

			if (node.transparent !== undefined) object.transparent = node.transparent;
		}

		for (uuid in json.passes) {

			node = json.passes[uuid];
			object = this.passes[uuid];

			object.value = this.getNode(node.value);

			object.build();
		}

		return this.material || this.pass || this;
	}

});

exports.default = NodeMaterialLoader;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _Volume = __webpack_require__(10);

var _Volume2 = _interopRequireDefault(_Volume);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var NRRDLoader = function NRRDLoader(manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};

NRRDLoader.prototype = {

	constructor: NRRDLoader,

	load: function load(url, onLoad, onProgress, onError) {

		var scope = this;

		var loader = new THREE.FileLoader(scope.manager);
		loader.setResponseType('arraybuffer');
		loader.load(url, function (data) {

			onLoad(scope.parse(data));
		}, onProgress, onError);
	},

	parse: function parse(data) {

		// this parser is largely inspired from the XTK NRRD parser : https://github.com/xtk/X

		var _data = data;

		var _dataPointer = 0;

		var _nativeLittleEndian = new Int8Array(new Int16Array([1]).buffer)[0] > 0;

		var _littleEndian = true;

		var headerObject = {};

		function scan(type, chunks) {

			if (chunks === undefined || chunks === null) {

				chunks = 1;
			}

			var _chunkSize = 1;
			var _array_type = Uint8Array;

			switch (type) {

				// 1 byte data types
				case 'uchar':
					break;
				case 'schar':
					_array_type = Int8Array;
					break;
				// 2 byte data types
				case 'ushort':
					_array_type = Uint16Array;
					_chunkSize = 2;
					break;
				case 'sshort':
					_array_type = Int16Array;
					_chunkSize = 2;
					break;
				// 4 byte data types
				case 'uint':
					_array_type = Uint32Array;
					_chunkSize = 4;
					break;
				case 'sint':
					_array_type = Int32Array;
					_chunkSize = 4;
					break;
				case 'float':
					_array_type = Float32Array;
					_chunkSize = 4;
					break;
				case 'complex':
					_array_type = Float64Array;
					_chunkSize = 8;
					break;
				case 'double':
					_array_type = Float64Array;
					_chunkSize = 8;
					break;

			}

			// increase the data pointer in-place
			var _bytes = new _array_type(_data.slice(_dataPointer, _dataPointer += chunks * _chunkSize));

			// if required, flip the endianness of the bytes
			if (_nativeLittleEndian != _littleEndian) {

				// we need to flip here since the format doesn't match the native endianness
				_bytes = flipEndianness(_bytes, _chunkSize);
			}

			if (chunks == 1) {

				// if only one chunk was requested, just return one value
				return _bytes[0];
			}

			// return the byte array
			return _bytes;
		}

		//Flips typed array endianness in-place. Based on https://github.com/kig/DataStream.js/blob/master/DataStream.js.

		function flipEndianness(array, chunkSize) {

			var u8 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
			for (var i = 0; i < array.byteLength; i += chunkSize) {

				for (var j = i + chunkSize - 1, k = i; j > k; j--, k++) {

					var tmp = u8[k];
					u8[k] = u8[j];
					u8[j] = tmp;
				}
			}

			return array;
		}

		//parse the header
		function parseHeader(header) {

			var data, field, fn, i, l, lines, m, _i, _len;
			lines = header.split(/\r?\n/);
			for (_i = 0, _len = lines.length; _i < _len; _i++) {

				l = lines[_i];
				if (l.match(/NRRD\d+/)) {

					headerObject.isNrrd = true;
				} else if (l.match(/^#/)) {} else if (m = l.match(/(.*):(.*)/)) {

					field = m[1].trim();
					data = m[2].trim();
					fn = THREE.NRRDLoader.prototype.fieldFunctions[field];
					if (fn) {

						fn.call(headerObject, data);
					} else {

						headerObject[field] = data;
					}
				}
			}
			if (!headerObject.isNrrd) {

				throw new Error('Not an NRRD file');
			}
			if (headerObject.encoding === 'bz2' || headerObject.encoding === 'bzip2') {

				throw new Error('Bzip is not supported');
			}
			if (!headerObject.vectors) {

				//if no space direction is set, let's use the identity
				headerObject.vectors = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1)];
				//apply spacing if defined
				if (headerObject.spacings) {

					for (i = 0; i <= 2; i++) {

						if (!isNaN(headerObject.spacings[i])) {

							headerObject.vectors[i].multiplyScalar(headerObject.spacings[i]);
						}
					}
				}
			}
		}

		//parse the data when registred as one of this type : 'text', 'ascii', 'txt'
		function parseDataAsText(data, start, end) {

			var number = '';
			start = start || 0;
			end = end || data.length;
			var value;
			//length of the result is the product of the sizes
			var lengthOfTheResult = headerObject.sizes.reduce(function (previous, current) {

				return previous * current;
			}, 1);

			var base = 10;
			if (headerObject.encoding === 'hex') {

				base = 16;
			}

			var result = new headerObject.__array(lengthOfTheResult);
			var resultIndex = 0;
			var parsingFunction = parseInt;
			if (headerObject.__array === Float32Array || headerObject.__array === Float64Array) {

				parsingFunction = parseFloat;
			}
			for (var i = start; i < end; i++) {

				value = data[i];
				//if value is not a space
				if ((value < 9 || value > 13) && value !== 32) {

					number += String.fromCharCode(value);
				} else {

					if (number !== '') {

						result[resultIndex] = parsingFunction(number, base);
						resultIndex++;
					}
					number = '';
				}
			}
			if (number !== '') {

				result[resultIndex] = parsingFunction(number, base);
				resultIndex++;
			}
			return result;
		}

		var _bytes = scan('uchar', data.byteLength);
		var _length = _bytes.length;
		var _header = null;
		var _data_start = 0;
		var i;
		for (i = 1; i < _length; i++) {

			if (_bytes[i - 1] == 10 && _bytes[i] == 10) {

				// we found two line breaks in a row
				// now we know what the header is
				_header = this.parseChars(_bytes, 0, i - 2);
				// this is were the data starts
				_data_start = i + 1;
				break;
			}
		}
		// parse the header
		parseHeader(_header);

		var _data = _bytes.subarray(_data_start); // the data without header
		if (headerObject.encoding === 'gzip' || headerObject.encoding === 'gz') {

			// we need to decompress the datastream
			// here we start the unzipping and get a typed Uint8Array back
			var inflate = new Zlib.Gunzip(new Uint8Array(_data)); // eslint-disable-line no-undef
			_data = inflate.decompress();
		} else if (headerObject.encoding === 'ascii' || headerObject.encoding === 'text' || headerObject.encoding === 'txt' || headerObject.encoding === 'hex') {

			_data = parseDataAsText(_data);
		} else if (headerObject.encoding === 'raw') {

			//we need to copy the array to create a new array buffer, else we retrieve the original arraybuffer with the header
			var _copy = new Uint8Array(_data.length);

			for (var i = 0; i < _data.length; i++) {

				_copy[i] = _data[i];
			}

			_data = _copy;
		}
		// .. let's use the underlying array buffer
		_data = _data.buffer;

		var volume = new _Volume2.default();
		volume.header = headerObject;
		//
		// parse the (unzipped) data to a datastream of the correct type
		//
		volume.data = new headerObject.__array(_data);
		// get the min and max intensities
		var min_max = volume.computeMinMax();
		var min = min_max[0];
		var max = min_max[1];
		// attach the scalar range to the volume
		volume.windowLow = min;
		volume.windowHigh = max;

		// get the image dimensions
		volume.dimensions = [headerObject.sizes[0], headerObject.sizes[1], headerObject.sizes[2]];
		volume.xLength = volume.dimensions[0];
		volume.yLength = volume.dimensions[1];
		volume.zLength = volume.dimensions[2];
		// spacing
		var spacingX = new THREE.Vector3(headerObject.vectors[0][0], headerObject.vectors[0][1], headerObject.vectors[0][2]).length();
		var spacingY = new THREE.Vector3(headerObject.vectors[1][0], headerObject.vectors[1][1], headerObject.vectors[1][2]).length();
		var spacingZ = new THREE.Vector3(headerObject.vectors[2][0], headerObject.vectors[2][1], headerObject.vectors[2][2]).length();
		volume.spacing = [spacingX, spacingY, spacingZ];

		// Create IJKtoRAS matrix
		volume.matrix = new THREE.Matrix4();

		var _spaceX = 1;
		var _spaceY = 1;
		var _spaceZ = 1;

		if (headerObject.space == "left-posterior-superior") {

			_spaceX = -1;
			_spaceY = -1;
		} else if (headerObject.space === 'left-anterior-superior') {

			_spaceX = -1;
		}

		if (!headerObject.vectors) {

			volume.matrix.set(_spaceX, 0, 0, 0, 0, _spaceY, 0, 0, 0, 0, _spaceZ, 0, 0, 0, 0, 1);
		} else {

			var v = headerObject.vectors;

			volume.matrix.set(_spaceX * v[0][0], _spaceX * v[1][0], _spaceX * v[2][0], 0, _spaceY * v[0][1], _spaceY * v[1][1], _spaceY * v[2][1], 0, _spaceZ * v[0][2], _spaceZ * v[1][2], _spaceZ * v[2][2], 0, 0, 0, 0, 1);
		}

		volume.inverseMatrix = new THREE.Matrix4();
		volume.inverseMatrix.getInverse(volume.matrix);
		volume.RASDimensions = new THREE.Vector3(volume.xLength, volume.yLength, volume.zLength).applyMatrix4(volume.matrix).round().toArray().map(Math.abs);

		// .. and set the default threshold
		// only if the threshold was not already set
		if (volume.lowerThreshold === -Infinity) {

			volume.lowerThreshold = min;
		}
		if (volume.upperThreshold === Infinity) {

			volume.upperThreshold = max;
		}

		return volume;
	},

	parseChars: function parseChars(array, start, end) {

		// without borders, use the whole array
		if (start === undefined) {

			start = 0;
		}
		if (end === undefined) {

			end = array.length;
		}

		var output = '';
		// create and append the chars
		var i = 0;
		for (i = start; i < end; ++i) {

			output += String.fromCharCode(array[i]);
		}

		return output;
	},

	fieldFunctions: {

		type: function type(data) {

			switch (data) {

				case 'uchar':
				case 'unsigned char':
				case 'uint8':
				case 'uint8_t':
					this.__array = Uint8Array;
					break;
				case 'signed char':
				case 'int8':
				case 'int8_t':
					this.__array = Int8Array;
					break;
				case 'short':
				case 'short int':
				case 'signed short':
				case 'signed short int':
				case 'int16':
				case 'int16_t':
					this.__array = Int16Array;
					break;
				case 'ushort':
				case 'unsigned short':
				case 'unsigned short int':
				case 'uint16':
				case 'uint16_t':
					this.__array = Uint16Array;
					break;
				case 'int':
				case 'signed int':
				case 'int32':
				case 'int32_t':
					this.__array = Int32Array;
					break;
				case 'uint':
				case 'unsigned int':
				case 'uint32':
				case 'uint32_t':
					this.__array = Uint32Array;
					break;
				case 'float':
					this.__array = Float32Array;
					break;
				case 'double':
					this.__array = Float64Array;
					break;
				default:
					throw new Error('Unsupported NRRD data type: ' + data);

			}

			return this.type = data;
		},

		endian: function endian(data) {

			return this.endian = data;
		},

		encoding: function encoding(data) {

			return this.encoding = data;
		},

		dimension: function dimension(data) {

			return this.dim = parseInt(data, 10);
		},

		sizes: function sizes(data) {

			var i;
			return this.sizes = function () {

				var _i, _len, _ref, _results;
				_ref = data.split(/\s+/);
				_results = [];
				for (_i = 0, _len = _ref.length; _i < _len; _i++) {

					i = _ref[_i];
					_results.push(parseInt(i, 10));
				}
				return _results;
			}();
		},

		space: function space(data) {

			return this.space = data;
		},

		'space origin': function spaceOrigin(data) {

			return this.space_origin = data.split("(")[1].split(")")[0].split(",");
		},

		'space directions': function spaceDirections(data) {

			var f, parts, v;
			parts = data.match(/\(.*?\)/g);
			return this.vectors = function () {

				var _i, _len, _results;
				_results = [];
				for (_i = 0, _len = parts.length; _i < _len; _i++) {

					v = parts[_i];
					_results.push(function () {

						var _j, _len2, _ref, _results2;
						_ref = v.slice(1, -1).split(/,/);
						_results2 = [];
						for (_j = 0, _len2 = _ref.length; _j < _len2; _j++) {

							f = _ref[_j];
							_results2.push(parseFloat(f));
						}
						return _results2;
					}());
				}
				return _results;
			}();
		},

		spacings: function spacings(data) {

			var f, parts;
			parts = data.split(/\s+/);
			return this.spacings = function () {

				var _i,
				    _len,
				    _results = [];

				for (_i = 0, _len = parts.length; _i < _len; _i++) {

					f = parts[_i];
					_results.push(parseFloat(f));
				}
				return _results;
			}();
		}
	}

};

exports.default = NRRDLoader;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author mrdoob / http://mrdoob.com/
 */

var OBJLoader = function () {

	// o object_name | g group_name
	var object_pattern = /^[og]\s*(.+)?/;
	// mtllib file_reference
	var material_library_pattern = /^mtllib /;
	// usemtl material_name
	var material_use_pattern = /^usemtl /;

	function ParserState() {

		var state = {
			objects: [],
			object: {},

			vertices: [],
			normals: [],
			colors: [],
			uvs: [],

			materialLibraries: [],

			startObject: function startObject(name, fromDeclaration) {

				// If the current object (initial from reset) is not from a g/o declaration in the parsed
				// file. We need to use it for the first parsed g/o to keep things in sync.
				if (this.object && this.object.fromDeclaration === false) {

					this.object.name = name;
					this.object.fromDeclaration = fromDeclaration !== false;
					return;
				}

				var previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;

				if (this.object && typeof this.object._finalize === 'function') {

					this.object._finalize(true);
				}

				this.object = {
					name: name || '',
					fromDeclaration: fromDeclaration !== false,

					geometry: {
						vertices: [],
						normals: [],
						colors: [],
						uvs: []
					},
					materials: [],
					smooth: true,

					startMaterial: function startMaterial(name, libraries) {

						var previous = this._finalize(false);

						// New usemtl declaration overwrites an inherited material, except if faces were declared
						// after the material, then it must be preserved for proper MultiMaterial continuation.
						if (previous && (previous.inherited || previous.groupCount <= 0)) {

							this.materials.splice(previous.index, 1);
						}

						var material = {
							index: this.materials.length,
							name: name || '',
							mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',
							smooth: previous !== undefined ? previous.smooth : this.smooth,
							groupStart: previous !== undefined ? previous.groupEnd : 0,
							groupEnd: -1,
							groupCount: -1,
							inherited: false,

							clone: function clone(index) {

								var cloned = {
									index: typeof index === 'number' ? index : this.index,
									name: this.name,
									mtllib: this.mtllib,
									smooth: this.smooth,
									groupStart: 0,
									groupEnd: -1,
									groupCount: -1,
									inherited: false
								};
								cloned.clone = this.clone.bind(cloned);
								return cloned;
							}
						};

						this.materials.push(material);

						return material;
					},

					currentMaterial: function currentMaterial() {

						if (this.materials.length > 0) {

							return this.materials[this.materials.length - 1];
						}

						return undefined;
					},

					_finalize: function _finalize(end) {

						var lastMultiMaterial = this.currentMaterial();
						if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {

							lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
							lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
							lastMultiMaterial.inherited = false;
						}

						// Ignore objects tail materials if no face declarations followed them before a new o/g started.
						if (end && this.materials.length > 1) {

							for (var mi = this.materials.length - 1; mi >= 0; mi--) {

								if (this.materials[mi].groupCount <= 0) {

									this.materials.splice(mi, 1);
								}
							}
						}

						// Guarantee at least one empty material, this makes the creation later more straight forward.
						if (end && this.materials.length === 0) {

							this.materials.push({
								name: '',
								smooth: this.smooth
							});
						}

						return lastMultiMaterial;
					}
				};

				// Inherit previous objects material.
				// Spec tells us that a declared material must be set to all objects until a new material is declared.
				// If a usemtl declaration is encountered while this new object is being parsed, it will
				// overwrite the inherited material. Exception being that there was already face declarations
				// to the inherited material, then it will be preserved for proper MultiMaterial continuation.

				if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {

					var declared = previousMaterial.clone(0);
					declared.inherited = true;
					this.object.materials.push(declared);
				}

				this.objects.push(this.object);
			},

			finalize: function finalize() {

				if (this.object && typeof this.object._finalize === 'function') {

					this.object._finalize(true);
				}
			},

			parseVertexIndex: function parseVertexIndex(value, len) {

				var index = parseInt(value, 10);
				return (index >= 0 ? index - 1 : index + len / 3) * 3;
			},

			parseNormalIndex: function parseNormalIndex(value, len) {

				var index = parseInt(value, 10);
				return (index >= 0 ? index - 1 : index + len / 3) * 3;
			},

			parseUVIndex: function parseUVIndex(value, len) {

				var index = parseInt(value, 10);
				return (index >= 0 ? index - 1 : index + len / 2) * 2;
			},

			addVertex: function addVertex(a, b, c) {

				var src = this.vertices;
				var dst = this.object.geometry.vertices;

				dst.push(src[a + 0], src[a + 1], src[a + 2]);
				dst.push(src[b + 0], src[b + 1], src[b + 2]);
				dst.push(src[c + 0], src[c + 1], src[c + 2]);
			},

			addVertexPoint: function addVertexPoint(a) {

				var src = this.vertices;
				var dst = this.object.geometry.vertices;

				dst.push(src[a + 0], src[a + 1], src[a + 2]);
			},

			addVertexLine: function addVertexLine(a) {

				var src = this.vertices;
				var dst = this.object.geometry.vertices;

				dst.push(src[a + 0], src[a + 1], src[a + 2]);
			},

			addNormal: function addNormal(a, b, c) {

				var src = this.normals;
				var dst = this.object.geometry.normals;

				dst.push(src[a + 0], src[a + 1], src[a + 2]);
				dst.push(src[b + 0], src[b + 1], src[b + 2]);
				dst.push(src[c + 0], src[c + 1], src[c + 2]);
			},

			addColor: function addColor(a, b, c) {

				var src = this.colors;
				var dst = this.object.geometry.colors;

				dst.push(src[a + 0], src[a + 1], src[a + 2]);
				dst.push(src[b + 0], src[b + 1], src[b + 2]);
				dst.push(src[c + 0], src[c + 1], src[c + 2]);
			},

			addUV: function addUV(a, b, c) {

				var src = this.uvs;
				var dst = this.object.geometry.uvs;

				dst.push(src[a + 0], src[a + 1]);
				dst.push(src[b + 0], src[b + 1]);
				dst.push(src[c + 0], src[c + 1]);
			},

			addUVLine: function addUVLine(a) {

				var src = this.uvs;
				var dst = this.object.geometry.uvs;

				dst.push(src[a + 0], src[a + 1]);
			},

			addFace: function addFace(a, b, c, ua, ub, uc, na, nb, nc) {

				var vLen = this.vertices.length;

				var ia = this.parseVertexIndex(a, vLen);
				var ib = this.parseVertexIndex(b, vLen);
				var ic = this.parseVertexIndex(c, vLen);

				this.addVertex(ia, ib, ic);

				if (ua !== undefined && ua !== '') {

					var uvLen = this.uvs.length;
					ia = this.parseUVIndex(ua, uvLen);
					ib = this.parseUVIndex(ub, uvLen);
					ic = this.parseUVIndex(uc, uvLen);
					this.addUV(ia, ib, ic);
				}

				if (na !== undefined && na !== '') {

					// Normals are many times the same. If so, skip function call and parseInt.
					var nLen = this.normals.length;
					ia = this.parseNormalIndex(na, nLen);

					ib = na === nb ? ia : this.parseNormalIndex(nb, nLen);
					ic = na === nc ? ia : this.parseNormalIndex(nc, nLen);

					this.addNormal(ia, ib, ic);
				}

				if (this.colors.length > 0) {

					this.addColor(ia, ib, ic);
				}
			},

			addPointGeometry: function addPointGeometry(vertices) {

				this.object.geometry.type = 'Points';

				var vLen = this.vertices.length;

				for (var vi = 0, l = vertices.length; vi < l; vi++) {

					this.addVertexPoint(this.parseVertexIndex(vertices[vi], vLen));
				}
			},

			addLineGeometry: function addLineGeometry(vertices, uvs) {

				this.object.geometry.type = 'Line';

				var vLen = this.vertices.length;
				var uvLen = this.uvs.length;

				for (var vi = 0, l = vertices.length; vi < l; vi++) {

					this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));
				}

				for (var uvi = 0, l = uvs.length; uvi < l; uvi++) {

					this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));
				}
			}

		};

		state.startObject('', false);

		return state;
	}

	//

	function OBJLoader(manager) {

		this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;

		this.materials = null;
	}

	OBJLoader.prototype = {

		constructor: OBJLoader,

		load: function load(url, onLoad, onProgress, onError) {

			var scope = this;

			var loader = new THREE.FileLoader(scope.manager);
			loader.setPath(this.path);
			loader.load(url, function (text) {

				onLoad(scope.parse(text));
			}, onProgress, onError);
		},

		setPath: function setPath(value) {

			this.path = value;

			return this;
		},

		setMaterials: function setMaterials(materials) {

			this.materials = materials;

			return this;
		},

		parse: function parse(text) {

			console.time('OBJLoader');

			var state = new ParserState();

			if (text.indexOf('\r\n') !== -1) {

				// This is faster than String.split with regex that splits on both
				text = text.replace(/\r\n/g, '\n');
			}

			if (text.indexOf('\\\n') !== -1) {

				// join lines separated by a line continuation character (\)
				text = text.replace(/\\\n/g, '');
			}

			var lines = text.split('\n');
			var line = '',
			    lineFirstChar = '';
			var lineLength = 0;
			var result = [];

			// Faster to just trim left side of the line. Use if available.
			var trimLeft = typeof ''.trimLeft === 'function';

			for (var i = 0, l = lines.length; i < l; i++) {

				line = lines[i];

				line = trimLeft ? line.trimLeft() : line.trim();

				lineLength = line.length;

				if (lineLength === 0) continue;

				lineFirstChar = line.charAt(0);

				// @todo invoke passed in handler if any
				if (lineFirstChar === '#') continue;

				if (lineFirstChar === 'v') {

					var data = line.split(/\s+/);

					switch (data[0]) {

						case 'v':
							state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
							if (data.length === 8) {

								state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));
							}
							break;
						case 'vn':
							state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
							break;
						case 'vt':
							state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));
							break;

					}
				} else if (lineFirstChar === 'f') {

					var lineData = line.substr(1).trim();
					var vertexData = lineData.split(/\s+/);
					var faceVertices = [];

					// Parse the face vertex data into an easy to work with format

					for (var j = 0, jl = vertexData.length; j < jl; j++) {

						var vertex = vertexData[j];

						if (vertex.length > 0) {

							var vertexParts = vertex.split('/');
							faceVertices.push(vertexParts);
						}
					}

					// Draw an edge between the first vertex and all subsequent vertices to form an n-gon

					var v1 = faceVertices[0];

					for (var j = 1, jl = faceVertices.length - 1; j < jl; j++) {

						var v2 = faceVertices[j];
						var v3 = faceVertices[j + 1];

						state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);
					}
				} else if (lineFirstChar === 'l') {

					var lineParts = line.substring(1).trim().split(" ");
					var lineVertices = [],
					    lineUVs = [];

					if (line.indexOf("/") === -1) {

						lineVertices = lineParts;
					} else {

						for (var li = 0, llen = lineParts.length; li < llen; li++) {

							var parts = lineParts[li].split("/");

							if (parts[0] !== "") lineVertices.push(parts[0]);
							if (parts[1] !== "") lineUVs.push(parts[1]);
						}
					}
					state.addLineGeometry(lineVertices, lineUVs);
				} else if (lineFirstChar === 'p') {

					var lineData = line.substr(1).trim();
					var pointData = lineData.split(" ");

					state.addPointGeometry(pointData);
				} else if ((result = object_pattern.exec(line)) !== null) {

					// o object_name
					// or
					// g group_name

					// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869
					// var name = result[ 0 ].substr( 1 ).trim();
					var name = (" " + result[0].substr(1).trim()).substr(1);

					state.startObject(name);
				} else if (material_use_pattern.test(line)) {

					// material

					state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);
				} else if (material_library_pattern.test(line)) {

					// mtl file

					state.materialLibraries.push(line.substring(7).trim());
				} else if (lineFirstChar === 's') {

					result = line.split(' ');

					// smooth shading

					// @todo Handle files that have varying smooth values for a set of faces inside one geometry,
					// but does not define a usemtl for each face set.
					// This should be detected and a dummy material created (later MultiMaterial and geometry groups).
					// This requires some care to not create extra material on each smooth value for "normal" obj files.
					// where explicit usemtl defines geometry groups.
					// Example asset: examples/models/obj/cerberus/Cerberus.obj

					/*
      * http://paulbourke.net/dataformats/obj/
      * or
      * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf
      *
      * From chapter "Grouping" Syntax explanation "s group_number":
      * "group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.
      * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form
      * surfaces, smoothing groups are either turned on or off; there is no difference between values greater
      * than 0."
      */
					if (result.length > 1) {

						var value = result[1].trim().toLowerCase();
						state.object.smooth = value !== '0' && value !== 'off';
					} else {

						// ZBrush can produce "s" lines #11707
						state.object.smooth = true;
					}
					var material = state.object.currentMaterial();
					if (material) material.smooth = state.object.smooth;
				} else {

					// Handle null terminated files without exception
					if (line === '\0') continue;

					throw new Error('THREE.OBJLoader: Unexpected line: "' + line + '"');
				}
			}

			state.finalize();

			var container = new THREE.Group();
			container.materialLibraries = [].concat(state.materialLibraries);

			for (var i = 0, l = state.objects.length; i < l; i++) {

				var object = state.objects[i];
				var geometry = object.geometry;
				var materials = object.materials;
				var isLine = geometry.type === 'Line';
				var isPoints = geometry.type === 'Points';
				var hasVertexColors = false;

				// Skip o/g line declarations that did not follow with any faces
				if (geometry.vertices.length === 0) continue;

				var buffergeometry = new THREE.BufferGeometry();

				buffergeometry.addAttribute('position', new THREE.Float32BufferAttribute(geometry.vertices, 3));

				if (geometry.normals.length > 0) {

					buffergeometry.addAttribute('normal', new THREE.Float32BufferAttribute(geometry.normals, 3));
				} else {

					buffergeometry.computeVertexNormals();
				}

				if (geometry.colors.length > 0) {

					hasVertexColors = true;
					buffergeometry.addAttribute('color', new THREE.Float32BufferAttribute(geometry.colors, 3));
				}

				if (geometry.uvs.length > 0) {

					buffergeometry.addAttribute('uv', new THREE.Float32BufferAttribute(geometry.uvs, 2));
				}

				// Create materials

				var createdMaterials = [];

				for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {

					var sourceMaterial = materials[mi];
					var material = undefined;

					if (this.materials !== null) {

						material = this.materials.create(sourceMaterial.name);

						// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.
						if (isLine && material && !(material instanceof THREE.LineBasicMaterial)) {

							var materialLine = new THREE.LineBasicMaterial();
							materialLine.copy(material);
							materialLine.lights = false; // TOFIX
							material = materialLine;
						} else if (isPoints && material && !(material instanceof THREE.PointsMaterial)) {

							var materialPoints = new THREE.PointsMaterial({ size: 10, sizeAttenuation: false });
							materialLine.copy(material);
							material = materialPoints;
						}
					}

					if (!material) {

						if (isLine) {

							material = new THREE.LineBasicMaterial();
						} else if (isPoints) {

							material = new THREE.PointsMaterial({ size: 1, sizeAttenuation: false });
						} else {

							material = new THREE.MeshPhongMaterial();
						}

						material.name = sourceMaterial.name;
					}

					material.flatShading = sourceMaterial.smooth ? false : true;
					material.vertexColors = hasVertexColors ? THREE.VertexColors : THREE.NoColors;

					createdMaterials.push(material);
				}

				// Create mesh

				var mesh;

				if (createdMaterials.length > 1) {

					for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {

						var sourceMaterial = materials[mi];
						buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);
					}

					if (isLine) {

						mesh = new THREE.LineSegments(buffergeometry, createdMaterials);
					} else if (isPoints) {

						mesh = new THREE.Points(buffergeometry, createdMaterials);
					} else {

						mesh = new THREE.Mesh(buffergeometry, createdMaterials);
					}
				} else {

					if (isLine) {

						mesh = new THREE.LineSegments(buffergeometry, createdMaterials[0]);
					} else if (isPoints) {

						mesh = new THREE.Points(buffergeometry, createdMaterials[0]);
					} else {

						mesh = new THREE.Mesh(buffergeometry, createdMaterials[0]);
					}
				}

				mesh.name = object.name;

				container.add(mesh);
			}

			console.timeEnd('OBJLoader');

			return container;
		}

	};

	return OBJLoader;
}();

exports.default = OBJLoader;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _LoaderSupport = __webpack_require__(7);

var _LoaderSupport2 = _interopRequireDefault(_LoaderSupport);

var _MTLLoader = __webpack_require__(9);

var _MTLLoader2 = _interopRequireDefault(_MTLLoader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
  * @author Kai Salmen / https://kaisalmen.de
  * Development repository: https://github.com/kaisalmen/WWOBJLoader
  */

'use strict';

// if ( THREE.OBJLoader2 === undefined ) { THREE.OBJLoader2 = {} }

// if ( THREE.LoaderSupport === undefined ) console.error( '"THREE.LoaderSupport" is not available. "THREE.OBJLoader2" requires it. Please include "LoaderSupport.js" in your HTML.' );

/**
 * Use this class to load OBJ data from files or to parse OBJ data from an arraybuffer
 * @class
 *
 * @param {THREE.DefaultLoadingManager} [manager] The loadingManager for the loader to use. Default is {@link THREE.DefaultLoadingManager}
 */
var OBJLoader2 = function () {

	var OBJLOADER2_VERSION = '2.4.0';
	var Validator = _LoaderSupport2.default.Validator;

	function OBJLoader2(manager) {
		console.info('Using THREE.OBJLoader2 version: ' + OBJLOADER2_VERSION);

		this.manager = Validator.verifyInput(manager, THREE.DefaultLoadingManager);
		this.logging = {
			enabled: true,
			debug: false
		};

		this.modelName = '';
		this.instanceNo = 0;
		this.path = '';
		this.useIndices = false;
		this.disregardNormals = false;
		this.materialPerSmoothingGroup = false;
		this.loaderRootNode = new THREE.Group();

		this.meshBuilder = new _LoaderSupport2.default.MeshBuilder();
		this.callbacks = new _LoaderSupport2.default.Callbacks();
		this.workerSupport = new _LoaderSupport2.default.WorkerSupport();
		this.terminateWorkerOnLoad = true;
	}

	/**
  * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.
  * @memberOf THREE.OBJLoader2
  *
  * @param {boolean} enabled True or false.
  * @param {boolean} debug True or false.
  */
	OBJLoader2.prototype.setLogging = function (enabled, debug) {
		this.logging.enabled = enabled === true;
		this.logging.debug = debug === true;
		this.meshBuilder.setLogging(this.logging.enabled, this.logging.debug);
	};

	/**
  * Set the name of the model.
  * @memberOf THREE.OBJLoader2
  *
  * @param {string} modelName
  */
	OBJLoader2.prototype.setModelName = function (modelName) {
		this.modelName = Validator.verifyInput(modelName, this.modelName);
	};

	/**
  * The URL of the base path.
  * @memberOf THREE.OBJLoader2
  *
  * @param {string} path URL
  */
	OBJLoader2.prototype.setPath = function (path) {
		this.path = Validator.verifyInput(path, this.path);
	};

	/**
  * Set the node where the loaded objects will be attached directly.
  * @memberOf THREE.OBJLoader2
  *
  * @param {THREE.Object3D} streamMeshesTo Object already attached to scenegraph where new meshes will be attached to
  */
	OBJLoader2.prototype.setStreamMeshesTo = function (streamMeshesTo) {
		this.loaderRootNode = Validator.verifyInput(streamMeshesTo, this.loaderRootNode);
	};

	/**
  * Set materials loaded by MTLLoader or any other supplier of an Array of {@link THREE.Material}.
  * @memberOf THREE.OBJLoader2
  *
  * @param {THREE.Material[]} materials Array of {@link THREE.Material}
  */
	OBJLoader2.prototype.setMaterials = function (materials) {
		this.meshBuilder.setMaterials(materials);
	};

	/**
  * Instructs loaders to create indexed {@link THREE.BufferGeometry}.
  * @memberOf THREE.OBJLoader2
  *
  * @param {boolean} useIndices=false
  */
	OBJLoader2.prototype.setUseIndices = function (useIndices) {
		this.useIndices = useIndices === true;
	};

	/**
  * Tells whether normals should be completely disregarded and regenerated.
  * @memberOf THREE.OBJLoader2
  *
  * @param {boolean} disregardNormals=false
  */
	OBJLoader2.prototype.setDisregardNormals = function (disregardNormals) {
		this.disregardNormals = disregardNormals === true;
	};

	/**
  * Tells whether a material shall be created per smoothing group.
  * @memberOf THREE.OBJLoader2
  *
  * @param {boolean} materialPerSmoothingGroup=false
  */
	OBJLoader2.prototype.setMaterialPerSmoothingGroup = function (materialPerSmoothingGroup) {
		this.materialPerSmoothingGroup = materialPerSmoothingGroup === true;
	};

	OBJLoader2.prototype._setCallbacks = function (callbacks) {
		if (Validator.isValid(callbacks.onProgress)) this.callbacks.setCallbackOnProgress(callbacks.onProgress);
		if (Validator.isValid(callbacks.onMeshAlter)) this.callbacks.setCallbackOnMeshAlter(callbacks.onMeshAlter);
		if (Validator.isValid(callbacks.onLoad)) this.callbacks.setCallbackOnLoad(callbacks.onLoad);
		if (Validator.isValid(callbacks.onLoadMaterials)) this.callbacks.setCallbackOnLoadMaterials(callbacks.onLoadMaterials);

		this.meshBuilder._setCallbacks(this.callbacks);
	};

	/**
  * Announce feedback which is give to the registered callbacks.
  * @memberOf THREE.OBJLoader2
  * @private
  *
  * @param {string} type The type of event
  * @param {string} text Textual description of the event
  * @param {number} numericalValue Numerical value describing the progress
  */
	OBJLoader2.prototype.onProgress = function (type, text, numericalValue) {
		var content = Validator.isValid(text) ? text : '';
		var event = {
			detail: {
				type: type,
				modelName: this.modelName,
				instanceNo: this.instanceNo,
				text: content,
				numericalValue: numericalValue
			}
		};

		if (Validator.isValid(this.callbacks.onProgress)) this.callbacks.onProgress(event);

		if (this.logging.enabled && this.logging.debug) console.debug(content);
	};

	OBJLoader2.prototype._onError = function (event) {
		var output = 'Error occurred while downloading!';

		if (event.currentTarget && event.currentTarget.statusText !== null) {

			output += '\nurl: ' + event.currentTarget.responseURL + '\nstatus: ' + event.currentTarget.statusText;
		}
		this.onProgress('error', output, -1);
		throw output;
	};

	/**
  * Use this convenient method to load a file at the given URL. By default the fileLoader uses an ArrayBuffer.
  * @memberOf THREE.OBJLoader2
  *
  * @param {string}  url A string containing the path/URL of the file to be loaded.
  * @param {callback} onLoad A function to be called after loading is successfully completed. The function receives loaded Object3D as an argument.
  * @param {callback} [onProgress] A function to be called while the loading is in progress. The argument will be the XMLHttpRequest instance, which contains total and Integer bytes.
  * @param {callback} [onError] A function to be called if an error occurs during loading. The function receives the error as an argument.
  * @param {callback} [onMeshAlter] A function to be called after a new mesh raw data becomes available for alteration.
  * @param {boolean} [useAsync] If true, uses async loading with worker, if false loads data synchronously.
  */
	OBJLoader2.prototype.load = function (url, onLoad, onProgress, onError, onMeshAlter, useAsync) {
		var resource = new _LoaderSupport2.default.ResourceDescriptor(url, 'OBJ');
		this._loadObj(resource, onLoad, onProgress, onError, onMeshAlter, useAsync);
	};

	OBJLoader2.prototype._loadObj = function (resource, onLoad, onProgress, onError, onMeshAlter, useAsync) {
		if (!Validator.isValid(onError)) onError = this._onError;

		// fast-fail
		if (!Validator.isValid(resource)) onError('An invalid ResourceDescriptor was provided. Unable to continue!');
		var scope = this;
		var fileLoaderOnLoad = function fileLoaderOnLoad(content) {

			resource.content = content;
			if (useAsync) {

				scope.parseAsync(content, onLoad);
			} else {

				var callbacks = new _LoaderSupport2.default.Callbacks();
				callbacks.setCallbackOnMeshAlter(onMeshAlter);
				scope._setCallbacks(callbacks);
				onLoad({
					detail: {
						loaderRootNode: scope.parse(content),
						modelName: scope.modelName,
						instanceNo: scope.instanceNo
					}
				});
			}
		};

		// fast-fail
		if (!Validator.isValid(resource.url) || Validator.isValid(resource.content)) {

			fileLoaderOnLoad(Validator.isValid(resource.content) ? resource.content : null);
		} else {

			if (!Validator.isValid(onProgress)) {
				var numericalValueRef = 0;
				var numericalValue = 0;
				onProgress = function onProgress(event) {
					if (!event.lengthComputable) return;

					numericalValue = event.loaded / event.total;
					if (numericalValue > numericalValueRef) {

						numericalValueRef = numericalValue;
						var output = 'Download of "' + resource.url + '": ' + (numericalValue * 100).toFixed(2) + '%';
						scope.onProgress('progressLoad', output, numericalValue);
					}
				};
			}

			var fileLoader = new THREE.FileLoader(this.manager);
			fileLoader.setPath(this.path);
			fileLoader.setResponseType('arraybuffer');
			fileLoader.load(resource.url, fileLoaderOnLoad, onProgress, onError);
		}
	};

	/**
  * Run the loader according the provided instructions.
  * @memberOf THREE.OBJLoader2
  *
  * @param {LoaderSupport.PrepData} prepData All parameters and resources required for execution
  * @param {LoaderSupport.WorkerSupport} [workerSupportExternal] Use pre-existing WorkerSupport
  */
	OBJLoader2.prototype.run = function (prepData, workerSupportExternal) {
		this._applyPrepData(prepData);
		var available = prepData.checkResourceDescriptorFiles(prepData.resources, [{ ext: "obj", type: "ArrayBuffer", ignore: false }, { ext: "mtl", type: "String", ignore: false }, { ext: "zip", type: "String", ignore: true }]);
		if (Validator.isValid(workerSupportExternal)) {

			this.terminateWorkerOnLoad = false;
			this.workerSupport = workerSupportExternal;
			this.logging.enabled = this.workerSupport.logging.enabled;
			this.logging.debug = this.workerSupport.logging.debug;
		}
		var scope = this;
		var onMaterialsLoaded = function onMaterialsLoaded(materials) {
			if (materials !== null) scope.meshBuilder.setMaterials(materials);
			scope._loadObj(available.obj, scope.callbacks.onLoad, null, null, scope.callbacks.onMeshAlter, prepData.useAsync);
		};
		this._loadMtl(available.mtl, onMaterialsLoaded, prepData.crossOrigin, prepData.materialOptions);
	};

	OBJLoader2.prototype._applyPrepData = function (prepData) {
		if (Validator.isValid(prepData)) {

			this.setLogging(prepData.logging.enabled, prepData.logging.debug);
			this.setModelName(prepData.modelName);
			this.setStreamMeshesTo(prepData.streamMeshesTo);
			this.meshBuilder.setMaterials(prepData.materials);
			this.setUseIndices(prepData.useIndices);
			this.setDisregardNormals(prepData.disregardNormals);
			this.setMaterialPerSmoothingGroup(prepData.materialPerSmoothingGroup);

			this._setCallbacks(prepData.getCallbacks());
		}
	};

	/**
  * Parses OBJ data synchronously from arraybuffer or string.
  * @memberOf THREE.OBJLoader2
  *
  * @param {arraybuffer|string} content OBJ data as Uint8Array or String
  */
	OBJLoader2.prototype.parse = function (content) {
		// fast-fail in case of illegal data
		if (!Validator.isValid(content)) {

			console.warn('Provided content is not a valid ArrayBuffer or String.');
			return this.loaderRootNode;
		}
		if (this.logging.enabled) console.time('OBJLoader2 parse: ' + this.modelName);
		this.meshBuilder.init();

		var parser = new Parser();
		parser.setLogging(this.logging.enabled, this.logging.debug);
		parser.setMaterialPerSmoothingGroup(this.materialPerSmoothingGroup);
		parser.setUseIndices(this.useIndices);
		parser.setDisregardNormals(this.disregardNormals);
		// sync code works directly on the material references
		parser.setMaterials(this.meshBuilder.getMaterials());

		var scope = this;
		var onMeshLoaded = function onMeshLoaded(payload) {
			var meshes = scope.meshBuilder.processPayload(payload);
			var mesh;
			for (var i in meshes) {
				mesh = meshes[i];
				scope.loaderRootNode.add(mesh);
			}
		};
		parser.setCallbackMeshBuilder(onMeshLoaded);
		var onProgressScoped = function onProgressScoped(text, numericalValue) {
			scope.onProgress('progressParse', text, numericalValue);
		};
		parser.setCallbackProgress(onProgressScoped);

		if (content instanceof ArrayBuffer || content instanceof Uint8Array) {

			if (this.logging.enabled) console.info('Parsing arrayBuffer...');
			parser.parse(content);
		} else if (typeof content === 'string' || content instanceof String) {

			if (this.logging.enabled) console.info('Parsing text...');
			parser.parseText(content);
		} else {

			throw 'Provided content was neither of type String nor Uint8Array! Aborting...';
		}
		if (this.logging.enabled) console.timeEnd('OBJLoader2 parse: ' + this.modelName);

		return this.loaderRootNode;
	};

	/**
  * Parses OBJ content asynchronously from arraybuffer.
  * @memberOf THREE.OBJLoader2
  *
  * @param {arraybuffer} content OBJ data as Uint8Array
  * @param {callback} onLoad Called after worker successfully completed loading
  */
	OBJLoader2.prototype.parseAsync = function (content, onLoad) {
		var scope = this;
		var measureTime = false;
		var scopedOnLoad = function scopedOnLoad() {
			onLoad({
				detail: {
					loaderRootNode: scope.loaderRootNode,
					modelName: scope.modelName,
					instanceNo: scope.instanceNo
				}
			});
			if (measureTime && scope.logging.enabled) console.timeEnd('OBJLoader2 parseAsync: ' + scope.modelName);
		};
		// fast-fail in case of illegal data
		if (!Validator.isValid(content)) {

			console.warn('Provided content is not a valid ArrayBuffer.');
			scopedOnLoad();
		} else {

			measureTime = true;
		}
		if (measureTime && this.logging.enabled) console.time('OBJLoader2 parseAsync: ' + this.modelName);
		this.meshBuilder.init();

		var scopedOnMeshLoaded = function scopedOnMeshLoaded(payload) {
			var meshes = scope.meshBuilder.processPayload(payload);
			var mesh;
			for (var i in meshes) {
				mesh = meshes[i];
				scope.loaderRootNode.add(mesh);
			}
		};
		var buildCode = function buildCode(funcBuildObject, funcBuildSingleton) {
			var workerCode = '';
			workerCode += '/**\n';
			workerCode += '  * This code was constructed by OBJLoader2 buildCode.\n';
			workerCode += '  */\n\n';
			workerCode += 'THREE = { LoaderSupport: {} };\n\n';
			workerCode += funcBuildObject('LoaderSupport.Validator', Validator);
			workerCode += funcBuildSingleton('Parser', Parser);

			return workerCode;
		};
		this.workerSupport.validate(buildCode, 'Parser');
		this.workerSupport.setCallbacks(scopedOnMeshLoaded, scopedOnLoad);
		if (scope.terminateWorkerOnLoad) this.workerSupport.setTerminateRequested(true);

		var materialNames = {};
		var materials = this.meshBuilder.getMaterials();
		for (var materialName in materials) {

			materialNames[materialName] = materialName;
		}
		this.workerSupport.run({
			params: {
				useAsync: true,
				materialPerSmoothingGroup: this.materialPerSmoothingGroup,
				useIndices: this.useIndices,
				disregardNormals: this.disregardNormals
			},
			logging: {
				enabled: this.logging.enabled,
				debug: this.logging.debug
			},
			materials: {
				// in async case only material names are supplied to parser
				materials: materialNames
			},
			data: {
				input: content,
				options: null
			}
		});
	};

	/**
  * Parse OBJ data either from ArrayBuffer or string
  * @class
  */
	var Parser = function () {

		function Parser() {
			this.callbackProgress = null;
			this.callbackMeshBuilder = null;
			this.contentRef = null;
			this.legacyMode = false;

			this.materials = {};
			this.useAsync = false;
			this.materialPerSmoothingGroup = false;
			this.useIndices = false;
			this.disregardNormals = false;

			this.vertices = [];
			this.colors = [];
			this.normals = [];
			this.uvs = [];

			this.rawMesh = {
				objectName: '',
				groupName: '',
				activeMtlName: '',
				mtllibName: '',

				// reset with new mesh
				faceType: -1,
				subGroups: [],
				subGroupInUse: null,
				smoothingGroup: {
					splitMaterials: false,
					normalized: -1,
					real: -1
				},
				counts: {
					doubleIndicesCount: 0,
					faceCount: 0,
					mtlCount: 0,
					smoothingGroupCount: 0
				}
			};

			this.inputObjectCount = 1;
			this.outputObjectCount = 1;
			this.globalCounts = {
				vertices: 0,
				faces: 0,
				doubleIndicesCount: 0,
				lineByte: 0,
				currentByte: 0,
				totalBytes: 0
			};

			this.logging = {
				enabled: true,
				debug: false
			};
		}

		Parser.prototype.resetRawMesh = function () {
			// faces are stored according combined index of group, material and smoothingGroup (0 or not)
			this.rawMesh.subGroups = [];
			this.rawMesh.subGroupInUse = null;
			this.rawMesh.smoothingGroup.normalized = -1;
			this.rawMesh.smoothingGroup.real = -1;

			// this default index is required as it is possible to define faces without 'g' or 'usemtl'
			this.pushSmoothingGroup(1);

			this.rawMesh.counts.doubleIndicesCount = 0;
			this.rawMesh.counts.faceCount = 0;
			this.rawMesh.counts.mtlCount = 0;
			this.rawMesh.counts.smoothingGroupCount = 0;
		};

		Parser.prototype.setUseAsync = function (useAsync) {
			this.useAsync = useAsync;
		};

		Parser.prototype.setMaterialPerSmoothingGroup = function (materialPerSmoothingGroup) {
			this.materialPerSmoothingGroup = materialPerSmoothingGroup;
		};

		Parser.prototype.setUseIndices = function (useIndices) {
			this.useIndices = useIndices;
		};

		Parser.prototype.setDisregardNormals = function (disregardNormals) {
			this.disregardNormals = disregardNormals;
		};

		Parser.prototype.setMaterials = function (materials) {
			this.materials = _LoaderSupport2.default.Validator.verifyInput(materials, this.materials);
			this.materials = _LoaderSupport2.default.Validator.verifyInput(this.materials, {});
		};

		Parser.prototype.setCallbackMeshBuilder = function (callbackMeshBuilder) {
			if (!_LoaderSupport2.default.Validator.isValid(callbackMeshBuilder)) throw 'Unable to run as no "MeshBuilder" callback is set.';
			this.callbackMeshBuilder = callbackMeshBuilder;
		};

		Parser.prototype.setCallbackProgress = function (callbackProgress) {
			this.callbackProgress = callbackProgress;
		};

		Parser.prototype.setLogging = function (enabled, debug) {
			this.logging.enabled = enabled === true;
			this.logging.debug = debug === true;
		};

		Parser.prototype.configure = function () {
			this.pushSmoothingGroup(1);

			if (this.logging.enabled) {

				var matKeys = Object.keys(this.materials);
				var matNames = matKeys.length > 0 ? '\n\tmaterialNames:\n\t\t- ' + matKeys.join('\n\t\t- ') : '\n\tmaterialNames: None';
				var printedConfig = 'OBJLoader2.Parser configuration:' + matNames + '\n\tuseAsync: ' + this.useAsync + '\n\tmaterialPerSmoothingGroup: ' + this.materialPerSmoothingGroup + '\n\tuseIndices: ' + this.useIndices + '\n\tdisregardNormals: ' + this.disregardNormals + '\n\tcallbackMeshBuilderName: ' + this.callbackMeshBuilder.name + '\n\tcallbackProgressName: ' + this.callbackProgress.name;
				console.info(printedConfig);
			}
		};

		/**
   * Parse the provided arraybuffer
   * @memberOf Parser
   *
   * @param {Uint8Array} arrayBuffer OBJ data as Uint8Array
   */
		Parser.prototype.parse = function (arrayBuffer) {
			if (this.logging.enabled) console.time('OBJLoader2.Parser.parse');
			this.configure();

			var arrayBufferView = new Uint8Array(arrayBuffer);
			this.contentRef = arrayBufferView;
			var length = arrayBufferView.byteLength;
			this.globalCounts.totalBytes = length;
			var buffer = new Array(128);

			for (var code, word = '', bufferPointer = 0, slashesCount = 0, i = 0; i < length; i++) {

				code = arrayBufferView[i];
				switch (code) {
					// space
					case 32:
						if (word.length > 0) buffer[bufferPointer++] = word;
						word = '';
						break;
					// slash
					case 47:
						if (word.length > 0) buffer[bufferPointer++] = word;
						slashesCount++;
						word = '';
						break;

					// LF
					case 10:
						if (word.length > 0) buffer[bufferPointer++] = word;
						word = '';
						this.globalCounts.lineByte = this.globalCounts.currentByte;
						this.globalCounts.currentByte = i;
						this.processLine(buffer, bufferPointer, slashesCount);
						bufferPointer = 0;
						slashesCount = 0;
						break;

					// CR
					case 13:
						break;

					default:
						word += String.fromCharCode(code);
						break;
				}
			}
			this.finalizeParsing();
			if (this.logging.enabled) console.timeEnd('OBJLoader2.Parser.parse');
		};

		/**
   * Parse the provided text
   * @memberOf Parser
   *
   * @param {string} text OBJ data as string
   */
		Parser.prototype.parseText = function (text) {
			if (this.logging.enabled) console.time('OBJLoader2.Parser.parseText');
			this.configure();
			this.legacyMode = true;
			this.contentRef = text;
			var length = text.length;
			this.globalCounts.totalBytes = length;
			var buffer = new Array(128);

			for (var char, word = '', bufferPointer = 0, slashesCount = 0, i = 0; i < length; i++) {

				char = text[i];
				switch (char) {
					case ' ':
						if (word.length > 0) buffer[bufferPointer++] = word;
						word = '';
						break;

					case '/':
						if (word.length > 0) buffer[bufferPointer++] = word;
						slashesCount++;
						word = '';
						break;

					case '\n':
						if (word.length > 0) buffer[bufferPointer++] = word;
						word = '';
						this.globalCounts.lineByte = this.globalCounts.currentByte;
						this.globalCounts.currentByte = i;
						this.processLine(buffer, bufferPointer, slashesCount);
						bufferPointer = 0;
						slashesCount = 0;
						break;

					case '\r':
						break;

					default:
						word += char;
				}
			}
			this.finalizeParsing();
			if (this.logging.enabled) console.timeEnd('OBJLoader2.Parser.parseText');
		};

		Parser.prototype.processLine = function (buffer, bufferPointer, slashesCount) {
			if (bufferPointer < 1) return;

			var reconstructString = function reconstructString(content, legacyMode, start, stop) {
				var line = '';
				if (stop > start) {

					var i;
					if (legacyMode) {

						for (i = start; i < stop; i++) {
							line += content[i];
						}
					} else {

						for (i = start; i < stop; i++) {
							line += String.fromCharCode(content[i]);
						}
					}
					line = line.trim();
				}
				return line;
			};

			var bufferLength, length, i, lineDesignation;
			lineDesignation = buffer[0];
			switch (lineDesignation) {
				case 'v':
					this.vertices.push(parseFloat(buffer[1]));
					this.vertices.push(parseFloat(buffer[2]));
					this.vertices.push(parseFloat(buffer[3]));
					if (bufferPointer > 4) {

						this.colors.push(parseFloat(buffer[4]));
						this.colors.push(parseFloat(buffer[5]));
						this.colors.push(parseFloat(buffer[6]));
					}
					break;

				case 'vt':
					this.uvs.push(parseFloat(buffer[1]));
					this.uvs.push(parseFloat(buffer[2]));
					break;

				case 'vn':
					this.normals.push(parseFloat(buffer[1]));
					this.normals.push(parseFloat(buffer[2]));
					this.normals.push(parseFloat(buffer[3]));
					break;

				case 'f':
					bufferLength = bufferPointer - 1;

					// "f vertex ..."
					if (slashesCount === 0) {

						this.checkFaceType(0);
						for (i = 2, length = bufferLength; i < length; i++) {

							this.buildFace(buffer[1]);
							this.buildFace(buffer[i]);
							this.buildFace(buffer[i + 1]);
						}

						// "f vertex/uv ..."
					} else if (bufferLength === slashesCount * 2) {

						this.checkFaceType(1);
						for (i = 3, length = bufferLength - 2; i < length; i += 2) {

							this.buildFace(buffer[1], buffer[2]);
							this.buildFace(buffer[i], buffer[i + 1]);
							this.buildFace(buffer[i + 2], buffer[i + 3]);
						}

						// "f vertex/uv/normal ..."
					} else if (bufferLength * 2 === slashesCount * 3) {

						this.checkFaceType(2);
						for (i = 4, length = bufferLength - 3; i < length; i += 3) {

							this.buildFace(buffer[1], buffer[2], buffer[3]);
							this.buildFace(buffer[i], buffer[i + 1], buffer[i + 2]);
							this.buildFace(buffer[i + 3], buffer[i + 4], buffer[i + 5]);
						}

						// "f vertex//normal ..."
					} else {

						this.checkFaceType(3);
						for (i = 3, length = bufferLength - 2; i < length; i += 2) {

							this.buildFace(buffer[1], undefined, buffer[2]);
							this.buildFace(buffer[i], undefined, buffer[i + 1]);
							this.buildFace(buffer[i + 2], undefined, buffer[i + 3]);
						}
					}
					break;

				case 'l':
				case 'p':
					bufferLength = bufferPointer - 1;
					if (bufferLength === slashesCount * 2) {

						this.checkFaceType(4);
						for (i = 1, length = bufferLength + 1; i < length; i += 2) {
							this.buildFace(buffer[i], buffer[i + 1]);
						}
					} else {

						this.checkFaceType(lineDesignation === 'l' ? 5 : 6);
						for (i = 1, length = bufferLength + 1; i < length; i++) {
							this.buildFace(buffer[i]);
						}
					}
					break;

				case 's':
					this.pushSmoothingGroup(buffer[1]);
					break;

				case 'g':
					// 'g' leads to creation of mesh if valid data (faces declaration was done before), otherwise only groupName gets set
					this.processCompletedMesh();
					this.rawMesh.groupName = reconstructString(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte);
					break;

				case 'o':
					// 'o' is pure meta-information and does not result in creation of new meshes
					this.rawMesh.objectName = reconstructString(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte);
					break;

				case 'mtllib':
					this.rawMesh.mtllibName = reconstructString(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte);
					break;

				case 'usemtl':
					var mtlName = reconstructString(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte);
					if (mtlName !== '' && this.rawMesh.activeMtlName !== mtlName) {

						this.rawMesh.activeMtlName = mtlName;
						this.rawMesh.counts.mtlCount++;
						this.checkSubGroup();
					}
					break;

				default:
					break;
			}
		};

		Parser.prototype.pushSmoothingGroup = function (smoothingGroup) {
			var smoothingGroupInt = parseInt(smoothingGroup);
			if (isNaN(smoothingGroupInt)) {
				smoothingGroupInt = smoothingGroup === "off" ? 0 : 1;
			}

			var smoothCheck = this.rawMesh.smoothingGroup.normalized;
			this.rawMesh.smoothingGroup.normalized = this.rawMesh.smoothingGroup.splitMaterials ? smoothingGroupInt : smoothingGroupInt === 0 ? 0 : 1;
			this.rawMesh.smoothingGroup.real = smoothingGroupInt;

			if (smoothCheck !== smoothingGroupInt) {

				this.rawMesh.counts.smoothingGroupCount++;
				this.checkSubGroup();
			}
		};

		/**
   * Expanded faceTypes include all four face types, both line types and the point type
   * faceType = 0: "f vertex ..."
   * faceType = 1: "f vertex/uv ..."
   * faceType = 2: "f vertex/uv/normal ..."
   * faceType = 3: "f vertex//normal ..."
   * faceType = 4: "l vertex/uv ..." or "l vertex ..."
   * faceType = 5: "l vertex ..."
   * faceType = 6: "p vertex ..."
   */
		Parser.prototype.checkFaceType = function (faceType) {
			if (this.rawMesh.faceType !== faceType) {

				this.processCompletedMesh();
				this.rawMesh.faceType = faceType;
				this.checkSubGroup();
			}
		};

		Parser.prototype.checkSubGroup = function () {
			var index = this.rawMesh.activeMtlName + '|' + this.rawMesh.smoothingGroup.normalized;
			this.rawMesh.subGroupInUse = this.rawMesh.subGroups[index];

			if (!_LoaderSupport2.default.Validator.isValid(this.rawMesh.subGroupInUse)) {

				this.rawMesh.subGroupInUse = {
					index: index,
					objectName: this.rawMesh.objectName,
					groupName: this.rawMesh.groupName,
					materialName: this.rawMesh.activeMtlName,
					smoothingGroup: this.rawMesh.smoothingGroup.normalized,
					vertices: [],
					indexMappingsCount: 0,
					indexMappings: [],
					indices: [],
					colors: [],
					uvs: [],
					normals: []
				};
				this.rawMesh.subGroups[index] = this.rawMesh.subGroupInUse;
			}
		};

		Parser.prototype.buildFace = function (faceIndexV, faceIndexU, faceIndexN) {
			if (this.disregardNormals) faceIndexN = undefined;
			var scope = this;
			var updateSubGroupInUse = function updateSubGroupInUse() {

				var faceIndexVi = parseInt(faceIndexV);
				var indexPointerV = 3 * (faceIndexVi > 0 ? faceIndexVi - 1 : faceIndexVi + scope.vertices.length / 3);

				var vertices = scope.rawMesh.subGroupInUse.vertices;
				vertices.push(scope.vertices[indexPointerV++]);
				vertices.push(scope.vertices[indexPointerV++]);
				vertices.push(scope.vertices[indexPointerV]);

				var indexPointerC = scope.colors.length > 0 ? indexPointerV : null;
				if (indexPointerC !== null) {

					var colors = scope.rawMesh.subGroupInUse.colors;
					colors.push(scope.colors[indexPointerC++]);
					colors.push(scope.colors[indexPointerC++]);
					colors.push(scope.colors[indexPointerC]);
				}
				if (faceIndexU) {

					var faceIndexUi = parseInt(faceIndexU);
					var indexPointerU = 2 * (faceIndexUi > 0 ? faceIndexUi - 1 : faceIndexUi + scope.uvs.length / 2);
					var uvs = scope.rawMesh.subGroupInUse.uvs;
					uvs.push(scope.uvs[indexPointerU++]);
					uvs.push(scope.uvs[indexPointerU]);
				}
				if (faceIndexN) {

					var faceIndexNi = parseInt(faceIndexN);
					var indexPointerN = 3 * (faceIndexNi > 0 ? faceIndexNi - 1 : faceIndexNi + scope.normals.length / 3);
					var normals = scope.rawMesh.subGroupInUse.normals;
					normals.push(scope.normals[indexPointerN++]);
					normals.push(scope.normals[indexPointerN++]);
					normals.push(scope.normals[indexPointerN]);
				}
			};

			if (this.useIndices) {

				var mappingName = faceIndexV + (faceIndexU ? '_' + faceIndexU : '_n') + (faceIndexN ? '_' + faceIndexN : '_n');
				var indicesPointer = this.rawMesh.subGroupInUse.indexMappings[mappingName];
				if (_LoaderSupport2.default.Validator.isValid(indicesPointer)) {

					this.rawMesh.counts.doubleIndicesCount++;
				} else {

					indicesPointer = this.rawMesh.subGroupInUse.vertices.length / 3;
					updateSubGroupInUse();
					this.rawMesh.subGroupInUse.indexMappings[mappingName] = indicesPointer;
					this.rawMesh.subGroupInUse.indexMappingsCount++;
				}
				this.rawMesh.subGroupInUse.indices.push(indicesPointer);
			} else {

				updateSubGroupInUse();
			}
			this.rawMesh.counts.faceCount++;
		};

		Parser.prototype.createRawMeshReport = function (inputObjectCount) {
			return 'Input Object number: ' + inputObjectCount + '\n\tObject name: ' + this.rawMesh.objectName + '\n\tGroup name: ' + this.rawMesh.groupName + '\n\tMtllib name: ' + this.rawMesh.mtllibName + '\n\tVertex count: ' + this.vertices.length / 3 + '\n\tNormal count: ' + this.normals.length / 3 + '\n\tUV count: ' + this.uvs.length / 2 + '\n\tSmoothingGroup count: ' + this.rawMesh.counts.smoothingGroupCount + '\n\tMaterial count: ' + this.rawMesh.counts.mtlCount + '\n\tReal MeshOutputGroup count: ' + this.rawMesh.subGroups.length;
		};

		/**
   * Clear any empty subGroup and calculate absolute vertex, normal and uv counts
   */
		Parser.prototype.finalizeRawMesh = function () {
			var meshOutputGroupTemp = [];
			var meshOutputGroup;
			var absoluteVertexCount = 0;
			var absoluteIndexMappingsCount = 0;
			var absoluteIndexCount = 0;
			var absoluteColorCount = 0;
			var absoluteNormalCount = 0;
			var absoluteUvCount = 0;
			var indices;
			for (var name in this.rawMesh.subGroups) {

				meshOutputGroup = this.rawMesh.subGroups[name];
				if (meshOutputGroup.vertices.length > 0) {

					indices = meshOutputGroup.indices;
					if (indices.length > 0 && absoluteIndexMappingsCount > 0) {

						for (var i in indices) {
							indices[i] = indices[i] + absoluteIndexMappingsCount;
						}
					}
					meshOutputGroupTemp.push(meshOutputGroup);
					absoluteVertexCount += meshOutputGroup.vertices.length;
					absoluteIndexMappingsCount += meshOutputGroup.indexMappingsCount;
					absoluteIndexCount += meshOutputGroup.indices.length;
					absoluteColorCount += meshOutputGroup.colors.length;
					absoluteUvCount += meshOutputGroup.uvs.length;
					absoluteNormalCount += meshOutputGroup.normals.length;
				}
			}

			// do not continue if no result
			var result = null;
			if (meshOutputGroupTemp.length > 0) {

				result = {
					name: this.rawMesh.groupName !== '' ? this.rawMesh.groupName : this.rawMesh.objectName,
					subGroups: meshOutputGroupTemp,
					absoluteVertexCount: absoluteVertexCount,
					absoluteIndexCount: absoluteIndexCount,
					absoluteColorCount: absoluteColorCount,
					absoluteNormalCount: absoluteNormalCount,
					absoluteUvCount: absoluteUvCount,
					faceCount: this.rawMesh.counts.faceCount,
					doubleIndicesCount: this.rawMesh.counts.doubleIndicesCount
				};
			}
			return result;
		};

		Parser.prototype.processCompletedMesh = function () {
			var result = this.finalizeRawMesh();
			if (_LoaderSupport2.default.Validator.isValid(result)) {

				if (this.colors.length > 0 && this.colors.length !== this.vertices.length) {

					throw 'Vertex Colors were detected, but vertex count and color count do not match!';
				}
				if (this.logging.enabled && this.logging.debug) console.debug(this.createRawMeshReport(this.inputObjectCount));
				this.inputObjectCount++;

				this.buildMesh(result);
				var progressBytesPercent = this.globalCounts.currentByte / this.globalCounts.totalBytes;
				this.callbackProgress('Completed [o: ' + this.rawMesh.objectName + ' g:' + this.rawMesh.groupName + '] Total progress: ' + (progressBytesPercent * 100).toFixed(2) + '%', progressBytesPercent);
				this.resetRawMesh();
				return true;
			} else {

				return false;
			}
		};

		/**
   * SubGroups are transformed to too intermediate format that is forwarded to the MeshBuilder.
   * It is ensured that SubGroups only contain objects with vertices (no need to check).
   *
   * @param result
   */
		Parser.prototype.buildMesh = function (result) {
			var meshOutputGroups = result.subGroups;

			var vertexFA = new Float32Array(result.absoluteVertexCount);
			this.globalCounts.vertices += result.absoluteVertexCount / 3;
			this.globalCounts.faces += result.faceCount;
			this.globalCounts.doubleIndicesCount += result.doubleIndicesCount;
			var indexUA = result.absoluteIndexCount > 0 ? new Uint32Array(result.absoluteIndexCount) : null;
			var colorFA = result.absoluteColorCount > 0 ? new Float32Array(result.absoluteColorCount) : null;
			var normalFA = result.absoluteNormalCount > 0 ? new Float32Array(result.absoluteNormalCount) : null;
			var uvFA = result.absoluteUvCount > 0 ? new Float32Array(result.absoluteUvCount) : null;
			var haveVertexColors = _LoaderSupport2.default.Validator.isValid(colorFA);

			var meshOutputGroup;
			var materialNames = [];

			var createMultiMaterial = meshOutputGroups.length > 1;
			var materialIndex = 0;
			var materialIndexMapping = [];
			var selectedMaterialIndex;
			var materialGroup;
			var materialGroups = [];

			var vertexFAOffset = 0;
			var indexUAOffset = 0;
			var colorFAOffset = 0;
			var normalFAOffset = 0;
			var uvFAOffset = 0;
			var materialGroupOffset = 0;
			var materialGroupLength = 0;

			var materialOrg, material, materialName, materialNameOrg;
			// only one specific face type
			for (var oodIndex in meshOutputGroups) {

				if (!meshOutputGroups.hasOwnProperty(oodIndex)) continue;
				meshOutputGroup = meshOutputGroups[oodIndex];

				materialNameOrg = meshOutputGroup.materialName;
				if (this.rawMesh.faceType < 4) {

					materialName = materialNameOrg + (haveVertexColors ? '_vertexColor' : '') + (meshOutputGroup.smoothingGroup === 0 ? '_flat' : '');
				} else {

					materialName = this.rawMesh.faceType === 6 ? 'defaultPointMaterial' : 'defaultLineMaterial';
				}
				materialOrg = this.materials[materialNameOrg];
				material = this.materials[materialName];

				// both original and derived names do not lead to an existing material => need to use a default material
				if (!_LoaderSupport2.default.Validator.isValid(materialOrg) && !_LoaderSupport2.default.Validator.isValid(material)) {

					var defaultMaterialName = haveVertexColors ? 'defaultVertexColorMaterial' : 'defaultMaterial';
					materialOrg = this.materials[defaultMaterialName];
					if (this.logging.enabled) console.warn('object_group "' + meshOutputGroup.objectName + '_' + meshOutputGroup.groupName + '" was defined with unresolvable material "' + materialNameOrg + '"! Assigning "' + defaultMaterialName + '".');
					materialNameOrg = defaultMaterialName;

					// if names are identical then there is no need for later manipulation
					if (materialNameOrg === materialName) {

						material = materialOrg;
						materialName = defaultMaterialName;
					}
				}
				if (!_LoaderSupport2.default.Validator.isValid(material)) {

					var materialCloneInstructions = {
						materialNameOrg: materialNameOrg,
						materialName: materialName,
						materialProperties: {
							vertexColors: haveVertexColors ? 2 : 0,
							flatShading: meshOutputGroup.smoothingGroup === 0
						}
					};
					var payload = {
						cmd: 'materialData',
						materials: {
							materialCloneInstructions: materialCloneInstructions
						}
					};
					this.callbackMeshBuilder(payload);

					// fake entry for async; sync Parser always works on material references (Builder update directly visible here)
					if (this.useAsync) this.materials[materialName] = materialCloneInstructions;
				}

				if (createMultiMaterial) {

					// re-use material if already used before. Reduces materials array size and eliminates duplicates
					selectedMaterialIndex = materialIndexMapping[materialName];
					if (!selectedMaterialIndex) {

						selectedMaterialIndex = materialIndex;
						materialIndexMapping[materialName] = materialIndex;
						materialNames.push(materialName);
						materialIndex++;
					}
					materialGroupLength = this.useIndices ? meshOutputGroup.indices.length : meshOutputGroup.vertices.length / 3;
					materialGroup = {
						start: materialGroupOffset,
						count: materialGroupLength,
						index: selectedMaterialIndex
					};
					materialGroups.push(materialGroup);
					materialGroupOffset += materialGroupLength;
				} else {

					materialNames.push(materialName);
				}

				vertexFA.set(meshOutputGroup.vertices, vertexFAOffset);
				vertexFAOffset += meshOutputGroup.vertices.length;

				if (indexUA) {

					indexUA.set(meshOutputGroup.indices, indexUAOffset);
					indexUAOffset += meshOutputGroup.indices.length;
				}

				if (colorFA) {

					colorFA.set(meshOutputGroup.colors, colorFAOffset);
					colorFAOffset += meshOutputGroup.colors.length;
				}

				if (normalFA) {

					normalFA.set(meshOutputGroup.normals, normalFAOffset);
					normalFAOffset += meshOutputGroup.normals.length;
				}
				if (uvFA) {

					uvFA.set(meshOutputGroup.uvs, uvFAOffset);
					uvFAOffset += meshOutputGroup.uvs.length;
				}

				if (this.logging.enabled && this.logging.debug) {
					var materialIndexLine = _LoaderSupport2.default.Validator.isValid(selectedMaterialIndex) ? '\n\t\tmaterialIndex: ' + selectedMaterialIndex : '';
					var createdReport = '\tOutput Object no.: ' + this.outputObjectCount + '\n\t\tgroupName: ' + meshOutputGroup.groupName + '\n\t\tIndex: ' + meshOutputGroup.index + '\n\t\tfaceType: ' + this.rawMesh.faceType + '\n\t\tmaterialName: ' + meshOutputGroup.materialName + '\n\t\tsmoothingGroup: ' + meshOutputGroup.smoothingGroup + materialIndexLine + '\n\t\tobjectName: ' + meshOutputGroup.objectName + '\n\t\t#vertices: ' + meshOutputGroup.vertices.length / 3 + '\n\t\t#indices: ' + meshOutputGroup.indices.length + '\n\t\t#colors: ' + meshOutputGroup.colors.length / 3 + '\n\t\t#uvs: ' + meshOutputGroup.uvs.length / 2 + '\n\t\t#normals: ' + meshOutputGroup.normals.length / 3;
					console.debug(createdReport);
				}
			}

			this.outputObjectCount++;
			this.callbackMeshBuilder({
				cmd: 'meshData',
				progress: {
					numericalValue: this.globalCounts.currentByte / this.globalCounts.totalBytes
				},
				params: {
					meshName: result.name
				},
				materials: {
					multiMaterial: createMultiMaterial,
					materialNames: materialNames,
					materialGroups: materialGroups
				},
				buffers: {
					vertices: vertexFA,
					indices: indexUA,
					colors: colorFA,
					normals: normalFA,
					uvs: uvFA
				},
				// 0: mesh, 1: line, 2: point
				geometryType: this.rawMesh.faceType < 4 ? 0 : this.rawMesh.faceType === 6 ? 2 : 1
			}, [vertexFA.buffer], _LoaderSupport2.default.Validator.isValid(indexUA) ? [indexUA.buffer] : null, _LoaderSupport2.default.Validator.isValid(colorFA) ? [colorFA.buffer] : null, _LoaderSupport2.default.Validator.isValid(normalFA) ? [normalFA.buffer] : null, _LoaderSupport2.default.Validator.isValid(uvFA) ? [uvFA.buffer] : null);
		};

		Parser.prototype.finalizeParsing = function () {
			if (this.logging.enabled) console.info('Global output object count: ' + this.outputObjectCount);
			if (this.processCompletedMesh() && this.logging.enabled) {

				var parserFinalReport = 'Overall counts: ' + '\n\tVertices: ' + this.globalCounts.vertices + '\n\tFaces: ' + this.globalCounts.faces + '\n\tMultiple definitions: ' + this.globalCounts.doubleIndicesCount;
				console.info(parserFinalReport);
			}
		};

		return Parser;
	}();

	/**
  * Utility method for loading an mtl file according resource description. Provide url or content.
  * @memberOf THREE.OBJLoader2
  *
  * @param {string} url URL to the file
  * @param {Object} content The file content as arraybuffer or text
  * @param {function} callbackOnLoad Callback to be called after successful load
  * @param {string} [crossOrigin] CORS value
 	 * @param {Object} [materialOptions] Set material loading options for MTLLoader
  */
	OBJLoader2.prototype.loadMtl = function (url, content, callbackOnLoad, crossOrigin, materialOptions) {
		var resource = new _LoaderSupport2.default.ResourceDescriptor(url, 'MTL');
		resource.setContent(content);
		this._loadMtl(resource, callbackOnLoad, crossOrigin, materialOptions);
	};

	OBJLoader2.prototype._loadMtl = function (resource, callbackOnLoad, crossOrigin, materialOptions) {
		if (_MTLLoader2.default === undefined) console.error('"THREE.MTLLoader" is not available. "THREE.OBJLoader2" requires it for loading MTL files.');
		if (Validator.isValid(resource) && this.logging.enabled) console.time('Loading MTL: ' + resource.name);

		var materials = [];
		var scope = this;
		var processMaterials = function processMaterials(materialCreator) {
			var materialCreatorMaterials = [];
			if (Validator.isValid(materialCreator)) {

				materialCreator.preload();
				materialCreatorMaterials = materialCreator.materials;
				for (var materialName in materialCreatorMaterials) {

					if (materialCreatorMaterials.hasOwnProperty(materialName)) {

						materials[materialName] = materialCreatorMaterials[materialName];
					}
				}
			}

			if (Validator.isValid(resource) && scope.logging.enabled) console.timeEnd('Loading MTL: ' + resource.name);
			callbackOnLoad(materials, materialCreator);
		};

		// fast-fail
		if (!Validator.isValid(resource) || !Validator.isValid(resource.content) && !Validator.isValid(resource.url)) {

			processMaterials();
		} else {

			var mtlLoader = new _MTLLoader2.default(this.manager);
			crossOrigin = Validator.verifyInput(crossOrigin, 'anonymous');
			mtlLoader.setCrossOrigin(crossOrigin);
			mtlLoader.setPath(resource.path);
			if (Validator.isValid(materialOptions)) mtlLoader.setMaterialOptions(materialOptions);

			if (Validator.isValid(resource.content)) {

				processMaterials(Validator.isValid(resource.content) ? mtlLoader.parse(resource.content) : null);
			} else if (Validator.isValid(resource.url)) {

				var fileLoader = new THREE.FileLoader(this.manager);
				fileLoader.load(resource.url, function (text) {

					resource.content = text;
					processMaterials(mtlLoader.parse(text));
				}, this._onProgress, this._onError);
			}
		}
	};

	return OBJLoader2;
}();

exports.default = OBJLoader2;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author Filipe Caixeta / http://filipecaixeta.com.br
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Description: A THREE loader for PCD ascii and binary files.
 *
 * Limitations: Compressed binary files are not supported.
 *
 */

var PCDLoader = function PCDLoader(manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
	this.littleEndian = true;
};

PCDLoader.prototype = {

	constructor: PCDLoader,

	load: function load(url, onLoad, onProgress, onError) {

		var scope = this;

		var loader = new THREE.FileLoader(scope.manager);
		loader.setResponseType('arraybuffer');
		loader.load(url, function (data) {

			onLoad(scope.parse(data, url));
		}, onProgress, onError);
	},

	parse: function parse(data, url) {

		function parseHeader(data) {

			var PCDheader = {};
			var result1 = data.search(/[\r\n]DATA\s(\S*)\s/i);
			var result2 = /[\r\n]DATA\s(\S*)\s/i.exec(data.substr(result1 - 1));

			PCDheader.data = result2[1];
			PCDheader.headerLen = result2[0].length + result1;
			PCDheader.str = data.substr(0, PCDheader.headerLen);

			// remove comments

			PCDheader.str = PCDheader.str.replace(/\#.*/gi, '');

			// parse

			PCDheader.version = /VERSION (.*)/i.exec(PCDheader.str);
			PCDheader.fields = /FIELDS (.*)/i.exec(PCDheader.str);
			PCDheader.size = /SIZE (.*)/i.exec(PCDheader.str);
			PCDheader.type = /TYPE (.*)/i.exec(PCDheader.str);
			PCDheader.count = /COUNT (.*)/i.exec(PCDheader.str);
			PCDheader.width = /WIDTH (.*)/i.exec(PCDheader.str);
			PCDheader.height = /HEIGHT (.*)/i.exec(PCDheader.str);
			PCDheader.viewpoint = /VIEWPOINT (.*)/i.exec(PCDheader.str);
			PCDheader.points = /POINTS (.*)/i.exec(PCDheader.str);

			// evaluate

			if (PCDheader.version !== null) PCDheader.version = parseFloat(PCDheader.version[1]);

			if (PCDheader.fields !== null) PCDheader.fields = PCDheader.fields[1].split(' ');

			if (PCDheader.type !== null) PCDheader.type = PCDheader.type[1].split(' ');

			if (PCDheader.width !== null) PCDheader.width = parseInt(PCDheader.width[1]);

			if (PCDheader.height !== null) PCDheader.height = parseInt(PCDheader.height[1]);

			if (PCDheader.viewpoint !== null) PCDheader.viewpoint = PCDheader.viewpoint[1];

			if (PCDheader.points !== null) PCDheader.points = parseInt(PCDheader.points[1], 10);

			if (PCDheader.points === null) PCDheader.points = PCDheader.width * PCDheader.height;

			if (PCDheader.size !== null) {

				PCDheader.size = PCDheader.size[1].split(' ').map(function (x) {

					return parseInt(x, 10);
				});
			}

			if (PCDheader.count !== null) {

				PCDheader.count = PCDheader.count[1].split(' ').map(function (x) {

					return parseInt(x, 10);
				});
			} else {

				PCDheader.count = [];

				for (var i = 0, l = PCDheader.fields.length; i < l; i++) {

					PCDheader.count.push(1);
				}
			}

			PCDheader.offset = {};

			var sizeSum = 0;

			for (var i = 0, l = PCDheader.fields.length; i < l; i++) {

				if (PCDheader.data === 'ascii') {

					PCDheader.offset[PCDheader.fields[i]] = i;
				} else {

					PCDheader.offset[PCDheader.fields[i]] = sizeSum;
					sizeSum += PCDheader.size[i];
				}
			}

			// for binary only

			PCDheader.rowSize = sizeSum;

			return PCDheader;
		}

		var textData = THREE.LoaderUtils.decodeText(data);

		// parse header (always ascii format)

		var PCDheader = parseHeader(textData);

		// parse data

		var position = [];
		var normal = [];
		var color = [];

		// ascii

		if (PCDheader.data === 'ascii') {

			var offset = PCDheader.offset;
			var pcdData = textData.substr(PCDheader.headerLen);
			var lines = pcdData.split('\n');

			for (var i = 0, l = lines.length; i < l; i++) {

				if (lines[i] === '') continue;

				var line = lines[i].split(' ');

				if (offset.x !== undefined) {

					position.push(parseFloat(line[offset.x]));
					position.push(parseFloat(line[offset.y]));
					position.push(parseFloat(line[offset.z]));
				}

				if (offset.rgb !== undefined) {

					var c = new Float32Array([parseFloat(line[offset.rgb])]);
					var dataview = new DataView(c.buffer, 0);
					color.push(dataview.getUint8(0) / 255.0);
					color.push(dataview.getUint8(1) / 255.0);
					color.push(dataview.getUint8(2) / 255.0);
				}

				if (offset.normal_x !== undefined) {

					normal.push(parseFloat(line[offset.normal_x]));
					normal.push(parseFloat(line[offset.normal_y]));
					normal.push(parseFloat(line[offset.normal_z]));
				}
			}
		}

		// binary

		if (PCDheader.data === 'binary_compressed') {

			console.error('THREE.PCDLoader: binary_compressed files are not supported');
			return;
		}

		if (PCDheader.data === 'binary') {

			var dataview = new DataView(data, PCDheader.headerLen);
			var offset = PCDheader.offset;

			for (var i = 0, row = 0; i < PCDheader.points; i++, row += PCDheader.rowSize) {

				if (offset.x !== undefined) {

					position.push(dataview.getFloat32(row + offset.x, this.littleEndian));
					position.push(dataview.getFloat32(row + offset.y, this.littleEndian));
					position.push(dataview.getFloat32(row + offset.z, this.littleEndian));
				}

				if (offset.rgb !== undefined) {

					color.push(dataview.getUint8(row + offset.rgb + 0) / 255.0);
					color.push(dataview.getUint8(row + offset.rgb + 1) / 255.0);
					color.push(dataview.getUint8(row + offset.rgb + 2) / 255.0);
				}

				if (offset.normal_x !== undefined) {

					normal.push(dataview.getFloat32(row + offset.normal_x, this.littleEndian));
					normal.push(dataview.getFloat32(row + offset.normal_y, this.littleEndian));
					normal.push(dataview.getFloat32(row + offset.normal_z, this.littleEndian));
				}
			}
		}

		// build geometry

		var geometry = new THREE.BufferGeometry();

		if (position.length > 0) geometry.addAttribute('position', new THREE.Float32BufferAttribute(position, 3));
		if (normal.length > 0) geometry.addAttribute('normal', new THREE.Float32BufferAttribute(normal, 3));
		if (color.length > 0) geometry.addAttribute('color', new THREE.Float32BufferAttribute(color, 3));

		geometry.computeBoundingSphere();

		// build material

		var material = new THREE.PointsMaterial({ size: 0.005 });

		if (color.length > 0) {

			material.vertexColors = true;
		} else {

			material.color.setHex(Math.random() * 0xffffff);
		}

		// build mesh

		var mesh = new THREE.Points(geometry, material);
		var name = url.split('').reverse().join('');
		name = /([^\/]*)/.exec(name);
		name = name[1].split('').reverse().join('');
		mesh.name = name;

		return mesh;
	}

};

exports.default = PCDLoader;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author alteredq / http://alteredqualia.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

var PDBLoader = function PDBLoader(manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};

PDBLoader.prototype = {

	constructor: PDBLoader,

	load: function load(url, onLoad, onProgress, onError) {

		var scope = this;

		var loader = new THREE.FileLoader(scope.manager);
		loader.load(url, function (text) {

			onLoad(scope.parse(text));
		}, onProgress, onError);
	},

	// Based on CanvasMol PDB parser

	parse: function parse(text) {

		function trim(text) {

			return text.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
		}

		function capitalize(text) {

			return text.charAt(0).toUpperCase() + text.substr(1).toLowerCase();
		}

		function hash(s, e) {

			return 's' + Math.min(s, e) + 'e' + Math.max(s, e);
		}

		function parseBond(start, length) {

			var eatom = parseInt(lines[i].substr(start, length));

			if (eatom) {

				var h = hash(satom, eatom);

				if (bhash[h] === undefined) {

					bonds.push([satom - 1, eatom - 1, 1]);
					bhash[h] = bonds.length - 1;
				} else {

					// doesn't really work as almost all PDBs
					// have just normal bonds appearing multiple
					// times instead of being double/triple bonds
					// bonds[bhash[h]][2] += 1;

				}
			}
		}

		function buildGeometry() {

			var build = {
				geometryAtoms: new THREE.BufferGeometry(),
				geometryBonds: new THREE.BufferGeometry(),
				json: {
					atoms: atoms,
					bonds: bonds
				}
			};

			var geometryAtoms = build.geometryAtoms;
			var geometryBonds = build.geometryBonds;

			var i, l;

			var verticesAtoms = [];
			var colorsAtoms = [];
			var verticesBonds = [];

			// atoms

			for (i = 0, l = atoms.length; i < l; i++) {

				var atom = atoms[i];

				var x = atom[0];
				var y = atom[1];
				var z = atom[2];

				verticesAtoms.push(x, y, z);

				var r = atom[3][0] / 255;
				var g = atom[3][1] / 255;
				var b = atom[3][2] / 255;

				colorsAtoms.push(r, g, b);
			}

			// bonds

			for (i = 0, l = bonds.length; i < l; i++) {

				var bond = bonds[i];

				var start = bond[0];
				var end = bond[1];

				verticesBonds.push(verticesAtoms[start * 3 + 0]);
				verticesBonds.push(verticesAtoms[start * 3 + 1]);
				verticesBonds.push(verticesAtoms[start * 3 + 2]);

				verticesBonds.push(verticesAtoms[end * 3 + 0]);
				verticesBonds.push(verticesAtoms[end * 3 + 1]);
				verticesBonds.push(verticesAtoms[end * 3 + 2]);
			}

			// build geometry

			geometryAtoms.addAttribute('position', new THREE.Float32BufferAttribute(verticesAtoms, 3));
			geometryAtoms.addAttribute('color', new THREE.Float32BufferAttribute(colorsAtoms, 3));

			geometryBonds.addAttribute('position', new THREE.Float32BufferAttribute(verticesBonds, 3));

			return build;
		}

		var CPK = { h: [255, 255, 255], he: [217, 255, 255], li: [204, 128, 255], be: [194, 255, 0], b: [255, 181, 181], c: [144, 144, 144], n: [48, 80, 248], o: [255, 13, 13], f: [144, 224, 80], ne: [179, 227, 245], na: [171, 92, 242], mg: [138, 255, 0], al: [191, 166, 166], si: [240, 200, 160], p: [255, 128, 0], s: [255, 255, 48], cl: [31, 240, 31], ar: [128, 209, 227], k: [143, 64, 212], ca: [61, 255, 0], sc: [230, 230, 230], ti: [191, 194, 199], v: [166, 166, 171], cr: [138, 153, 199], mn: [156, 122, 199], fe: [224, 102, 51], co: [240, 144, 160], ni: [80, 208, 80], cu: [200, 128, 51], zn: [125, 128, 176], ga: [194, 143, 143], ge: [102, 143, 143], as: [189, 128, 227], se: [255, 161, 0], br: [166, 41, 41], kr: [92, 184, 209], rb: [112, 46, 176], sr: [0, 255, 0], y: [148, 255, 255], zr: [148, 224, 224], nb: [115, 194, 201], mo: [84, 181, 181], tc: [59, 158, 158], ru: [36, 143, 143], rh: [10, 125, 140], pd: [0, 105, 133], ag: [192, 192, 192], cd: [255, 217, 143], in: [166, 117, 115], sn: [102, 128, 128], sb: [158, 99, 181], te: [212, 122, 0], i: [148, 0, 148], xe: [66, 158, 176], cs: [87, 23, 143], ba: [0, 201, 0], la: [112, 212, 255], ce: [255, 255, 199], pr: [217, 255, 199], nd: [199, 255, 199], pm: [163, 255, 199], sm: [143, 255, 199], eu: [97, 255, 199], gd: [69, 255, 199], tb: [48, 255, 199], dy: [31, 255, 199], ho: [0, 255, 156], er: [0, 230, 117], tm: [0, 212, 82], yb: [0, 191, 56], lu: [0, 171, 36], hf: [77, 194, 255], ta: [77, 166, 255], w: [33, 148, 214], re: [38, 125, 171], os: [38, 102, 150], ir: [23, 84, 135], pt: [208, 208, 224], au: [255, 209, 35], hg: [184, 184, 208], tl: [166, 84, 77], pb: [87, 89, 97], bi: [158, 79, 181], po: [171, 92, 0], at: [117, 79, 69], rn: [66, 130, 150], fr: [66, 0, 102], ra: [0, 125, 0], ac: [112, 171, 250], th: [0, 186, 255], pa: [0, 161, 255], u: [0, 143, 255], np: [0, 128, 255], pu: [0, 107, 255], am: [84, 92, 242], cm: [120, 92, 227], bk: [138, 79, 227], cf: [161, 54, 212], es: [179, 31, 212], fm: [179, 31, 186], md: [179, 13, 166], no: [189, 13, 135], lr: [199, 0, 102], rf: [204, 0, 89], db: [209, 0, 79], sg: [217, 0, 69], bh: [224, 0, 56], hs: [230, 0, 46], mt: [235, 0, 38], ds: [235, 0, 38], rg: [235, 0, 38], cn: [235, 0, 38], uut: [235, 0, 38], uuq: [235, 0, 38], uup: [235, 0, 38], uuh: [235, 0, 38], uus: [235, 0, 38], uuo: [235, 0, 38] };

		var atoms = [];
		var bonds = [];
		var histogram = {};

		var bhash = {};

		var x, y, z, index, e;

		// parse

		var lines = text.split('\n');

		for (var i = 0, l = lines.length; i < l; i++) {

			if (lines[i].substr(0, 4) === 'ATOM' || lines[i].substr(0, 6) === 'HETATM') {

				x = parseFloat(lines[i].substr(30, 7));
				y = parseFloat(lines[i].substr(38, 7));
				z = parseFloat(lines[i].substr(46, 7));
				index = parseInt(lines[i].substr(6, 5)) - 1;

				e = trim(lines[i].substr(76, 2)).toLowerCase();

				if (e === '') {

					e = trim(lines[i].substr(12, 2)).toLowerCase();
				}

				atoms[index] = [x, y, z, CPK[e], capitalize(e)];

				if (histogram[e] === undefined) {

					histogram[e] = 1;
				} else {

					histogram[e] += 1;
				}
			} else if (lines[i].substr(0, 6) === 'CONECT') {

				var satom = parseInt(lines[i].substr(6, 5));

				parseBond(11, 5);
				parseBond(16, 5);
				parseBond(21, 5);
				parseBond(26, 5);
			}
		}

		// build and return geometry

		return buildGeometry();
	}

};

exports.default = PDBLoader;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

var PlayCanvasLoader = function PlayCanvasLoader(manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};

PlayCanvasLoader.prototype = {

	constructor: PlayCanvasLoader,

	load: function load(url, onLoad, onProgress, onError) {

		var scope = this;

		var loader = new THREE.FileLoader(scope.manager);
		loader.load(url, function (text) {

			onLoad(scope.parse(JSON.parse(text)));
		}, onProgress, onError);
	},

	parse: function parse(json) {

		function parseVertices(data) {

			var attributes = {};

			// create a buffer attribute for each array that contains vertex information

			for (var name in data) {

				var array = data[name];

				var type = array.type;
				var size = array.components;

				var attribute;

				switch (type) {

					case 'float32':
						attribute = new THREE.Float32BufferAttribute(array.data, size);
						break;

					case 'uint8':
						attribute = new THREE.Uint8BufferAttribute(array.data, size);
						break;

					case 'uint16':
						attribute = new THREE.Uint16BufferAttribute(array.data, size);
						break;

					default:
						console.log('THREE.PlayCanvasLoader: Array type "%s" not yet supported.', type);

				}

				attributes[name] = attribute;
			}

			data._attributes = attributes;
		}

		function parseMeshes(data) {

			// create buffer geometry

			var geometry = new THREE.BufferGeometry();

			geometry.setIndex(data.indices);

			var attributes = model.vertices[data.vertices]._attributes;

			for (var name in attributes) {

				var attribute = attributes[name];

				if (name === 'texCoord0') name = 'uv';

				geometry.addAttribute(name, attribute);
			}

			data._geometry = geometry;
		}

		function parseMeshInstances(data) {

			var node = model.nodes[data.node];
			var mesh = model.meshes[data.mesh];

			if (node._geometries === undefined) {

				node._geometries = [];
			}

			node._geometries.push(mesh._geometry);
		}

		function parseNodes(data) {

			var object = new THREE.Group();

			var geometries = data._geometries;

			if (geometries !== undefined) {

				var material = new THREE.MeshPhongMaterial();

				for (var i = 0, l = geometries.length; i < l; i++) {

					var geometry = geometries[i];

					object.add(new THREE.Mesh(geometry, material));
				}
			}

			for (var i = 0, l = data.rotation.length; i < l; i++) {

				data.rotation[i] *= Math.PI / 180;
			}

			//

			object.name = data.name;

			object.position.fromArray(data.position);
			object.quaternion.setFromEuler(new THREE.Euler().fromArray(data.rotation));
			object.scale.fromArray(data.scale);

			data._object = object;
		}

		//

		var model = json.model;

		for (var i = 0, l = model.vertices.length; i < l; i++) {

			parseVertices(model.vertices[i]);
		}

		for (var i = 0, l = model.meshes.length; i < l; i++) {

			parseMeshes(model.meshes[i]);
		}

		for (var i = 0, l = model.meshInstances.length; i < l; i++) {

			parseMeshInstances(model.meshInstances[i]);
		}

		for (var i = 0, l = model.nodes.length; i < l; i++) {

			parseNodes(model.nodes[i]);
		}

		// setup scene hierarchy

		for (var i = 0, l = model.parents.length; i < l; i++) {

			var parent = model.parents[i];

			if (parent === -1) continue;

			model.nodes[parent]._object.add(model.nodes[i]._object);
		}

		return model.nodes[0]._object;
	}

};

exports.default = PlayCanvasLoader;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author Wei Meng / http://about.me/menway
 *
 * Description: A THREE loader for PLY ASCII files (known as the Polygon
 * File Format or the Stanford Triangle Format).
 *
 * Limitations: ASCII decoding assumes file is UTF-8.
 *
 * Usage:
 *	var loader = new THREE.PLYLoader();
 *	loader.load('./models/ply/ascii/dolphins.ply', function (geometry) {
 *
 *		scene.add( new THREE.Mesh( geometry ) );
 *
 *	} );
 *
 * If the PLY file uses non standard property names, they can be mapped while
 * loading. For example, the following maps the properties
 * “diffuse_(red|green|blue)” in the file to standard color names.
 *
 * loader.setPropertyNameMapping( {
 *	diffuse_red: 'red',
 *	diffuse_green: 'green',
 *	diffuse_blue: 'blue'
 * } );
 *
 */

var PLYLoader = function PLYLoader(manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;

	this.propertyNameMapping = {};
};

PLYLoader.prototype = {

	constructor: PLYLoader,

	load: function load(url, onLoad, onProgress, onError) {

		var scope = this;

		var loader = new THREE.FileLoader(this.manager);
		loader.setResponseType('arraybuffer');
		loader.load(url, function (text) {

			onLoad(scope.parse(text));
		}, onProgress, onError);
	},

	setPropertyNameMapping: function setPropertyNameMapping(mapping) {

		this.propertyNameMapping = mapping;
	},

	parse: function parse(data) {

		function parseHeader(data) {

			var patternHeader = /ply([\s\S]*)end_header\s/;
			var headerText = '';
			var headerLength = 0;
			var result = patternHeader.exec(data);

			if (result !== null) {

				headerText = result[1];
				headerLength = result[0].length;
			}

			var header = {
				comments: [],
				elements: [],
				headerLength: headerLength
			};

			var lines = headerText.split('\n');
			var currentElement;
			var lineType, lineValues;

			function make_ply_element_property(propertValues, propertyNameMapping) {

				var property = { type: propertValues[0] };

				if (property.type === 'list') {

					property.name = propertValues[3];
					property.countType = propertValues[1];
					property.itemType = propertValues[2];
				} else {

					property.name = propertValues[1];
				}

				if (property.name in propertyNameMapping) {

					property.name = propertyNameMapping[property.name];
				}

				return property;
			}

			for (var i = 0; i < lines.length; i++) {

				var line = lines[i];
				line = line.trim();

				if (line === '') continue;

				lineValues = line.split(/\s+/);
				lineType = lineValues.shift();
				line = lineValues.join(' ');

				switch (lineType) {

					case 'format':

						header.format = lineValues[0];
						header.version = lineValues[1];

						break;

					case 'comment':

						header.comments.push(line);

						break;

					case 'element':

						if (currentElement !== undefined) {

							header.elements.push(currentElement);
						}

						currentElement = {};
						currentElement.name = lineValues[0];
						currentElement.count = parseInt(lineValues[1]);
						currentElement.properties = [];

						break;

					case 'property':

						currentElement.properties.push(make_ply_element_property(lineValues, scope.propertyNameMapping));

						break;

					default:

						console.log('unhandled', lineType, lineValues);

				}
			}

			if (currentElement !== undefined) {

				header.elements.push(currentElement);
			}

			return header;
		}

		function parseASCIINumber(n, type) {

			switch (type) {

				case 'char':case 'uchar':case 'short':case 'ushort':case 'int':case 'uint':
				case 'int8':case 'uint8':case 'int16':case 'uint16':case 'int32':case 'uint32':

					return parseInt(n);

				case 'float':case 'double':case 'float32':case 'float64':

					return parseFloat(n);

			}
		}

		function parseASCIIElement(properties, line) {

			var values = line.split(/\s+/);

			var element = {};

			for (var i = 0; i < properties.length; i++) {

				if (properties[i].type === 'list') {

					var list = [];
					var n = parseASCIINumber(values.shift(), properties[i].countType);

					for (var j = 0; j < n; j++) {

						list.push(parseASCIINumber(values.shift(), properties[i].itemType));
					}

					element[properties[i].name] = list;
				} else {

					element[properties[i].name] = parseASCIINumber(values.shift(), properties[i].type);
				}
			}

			return element;
		}

		function parseASCII(data, header) {

			// PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)

			var buffer = {
				indices: [],
				vertices: [],
				normals: [],
				uvs: [],
				colors: []
			};

			var result;

			var patternBody = /end_header\s([\s\S]*)$/;
			var body = '';
			if ((result = patternBody.exec(data)) !== null) {

				body = result[1];
			}

			var lines = body.split('\n');
			var currentElement = 0;
			var currentElementCount = 0;

			for (var i = 0; i < lines.length; i++) {

				var line = lines[i];
				line = line.trim();
				if (line === '') {

					continue;
				}

				if (currentElementCount >= header.elements[currentElement].count) {

					currentElement++;
					currentElementCount = 0;
				}

				var element = parseASCIIElement(header.elements[currentElement].properties, line);

				handleElement(buffer, header.elements[currentElement].name, element);

				currentElementCount++;
			}

			return postProcess(buffer);
		}

		function postProcess(buffer) {

			var geometry = new THREE.BufferGeometry();

			// mandatory buffer data

			if (buffer.indices.length > 0) {

				geometry.setIndex(buffer.indices);
			}

			geometry.addAttribute('position', new THREE.Float32BufferAttribute(buffer.vertices, 3));

			// optional buffer data

			if (buffer.normals.length > 0) {

				geometry.addAttribute('normal', new THREE.Float32BufferAttribute(buffer.normals, 3));
			}

			if (buffer.uvs.length > 0) {

				geometry.addAttribute('uv', new THREE.Float32BufferAttribute(buffer.uvs, 2));
			}

			if (buffer.colors.length > 0) {

				geometry.addAttribute('color', new THREE.Float32BufferAttribute(buffer.colors, 3));
			}

			geometry.computeBoundingSphere();

			return geometry;
		}

		function handleElement(buffer, elementName, element) {

			if (elementName === 'vertex') {

				buffer.vertices.push(element.x, element.y, element.z);

				if ('nx' in element && 'ny' in element && 'nz' in element) {

					buffer.normals.push(element.nx, element.ny, element.nz);
				}

				if ('s' in element && 't' in element) {

					buffer.uvs.push(element.s, element.t);
				}

				if ('red' in element && 'green' in element && 'blue' in element) {

					buffer.colors.push(element.red / 255.0, element.green / 255.0, element.blue / 255.0);
				}
			} else if (elementName === 'face') {

				var vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338

				if (vertex_indices.length === 3) {

					buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[2]);
				} else if (vertex_indices.length === 4) {

					buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[3]);
					buffer.indices.push(vertex_indices[1], vertex_indices[2], vertex_indices[3]);
				}
			}
		}

		function binaryRead(dataview, at, type, little_endian) {

			switch (type) {

				// corespondences for non-specific length types here match rply:
				case 'int8':case 'char':
					return [dataview.getInt8(at), 1];
				case 'uint8':case 'uchar':
					return [dataview.getUint8(at), 1];
				case 'int16':case 'short':
					return [dataview.getInt16(at, little_endian), 2];
				case 'uint16':case 'ushort':
					return [dataview.getUint16(at, little_endian), 2];
				case 'int32':case 'int':
					return [dataview.getInt32(at, little_endian), 4];
				case 'uint32':case 'uint':
					return [dataview.getUint32(at, little_endian), 4];
				case 'float32':case 'float':
					return [dataview.getFloat32(at, little_endian), 4];
				case 'float64':case 'double':
					return [dataview.getFloat64(at, little_endian), 8];

			}
		}

		function binaryReadElement(dataview, at, properties, little_endian) {

			var element = {};
			var result,
			    read = 0;

			for (var i = 0; i < properties.length; i++) {

				if (properties[i].type === 'list') {

					var list = [];

					result = binaryRead(dataview, at + read, properties[i].countType, little_endian);
					var n = result[0];
					read += result[1];

					for (var j = 0; j < n; j++) {

						result = binaryRead(dataview, at + read, properties[i].itemType, little_endian);
						list.push(result[0]);
						read += result[1];
					}

					element[properties[i].name] = list;
				} else {

					result = binaryRead(dataview, at + read, properties[i].type, little_endian);
					element[properties[i].name] = result[0];
					read += result[1];
				}
			}

			return [element, read];
		}

		function parseBinary(data, header) {

			var buffer = {
				indices: [],
				vertices: [],
				normals: [],
				uvs: [],
				colors: []
			};

			var little_endian = header.format === 'binary_little_endian';
			var body = new DataView(data, header.headerLength);
			var result,
			    loc = 0;

			for (var currentElement = 0; currentElement < header.elements.length; currentElement++) {

				for (var currentElementCount = 0; currentElementCount < header.elements[currentElement].count; currentElementCount++) {

					result = binaryReadElement(body, loc, header.elements[currentElement].properties, little_endian);
					loc += result[1];
					var element = result[0];

					handleElement(buffer, header.elements[currentElement].name, element);
				}
			}

			return postProcess(buffer);
		}

		//

		var geometry;
		var scope = this;

		if (data instanceof ArrayBuffer) {

			var text = THREE.LoaderUtils.decodeText(new Uint8Array(data));
			var header = parseHeader(text);

			geometry = header.format === 'ascii' ? parseASCII(text, header) : parseBinary(data, header);
		} else {

			geometry = parseASCII(data, parseHeader(data));
		}

		return geometry;
	}

};

exports.default = PLYLoader;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author Kevin Chapelier / https://github.com/kchapelier
 * See https://github.com/kchapelier/PRWM for more informations about this file format
 */

exports.default = function () {

	'use strict';

	var bigEndianPlatform = null;

	/**
  * Check if the endianness of the platform is big-endian (most significant bit first)
  * @returns {boolean} True if big-endian, false if little-endian
  */
	function isBigEndianPlatform() {

		if (bigEndianPlatform === null) {

			var buffer = new ArrayBuffer(2),
			    uint8Array = new Uint8Array(buffer),
			    uint16Array = new Uint16Array(buffer);

			uint8Array[0] = 0xAA; // set first byte
			uint8Array[1] = 0xBB; // set second byte
			bigEndianPlatform = uint16Array[0] === 0xAABB;
		}

		return bigEndianPlatform;
	}

	// match the values defined in the spec to the TypedArray types
	var InvertedEncodingTypes = [null, Float32Array, null, Int8Array, Int16Array, null, Int32Array, Uint8Array, Uint16Array, null, Uint32Array];

	// define the method to use on a DataView, corresponding the TypedArray type
	var getMethods = {
		Uint16Array: 'getUint16',
		Uint32Array: 'getUint32',
		Int16Array: 'getInt16',
		Int32Array: 'getInt32',
		Float32Array: 'getFloat32',
		Float64Array: 'getFloat64'
	};

	function copyFromBuffer(sourceArrayBuffer, viewType, position, length, fromBigEndian) {

		var bytesPerElement = viewType.BYTES_PER_ELEMENT,
		    result;

		if (fromBigEndian === isBigEndianPlatform() || bytesPerElement === 1) {

			result = new viewType(sourceArrayBuffer, position, length);
		} else {

			var readView = new DataView(sourceArrayBuffer, position, length * bytesPerElement),
			    getMethod = getMethods[viewType.name],
			    littleEndian = !fromBigEndian,
			    i = 0;

			result = new viewType(length);

			for (; i < length; i++) {

				result[i] = readView[getMethod](i * bytesPerElement, littleEndian);
			}
		}

		return result;
	}

	function decodePrwm(buffer) {

		var array = new Uint8Array(buffer),
		    version = array[0],
		    flags = array[1],
		    indexedGeometry = !!(flags >> 7 & 0x01),
		    indicesType = flags >> 6 & 0x01,
		    bigEndian = (flags >> 5 & 0x01) === 1,
		    attributesNumber = flags & 0x1F,
		    valuesNumber = 0,
		    indicesNumber = 0;

		if (bigEndian) {

			valuesNumber = (array[2] << 16) + (array[3] << 8) + array[4];
			indicesNumber = (array[5] << 16) + (array[6] << 8) + array[7];
		} else {

			valuesNumber = array[2] + (array[3] << 8) + (array[4] << 16);
			indicesNumber = array[5] + (array[6] << 8) + (array[7] << 16);
		}

		/** PRELIMINARY CHECKS **/

		if (version === 0) {

			throw new Error('PRWM decoder: Invalid format version: 0');
		} else if (version !== 1) {

			throw new Error('PRWM decoder: Unsupported format version: ' + version);
		}

		if (!indexedGeometry) {

			if (indicesType !== 0) {

				throw new Error('PRWM decoder: Indices type must be set to 0 for non-indexed geometries');
			} else if (indicesNumber !== 0) {

				throw new Error('PRWM decoder: Number of indices must be set to 0 for non-indexed geometries');
			}
		}

		/** PARSING **/

		var pos = 8;

		var attributes = {},
		    attributeName,
		    char,
		    attributeType,
		    cardinality,
		    encodingType,
		    arrayType,
		    values,
		    indices,
		    i;

		for (i = 0; i < attributesNumber; i++) {

			attributeName = '';

			while (pos < array.length) {

				char = array[pos];
				pos++;

				if (char === 0) {

					break;
				} else {

					attributeName += String.fromCharCode(char);
				}
			}

			flags = array[pos];

			attributeType = flags >> 7 & 0x01;
			cardinality = (flags >> 4 & 0x03) + 1;
			encodingType = flags & 0x0F;
			arrayType = InvertedEncodingTypes[encodingType];

			pos++;

			// padding to next multiple of 4
			pos = Math.ceil(pos / 4) * 4;

			values = copyFromBuffer(buffer, arrayType, pos, cardinality * valuesNumber, bigEndian);

			pos += arrayType.BYTES_PER_ELEMENT * cardinality * valuesNumber;

			attributes[attributeName] = {
				type: attributeType,
				cardinality: cardinality,
				values: values
			};
		}

		pos = Math.ceil(pos / 4) * 4;

		indices = null;

		if (indexedGeometry) {

			indices = copyFromBuffer(buffer, indicesType === 1 ? Uint32Array : Uint16Array, pos, indicesNumber, bigEndian);
		}

		return {
			version: version,
			attributes: attributes,
			indices: indices
		};
	}

	// Define the public interface

	var PRWMLoader = function PRWMLoader(manager) {

		this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
	};

	PRWMLoader.prototype = {

		constructor: PRWMLoader,

		load: function load(url, onLoad, onProgress, onError) {

			var scope = this;

			var loader = new THREE.FileLoader(scope.manager);
			loader.setResponseType('arraybuffer');

			url = url.replace(/\*/g, isBigEndianPlatform() ? 'be' : 'le');

			loader.load(url, function (arrayBuffer) {

				onLoad(scope.parse(arrayBuffer));
			}, onProgress, onError);
		},

		parse: function parse(arrayBuffer) {

			console.time('PRWMLoader');

			var data = decodePrwm(arrayBuffer),
			    attributesKey = Object.keys(data.attributes),
			    bufferGeometry = new THREE.BufferGeometry(),
			    attribute,
			    i;

			for (i = 0; i < attributesKey.length; i++) {

				attribute = data.attributes[attributesKey[i]];
				bufferGeometry.addAttribute(attributesKey[i], new THREE.BufferAttribute(attribute.values, attribute.cardinality, attribute.normalized));
			}

			if (data.indices !== null) {

				bufferGeometry.setIndex(new THREE.BufferAttribute(data.indices, 1));
			}

			console.timeEnd('PRWMLoader');

			return bufferGeometry;
		}

	};

	PRWMLoader.isBigEndianPlatform = function () {

		return isBigEndianPlatform();
	};

	return PRWMLoader;
}();

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 *	 PVRLoader
 *   Author: pierre lepers
 *   Date: 17/09/2014 11:09
 *
 *	 PVR v2 (legacy) parser
 *   TODO : Add Support for PVR v3 format
 *   TODO : implement loadMipmaps option
 */

var PVRLoader = function PVRLoader(manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;

	this._parser = PVRLoader.parse;
};

PVRLoader.prototype = Object.create(THREE.CompressedTextureLoader.prototype);
PVRLoader.prototype.constructor = PVRLoader;

PVRLoader.parse = function (buffer, loadMipmaps) {

	var headerLengthInt = 13;
	var header = new Uint32Array(buffer, 0, headerLengthInt);

	var pvrDatas = {
		buffer: buffer,
		header: header,
		loadMipmaps: loadMipmaps
	};

	if (header[0] === 0x03525650) {

		// PVR v3

		return PVRLoader._parseV3(pvrDatas);
	} else if (header[11] === 0x21525650) {

		// PVR v2

		return PVRLoader._parseV2(pvrDatas);
	} else {

		console.error('THREE.PVRLoader: Unknown PVR format.');
	}
};

PVRLoader._parseV3 = function (pvrDatas) {

	var header = pvrDatas.header;
	var bpp, format;

	var metaLen = header[12],
	    pixelFormat = header[2],
	    height = header[6],
	    width = header[7],

	// numSurfs = header[ 9 ],
	numFaces = header[10],
	    numMipmaps = header[11];

	switch (pixelFormat) {

		case 0:
			// PVRTC 2bpp RGB
			bpp = 2;
			format = THREE.RGB_PVRTC_2BPPV1_Format;
			break;

		case 1:
			// PVRTC 2bpp RGBA
			bpp = 2;
			format = THREE.RGBA_PVRTC_2BPPV1_Format;
			break;

		case 2:
			// PVRTC 4bpp RGB
			bpp = 4;
			format = THREE.RGB_PVRTC_4BPPV1_Format;
			break;

		case 3:
			// PVRTC 4bpp RGBA
			bpp = 4;
			format = THREE.RGBA_PVRTC_4BPPV1_Format;
			break;

		default:
			console.error('THREE.PVRLoader: Unsupported PVR format:', pixelFormat);

	}

	pvrDatas.dataPtr = 52 + metaLen;
	pvrDatas.bpp = bpp;
	pvrDatas.format = format;
	pvrDatas.width = width;
	pvrDatas.height = height;
	pvrDatas.numSurfaces = numFaces;
	pvrDatas.numMipmaps = numMipmaps;
	pvrDatas.isCubemap = numFaces === 6;

	return PVRLoader._extract(pvrDatas);
};

PVRLoader._parseV2 = function (pvrDatas) {

	var header = pvrDatas.header;

	var headerLength = header[0],
	    height = header[1],
	    width = header[2],
	    numMipmaps = header[3],
	    flags = header[4],

	// dataLength = header[ 5 ],
	// bpp =  header[ 6 ],
	// bitmaskRed = header[ 7 ],
	// bitmaskGreen = header[ 8 ],
	// bitmaskBlue = header[ 9 ],
	bitmaskAlpha = header[10],

	// pvrTag = header[ 11 ],
	numSurfs = header[12];

	var TYPE_MASK = 0xff;
	var PVRTC_2 = 24,
	    PVRTC_4 = 25;

	var formatFlags = flags & TYPE_MASK;

	var bpp, format;
	var _hasAlpha = bitmaskAlpha > 0;

	if (formatFlags === PVRTC_4) {

		format = _hasAlpha ? THREE.RGBA_PVRTC_4BPPV1_Format : THREE.RGB_PVRTC_4BPPV1_Format;
		bpp = 4;
	} else if (formatFlags === PVRTC_2) {

		format = _hasAlpha ? THREE.RGBA_PVRTC_2BPPV1_Format : THREE.RGB_PVRTC_2BPPV1_Format;
		bpp = 2;
	} else {

		console.error('THREE.PVRLoader: Unknown PVR format:', formatFlags);
	}

	pvrDatas.dataPtr = headerLength;
	pvrDatas.bpp = bpp;
	pvrDatas.format = format;
	pvrDatas.width = width;
	pvrDatas.height = height;
	pvrDatas.numSurfaces = numSurfs;
	pvrDatas.numMipmaps = numMipmaps + 1;

	// guess cubemap type seems tricky in v2
	// it juste a pvr containing 6 surface (no explicit cubemap type)
	pvrDatas.isCubemap = numSurfs === 6;

	return PVRLoader._extract(pvrDatas);
};

PVRLoader._extract = function (pvrDatas) {

	var pvr = {
		mipmaps: [],
		width: pvrDatas.width,
		height: pvrDatas.height,
		format: pvrDatas.format,
		mipmapCount: pvrDatas.numMipmaps,
		isCubemap: pvrDatas.isCubemap
	};

	var buffer = pvrDatas.buffer;

	var dataOffset = pvrDatas.dataPtr,
	    bpp = pvrDatas.bpp,
	    numSurfs = pvrDatas.numSurfaces,
	    dataSize = 0,
	    blockSize = 0,
	    blockWidth = 0,
	    blockHeight = 0,
	    widthBlocks = 0,
	    heightBlocks = 0;

	if (bpp === 2) {

		blockWidth = 8;
		blockHeight = 4;
	} else {

		blockWidth = 4;
		blockHeight = 4;
	}

	blockSize = blockWidth * blockHeight * bpp / 8;

	pvr.mipmaps.length = pvrDatas.numMipmaps * numSurfs;

	var mipLevel = 0;

	while (mipLevel < pvrDatas.numMipmaps) {

		var sWidth = pvrDatas.width >> mipLevel,
		    sHeight = pvrDatas.height >> mipLevel;

		widthBlocks = sWidth / blockWidth;
		heightBlocks = sHeight / blockHeight;

		// Clamp to minimum number of blocks
		if (widthBlocks < 2) widthBlocks = 2;
		if (heightBlocks < 2) heightBlocks = 2;

		dataSize = widthBlocks * heightBlocks * blockSize;

		for (var surfIndex = 0; surfIndex < numSurfs; surfIndex++) {

			var byteArray = new Uint8Array(buffer, dataOffset, dataSize);

			var mipmap = {
				data: byteArray,
				width: sWidth,
				height: sHeight
			};

			pvr.mipmaps[surfIndex * pvrDatas.numMipmaps + mipLevel] = mipmap;

			dataOffset += dataSize;
		}

		mipLevel++;
	}

	return pvr;
};

exports.default = PVRLoader;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author aleeper / http://adamleeper.com/
 * @author mrdoob / http://mrdoob.com/
 * @author gero3 / https://github.com/gero3
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.
 *
 * Supports both binary and ASCII encoded files, with automatic detection of type.
 *
 * The loader returns a non-indexed buffer geometry.
 *
 * Limitations:
 *  Binary decoding supports "Magics" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).
 *  There is perhaps some question as to how valid it is to always assume little-endian-ness.
 *  ASCII decoding assumes file is UTF-8.
 *
 * Usage:
 *  var loader = new THREE.STLLoader();
 *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {
 *    scene.add( new THREE.Mesh( geometry ) );
 *  });
 *
 * For binary STLs geometry might contain colors for vertices. To use it:
 *  // use the same code to load STL as above
 *  if (geometry.hasColors) {
 *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: THREE.VertexColors });
 *  } else { .... }
 *  var mesh = new THREE.Mesh( geometry, material );
 */

var STLLoader = function STLLoader(manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};

STLLoader.prototype = {

	constructor: STLLoader,

	load: function load(url, onLoad, onProgress, onError) {

		var scope = this;

		var loader = new THREE.FileLoader(scope.manager);
		loader.setResponseType('arraybuffer');
		loader.load(url, function (text) {

			try {

				onLoad(scope.parse(text));
			} catch (exception) {

				if (onError) {

					onError(exception);
				}
			}
		}, onProgress, onError);
	},

	parse: function parse(data) {

		function isBinary(data) {

			var expect, face_size, n_faces, reader;
			reader = new DataView(data);
			face_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;
			n_faces = reader.getUint32(80, true);
			expect = 80 + 32 / 8 + n_faces * face_size;

			if (expect === reader.byteLength) {

				return true;
			}

			// An ASCII STL data must begin with 'solid ' as the first six bytes.
			// However, ASCII STLs lacking the SPACE after the 'd' are known to be
			// plentiful.  So, check the first 5 bytes for 'solid'.

			// US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'

			var solid = [115, 111, 108, 105, 100];

			for (var i = 0; i < 5; i++) {

				// If solid[ i ] does not match the i-th byte, then it is not an
				// ASCII STL; hence, it is binary and return true.

				if (solid[i] != reader.getUint8(i, false)) return true;
			}

			// First 5 bytes read "solid"; declare it to be an ASCII STL

			return false;
		}

		function parseBinary(data) {

			var reader = new DataView(data);
			var faces = reader.getUint32(80, true);

			var r,
			    g,
			    b,
			    hasColors = false,
			    colors;
			var defaultR, defaultG, defaultB, alpha;

			// process STL header
			// check for default color in header ("COLOR=rgba" sequence).

			for (var index = 0; index < 80 - 10; index++) {

				if (reader.getUint32(index, false) == 0x434F4C4F /*COLO*/ && reader.getUint8(index + 4) == 0x52 /*'R'*/ && reader.getUint8(index + 5) == 0x3D /*'='*/) {

					hasColors = true;
					colors = [];

					defaultR = reader.getUint8(index + 6) / 255;
					defaultG = reader.getUint8(index + 7) / 255;
					defaultB = reader.getUint8(index + 8) / 255;
					alpha = reader.getUint8(index + 9) / 255;
				}
			}

			var dataOffset = 84;
			var faceLength = 12 * 4 + 2;

			var geometry = new THREE.BufferGeometry();

			var vertices = [];
			var normals = [];

			for (var face = 0; face < faces; face++) {

				var start = dataOffset + face * faceLength;
				var normalX = reader.getFloat32(start, true);
				var normalY = reader.getFloat32(start + 4, true);
				var normalZ = reader.getFloat32(start + 8, true);

				if (hasColors) {

					var packedColor = reader.getUint16(start + 48, true);

					if ((packedColor & 0x8000) === 0) {

						// facet has its own unique color

						r = (packedColor & 0x1F) / 31;
						g = (packedColor >> 5 & 0x1F) / 31;
						b = (packedColor >> 10 & 0x1F) / 31;
					} else {

						r = defaultR;
						g = defaultG;
						b = defaultB;
					}
				}

				for (var i = 1; i <= 3; i++) {

					var vertexstart = start + i * 12;

					vertices.push(reader.getFloat32(vertexstart, true));
					vertices.push(reader.getFloat32(vertexstart + 4, true));
					vertices.push(reader.getFloat32(vertexstart + 8, true));

					normals.push(normalX, normalY, normalZ);

					if (hasColors) {

						colors.push(r, g, b);
					}
				}
			}

			geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
			geometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), 3));

			if (hasColors) {

				geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), 3));
				geometry.hasColors = true;
				geometry.alpha = alpha;
			}

			return geometry;
		}

		function parseASCII(data) {

			var geometry = new THREE.BufferGeometry();
			var patternFace = /facet([\s\S]*?)endfacet/g;
			var faceCounter = 0;

			var patternFloat = /[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/.source;
			var patternVertex = new RegExp('vertex' + patternFloat + patternFloat + patternFloat, 'g');
			var patternNormal = new RegExp('normal' + patternFloat + patternFloat + patternFloat, 'g');

			var vertices = [];
			var normals = [];

			var normal = new THREE.Vector3();

			var result;

			while ((result = patternFace.exec(data)) !== null) {

				var vertexCountPerFace = 0;
				var normalCountPerFace = 0;

				var text = result[0];

				while ((result = patternNormal.exec(text)) !== null) {

					normal.x = parseFloat(result[1]);
					normal.y = parseFloat(result[2]);
					normal.z = parseFloat(result[3]);
					normalCountPerFace++;
				}

				while ((result = patternVertex.exec(text)) !== null) {

					vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
					normals.push(normal.x, normal.y, normal.z);
					vertexCountPerFace++;
				}

				// every face have to own ONE valid normal

				if (normalCountPerFace !== 1) {

					console.error('THREE.STLLoader: Something isn\'t right with the normal of face number ' + faceCounter);
				}

				// each face have to own THREE valid vertices

				if (vertexCountPerFace !== 3) {

					console.error('THREE.STLLoader: Something isn\'t right with the vertices of face number ' + faceCounter);
				}

				faceCounter++;
			}

			geometry.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
			geometry.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));

			return geometry;
		}

		function ensureString(buffer) {

			if (typeof buffer !== 'string') {

				return THREE.LoaderUtils.decodeText(new Uint8Array(buffer));
			}

			return buffer;
		}

		function ensureBinary(buffer) {

			if (typeof buffer === 'string') {

				var array_buffer = new Uint8Array(buffer.length);
				for (var i = 0; i < buffer.length; i++) {

					array_buffer[i] = buffer.charCodeAt(i) & 0xff; // implicitly assumes little-endian
				}
				return array_buffer.buffer || array_buffer;
			} else {

				return buffer;
			}
		}

		// start

		var binData = ensureBinary(data);

		return isBinary(binData) ? parseBinary(binData) : parseASCII(ensureString(data));
	}

};

exports.default = STLLoader;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author mrdoob / http://mrdoob.com/
 * @author zz85 / http://joshuakoo.com/
 */

var SVGLoader = function SVGLoader(manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};

SVGLoader.prototype = {

	constructor: SVGLoader,

	load: function load(url, onLoad, onProgress, onError) {

		var scope = this;

		var loader = new THREE.FileLoader(scope.manager);
		loader.load(url, function (text) {

			onLoad(scope.parse(text));
		}, onProgress, onError);
	},

	parse: function parse(text) {

		function parseNode(node, style) {

			if (node.nodeType !== 1) return;

			switch (node.nodeName) {

				case 'svg':
					break;

				case 'g':
					style = parseStyle(node, style);
					break;

				case 'path':
					style = parseStyle(node, style);
					if (node.hasAttribute('d') && isVisible(style)) paths.push(parsePathNode(node, style));
					break;

				case 'rect':
					style = parseStyle(node, style);
					if (isVisible(style)) paths.push(parseRectNode(node, style));
					break;

				case 'polygon':
					style = parseStyle(node, style);
					if (isVisible(style)) paths.push(parsePolygonNode(node, style));
					break;

				case 'polyline':
					style = parseStyle(node, style);
					if (isVisible(style)) paths.push(parsePolylineNode(node, style));
					break;

				case 'circle':
					style = parseStyle(node, style);
					if (isVisible(style)) paths.push(parseCircleNode(node, style));
					break;

				case 'ellipse':
					style = parseStyle(node, style);
					if (isVisible(style)) paths.push(parseEllipseNode(node, style));
					break;

				case 'line':
					style = parseStyle(node, style);
					if (isVisible(style)) paths.push(parseLineNode(node, style));
					break;

				default:
					console.log(node);

			}

			var nodes = node.childNodes;

			for (var i = 0; i < nodes.length; i++) {

				parseNode(nodes[i], style);
			}
		}

		function parsePathNode(node, style) {

			var path = new THREE.ShapePath();
			path.color.setStyle(style.fill);

			var point = new THREE.Vector2();
			var control = new THREE.Vector2();

			var d = node.getAttribute('d');

			// console.log( d );

			var commands = d.match(/[a-df-z][^a-df-z]*/ig);

			for (var i = 0, l = commands.length; i < l; i++) {

				var command = commands[i];

				var type = command.charAt(0);
				var data = command.substr(1).trim();

				switch (type) {

					case 'M':
						var numbers = parseFloats(data);
						for (var j = 0, jl = numbers.length; j < jl; j += 2) {
							point.x = numbers[j + 0];
							point.y = numbers[j + 1];
							control.x = point.x;
							control.y = point.y;
							path.moveTo(point.x, point.y);
						}
						break;

					case 'H':
						var numbers = parseFloats(data);
						for (var j = 0, jl = numbers.length; j < jl; j++) {
							point.x = numbers[j];
							control.x = point.x;
							control.y = point.y;
							path.lineTo(point.x, point.y);
						}
						break;

					case 'V':
						var numbers = parseFloats(data);
						for (var j = 0, jl = numbers.length; j < jl; j++) {
							point.y = numbers[j];
							control.x = point.x;
							control.y = point.y;
							path.lineTo(point.x, point.y);
						}
						break;

					case 'L':
						var numbers = parseFloats(data);
						for (var j = 0, jl = numbers.length; j < jl; j += 2) {
							point.x = numbers[j + 0];
							point.y = numbers[j + 1];
							control.x = point.x;
							control.y = point.y;
							path.lineTo(point.x, point.y);
						}
						break;

					case 'C':
						var numbers = parseFloats(data);
						for (var j = 0, jl = numbers.length; j < jl; j += 6) {
							path.bezierCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], numbers[j + 5]);
							control.x = numbers[j + 2];
							control.y = numbers[j + 3];
							point.x = numbers[j + 4];
							point.y = numbers[j + 5];
						}
						break;

					case 'S':
						var numbers = parseFloats(data);
						path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), numbers[0], numbers[1], numbers[2], numbers[3]);
						control.x = numbers[0];
						control.y = numbers[1];
						point.x = numbers[2];
						point.y = numbers[3];
						break;

					case 'Q':
						var numbers = parseFloats(data);
						path.quadraticCurveTo(numbers[0], numbers[1], numbers[2], numbers[3]);
						control.x = numbers[0];
						control.y = numbers[1];
						point.x = numbers[2];
						point.y = numbers[3];
						break;

					case 'T':
						var numbers = parseFloats(data);
						var rx = getReflection(point.x, control.x);
						var ry = getReflection(point.y, control.y);
						path.quadraticCurveTo(rx, ry, numbers[0], numbers[1]);
						control.x = rx;
						control.y = ry;
						point.x = numbers[0];
						point.y = numbers[1];
						break;

					case 'A':
						var numbers = parseFloats(data);
						for (var j = 0, jl = numbers.length; j < jl; j += 7) {
							var start = point.clone();
							point.x = numbers[j + 5];
							point.y = numbers[j + 6];
							control.x = point.x;
							control.y = point.y;
							parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);
						}
						break;

					//

					case 'm':
						var numbers = parseFloats(data);
						for (var j = 0, jl = numbers.length; j < jl; j += 2) {
							point.x += numbers[j + 0];
							point.y += numbers[j + 1];
							control.x = point.x;
							control.y = point.y;
							path.moveTo(point.x, point.y);
						}
						break;

					case 'h':
						var numbers = parseFloats(data);
						for (var j = 0, jl = numbers.length; j < jl; j++) {
							point.x += numbers[j];
							control.x = point.x;
							control.y = point.y;
							path.lineTo(point.x, point.y);
						}
						break;

					case 'v':
						var numbers = parseFloats(data);
						for (var j = 0, jl = numbers.length; j < jl; j++) {
							point.y += numbers[j];
							control.x = point.x;
							control.y = point.y;
							path.lineTo(point.x, point.y);
						}
						break;

					case 'l':
						var numbers = parseFloats(data);
						for (var j = 0, jl = numbers.length; j < jl; j += 2) {
							point.x += numbers[j + 0];
							point.y += numbers[j + 1];
							control.x = point.x;
							control.y = point.y;
							path.lineTo(point.x, point.y);
						}
						break;

					case 'c':
						var numbers = parseFloats(data);
						for (var j = 0, jl = numbers.length; j < jl; j += 6) {
							path.bezierCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3], point.x + numbers[j + 4], point.y + numbers[j + 5]);
							point.x += numbers[j + 4];
							point.y += numbers[j + 5];
						}
						break;

					case 's':
						var numbers = parseFloats(data);
						path.bezierCurveTo(
						// TODO: Not sure if point needs
						// to be added to reflection...
						getReflection(point.x, control.x), getReflection(point.y, control.y), point.x + numbers[0], point.y + numbers[1], point.x + numbers[2], point.y + numbers[3]);
						control.x = point.x + numbers[0];
						control.y = point.y + numbers[1];
						point.x += numbers[2];
						point.y += numbers[3];
						break;

					case 'q':
						var numbers = parseFloats(data);
						path.quadraticCurveTo(point.x + numbers[0], point.y + numbers[1], point.x + numbers[2], point.y + numbers[3]);
						control.x = point.x + numbers[0];
						control.y = point.y + numbers[1];
						point.x += numbers[2];
						point.y += numbers[3];
						break;

					case 't':
						var numbers = parseFloats(data);
						var rx = getReflection(point.x, control.x);
						var ry = getReflection(point.y, control.y);
						path.quadraticCurveTo(rx, ry, point.x + numbers[0], point.y + numbers[1]);
						control.x = rx;
						control.y = ry;
						point.x = point.x + numbers[0];
						point.y = point.y + numbers[1];
						break;

					case 'a':
						var numbers = parseFloats(data);
						for (var j = 0, jl = numbers.length; j < jl; j += 7) {
							var start = point.clone();
							point.x += numbers[j + 5];
							point.y += numbers[j + 6];
							control.x = point.x;
							control.y = point.y;
							parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);
						}
						break;

					//

					case 'Z':
					case 'z':
						path.currentPath.autoClose = true;
						break;

					default:
						console.warn(command);

				}

				// console.log( type, parseFloats( data ), parseFloats( data ).length  )
			}

			return path;
		}

		/**
   * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
   * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion
   * From
   * rx ry x-axis-rotation large-arc-flag sweep-flag x y
   * To
   * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation
   */

		function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {

			x_axis_rotation = x_axis_rotation * Math.PI / 180;

			// Ensure radii are positive
			rx = Math.abs(rx);
			ry = Math.abs(ry);

			// Compute (x1′, y1′)
			var dx2 = (start.x - end.x) / 2.0;
			var dy2 = (start.y - end.y) / 2.0;
			var x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;
			var y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2;

			// Compute (cx′, cy′)
			var rxs = rx * rx;
			var rys = ry * ry;
			var x1ps = x1p * x1p;
			var y1ps = y1p * y1p;

			// Ensure radii are large enough
			var cr = x1ps / rxs + y1ps / rys;

			if (cr > 1) {

				// scale up rx,ry equally so cr == 1
				var s = Math.sqrt(cr);
				rx = s * rx;
				ry = s * ry;
				rxs = rx * rx;
				rys = ry * ry;
			}

			var dq = rxs * y1ps + rys * x1ps;
			var pq = (rxs * rys - dq) / dq;
			var q = Math.sqrt(Math.max(0, pq));
			if (large_arc_flag === sweep_flag) q = -q;
			var cxp = q * rx * y1p / ry;
			var cyp = -q * ry * x1p / rx;

			// Step 3: Compute (cx, cy) from (cx′, cy′)
			var cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;
			var cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2;

			// Step 4: Compute θ1 and Δθ
			var theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);
			var delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);

			path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);
		}

		function svgAngle(ux, uy, vx, vy) {

			var dot = ux * vx + uy * vy;
			var len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);
			var ang = Math.acos(Math.max(-1, Math.min(1, dot / len))); // floating point precision, slightly over values appear
			if (ux * vy - uy * vx < 0) ang = -ang;
			return ang;
		}

		/*
  * According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute
  * rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough
  */
		function parseRectNode(node, style) {

			var x = parseFloat(node.getAttribute('x') || 0);
			var y = parseFloat(node.getAttribute('y') || 0);
			var rx = parseFloat(node.getAttribute('rx') || 0);
			var ry = parseFloat(node.getAttribute('ry') || 0);
			var w = parseFloat(node.getAttribute('width'));
			var h = parseFloat(node.getAttribute('height'));

			var path = new THREE.ShapePath();
			path.color.setStyle(style.fill);
			path.moveTo(x + 2 * rx, y);
			path.lineTo(x + w - 2 * rx, y);
			if (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w, y, x + w, y, x + w, y + 2 * ry);
			path.lineTo(x + w, y + h - 2 * ry);
			if (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h);
			path.lineTo(x + 2 * rx, y + h);

			if (rx !== 0 || ry !== 0) {

				path.bezierCurveTo(x, y + h, x, y + h, x, y + h - 2 * ry);
				path.lineTo(x, y + 2 * ry);
				path.bezierCurveTo(x, y, x, y, x + 2 * rx, y);
			}

			return path;
		}

		function parsePolygonNode(node, style) {

			function iterator(match, a, b) {

				var x = parseFloat(a);
				var y = parseFloat(b);

				if (index === 0) {
					path.moveTo(x, y);
				} else {
					path.lineTo(x, y);
				}

				index++;
			}

			var regex = /(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g;

			var path = new THREE.ShapePath();
			path.color.setStyle(style.fill);

			var index = 0;

			node.getAttribute('points').replace(regex, iterator);

			path.currentPath.autoClose = true;

			return path;
		}

		function parsePolylineNode(node, style) {

			function iterator(match, a, b) {

				var x = parseFloat(a);
				var y = parseFloat(b);

				if (index === 0) {
					path.moveTo(x, y);
				} else {
					path.lineTo(x, y);
				}

				index++;
			}

			var regex = /(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g;

			var path = new THREE.ShapePath();
			path.color.setStyle(style.fill);

			var index = 0;

			node.getAttribute('points').replace(regex, iterator);

			path.currentPath.autoClose = false;

			return path;
		}

		function parseCircleNode(node, style) {

			var x = parseFloat(node.getAttribute('cx'));
			var y = parseFloat(node.getAttribute('cy'));
			var r = parseFloat(node.getAttribute('r'));

			var subpath = new THREE.Path();
			subpath.absarc(x, y, r, 0, Math.PI * 2);

			var path = new THREE.ShapePath();
			path.color.setStyle(style.fill);
			path.subPaths.push(subpath);

			return path;
		}

		function parseEllipseNode(node, style) {

			var x = parseFloat(node.getAttribute('cx'));
			var y = parseFloat(node.getAttribute('cy'));
			var rx = parseFloat(node.getAttribute('rx'));
			var ry = parseFloat(node.getAttribute('ry'));

			var subpath = new THREE.Path();
			subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);

			var path = new THREE.ShapePath();
			path.color.setStyle(style.fill);
			path.subPaths.push(subpath);

			return path;
		}

		function parseLineNode(node, style) {

			var x1 = parseFloat(node.getAttribute('x1'));
			var y1 = parseFloat(node.getAttribute('y1'));
			var x2 = parseFloat(node.getAttribute('x2'));
			var y2 = parseFloat(node.getAttribute('y2'));

			var path = new THREE.ShapePath();
			path.moveTo(x1, y1);
			path.lineTo(x2, y2);
			path.currentPath.autoClose = false;

			return path;
		}

		//

		function parseStyle(node, style) {

			style = Object.assign({}, style); // clone style

			if (node.hasAttribute('fill')) style.fill = node.getAttribute('fill');
			if (node.style.fill !== '') style.fill = node.style.fill;

			return style;
		}

		function isVisible(style) {

			return style.fill !== 'none' && style.fill !== 'transparent';
		}

		// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes

		function getReflection(a, b) {

			return 2 * a - (b - a);
		}

		function parseFloats(string) {

			var array = string.split(/[\s,]+|(?=\s?[+\-])/);

			for (var i = 0; i < array.length; i++) {

				array[i] = parseFloat(array[i]);
			}

			return array;
		}

		//

		console.log('THREE.SVGLoader');

		var paths = [];

		console.time('THREE.SVGLoader: DOMParser');

		var xml = new DOMParser().parseFromString(text, 'image/svg+xml'); // application/xml

		console.timeEnd('THREE.SVGLoader: DOMParser');

		console.time('THREE.SVGLoader: Parse');

		parseNode(xml.documentElement, { fill: '#000' });

		// console.log( paths );

		console.timeEnd('THREE.SVGLoader: Parse');

		return paths;
	}

};

exports.default = SVGLoader;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * Autodesk 3DS threee.js file loader, based on lib3ds.
 *
 * Loads geometry with uv and materials basic properties with texture support.
 *
 * @author @tentone
 * @author @timknip
 * @class TDSLoader
 * @constructor
 */

'use strict';

var TDSLoader = function TDSLoader(manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
	this.debug = false;

	this.group = null;
	this.position = 0;

	this.materials = [];
	this.meshes = [];
};

TDSLoader.prototype = {

	constructor: TDSLoader,

	/**
  * Load 3ds file from url.
  *
  * @method load
  * @param {[type]} url URL for the file.
  * @param {Function} onLoad onLoad callback, receives group Object3D as argument.
  * @param {Function} onProgress onProgress callback.
  * @param {Function} onError onError callback.
  */
	load: function load(url, onLoad, onProgress, onError) {

		var scope = this;

		var path = this.path !== undefined ? this.path : THREE.LoaderUtils.extractUrlBase(url);

		var loader = new THREE.FileLoader(this.manager);

		loader.setResponseType('arraybuffer');

		loader.load(url, function (data) {

			onLoad(scope.parse(data, path));
		}, onProgress, onError);
	},

	/**
  * Parse arraybuffer data and load 3ds file.
  *
  * @method parse
  * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.
  * @param {String} path Path for external resources.
  * @return {Object3D} Group loaded from 3ds file.
  */
	parse: function parse(arraybuffer, path) {

		this.group = new THREE.Group();
		this.position = 0;
		this.materials = [];
		this.meshes = [];

		this.readFile(arraybuffer, path);

		for (var i = 0; i < this.meshes.length; i++) {

			this.group.add(this.meshes[i]);
		}

		return this.group;
	},

	/**
  * Decode file content to read 3ds data.
  *
  * @method readFile
  * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.
  */
	readFile: function readFile(arraybuffer, path) {

		var data = new DataView(arraybuffer);
		var chunk = this.readChunk(data);

		if (chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC) {

			var next = this.nextChunk(data, chunk);

			while (next !== 0) {

				if (next === M3D_VERSION) {

					var version = this.readDWord(data);
					this.debugMessage('3DS file version: ' + version);
				} else if (next === MDATA) {

					this.resetPosition(data);
					this.readMeshData(data, path);
				} else {

					this.debugMessage('Unknown main chunk: ' + next.toString(16));
				}

				next = this.nextChunk(data, chunk);
			}
		}

		this.debugMessage('Parsed ' + this.meshes.length + ' meshes');
	},

	/**
  * Read mesh data chunk.
  *
  * @method readMeshData
  * @param {Dataview} data Dataview in use.
  */
	readMeshData: function readMeshData(data, path) {

		var chunk = this.readChunk(data);
		var next = this.nextChunk(data, chunk);

		while (next !== 0) {

			if (next === MESH_VERSION) {

				var version = +this.readDWord(data);
				this.debugMessage('Mesh Version: ' + version);
			} else if (next === MASTER_SCALE) {

				var scale = this.readFloat(data);
				this.debugMessage('Master scale: ' + scale);
				this.group.scale.set(scale, scale, scale);
			} else if (next === NAMED_OBJECT) {

				this.debugMessage('Named Object');
				this.resetPosition(data);
				this.readNamedObject(data);
			} else if (next === MAT_ENTRY) {

				this.debugMessage('Material');
				this.resetPosition(data);
				this.readMaterialEntry(data, path);
			} else {

				this.debugMessage('Unknown MDATA chunk: ' + next.toString(16));
			}

			next = this.nextChunk(data, chunk);
		}
	},

	/**
  * Read named object chunk.
  *
  * @method readNamedObject
  * @param {Dataview} data Dataview in use.
  */
	readNamedObject: function readNamedObject(data) {

		var chunk = this.readChunk(data);
		var name = this.readString(data, 64);
		chunk.cur = this.position;

		var next = this.nextChunk(data, chunk);
		while (next !== 0) {

			if (next === N_TRI_OBJECT) {

				this.resetPosition(data);
				var mesh = this.readMesh(data);
				mesh.name = name;
				this.meshes.push(mesh);
			} else {

				this.debugMessage('Unknown named object chunk: ' + next.toString(16));
			}

			next = this.nextChunk(data, chunk);
		}

		this.endChunk(chunk);
	},

	/**
  * Read material data chunk and add it to the material list.
  *
  * @method readMaterialEntry
  * @param {Dataview} data Dataview in use.
  */
	readMaterialEntry: function readMaterialEntry(data, path) {

		var chunk = this.readChunk(data);
		var next = this.nextChunk(data, chunk);
		var material = new THREE.MeshPhongMaterial();

		while (next !== 0) {

			if (next === MAT_NAME) {

				material.name = this.readString(data, 64);
				this.debugMessage('   Name: ' + material.name);
			} else if (next === MAT_WIRE) {

				this.debugMessage('   Wireframe');
				material.wireframe = true;
			} else if (next === MAT_WIRE_SIZE) {

				var value = this.readByte(data);
				material.wireframeLinewidth = value;
				this.debugMessage('   Wireframe Thickness: ' + value);
			} else if (next === MAT_TWO_SIDE) {

				material.side = THREE.DoubleSide;
				this.debugMessage('   DoubleSided');
			} else if (next === MAT_ADDITIVE) {

				this.debugMessage('   Additive Blending');
				material.blending = THREE.AdditiveBlending;
			} else if (next === MAT_DIFFUSE) {

				this.debugMessage('   Diffuse Color');
				material.color = this.readColor(data);
			} else if (next === MAT_SPECULAR) {

				this.debugMessage('   Specular Color');
				material.specular = this.readColor(data);
			} else if (next === MAT_AMBIENT) {

				this.debugMessage('   Ambient color');
				material.color = this.readColor(data);
			} else if (next === MAT_SHININESS) {

				var shininess = this.readWord(data);
				material.shininess = shininess;
				this.debugMessage('   Shininess : ' + shininess);
			} else if (next === MAT_TEXMAP) {

				this.debugMessage('   ColorMap');
				this.resetPosition(data);
				material.map = this.readMap(data, path);
			} else if (next === MAT_BUMPMAP) {

				this.debugMessage('   BumpMap');
				this.resetPosition(data);
				material.bumpMap = this.readMap(data, path);
			} else if (next === MAT_OPACMAP) {

				this.debugMessage('   OpacityMap');
				this.resetPosition(data);
				material.alphaMap = this.readMap(data, path);
			} else if (next === MAT_SPECMAP) {

				this.debugMessage('   SpecularMap');
				this.resetPosition(data);
				material.specularMap = this.readMap(data, path);
			} else {

				this.debugMessage('   Unknown material chunk: ' + next.toString(16));
			}

			next = this.nextChunk(data, chunk);
		}

		this.endChunk(chunk);

		this.materials[material.name] = material;
	},

	/**
  * Read mesh data chunk.
  *
  * @method readMesh
  * @param {Dataview} data Dataview in use.
  */
	readMesh: function readMesh(data) {

		var chunk = this.readChunk(data);
		var next = this.nextChunk(data, chunk);

		var useBufferGeometry = false;
		var geometry = null;
		var uvs = [];

		if (useBufferGeometry) {

			geometry = new THREE.BufferGeometry();
		} else {

			geometry = new THREE.Geometry();
		}

		var material = new THREE.MeshPhongMaterial();
		var mesh = new THREE.Mesh(geometry, material);
		mesh.name = 'mesh';

		while (next !== 0) {

			if (next === POINT_ARRAY) {

				var points = this.readWord(data);

				this.debugMessage('   Vertex: ' + points);

				//BufferGeometry

				if (useBufferGeometry) {

					var vertices = [];
					for (var i = 0; i < points; i++) {

						vertices.push(this.readFloat(data));
						vertices.push(this.readFloat(data));
						vertices.push(this.readFloat(data));
					}

					geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
				} else {
					//Geometry

					for (var i = 0; i < points; i++) {

						geometry.vertices.push(new THREE.Vector3(this.readFloat(data), this.readFloat(data), this.readFloat(data)));
					}
				}
			} else if (next === FACE_ARRAY) {

				this.resetPosition(data);
				this.readFaceArray(data, mesh);
			} else if (next === TEX_VERTS) {

				var texels = this.readWord(data);

				this.debugMessage('   UV: ' + texels);

				//BufferGeometry

				if (useBufferGeometry) {

					var uvs = [];
					for (var i = 0; i < texels; i++) {

						uvs.push(this.readFloat(data));
						uvs.push(this.readFloat(data));
					}
					geometry.addAttribute('uv', new THREE.BufferAttribute(new Float32Array(uvs), 2));
				} else {
					//Geometry

					uvs = [];
					for (var i = 0; i < texels; i++) {

						uvs.push(new THREE.Vector2(this.readFloat(data), this.readFloat(data)));
					}
				}
			} else if (next === MESH_MATRIX) {

				this.debugMessage('   Tranformation Matrix (TODO)');

				var values = [];
				for (var i = 0; i < 12; i++) {

					values[i] = this.readFloat(data);
				}

				var matrix = new THREE.Matrix4();

				//X Line
				matrix.elements[0] = values[0];
				matrix.elements[1] = values[6];
				matrix.elements[2] = values[3];
				matrix.elements[3] = values[9];

				//Y Line
				matrix.elements[4] = values[2];
				matrix.elements[5] = values[8];
				matrix.elements[6] = values[5];
				matrix.elements[7] = values[11];

				//Z Line
				matrix.elements[8] = values[1];
				matrix.elements[9] = values[7];
				matrix.elements[10] = values[4];
				matrix.elements[11] = values[10];

				//W Line
				matrix.elements[12] = 0;
				matrix.elements[13] = 0;
				matrix.elements[14] = 0;
				matrix.elements[15] = 1;

				matrix.transpose();

				var inverse = new THREE.Matrix4();
				inverse.getInverse(matrix, true);
				geometry.applyMatrix(inverse);

				matrix.decompose(mesh.position, mesh.quaternion, mesh.scale);
			} else {

				this.debugMessage('   Unknown mesh chunk: ' + next.toString(16));
			}

			next = this.nextChunk(data, chunk);
		}

		this.endChunk(chunk);

		if (!useBufferGeometry) {

			//geometry.faceVertexUvs[0][faceIndex][vertexIndex]

			if (uvs.length > 0) {

				var faceUV = [];

				for (var i = 0; i < geometry.faces.length; i++) {

					faceUV.push([uvs[geometry.faces[i].a], uvs[geometry.faces[i].b], uvs[geometry.faces[i].c]]);
				}

				geometry.faceVertexUvs[0] = faceUV;
			}

			geometry.computeVertexNormals();
		}

		return mesh;
	},

	/**
  * Read face array data chunk.
  *
  * @method readFaceArray
  * @param {Dataview} data Dataview in use.
  * @param {Mesh} mesh Mesh to be filled with the data read.
  */
	readFaceArray: function readFaceArray(data, mesh) {

		var chunk = this.readChunk(data);
		var faces = this.readWord(data);

		this.debugMessage('   Faces: ' + faces);

		for (var i = 0; i < faces; ++i) {

			mesh.geometry.faces.push(new THREE.Face3(this.readWord(data), this.readWord(data), this.readWord(data)));

			var visibility = this.readWord(data);
		}

		//The rest of the FACE_ARRAY chunk is subchunks

		while (this.position < chunk.end) {

			var chunk = this.readChunk(data);

			if (chunk.id === MSH_MAT_GROUP) {

				this.debugMessage('      Material Group');

				this.resetPosition(data);

				var group = this.readMaterialGroup(data);

				var material = this.materials[group.name];

				if (material !== undefined) {

					mesh.material = material;

					if (material.name === '') {

						material.name = mesh.name;
					}
				}
			} else {

				this.debugMessage('      Unknown face array chunk: ' + chunk.toString(16));
			}

			this.endChunk(chunk);
		}

		this.endChunk(chunk);
	},

	/**
  * Read texture map data chunk.
  *
  * @method readMap
  * @param {Dataview} data Dataview in use.
  * @return {Texture} Texture read from this data chunk.
  */
	readMap: function readMap(data, path) {

		var chunk = this.readChunk(data);
		var next = this.nextChunk(data, chunk);
		var texture = {};

		var loader = new THREE.TextureLoader(this.manager);
		loader.setPath(path);

		while (next !== 0) {

			if (next === MAT_MAPNAME) {

				var name = this.readString(data, 128);
				texture = loader.load(name);

				this.debugMessage('      File: ' + path + name);
			} else if (next === MAT_MAP_UOFFSET) {

				texture.offset.x = this.readFloat(data);
				this.debugMessage('      OffsetX: ' + texture.offset.x);
			} else if (next === MAT_MAP_VOFFSET) {

				texture.offset.y = this.readFloat(data);
				this.debugMessage('      OffsetY: ' + texture.offset.y);
			} else if (next === MAT_MAP_USCALE) {

				texture.repeat.x = this.readFloat(data);
				this.debugMessage('      RepeatX: ' + texture.repeat.x);
			} else if (next === MAT_MAP_VSCALE) {

				texture.repeat.y = this.readFloat(data);
				this.debugMessage('      RepeatY: ' + texture.repeat.y);
			} else {

				this.debugMessage('      Unknown map chunk: ' + next.toString(16));
			}

			next = this.nextChunk(data, chunk);
		}

		this.endChunk(chunk);

		return texture;
	},

	/**
  * Read material group data chunk.
  *
  * @method readMaterialGroup
  * @param {Dataview} data Dataview in use.
  * @return {Object} Object with name and index of the object.
  */
	readMaterialGroup: function readMaterialGroup(data) {

		var chunk = this.readChunk(data);
		var name = this.readString(data, 64);
		var numFaces = this.readWord(data);

		this.debugMessage('         Name: ' + name);
		this.debugMessage('         Faces: ' + numFaces);

		var index = [];
		for (var i = 0; i < numFaces; ++i) {

			index.push(this.readWord(data));
		}

		return { name: name, index: index };
	},

	/**
  * Read a color value.
  *
  * @method readColor
  * @param {DataView} data Dataview.
  * @return {Color} Color value read..
  */
	readColor: function readColor(data) {

		var chunk = this.readChunk(data);
		var color = new THREE.Color();

		if (chunk.id === COLOR_24 || chunk.id === LIN_COLOR_24) {

			var r = this.readByte(data);
			var g = this.readByte(data);
			var b = this.readByte(data);

			color.setRGB(r / 255, g / 255, b / 255);

			this.debugMessage('      Color: ' + color.r + ', ' + color.g + ', ' + color.b);
		} else if (chunk.id === COLOR_F || chunk.id === LIN_COLOR_F) {

			var r = this.readFloat(data);
			var g = this.readFloat(data);
			var b = this.readFloat(data);

			color.setRGB(r, g, b);

			this.debugMessage('      Color: ' + color.r + ', ' + color.g + ', ' + color.b);
		} else {

			this.debugMessage('      Unknown color chunk: ' + chunk.toString(16));
		}

		this.endChunk(chunk);
		return color;
	},

	/**
  * Read next chunk of data.
  *
  * @method readChunk
  * @param {DataView} data Dataview.
  * @return {Object} Chunk of data read.
  */
	readChunk: function readChunk(data) {

		var chunk = {};

		chunk.cur = this.position;
		chunk.id = this.readWord(data);
		chunk.size = this.readDWord(data);
		chunk.end = chunk.cur + chunk.size;
		chunk.cur += 6;

		return chunk;
	},

	/**
  * Set position to the end of the current chunk of data.
  *
  * @method endChunk
  * @param {Object} chunk Data chunk.
  */
	endChunk: function endChunk(chunk) {

		this.position = chunk.end;
	},

	/**
  * Move to the next data chunk.
  *
  * @method nextChunk
  * @param {DataView} data Dataview.
  * @param {Object} chunk Data chunk.
  */
	nextChunk: function nextChunk(data, chunk) {

		if (chunk.cur >= chunk.end) {

			return 0;
		}

		this.position = chunk.cur;

		try {

			var next = this.readChunk(data);
			chunk.cur += next.size;
			return next.id;
		} catch (e) {

			this.debugMessage('Unable to read chunk at ' + this.position);
			return 0;
		}
	},

	/**
  * Reset dataview position.
  *
  * @method resetPosition
  * @param {DataView} data Dataview.
  */
	resetPosition: function resetPosition() {

		this.position -= 6;
	},

	/**
  * Read byte value.
  *
  * @method readByte
  * @param {DataView} data Dataview to read data from.
  * @return {Number} Data read from the dataview.
  */
	readByte: function readByte(data) {

		var v = data.getUint8(this.position, true);
		this.position += 1;
		return v;
	},

	/**
  * Read 32 bit float value.
  *
  * @method readFloat
  * @param {DataView} data Dataview to read data from.
  * @return {Number} Data read from the dataview.
  */
	readFloat: function readFloat(data) {

		try {

			var v = data.getFloat32(this.position, true);
			this.position += 4;
			return v;
		} catch (e) {

			this.debugMessage(e + ' ' + this.position + ' ' + data.byteLength);
		}
	},

	/**
  * Read 32 bit signed integer value.
  *
  * @method readInt
  * @param {DataView} data Dataview to read data from.
  * @return {Number} Data read from the dataview.
  */
	readInt: function readInt(data) {

		var v = data.getInt32(this.position, true);
		this.position += 4;
		return v;
	},

	/**
  * Read 16 bit signed integer value.
  *
  * @method readShort
  * @param {DataView} data Dataview to read data from.
  * @return {Number} Data read from the dataview.
  */
	readShort: function readShort(data) {

		var v = data.getInt16(this.position, true);
		this.position += 2;
		return v;
	},

	/**
  * Read 64 bit unsigned integer value.
  *
  * @method readDWord
  * @param {DataView} data Dataview to read data from.
  * @return {Number} Data read from the dataview.
  */
	readDWord: function readDWord(data) {

		var v = data.getUint32(this.position, true);
		this.position += 4;
		return v;
	},

	/**
  * Read 32 bit unsigned integer value.
  *
  * @method readWord
  * @param {DataView} data Dataview to read data from.
  * @return {Number} Data read from the dataview.
  */
	readWord: function readWord(data) {

		var v = data.getUint16(this.position, true);
		this.position += 2;
		return v;
	},

	/**
  * Read string value.
  *
  * @method readString
  * @param {DataView} data Dataview to read data from.
  * @param {Number} maxLength Max size of the string to be read.
  * @return {String} Data read from the dataview.
  */
	readString: function readString(data, maxLength) {

		var s = '';

		for (var i = 0; i < maxLength; i++) {

			var c = this.readByte(data);
			if (!c) {

				break;
			}

			s += String.fromCharCode(c);
		}

		return s;
	},

	/**
  * Set resource path used to determine the file path to attached resources.
  *
  * @method setPath
  * @param {String} path Path to resources.
  * @return Self for chaining.
  */
	setPath: function setPath(path) {

		this.path = path;

		return this;
	},

	/**
  * Print debug message to the console.
  *
  * Is controlled by a flag to show or hide debug messages.
  *
  * @method debugMessage
  * @param {Object} message Debug message to print to the console.
  */
	debugMessage: function debugMessage(message) {

		if (this.debug) {

			console.log(message);
		}
	}
};

var NULL_CHUNK = 0x0000;
var M3DMAGIC = 0x4D4D;
var SMAGIC = 0x2D2D;
var LMAGIC = 0x2D3D;
var MLIBMAGIC = 0x3DAA;
var MATMAGIC = 0x3DFF;
var CMAGIC = 0xC23D;
var M3D_VERSION = 0x0002;
var M3D_KFVERSION = 0x0005;
var COLOR_F = 0x0010;
var COLOR_24 = 0x0011;
var LIN_COLOR_24 = 0x0012;
var LIN_COLOR_F = 0x0013;
var INT_PERCENTAGE = 0x0030;
var FLOAT_PERCENTAGE = 0x0031;
var MDATA = 0x3D3D;
var MESH_VERSION = 0x3D3E;
var MASTER_SCALE = 0x0100;
var LO_SHADOW_BIAS = 0x1400;
var HI_SHADOW_BIAS = 0x1410;
var SHADOW_MAP_SIZE = 0x1420;
var SHADOW_SAMPLES = 0x1430;
var SHADOW_RANGE = 0x1440;
var SHADOW_FILTER = 0x1450;
var RAY_BIAS = 0x1460;
var O_CONSTS = 0x1500;
var AMBIENT_LIGHT = 0x2100;
var BIT_MAP = 0x1100;
var SOLID_BGND = 0x1200;
var V_GRADIENT = 0x1300;
var USE_BIT_MAP = 0x1101;
var USE_SOLID_BGND = 0x1201;
var USE_V_GRADIENT = 0x1301;
var FOG = 0x2200;
var FOG_BGND = 0x2210;
var LAYER_FOG = 0x2302;
var DISTANCE_CUE = 0x2300;
var DCUE_BGND = 0x2310;
var USE_FOG = 0x2201;
var USE_LAYER_FOG = 0x2303;
var USE_DISTANCE_CUE = 0x2301;
var MAT_ENTRY = 0xAFFF;
var MAT_NAME = 0xA000;
var MAT_AMBIENT = 0xA010;
var MAT_DIFFUSE = 0xA020;
var MAT_SPECULAR = 0xA030;
var MAT_SHININESS = 0xA040;
var MAT_SHIN2PCT = 0xA041;
var MAT_TRANSPARENCY = 0xA050;
var MAT_XPFALL = 0xA052;
var MAT_USE_XPFALL = 0xA240;
var MAT_REFBLUR = 0xA053;
var MAT_SHADING = 0xA100;
var MAT_USE_REFBLUR = 0xA250;
var MAT_SELF_ILLUM = 0xA084;
var MAT_TWO_SIDE = 0xA081;
var MAT_DECAL = 0xA082;
var MAT_ADDITIVE = 0xA083;
var MAT_WIRE = 0xA085;
var MAT_FACEMAP = 0xA088;
var MAT_TRANSFALLOFF_IN = 0xA08A;
var MAT_PHONGSOFT = 0xA08C;
var MAT_WIREABS = 0xA08E;
var MAT_WIRE_SIZE = 0xA087;
var MAT_TEXMAP = 0xA200;
var MAT_SXP_TEXT_DATA = 0xA320;
var MAT_TEXMASK = 0xA33E;
var MAT_SXP_TEXTMASK_DATA = 0xA32A;
var MAT_TEX2MAP = 0xA33A;
var MAT_SXP_TEXT2_DATA = 0xA321;
var MAT_TEX2MASK = 0xA340;
var MAT_SXP_TEXT2MASK_DATA = 0xA32C;
var MAT_OPACMAP = 0xA210;
var MAT_SXP_OPAC_DATA = 0xA322;
var MAT_OPACMASK = 0xA342;
var MAT_SXP_OPACMASK_DATA = 0xA32E;
var MAT_BUMPMAP = 0xA230;
var MAT_SXP_BUMP_DATA = 0xA324;
var MAT_BUMPMASK = 0xA344;
var MAT_SXP_BUMPMASK_DATA = 0xA330;
var MAT_SPECMAP = 0xA204;
var MAT_SXP_SPEC_DATA = 0xA325;
var MAT_SPECMASK = 0xA348;
var MAT_SXP_SPECMASK_DATA = 0xA332;
var MAT_SHINMAP = 0xA33C;
var MAT_SXP_SHIN_DATA = 0xA326;
var MAT_SHINMASK = 0xA346;
var MAT_SXP_SHINMASK_DATA = 0xA334;
var MAT_SELFIMAP = 0xA33D;
var MAT_SXP_SELFI_DATA = 0xA328;
var MAT_SELFIMASK = 0xA34A;
var MAT_SXP_SELFIMASK_DATA = 0xA336;
var MAT_REFLMAP = 0xA220;
var MAT_REFLMASK = 0xA34C;
var MAT_SXP_REFLMASK_DATA = 0xA338;
var MAT_ACUBIC = 0xA310;
var MAT_MAPNAME = 0xA300;
var MAT_MAP_TILING = 0xA351;
var MAT_MAP_TEXBLUR = 0xA353;
var MAT_MAP_USCALE = 0xA354;
var MAT_MAP_VSCALE = 0xA356;
var MAT_MAP_UOFFSET = 0xA358;
var MAT_MAP_VOFFSET = 0xA35A;
var MAT_MAP_ANG = 0xA35C;
var MAT_MAP_COL1 = 0xA360;
var MAT_MAP_COL2 = 0xA362;
var MAT_MAP_RCOL = 0xA364;
var MAT_MAP_GCOL = 0xA366;
var MAT_MAP_BCOL = 0xA368;
var NAMED_OBJECT = 0x4000;
var N_DIRECT_LIGHT = 0x4600;
var DL_OFF = 0x4620;
var DL_OUTER_RANGE = 0x465A;
var DL_INNER_RANGE = 0x4659;
var DL_MULTIPLIER = 0x465B;
var DL_EXCLUDE = 0x4654;
var DL_ATTENUATE = 0x4625;
var DL_SPOTLIGHT = 0x4610;
var DL_SPOT_ROLL = 0x4656;
var DL_SHADOWED = 0x4630;
var DL_LOCAL_SHADOW2 = 0x4641;
var DL_SEE_CONE = 0x4650;
var DL_SPOT_RECTANGULAR = 0x4651;
var DL_SPOT_ASPECT = 0x4657;
var DL_SPOT_PROJECTOR = 0x4653;
var DL_SPOT_OVERSHOOT = 0x4652;
var DL_RAY_BIAS = 0x4658;
var DL_RAYSHAD = 0x4627;
var N_CAMERA = 0x4700;
var CAM_SEE_CONE = 0x4710;
var CAM_RANGES = 0x4720;
var OBJ_HIDDEN = 0x4010;
var OBJ_VIS_LOFTER = 0x4011;
var OBJ_DOESNT_CAST = 0x4012;
var OBJ_DONT_RECVSHADOW = 0x4017;
var OBJ_MATTE = 0x4013;
var OBJ_FAST = 0x4014;
var OBJ_PROCEDURAL = 0x4015;
var OBJ_FROZEN = 0x4016;
var N_TRI_OBJECT = 0x4100;
var POINT_ARRAY = 0x4110;
var POINT_FLAG_ARRAY = 0x4111;
var FACE_ARRAY = 0x4120;
var MSH_MAT_GROUP = 0x4130;
var SMOOTH_GROUP = 0x4150;
var MSH_BOXMAP = 0x4190;
var TEX_VERTS = 0x4140;
var MESH_MATRIX = 0x4160;
var MESH_COLOR = 0x4165;
var MESH_TEXTURE_INFO = 0x4170;
var KFDATA = 0xB000;
var KFHDR = 0xB00A;
var KFSEG = 0xB008;
var KFCURTIME = 0xB009;
var AMBIENT_NODE_TAG = 0xB001;
var OBJECT_NODE_TAG = 0xB002;
var CAMERA_NODE_TAG = 0xB003;
var TARGET_NODE_TAG = 0xB004;
var LIGHT_NODE_TAG = 0xB005;
var L_TARGET_NODE_TAG = 0xB006;
var SPOTLIGHT_NODE_TAG = 0xB007;
var NODE_ID = 0xB030;
var NODE_HDR = 0xB010;
var PIVOT = 0xB013;
var INSTANCE_NAME = 0xB011;
var MORPH_SMOOTH = 0xB015;
var BOUNDBOX = 0xB014;
var POS_TRACK_TAG = 0xB020;
var COL_TRACK_TAG = 0xB025;
var ROT_TRACK_TAG = 0xB021;
var SCL_TRACK_TAG = 0xB022;
var MORPH_TRACK_TAG = 0xB026;
var FOV_TRACK_TAG = 0xB023;
var ROLL_TRACK_TAG = 0xB024;
var HOT_TRACK_TAG = 0xB027;
var FALL_TRACK_TAG = 0xB028;
var HIDE_TRACK_TAG = 0xB029;
var POLY_2D = 0x5000;
var SHAPE_OK = 0x5010;
var SHAPE_NOT_OK = 0x5011;
var SHAPE_HOOK = 0x5020;
var PATH_3D = 0x6000;
var PATH_MATRIX = 0x6005;
var SHAPE_2D = 0x6010;
var M_SCALE = 0x6020;
var M_TWIST = 0x6030;
var M_TEETER = 0x6040;
var M_FIT = 0x6050;
var M_BEVEL = 0x6060;
var XZ_CURVE = 0x6070;
var YZ_CURVE = 0x6080;
var INTERPCT = 0x6090;
var DEFORM_LIMIT = 0x60A0;
var USE_CONTOUR = 0x6100;
var USE_TWEEN = 0x6110;
var USE_SCALE = 0x6120;
var USE_TWIST = 0x6130;
var USE_TEETER = 0x6140;
var USE_FIT = 0x6150;
var USE_BEVEL = 0x6160;
var DEFAULT_VIEW = 0x3000;
var VIEW_TOP = 0x3010;
var VIEW_BOTTOM = 0x3020;
var VIEW_LEFT = 0x3030;
var VIEW_RIGHT = 0x3040;
var VIEW_FRONT = 0x3050;
var VIEW_BACK = 0x3060;
var VIEW_USER = 0x3070;
var VIEW_CAMERA = 0x3080;
var VIEW_WINDOW = 0x3090;
var VIEWPORT_LAYOUT_OLD = 0x7000;
var VIEWPORT_DATA_OLD = 0x7010;
var VIEWPORT_LAYOUT = 0x7001;
var VIEWPORT_DATA = 0x7011;
var VIEWPORT_DATA_3 = 0x7012;
var VIEWPORT_SIZE = 0x7020;
var NETWORK_VIEW = 0x7030;

exports.default = TDSLoader;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @author Daosheng Mu / https://github.com/DaoshengMu/
 * @author mrdoob / http://mrdoob.com/
 * @author takahirox / https://github.com/takahirox/
 */

var TGALoader = function TGALoader(manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};

TGALoader.prototype = {

	constructor: TGALoader,

	load: function load(url, onLoad, onProgress, onError) {

		var scope = this;

		var texture = new THREE.Texture();

		var loader = new THREE.FileLoader(this.manager);
		loader.setResponseType('arraybuffer');

		loader.load(url, function (buffer) {

			texture.image = scope.parse(buffer);
			texture.needsUpdate = true;

			if (onLoad !== undefined) {

				onLoad(texture);
			}
		}, onProgress, onError);

		return texture;
	},

	parse: function parse(buffer) {

		// reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js

		function tgaCheckHeader(header) {

			switch (header.image_type) {

				// check indexed type

				case TGA_TYPE_INDEXED:
				case TGA_TYPE_RLE_INDEXED:
					if (header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1) {

						console.error('THREE.TGALoader: Invalid type colormap data for indexed type.');
					}
					break;

				// check colormap type

				case TGA_TYPE_RGB:
				case TGA_TYPE_GREY:
				case TGA_TYPE_RLE_RGB:
				case TGA_TYPE_RLE_GREY:
					if (header.colormap_type) {

						console.error('THREE.TGALoader: Invalid type colormap data for colormap type.');
					}
					break;

				// What the need of a file without data ?

				case TGA_TYPE_NO_DATA:
					console.error('THREE.TGALoader: No data.');

				// Invalid type ?

				default:
					console.error('THREE.TGALoader: Invalid type "%s".', header.image_type);

			}

			// check image width and height

			if (header.width <= 0 || header.height <= 0) {

				console.error('THREE.TGALoader: Invalid image size.');
			}

			// check image pixel size

			if (header.pixel_size !== 8 && header.pixel_size !== 16 && header.pixel_size !== 24 && header.pixel_size !== 32) {

				console.error('THREE.TGALoader: Invalid pixel size "%s".', header.pixel_size);
			}
		}

		// parse tga image buffer

		function tgaParse(use_rle, use_pal, header, offset, data) {

			var pixel_data, pixel_size, pixel_total, palettes;

			pixel_size = header.pixel_size >> 3;
			pixel_total = header.width * header.height * pixel_size;

			// read palettes

			if (use_pal) {

				palettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));
			}

			// read RLE

			if (use_rle) {

				pixel_data = new Uint8Array(pixel_total);

				var c, count, i;
				var shift = 0;
				var pixels = new Uint8Array(pixel_size);

				while (shift < pixel_total) {

					c = data[offset++];
					count = (c & 0x7f) + 1;

					// RLE pixels

					if (c & 0x80) {

						// bind pixel tmp array

						for (i = 0; i < pixel_size; ++i) {

							pixels[i] = data[offset++];
						}

						// copy pixel array

						for (i = 0; i < count; ++i) {

							pixel_data.set(pixels, shift + i * pixel_size);
						}

						shift += pixel_size * count;
					} else {

						// raw pixels

						count *= pixel_size;
						for (i = 0; i < count; ++i) {

							pixel_data[shift + i] = data[offset++];
						}
						shift += count;
					}
				}
			} else {

				// raw pixels

				pixel_data = data.subarray(offset, offset += use_pal ? header.width * header.height : pixel_total);
			}

			return {
				pixel_data: pixel_data,
				palettes: palettes
			};
		}

		function tgaGetImageData8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {

			var colormap = palettes;
			var color,
			    i = 0,
			    x,
			    y;
			var width = header.width;

			for (y = y_start; y !== y_end; y += y_step) {

				for (x = x_start; x !== x_end; x += x_step, i++) {

					color = image[i];
					imageData[(x + width * y) * 4 + 3] = 255;
					imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];
					imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];
					imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];
				}
			}

			return imageData;
		}

		function tgaGetImageData16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {

			var color,
			    i = 0,
			    x,
			    y;
			var width = header.width;

			for (y = y_start; y !== y_end; y += y_step) {

				for (x = x_start; x !== x_end; x += x_step, i += 2) {

					color = image[i + 0] + (image[i + 1] << 8); // Inversed ?
					imageData[(x + width * y) * 4 + 0] = (color & 0x7C00) >> 7;
					imageData[(x + width * y) * 4 + 1] = (color & 0x03E0) >> 2;
					imageData[(x + width * y) * 4 + 2] = (color & 0x001F) >> 3;
					imageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255;
				}
			}

			return imageData;
		}

		function tgaGetImageData24bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {

			var i = 0,
			    x,
			    y;
			var width = header.width;

			for (y = y_start; y !== y_end; y += y_step) {

				for (x = x_start; x !== x_end; x += x_step, i += 3) {

					imageData[(x + width * y) * 4 + 3] = 255;
					imageData[(x + width * y) * 4 + 2] = image[i + 0];
					imageData[(x + width * y) * 4 + 1] = image[i + 1];
					imageData[(x + width * y) * 4 + 0] = image[i + 2];
				}
			}

			return imageData;
		}

		function tgaGetImageData32bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {

			var i = 0,
			    x,
			    y;
			var width = header.width;

			for (y = y_start; y !== y_end; y += y_step) {

				for (x = x_start; x !== x_end; x += x_step, i += 4) {

					imageData[(x + width * y) * 4 + 2] = image[i + 0];
					imageData[(x + width * y) * 4 + 1] = image[i + 1];
					imageData[(x + width * y) * 4 + 0] = image[i + 2];
					imageData[(x + width * y) * 4 + 3] = image[i + 3];
				}
			}

			return imageData;
		}

		function tgaGetImageDataGrey8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {

			var color,
			    i = 0,
			    x,
			    y;
			var width = header.width;

			for (y = y_start; y !== y_end; y += y_step) {

				for (x = x_start; x !== x_end; x += x_step, i++) {

					color = image[i];
					imageData[(x + width * y) * 4 + 0] = color;
					imageData[(x + width * y) * 4 + 1] = color;
					imageData[(x + width * y) * 4 + 2] = color;
					imageData[(x + width * y) * 4 + 3] = 255;
				}
			}

			return imageData;
		}

		function tgaGetImageDataGrey16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {

			var i = 0,
			    x,
			    y;
			var width = header.width;

			for (y = y_start; y !== y_end; y += y_step) {

				for (x = x_start; x !== x_end; x += x_step, i += 2) {

					imageData[(x + width * y) * 4 + 0] = image[i + 0];
					imageData[(x + width * y) * 4 + 1] = image[i + 0];
					imageData[(x + width * y) * 4 + 2] = image[i + 0];
					imageData[(x + width * y) * 4 + 3] = image[i + 1];
				}
			}

			return imageData;
		}

		function getTgaRGBA(data, width, height, image, palette) {

			var x_start, y_start, x_step, y_step, x_end, y_end;

			switch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {

				default:
				case TGA_ORIGIN_UL:
					x_start = 0;
					x_step = 1;
					x_end = width;
					y_start = 0;
					y_step = 1;
					y_end = height;
					break;

				case TGA_ORIGIN_BL:
					x_start = 0;
					x_step = 1;
					x_end = width;
					y_start = height - 1;
					y_step = -1;
					y_end = -1;
					break;

				case TGA_ORIGIN_UR:
					x_start = width - 1;
					x_step = -1;
					x_end = -1;
					y_start = 0;
					y_step = 1;
					y_end = height;
					break;

				case TGA_ORIGIN_BR:
					x_start = width - 1;
					x_step = -1;
					x_end = -1;
					y_start = height - 1;
					y_step = -1;
					y_end = -1;
					break;

			}

			if (use_grey) {

				switch (header.pixel_size) {

					case 8:
						tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
						break;

					case 16:
						tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
						break;

					default:
						console.error('THREE.TGALoader: Format not supported.');
						break;

				}
			} else {

				switch (header.pixel_size) {

					case 8:
						tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);
						break;

					case 16:
						tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
						break;

					case 24:
						tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
						break;

					case 32:
						tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
						break;

					default:
						console.error('THREE.TGALoader: Format not supported.');
						break;

				}
			}

			// Load image data according to specific method
			// var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';
			// func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );
			return data;
		}

		// TGA constants

		var TGA_TYPE_NO_DATA = 0,
		    TGA_TYPE_INDEXED = 1,
		    TGA_TYPE_RGB = 2,
		    TGA_TYPE_GREY = 3,
		    TGA_TYPE_RLE_INDEXED = 9,
		    TGA_TYPE_RLE_RGB = 10,
		    TGA_TYPE_RLE_GREY = 11,
		    TGA_ORIGIN_MASK = 0x30,
		    TGA_ORIGIN_SHIFT = 0x04,
		    TGA_ORIGIN_BL = 0x00,
		    TGA_ORIGIN_BR = 0x01,
		    TGA_ORIGIN_UL = 0x02,
		    TGA_ORIGIN_UR = 0x03;

		if (buffer.length < 19) console.error('THREE.TGALoader: Not enough data to contain header.');

		var content = new Uint8Array(buffer),
		    offset = 0,
		    header = {
			id_length: content[offset++],
			colormap_type: content[offset++],
			image_type: content[offset++],
			colormap_index: content[offset++] | content[offset++] << 8,
			colormap_length: content[offset++] | content[offset++] << 8,
			colormap_size: content[offset++],
			origin: [content[offset++] | content[offset++] << 8, content[offset++] | content[offset++] << 8],
			width: content[offset++] | content[offset++] << 8,
			height: content[offset++] | content[offset++] << 8,
			pixel_size: content[offset++],
			flags: content[offset++]
		};

		// check tga if it is valid format

		tgaCheckHeader(header);

		if (header.id_length + offset > buffer.length) {

			console.error('THREE.TGALoader: No data.');
		}

		// skip the needn't data

		offset += header.id_length;

		// get targa information about RLE compression and palette

		var use_rle = false,
		    use_pal = false,
		    use_grey = false;

		switch (header.image_type) {

			case TGA_TYPE_RLE_INDEXED:
				use_rle = true;
				use_pal = true;
				break;

			case TGA_TYPE_INDEXED:
				use_pal = true;
				break;

			case TGA_TYPE_RLE_RGB:
				use_rle = true;
				break;

			case TGA_TYPE_RGB:
				break;

			case TGA_TYPE_RLE_GREY:
				use_rle = true;
				use_grey = true;
				break;

			case TGA_TYPE_GREY:
				use_grey = true;
				break;

		}

		//

		var canvas = document.createElement('canvas');
		canvas.width = header.width;
		canvas.height = header.height;

		var context = canvas.getContext('2d');
		var imageData = context.createImageData(header.width, header.height);

		var result = tgaParse(use_rle, use_pal, header, offset, content);
		var rgbaData = getTgaRGBA(imageData.data, header.width, header.height, result.pixel_data, result.palettes);

		context.putImageData(imageData, 0, 0);

		return canvas;
	}

};

exports.default = TGALoader;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author gero3 / https://github.com/gero3
 * @author tentone / https://github.com/tentone
 *
 * Requires opentype.js to be included in the project.
 * Loads TTF files and converts them into typeface JSON that can be used directly
 * to create THREE.Font objects.
 */

var TTFLoader = function TTFLoader(manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
	this.reversed = false;
};

TTFLoader.prototype = {

	constructor: TTFLoader,

	load: function load(url, onLoad, onProgress, onError) {

		var scope = this;

		var loader = new THREE.FileLoader(this.manager);
		loader.setResponseType('arraybuffer');
		loader.load(url, function (buffer) {

			onLoad(scope.parse(buffer));
		}, onProgress, onError);
	},

	parse: function parse(arraybuffer) {

		function convert(font, reversed) {

			var round = Math.round;

			var glyphs = {};
			var scale = 100000 / ((font.unitsPerEm || 2048) * 72);

			for (var i = 0; i < font.glyphs.length; i++) {

				var glyph = font.glyphs.glyphs[i];

				if (glyph.unicode !== undefined) {

					var token = {
						ha: round(glyph.advanceWidth * scale),
						x_min: round(glyph.xMin * scale),
						x_max: round(glyph.xMax * scale),
						o: ''
					};

					if (reversed) {

						glyph.path.commands = reverseCommands(glyph.path.commands);
					}

					glyph.path.commands.forEach(function (command, i) {

						if (command.type.toLowerCase() === 'c') {

							command.type = 'b';
						}

						token.o += command.type.toLowerCase() + ' ';

						if (command.x !== undefined && command.y !== undefined) {

							token.o += round(command.x * scale) + ' ' + round(command.y * scale) + ' ';
						}

						if (command.x1 !== undefined && command.y1 !== undefined) {

							token.o += round(command.x1 * scale) + ' ' + round(command.y1 * scale) + ' ';
						}

						if (command.x2 !== undefined && command.y2 !== undefined) {

							token.o += round(command.x2 * scale) + ' ' + round(command.y2 * scale) + ' ';
						}
					});

					glyphs[String.fromCharCode(glyph.unicode)] = token;
				}
			}

			return {
				glyphs: glyphs,
				familyName: font.familyName,
				ascender: round(font.ascender * scale),
				descender: round(font.descender * scale),
				underlinePosition: font.tables.post.underlinePosition,
				underlineThickness: font.tables.post.underlineThickness,
				boundingBox: {
					xMin: font.tables.head.xMin,
					xMax: font.tables.head.xMax,
					yMin: font.tables.head.yMin,
					yMax: font.tables.head.yMax
				},
				resolution: 1000,
				original_font_information: font.tables.name
			};
		}

		function reverseCommands(commands) {

			var paths = [];
			var path;

			commands.forEach(function (c) {

				if (c.type.toLowerCase() === 'm') {

					path = [c];
					paths.push(path);
				} else if (c.type.toLowerCase() !== 'z') {

					path.push(c);
				}
			});

			var reversed = [];

			paths.forEach(function (p) {

				var result = {
					type: 'm',
					x: p[p.length - 1].x,
					y: p[p.length - 1].y
				};

				reversed.push(result);

				for (var i = p.length - 1; i > 0; i--) {

					var command = p[i];
					var result = { type: command.type };

					if (command.x2 !== undefined && command.y2 !== undefined) {

						result.x1 = command.x2;
						result.y1 = command.y2;
						result.x2 = command.x1;
						result.y2 = command.y1;
					} else if (command.x1 !== undefined && command.y1 !== undefined) {

						result.x1 = command.x1;
						result.y1 = command.y1;
					}

					result.x = p[i - 1].x;
					result.y = p[i - 1].y;
					reversed.push(result);
				}
			});

			return reversed;
		}

		if (typeof opentype === 'undefined') {

			console.warn('THREE.TTFLoader: The loader requires opentype.js. Make sure it\'s included before using the loader.');
			return null;
		}

		return convert(opentype.parse(arraybuffer), this.reversed);
	}

};

exports.default = TTFLoader;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author mrdoob / http://mrdoob.com/
 */

var VRMLLoader = function VRMLLoader(manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};

VRMLLoader.prototype = {

	constructor: VRMLLoader,

	// for IndexedFaceSet support
	isRecordingPoints: false,
	isRecordingFaces: false,
	points: [],
	indexes: [],

	// for Background support
	isRecordingAngles: false,
	isRecordingColors: false,
	angles: [],
	colors: [],

	recordingFieldname: null,

	crossOrigin: 'Anonymous',

	load: function load(url, onLoad, onProgress, onError) {

		var scope = this;

		var loader = new THREE.FileLoader(this.manager);
		loader.load(url, function (text) {

			onLoad(scope.parse(text));
		}, onProgress, onError);
	},

	setCrossOrigin: function setCrossOrigin(value) {

		this.crossOrigin = value;
	},

	parse: function parse(data) {

		var texturePath = this.texturePath || '';

		var textureLoader = new THREE.TextureLoader(this.manager);
		textureLoader.setCrossOrigin(this.crossOrigin);

		function parseV2(lines, scene) {

			var defines = {};
			var float_pattern = /(\b|\-|\+)([\d\.e]+)/;
			var float2_pattern = /([\d\.\+\-e]+)\s+([\d\.\+\-e]+)/g;
			var float3_pattern = /([\d\.\+\-e]+)\s+([\d\.\+\-e]+)\s+([\d\.\+\-e]+)/g;

			/**
    * Vertically paints the faces interpolating between the
    * specified colors at the specified angels. This is used for the Background
    * node, but could be applied to other nodes with multiple faces as well.
    *
    * When used with the Background node, default is directionIsDown is true if
    * interpolating the skyColor down from the Zenith. When interpolationg up from
    * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.
    *
    * The first angle is never specified, it is the Zenith (0 rad). Angles are specified
    * in radians. The geometry is thought a sphere, but could be anything. The color interpolation
    * is linear along the Y axis in any case.
    *
    * You must specify one more color than you have angles at the beginning of the colors array.
    * This is the color of the Zenith (the top of the shape).
    *
    * @param geometry
    * @param radius
    * @param angles
    * @param colors
    * @param boolean topDown Whether to work top down or bottom up.
    */
			function paintFaces(geometry, radius, angles, colors, topDown) {

				var direction = topDown === true ? 1 : -1;

				var coord = [],
				    A = {},
				    B = {},
				    applyColor = false;

				for (var k = 0; k < angles.length; k++) {

					// push the vector at which the color changes

					var vec = {
						x: direction * (Math.cos(angles[k]) * radius),
						y: direction * (Math.sin(angles[k]) * radius)
					};

					coord.push(vec);
				}

				var index = geometry.index;
				var positionAttribute = geometry.attributes.position;
				var colorAttribute = new THREE.BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3);

				var position = new THREE.Vector3();
				var color = new THREE.Color();

				for (var i = 0; i < index.count; i++) {

					var vertexIndex = index.getX(i);

					position.fromBufferAttribute(positionAttribute, vertexIndex);

					for (var j = 0; j < colors.length; j++) {

						// linear interpolation between aColor and bColor, calculate proportion
						// A is previous point (angle)

						if (j === 0) {

							A.x = 0;
							A.y = topDown === true ? radius : -1 * radius;
						} else {

							A.x = coord[j - 1].x;
							A.y = coord[j - 1].y;
						}

						// B is current point (angle)

						B = coord[j];

						if (B !== undefined) {

							// p has to be between the points A and B which we interpolate

							applyColor = topDown === true ? position.y <= A.y && position.y > B.y : position.y >= A.y && position.y < B.y;

							if (applyColor === true) {

								var aColor = colors[j];
								var bColor = colors[j + 1];

								// below is simple linear interpolation

								var t = Math.abs(position.y - A.y) / (A.y - B.y);

								// to make it faster, you can only calculate this if the y coord changes, the color is the same for points with the same y

								color.copy(aColor).lerp(bColor, t);

								colorAttribute.setXYZ(vertexIndex, color.r, color.g, color.b);
							} else {

								var colorIndex = topDown === true ? colors.length - 1 : 0;
								var c = colors[colorIndex];
								colorAttribute.setXYZ(vertexIndex, c.r, c.g, c.b);
							}
						}
					}
				}

				geometry.addAttribute('color', colorAttribute);
			}

			var index = [];

			function parseProperty(node, line) {

				var parts = [],
				    part,
				    property = {},
				    fieldName;

				/**
     * Expression for matching relevant information, such as a name or value, but not the separators
     * @type {RegExp}
     */
				var regex = /[^\s,\[\]]+/g;

				var point;

				while (null !== (part = regex.exec(line))) {

					parts.push(part[0]);
				}

				fieldName = parts[0];

				// trigger several recorders
				switch (fieldName) {

					case 'skyAngle':
					case 'groundAngle':
						this.recordingFieldname = fieldName;
						this.isRecordingAngles = true;
						this.angles = [];
						break;

					case 'skyColor':
					case 'groundColor':
						this.recordingFieldname = fieldName;
						this.isRecordingColors = true;
						this.colors = [];
						break;

					case 'point':
						this.recordingFieldname = fieldName;
						this.isRecordingPoints = true;
						this.points = [];
						break;

					case 'coordIndex':
					case 'texCoordIndex':
						this.recordingFieldname = fieldName;
						this.isRecordingFaces = true;
						this.indexes = [];
						break;

				}

				if (this.isRecordingFaces) {

					// the parts hold the indexes as strings
					if (parts.length > 0) {

						for (var ind = 0; ind < parts.length; ind++) {

							// the part should either be positive integer or -1
							if (!/(-?\d+)/.test(parts[ind])) {

								continue;
							}

							// end of current face
							if (parts[ind] === '-1') {

								if (index.length > 0) {

									this.indexes.push(index);
								}

								// start new one
								index = [];
							} else {

								index.push(parseInt(parts[ind]));
							}
						}
					}

					// end
					if (/]/.exec(line)) {

						if (index.length > 0) {

							this.indexes.push(index);
						}

						// start new one
						index = [];

						this.isRecordingFaces = false;
						node[this.recordingFieldname] = this.indexes;
					}
				} else if (this.isRecordingPoints) {

					if (node.nodeType == 'Coordinate') {

						while (null !== (parts = float3_pattern.exec(line))) {

							point = {
								x: parseFloat(parts[1]),
								y: parseFloat(parts[2]),
								z: parseFloat(parts[3])
							};

							this.points.push(point);
						}
					}

					if (node.nodeType == 'TextureCoordinate') {

						while (null !== (parts = float2_pattern.exec(line))) {

							point = {
								x: parseFloat(parts[1]),
								y: parseFloat(parts[2])
							};

							this.points.push(point);
						}
					}

					// end
					if (/]/.exec(line)) {

						this.isRecordingPoints = false;
						node.points = this.points;
					}
				} else if (this.isRecordingAngles) {

					// the parts hold the angles as strings
					if (parts.length > 0) {

						for (var ind = 0; ind < parts.length; ind++) {

							// the part should be a float
							if (!float_pattern.test(parts[ind])) {

								continue;
							}

							this.angles.push(parseFloat(parts[ind]));
						}
					}

					// end
					if (/]/.exec(line)) {

						this.isRecordingAngles = false;
						node[this.recordingFieldname] = this.angles;
					}
				} else if (this.isRecordingColors) {

					while (null !== (parts = float3_pattern.exec(line))) {

						var color = {
							r: parseFloat(parts[1]),
							g: parseFloat(parts[2]),
							b: parseFloat(parts[3])
						};

						this.colors.push(color);
					}

					// end
					if (/]/.exec(line)) {

						this.isRecordingColors = false;
						node[this.recordingFieldname] = this.colors;
					}
				} else if (parts[parts.length - 1] !== 'NULL' && fieldName !== 'children') {

					switch (fieldName) {

						case 'diffuseColor':
						case 'emissiveColor':
						case 'specularColor':
						case 'color':

							if (parts.length !== 4) {

								console.warn('THREE.VRMLLoader: Invalid color format detected for %s.', fieldName);
								break;
							}

							property = {
								r: parseFloat(parts[1]),
								g: parseFloat(parts[2]),
								b: parseFloat(parts[3])
							};

							break;

						case 'location':
						case 'direction':
						case 'translation':
						case 'scale':
						case 'size':
							if (parts.length !== 4) {

								console.warn('THREE.VRMLLoader: Invalid vector format detected for %s.', fieldName);
								break;
							}

							property = {
								x: parseFloat(parts[1]),
								y: parseFloat(parts[2]),
								z: parseFloat(parts[3])
							};

							break;

						case 'intensity':
						case 'cutOffAngle':
						case 'radius':
						case 'topRadius':
						case 'bottomRadius':
						case 'height':
						case 'transparency':
						case 'shininess':
						case 'ambientIntensity':
							if (parts.length !== 2) {

								console.warn('THREE.VRMLLoader: Invalid single float value specification detected for %s.', fieldName);
								break;
							}

							property = parseFloat(parts[1]);

							break;

						case 'rotation':
							if (parts.length !== 5) {

								console.warn('THREE.VRMLLoader: Invalid quaternion format detected for %s.', fieldName);
								break;
							}

							property = {
								x: parseFloat(parts[1]),
								y: parseFloat(parts[2]),
								z: parseFloat(parts[3]),
								w: parseFloat(parts[4])
							};

							break;

						case 'on':
						case 'ccw':
						case 'solid':
						case 'colorPerVertex':
						case 'convex':
							if (parts.length !== 2) {

								console.warn('THREE.VRMLLoader: Invalid format detected for %s.', fieldName);
								break;
							}

							property = parts[1] === 'TRUE' ? true : false;

							break;

					}

					node[fieldName] = property;
				}

				return property;
			}

			function getTree(lines) {

				var tree = { 'string': 'Scene', children: [] };
				var current = tree;
				var matches;
				var specification;

				for (var i = 0; i < lines.length; i++) {

					var comment = '';

					var line = lines[i];

					// omit whitespace only lines
					if (null !== /^\s+?$/g.exec(line)) {

						continue;
					}

					line = line.trim();

					// skip empty lines
					if (line === '') {

						continue;
					}

					if (/#/.exec(line)) {

						var parts = line.split('#');

						// discard everything after the #, it is a comment
						line = parts[0];

						// well, let's also keep the comment
						comment = parts[1];
					}

					if (matches = /([^\s]*){1}(?:\s+)?{/.exec(line)) {

						// first subpattern should match the Node name

						var block = { 'nodeType': matches[1], 'string': line, 'parent': current, 'children': [], 'comment': comment };
						current.children.push(block);
						current = block;

						if (/}/.exec(line)) {

							// example: geometry Box { size 1 1 1 } # all on the same line
							specification = /{(.*)}/.exec(line)[1];

							// todo: remove once new parsing is complete?
							block.children.push(specification);

							parseProperty(current, specification);

							current = current.parent;
						}
					} else if (/}/.exec(line)) {

						current = current.parent;
					} else if (line !== '') {

						parseProperty(current, line);
						// todo: remove once new parsing is complete? we still do not parse geometry and appearance the new way
						current.children.push(line);
					}
				}

				return tree;
			}

			function parseNode(data, parent) {

				var object;

				if (typeof data === 'string') {

					if (/USE/.exec(data)) {

						var defineKey = /USE\s+?([^\s]+)/.exec(data)[1];

						if (undefined == defines[defineKey]) {

							console.warn('THREE.VRMLLoader: %s is not defined.', defineKey);
						} else {

							if (/appearance/.exec(data) && defineKey) {

								parent.material = defines[defineKey].clone();
							} else if (/geometry/.exec(data) && defineKey) {

								parent.geometry = defines[defineKey].clone();

								// the solid property is not cloned with clone(), is only needed for VRML loading, so we need to transfer it
								if (undefined !== defines[defineKey].solid && defines[defineKey].solid === false) {

									parent.geometry.solid = false;
									parent.material.side = THREE.DoubleSide;
								}
							} else if (defineKey) {

								object = defines[defineKey].clone();
								parent.add(object);
							}
						}
					}

					return;
				}

				object = parent;

				if (data.string.indexOf('AmbientLight') > -1 && data.nodeType === 'PointLight') {

					data.nodeType = 'AmbientLight';
				}

				var l_visible = data.on !== undefined ? data.on : true;
				var l_intensity = data.intensity !== undefined ? data.intensity : 1;
				var l_color = new THREE.Color();

				if (data.color) {

					l_color.copy(data.color);
				}

				if (data.nodeType === 'AmbientLight') {

					object = new THREE.AmbientLight(l_color, l_intensity);
					object.visible = l_visible;

					parent.add(object);
				} else if (data.nodeType === 'PointLight') {

					var l_distance = 0;

					if (data.radius !== undefined && data.radius < 1000) {

						l_distance = data.radius;
					}

					object = new THREE.PointLight(l_color, l_intensity, l_distance);
					object.visible = l_visible;

					parent.add(object);
				} else if (data.nodeType === 'SpotLight') {

					var l_intensity = 1;
					var l_distance = 0;
					var l_angle = Math.PI / 3;
					var l_penumbra = 0;
					var l_visible = true;

					if (data.radius !== undefined && data.radius < 1000) {

						l_distance = data.radius;
					}

					if (data.cutOffAngle !== undefined) {

						l_angle = data.cutOffAngle;
					}

					object = new THREE.SpotLight(l_color, l_intensity, l_distance, l_angle, l_penumbra);
					object.visible = l_visible;

					parent.add(object);
				} else if (data.nodeType === 'Transform' || data.nodeType === 'Group') {

					object = new THREE.Object3D();

					if (/DEF/.exec(data.string)) {

						object.name = /DEF\s+([^\s]+)/.exec(data.string)[1];
						defines[object.name] = object;
					}

					if (data.translation !== undefined) {

						var t = data.translation;

						object.position.set(t.x, t.y, t.z);
					}

					if (data.rotation !== undefined) {

						var r = data.rotation;

						object.quaternion.setFromAxisAngle(new THREE.Vector3(r.x, r.y, r.z), r.w);
					}

					if (data.scale !== undefined) {

						var s = data.scale;

						object.scale.set(s.x, s.y, s.z);
					}

					parent.add(object);
				} else if (data.nodeType === 'Shape') {

					object = new THREE.Mesh();

					if (/DEF/.exec(data.string)) {

						object.name = /DEF\s+([^\s]+)/.exec(data.string)[1];

						defines[object.name] = object;
					}

					parent.add(object);
				} else if (data.nodeType === 'Background') {

					var segments = 20;

					// sky (full sphere):

					var radius = 2e4;

					var skyGeometry = new THREE.SphereBufferGeometry(radius, segments, segments);
					var skyMaterial = new THREE.MeshBasicMaterial({ fog: false, side: THREE.BackSide });

					if (data.skyColor.length > 1) {

						paintFaces(skyGeometry, radius, data.skyAngle, data.skyColor, true);

						skyMaterial.vertexColors = THREE.VertexColors;
					} else {

						var color = data.skyColor[0];
						skyMaterial.color.setRGB(color.r, color.b, color.g);
					}

					scene.add(new THREE.Mesh(skyGeometry, skyMaterial));

					// ground (half sphere):

					if (data.groundColor !== undefined) {

						radius = 1.2e4;

						var groundGeometry = new THREE.SphereBufferGeometry(radius, segments, segments, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI);
						var groundMaterial = new THREE.MeshBasicMaterial({ fog: false, side: THREE.BackSide, vertexColors: THREE.VertexColors });

						paintFaces(groundGeometry, radius, data.groundAngle, data.groundColor, false);

						scene.add(new THREE.Mesh(groundGeometry, groundMaterial));
					}
				} else if (/geometry/.exec(data.string)) {

					if (data.nodeType === 'Box') {

						var s = data.size;

						parent.geometry = new THREE.BoxBufferGeometry(s.x, s.y, s.z);
					} else if (data.nodeType === 'Cylinder') {

						parent.geometry = new THREE.CylinderBufferGeometry(data.radius, data.radius, data.height);
					} else if (data.nodeType === 'Cone') {

						parent.geometry = new THREE.CylinderBufferGeometry(data.topRadius, data.bottomRadius, data.height);
					} else if (data.nodeType === 'Sphere') {

						parent.geometry = new THREE.SphereBufferGeometry(data.radius);
					} else if (data.nodeType === 'IndexedFaceSet') {

						var geometry = new THREE.BufferGeometry();

						var positions = [];
						var uvs = [];

						var position, uv;

						var i, il, j, jl;

						for (i = 0, il = data.children.length; i < il; i++) {

							var child = data.children[i];

							// uvs

							if (child.nodeType === 'TextureCoordinate') {

								if (child.points) {

									for (j = 0, jl = child.points.length; j < jl; j++) {

										uv = child.points[j];
										uvs.push(uv.x, uv.y);
									}
								}
							}

							// positions

							if (child.nodeType === 'Coordinate') {

								if (child.points) {

									for (j = 0, jl = child.points.length; j < jl; j++) {

										position = child.points[j];
										positions.push(position.x, position.y, position.z);
									}
								}

								if (child.string.indexOf('DEF') > -1) {

									var name = /DEF\s+([^\s]+)/.exec(child.string)[1];

									defines[name] = positions.slice(0);
								}

								if (child.string.indexOf('USE') > -1) {

									var defineKey = /USE\s+([^\s]+)/.exec(child.string)[1];

									positions = defines[defineKey];
								}
							}
						}

						var skip = 0;

						// some shapes only have vertices for use in other shapes

						if (data.coordIndex) {

							var newPositions = [];
							var newUvs = [];

							position = new THREE.Vector3();
							uv = new THREE.Vector2();

							for (i = 0, il = data.coordIndex.length; i < il; i++) {

								var indexes = data.coordIndex[i];

								// VRML support multipoint indexed face sets (more then 3 vertices). You must calculate the composing triangles here

								skip = 0;

								while (indexes.length >= 3 && skip < indexes.length - 2) {

									if (data.ccw === undefined) data.ccw = true; // ccw is true by default

									var i1 = indexes[0];
									var i2 = indexes[skip + (data.ccw ? 1 : 2)];
									var i3 = indexes[skip + (data.ccw ? 2 : 1)];

									// create non indexed geometry, necessary for face normal generation

									position.fromArray(positions, i1 * 3);
									uv.fromArray(uvs, i1 * 2);
									newPositions.push(position.x, position.y, position.z);
									newUvs.push(uv.x, uv.y);

									position.fromArray(positions, i2 * 3);
									uv.fromArray(uvs, i2 * 2);
									newPositions.push(position.x, position.y, position.z);
									newUvs.push(uv.x, uv.y);

									position.fromArray(positions, i3 * 3);
									uv.fromArray(uvs, i3 * 2);
									newPositions.push(position.x, position.y, position.z);
									newUvs.push(uv.x, uv.y);

									skip++;
								}
							}

							positions = newPositions;
							uvs = newUvs;
						} else {

							// do not add dummy mesh to the scene

							parent.parent.remove(parent);
						}

						if (false === data.solid) {

							parent.material.side = THREE.DoubleSide;
						}

						// we need to store it on the geometry for use with defines
						geometry.solid = data.solid;

						geometry.addAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

						if (uvs.length > 0) {

							geometry.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
						}

						geometry.computeVertexNormals();
						geometry.computeBoundingSphere();

						// see if it's a define
						if (/DEF/.exec(data.string)) {

							geometry.name = /DEF ([^\s]+)/.exec(data.string)[1];
							defines[geometry.name] = geometry;
						}

						parent.geometry = geometry;
					}

					return;
				} else if (/appearance/.exec(data.string)) {

					for (var i = 0; i < data.children.length; i++) {

						var child = data.children[i];

						if (child.nodeType === 'Material') {

							var material = new THREE.MeshPhongMaterial();

							if (child.diffuseColor !== undefined) {

								var d = child.diffuseColor;

								material.color.setRGB(d.r, d.g, d.b);
							}

							if (child.emissiveColor !== undefined) {

								var e = child.emissiveColor;

								material.emissive.setRGB(e.r, e.g, e.b);
							}

							if (child.specularColor !== undefined) {

								var s = child.specularColor;

								material.specular.setRGB(s.r, s.g, s.b);
							}

							if (child.transparency !== undefined) {

								var t = child.transparency;

								// transparency is opposite of opacity
								material.opacity = Math.abs(1 - t);

								material.transparent = true;
							}

							if (/DEF/.exec(data.string)) {

								material.name = /DEF ([^\s]+)/.exec(data.string)[1];

								defines[material.name] = material;
							}

							parent.material = material;
						}

						if (child.nodeType === 'ImageTexture') {

							var textureName = /"([^"]+)"/.exec(child.children[0]);

							if (textureName) {

								parent.material.name = textureName[1];

								parent.material.map = textureLoader.load(texturePath + textureName[1]);
							}
						}
					}

					return;
				}

				for (var i = 0, l = data.children.length; i < l; i++) {

					parseNode(data.children[i], object);
				}
			}

			parseNode(getTree(lines), scene);
		}

		var scene = new THREE.Scene();

		var lines = data.split('\n');

		// some lines do not have breaks

		for (var i = lines.length - 1; i > -1; i--) {

			var line = lines[i];

			// split lines with {..{ or {..[ - some have both
			if (/{.*[{\[]/.test(line)) {

				var parts = line.split('{').join('{\n').split('\n');
				parts.unshift(1);
				parts.unshift(i);
				lines.splice.apply(lines, parts);
			} else if (/\].*}/.test(line)) {

				// split lines with ]..}
				var parts = line.split(']').join(']\n').split('\n');
				parts.unshift(1);
				parts.unshift(i);
				lines.splice.apply(lines, parts);
			}

			if (/}.*}/.test(line)) {

				// split lines with }..}
				var parts = line.split('}').join('}\n').split('\n');
				parts.unshift(1);
				parts.unshift(i);
				lines.splice.apply(lines, parts);
			}

			if (/^\b[^\s]+\b$/.test(line.trim())) {

				// prevent lines with single words like "coord" or "geometry", see #12209
				lines[i + 1] = line + ' ' + lines[i + 1].trim();
				lines.splice(i, 1);
			} else if (line.indexOf('coord') > -1 && line.indexOf('[') < 0 && line.indexOf('{') < 0) {

				// force the parser to create Coordinate node for empty coords
				// coord USE something -> coord USE something Coordinate {}

				lines[i] += ' Coordinate {}';
			}
		}

		var header = lines.shift();

		if (/V1.0/.exec(header)) {

			console.warn('THREE.VRMLLoader: V1.0 not supported yet.');
		} else if (/V2.0/.exec(header)) {

			parseV2(lines, scene);
		}

		return scene;
	}

};

exports.default = VRMLLoader;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _GLTFLoader = __webpack_require__(5);

var _GLTFLoader2 = _interopRequireDefault(_GLTFLoader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author Takahiro / https://github.com/takahirox
 */

// VRM Specification: https://dwango.github.io/vrm/vrm_spec/
//
// VRM is based on glTF 2.0 and VRM extension is defined
// in top-level json.extensions.VRM

var VRMLoader = function () {

	function VRMLoader(manager) {

		if (_GLTFLoader2.default === undefined) {

			throw new Error('VRMLoader: Import GLTFLoader.');
		}

		this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
		this.gltfLoader = new _GLTFLoader2.default(this.manager);
	}

	VRMLoader.prototype = {

		constructor: VRMLoader,

		crossOrigin: 'Anonymous',

		load: function load(url, onLoad, onProgress, onError) {

			this.gltfLoader.load(url, onLoad, onProgress, onError);
		},

		setCrossOrigin: function setCrossOrigin(value) {

			this.glTFLoader.setCrossOrigin(value);
			return this;
		},

		setPath: function setPath(value) {

			this.glTFLoader.setPath(value);
			return this;
		},

		setDRACOLoader: function setDRACOLoader(dracoLoader) {

			this.glTFLoader.setDRACOLoader(dracoLoader);
			return this;
		}

	};

	return VRMLoader;
}();

exports.default = VRMLoader;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Loader for UTF8 version2 (after r51) encoded models generated by:
 *	http://code.google.com/p/webgl-loader/
 *
 * Code to load/decompress mesh is taken from r100 of this webgl-loader
 */

var UTF8Loader = function UTF8Loader() {};

/**
 * Load UTF8 encoded model
 * @param jsonUrl - URL from which to load json containing information about model
 * @param callback - Callback(THREE.Object3D) on successful loading of model
 * @param options - options on how to load model (see THREE.MTLLoader.MaterialCreator for basic options)
 *                  Additional options include
 *                   geometryBase: Base url from which to load referenced geometries
 *                   materialBase: Base url from which to load referenced textures
 */

UTF8Loader.prototype.load = function (jsonUrl, callback, options) {

	this.downloadModelJson(jsonUrl, callback, options);
};

// BufferGeometryCreator

UTF8Loader.BufferGeometryCreator = function () {};

UTF8Loader.BufferGeometryCreator.prototype.create = function (attribArray, indices) {

	var ntris = indices.length / 3;

	var geometry = new THREE.BufferGeometry();

	var positions = new Float32Array(ntris * 3 * 3);
	var normals = new Float32Array(ntris * 3 * 3);
	var uvs = new Float32Array(ntris * 3 * 2);

	var i, j, offset;

	var end = attribArray.length;
	var stride = 8;

	// extract positions

	j = 0;
	offset = 0;

	for (i = offset; i < end; i += stride) {

		positions[j++] = attribArray[i];
		positions[j++] = attribArray[i + 1];
		positions[j++] = attribArray[i + 2];
	}

	// extract uvs

	j = 0;
	offset = 3;

	for (i = offset; i < end; i += stride) {

		uvs[j++] = attribArray[i];
		uvs[j++] = attribArray[i + 1];
	}

	// extract normals

	j = 0;
	offset = 5;

	for (i = offset; i < end; i += stride) {

		normals[j++] = attribArray[i];
		normals[j++] = attribArray[i + 1];
		normals[j++] = attribArray[i + 2];
	}

	geometry.setIndex(new THREE.BufferAttribute(indices, 1));
	geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
	geometry.addAttribute('normal', new THREE.BufferAttribute(normals, 3));
	geometry.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));

	geometry.computeBoundingSphere();

	return geometry;
};

// UTF-8 decoder from webgl-loader (r100)
// http://code.google.com/p/webgl-loader/

// Model manifest description. Contains objects like:
// name: {
//   materials: { 'material_name': { ... } ... },
//   decodeParams: {
//     decodeOffsets: [ ... ],
//     decodeScales: [ ... ],
//   },
//   urls: {
//     'url': [
//       { material: 'material_name',
//         attribRange: [#, #],
//         indexRange: [#, #],
//         names: [ 'object names' ... ],
//         lengths: [#, #, # ... ]
//       }
//     ],
//     ...
//   }
// }

var DEFAULT_DECODE_PARAMS = {

	decodeOffsets: [-4095, -4095, -4095, 0, 0, -511, -511, -511],
	decodeScales: [1 / 8191, 1 / 8191, 1 / 8191, 1 / 1023, 1 / 1023, 1 / 1023, 1 / 1023, 1 / 1023]

	// TODO: normal decoding? (see walt.js)
	// needs to know: input, output (from vertex format!)
	//
	// Should split attrib/index.
	// 1) Decode position and non-normal attributes.
	// 2) Decode indices, computing normals
	// 3) Maybe normalize normals? Only necessary for refinement, or fixed?
	// 4) Maybe refine normals? Should this be part of regular refinement?
	// 5) Morphing

};

// Triangle strips!

// TODO: will it be an optimization to specialize this method at
// runtime for different combinations of stride, decodeOffset and
// decodeScale?

UTF8Loader.prototype.decompressAttribsInner_ = function (str, inputStart, inputEnd, output, outputStart, stride, decodeOffset, decodeScale) {

	var prev = 0;

	for (var j = inputStart; j < inputEnd; j++) {

		var code = str.charCodeAt(j);
		prev += code >> 1 ^ -(code & 1);

		output[outputStart] = decodeScale * (prev + decodeOffset);
		outputStart += stride;
	}
};

UTF8Loader.prototype.decompressIndices_ = function (str, inputStart, numIndices, output, outputStart) {

	var highest = 0;

	for (var i = 0; i < numIndices; i++) {

		var code = str.charCodeAt(inputStart++);

		output[outputStart++] = highest - code;

		if (code === 0) {

			highest++;
		}
	}
};

UTF8Loader.prototype.decompressAABBs_ = function (str, inputStart, numBBoxen, decodeOffsets, decodeScales) {

	var numFloats = 6 * numBBoxen;

	var inputEnd = inputStart + numFloats;
	var outputStart = 0;

	var bboxen = new Float32Array(numFloats);

	for (var i = inputStart; i < inputEnd; i += 6) {

		var minX = str.charCodeAt(i + 0) + decodeOffsets[0];
		var minY = str.charCodeAt(i + 1) + decodeOffsets[1];
		var minZ = str.charCodeAt(i + 2) + decodeOffsets[2];

		var radiusX = str.charCodeAt(i + 3) + 1 >> 1;
		var radiusY = str.charCodeAt(i + 4) + 1 >> 1;
		var radiusZ = str.charCodeAt(i + 5) + 1 >> 1;

		bboxen[outputStart++] = decodeScales[0] * (minX + radiusX);
		bboxen[outputStart++] = decodeScales[1] * (minY + radiusY);
		bboxen[outputStart++] = decodeScales[2] * (minZ + radiusZ);

		bboxen[outputStart++] = decodeScales[0] * radiusX;
		bboxen[outputStart++] = decodeScales[1] * radiusY;
		bboxen[outputStart++] = decodeScales[2] * radiusZ;
	}

	return bboxen;
};

UTF8Loader.prototype.decompressMesh = function (str, meshParams, decodeParams, name, idx, callback) {

	// Extract conversion parameters from attribArrays.

	var stride = decodeParams.decodeScales.length;

	var decodeOffsets = decodeParams.decodeOffsets;
	var decodeScales = decodeParams.decodeScales;

	var attribStart = meshParams.attribRange[0];
	var numVerts = meshParams.attribRange[1];

	// Decode attributes.

	var inputOffset = attribStart;
	var attribsOut = new Float32Array(stride * numVerts);

	for (var j = 0; j < stride; j++) {

		var end = inputOffset + numVerts;

		var decodeScale = decodeScales[j];

		if (decodeScale) {

			// Assume if decodeScale is never set, simply ignore the
			// attribute.

			this.decompressAttribsInner_(str, inputOffset, end, attribsOut, j, stride, decodeOffsets[j], decodeScale);
		}

		inputOffset = end;
	}

	var numIndices = 3 * meshParams.indexRange[1];

	var indicesOut = new Uint16Array(numIndices);

	this.decompressIndices_(str, inputOffset, numIndices, indicesOut, 0);

	// Decode bboxen.

	var bboxen = undefined;
	var bboxOffset = meshParams.bboxes;

	if (bboxOffset) {

		bboxen = this.decompressAABBs_(str, bboxOffset, meshParams.names.length, decodeOffsets, decodeScales);
	}

	callback(name, idx, attribsOut, indicesOut, bboxen, meshParams);
};

UTF8Loader.prototype.copyAttrib = function (stride, attribsOutFixed, lastAttrib, index) {

	for (var j = 0; j < stride; j++) {

		lastAttrib[j] = attribsOutFixed[stride * index + j];
	}
};

UTF8Loader.prototype.decodeAttrib2 = function (str, stride, decodeOffsets, decodeScales, deltaStart, numVerts, attribsOut, attribsOutFixed, lastAttrib, index) {

	for (var j = 0; j < 5; j++) {

		var code = str.charCodeAt(deltaStart + numVerts * j + index);
		var delta = code >> 1 ^ -(code & 1);

		lastAttrib[j] += delta;
		attribsOutFixed[stride * index + j] = lastAttrib[j];
		attribsOut[stride * index + j] = decodeScales[j] * (lastAttrib[j] + decodeOffsets[j]);
	}
};

UTF8Loader.prototype.accumulateNormal = function (i0, i1, i2, attribsOutFixed, crosses) {

	var p0x = attribsOutFixed[8 * i0];
	var p0y = attribsOutFixed[8 * i0 + 1];
	var p0z = attribsOutFixed[8 * i0 + 2];

	var p1x = attribsOutFixed[8 * i1];
	var p1y = attribsOutFixed[8 * i1 + 1];
	var p1z = attribsOutFixed[8 * i1 + 2];

	var p2x = attribsOutFixed[8 * i2];
	var p2y = attribsOutFixed[8 * i2 + 1];
	var p2z = attribsOutFixed[8 * i2 + 2];

	p1x -= p0x;
	p1y -= p0y;
	p1z -= p0z;

	p2x -= p0x;
	p2y -= p0y;
	p2z -= p0z;

	p0x = p1y * p2z - p1z * p2y;
	p0y = p1z * p2x - p1x * p2z;
	p0z = p1x * p2y - p1y * p2x;

	crosses[3 * i0] += p0x;
	crosses[3 * i0 + 1] += p0y;
	crosses[3 * i0 + 2] += p0z;

	crosses[3 * i1] += p0x;
	crosses[3 * i1 + 1] += p0y;
	crosses[3 * i1 + 2] += p0z;

	crosses[3 * i2] += p0x;
	crosses[3 * i2 + 1] += p0y;
	crosses[3 * i2 + 2] += p0z;
};

UTF8Loader.prototype.decompressMesh2 = function (str, meshParams, decodeParams, name, idx, callback) {

	var MAX_BACKREF = 96;

	// Extract conversion parameters from attribArrays.

	var stride = decodeParams.decodeScales.length;

	var decodeOffsets = decodeParams.decodeOffsets;
	var decodeScales = decodeParams.decodeScales;

	var deltaStart = meshParams.attribRange[0];
	var numVerts = meshParams.attribRange[1];

	var codeStart = meshParams.codeRange[0];

	var numIndices = 3 * meshParams.codeRange[2];

	var indicesOut = new Uint16Array(numIndices);

	var crosses = new Int32Array(3 * numVerts);

	var lastAttrib = new Uint16Array(stride);

	var attribsOutFixed = new Uint16Array(stride * numVerts);
	var attribsOut = new Float32Array(stride * numVerts);

	var highest = 0;
	var outputStart = 0;

	for (var i = 0; i < numIndices; i += 3) {

		var code = str.charCodeAt(codeStart++);

		var max_backref = Math.min(i, MAX_BACKREF);

		if (code < max_backref) {

			// Parallelogram

			var winding = code % 3;
			var backref = i - (code - winding);
			var i0, i1, i2;

			switch (winding) {

				case 0:

					i0 = indicesOut[backref + 2];
					i1 = indicesOut[backref + 1];
					i2 = indicesOut[backref + 0];
					break;

				case 1:

					i0 = indicesOut[backref + 0];
					i1 = indicesOut[backref + 2];
					i2 = indicesOut[backref + 1];
					break;

				case 2:

					i0 = indicesOut[backref + 1];
					i1 = indicesOut[backref + 0];
					i2 = indicesOut[backref + 2];
					break;

			}

			indicesOut[outputStart++] = i0;
			indicesOut[outputStart++] = i1;

			code = str.charCodeAt(codeStart++);

			var index = highest - code;
			indicesOut[outputStart++] = index;

			if (code === 0) {

				for (var j = 0; j < 5; j++) {

					var deltaCode = str.charCodeAt(deltaStart + numVerts * j + highest);

					var prediction = (deltaCode >> 1 ^ -(deltaCode & 1)) + attribsOutFixed[stride * i0 + j] + attribsOutFixed[stride * i1 + j] - attribsOutFixed[stride * i2 + j];

					lastAttrib[j] = prediction;

					attribsOutFixed[stride * highest + j] = prediction;
					attribsOut[stride * highest + j] = decodeScales[j] * (prediction + decodeOffsets[j]);
				}

				highest++;
			} else {

				this.copyAttrib(stride, attribsOutFixed, lastAttrib, index);
			}

			this.accumulateNormal(i0, i1, index, attribsOutFixed, crosses);
		} else {

			// Simple

			var index0 = highest - (code - max_backref);

			indicesOut[outputStart++] = index0;

			if (code === max_backref) {

				this.decodeAttrib2(str, stride, decodeOffsets, decodeScales, deltaStart, numVerts, attribsOut, attribsOutFixed, lastAttrib, highest++);
			} else {

				this.copyAttrib(stride, attribsOutFixed, lastAttrib, index0);
			}

			code = str.charCodeAt(codeStart++);

			var index1 = highest - code;
			indicesOut[outputStart++] = index1;

			if (code === 0) {

				this.decodeAttrib2(str, stride, decodeOffsets, decodeScales, deltaStart, numVerts, attribsOut, attribsOutFixed, lastAttrib, highest++);
			} else {

				this.copyAttrib(stride, attribsOutFixed, lastAttrib, index1);
			}

			code = str.charCodeAt(codeStart++);

			var index2 = highest - code;
			indicesOut[outputStart++] = index2;

			if (code === 0) {

				for (var j = 0; j < 5; j++) {

					lastAttrib[j] = (attribsOutFixed[stride * index0 + j] + attribsOutFixed[stride * index1 + j]) / 2;
				}

				this.decodeAttrib2(str, stride, decodeOffsets, decodeScales, deltaStart, numVerts, attribsOut, attribsOutFixed, lastAttrib, highest++);
			} else {

				this.copyAttrib(stride, attribsOutFixed, lastAttrib, index2);
			}

			this.accumulateNormal(index0, index1, index2, attribsOutFixed, crosses);
		}
	}

	for (var i = 0; i < numVerts; i++) {

		var nx = crosses[3 * i];
		var ny = crosses[3 * i + 1];
		var nz = crosses[3 * i + 2];

		var norm = 511.0 / Math.sqrt(nx * nx + ny * ny + nz * nz);

		var cx = str.charCodeAt(deltaStart + 5 * numVerts + i);
		var cy = str.charCodeAt(deltaStart + 6 * numVerts + i);
		var cz = str.charCodeAt(deltaStart + 7 * numVerts + i);

		attribsOut[stride * i + 5] = norm * nx + (cx >> 1 ^ -(cx & 1));
		attribsOut[stride * i + 6] = norm * ny + (cy >> 1 ^ -(cy & 1));
		attribsOut[stride * i + 7] = norm * nz + (cz >> 1 ^ -(cz & 1));
	}

	callback(name, idx, attribsOut, indicesOut, undefined, meshParams);
};

UTF8Loader.prototype.downloadMesh = function (path, name, meshEntry, decodeParams, callback) {

	var loader = this;
	var idx = 0;

	function onprogress(data) {

		while (idx < meshEntry.length) {

			var meshParams = meshEntry[idx];
			var indexRange = meshParams.indexRange;

			if (indexRange) {

				var meshEnd = indexRange[0] + 3 * indexRange[1];

				if (data.length < meshEnd) break;

				loader.decompressMesh(data, meshParams, decodeParams, name, idx, callback);
			} else {

				var codeRange = meshParams.codeRange;
				var meshEnd = codeRange[0] + codeRange[1];

				if (data.length < meshEnd) break;

				loader.decompressMesh2(data, meshParams, decodeParams, name, idx, callback);
			}

			++idx;
		}
	}

	getHttpRequest(path, function (data) {

		onprogress(data);

		// TODO: handle errors.
	});
};

UTF8Loader.prototype.downloadMeshes = function (path, meshUrlMap, decodeParams, callback) {

	for (var url in meshUrlMap) {

		var meshEntry = meshUrlMap[url];
		this.downloadMesh(path + url, url, meshEntry, decodeParams, callback);
	}
};

UTF8Loader.prototype.createMeshCallback = function (materialBaseUrl, loadModelInfo, allDoneCallback) {

	var nCompletedUrls = 0;
	var nExpectedUrls = 0;

	var expectedMeshesPerUrl = {};
	var decodedMeshesPerUrl = {};

	var modelParts = {};

	var meshUrlMap = loadModelInfo.urls;

	for (var url in meshUrlMap) {

		expectedMeshesPerUrl[url] = meshUrlMap[url].length;
		decodedMeshesPerUrl[url] = 0;

		nExpectedUrls++;

		modelParts[url] = new THREE.Object3D();
	}

	var model = new THREE.Object3D();

	// Prepare materials first...

	var materialCreator = new THREE.MTLLoader.MaterialCreator(materialBaseUrl, loadModelInfo.options);
	materialCreator.setMaterials(loadModelInfo.materials);

	materialCreator.preload();

	// Create callback for creating mesh parts

	var bufferGeometryCreator = new UTF8Loader.BufferGeometryCreator();

	var meshCallback = function meshCallback(name, idx, attribArray, indexArray, bboxen, meshParams) {

		// Got ourselves a new mesh

		// name identifies this part of the model (url)
		// idx is the mesh index of this mesh of the part
		// attribArray defines the vertices
		// indexArray defines the faces
		// bboxen defines the bounding box
		// meshParams contains the material info

		var geometry = bufferGeometryCreator.create(attribArray, indexArray);
		var material = materialCreator.create(meshParams.material);

		var mesh = new THREE.Mesh(geometry, material);
		modelParts[name].add(mesh);

		//model.add(new THREE.Mesh(geometry, material));

		decodedMeshesPerUrl[name]++;

		if (decodedMeshesPerUrl[name] === expectedMeshesPerUrl[name]) {

			nCompletedUrls++;

			model.add(modelParts[name]);

			if (nCompletedUrls === nExpectedUrls) {

				// ALL DONE!!!

				allDoneCallback(model);
			}
		}
	};

	return meshCallback;
};

UTF8Loader.prototype.downloadModel = function (geometryBase, materialBase, model, callback) {

	var meshCallback = this.createMeshCallback(materialBase, model, callback);
	this.downloadMeshes(geometryBase, model.urls, model.decodeParams, meshCallback);
};

UTF8Loader.prototype.downloadModelJson = function (jsonUrl, callback, options) {

	getJsonRequest(jsonUrl, function (loaded) {

		if (!loaded.decodeParams) {

			if (options && options.decodeParams) {

				loaded.decodeParams = options.decodeParams;
			} else {

				loaded.decodeParams = DEFAULT_DECODE_PARAMS;
			}
		}

		loaded.options = options;

		var geometryBase = jsonUrl.substr(0, jsonUrl.lastIndexOf("/") + 1);
		var materialBase = geometryBase;

		if (options && options.geometryBase) {

			geometryBase = options.geometryBase;

			if (geometryBase.charAt(geometryBase.length - 1) !== "/") {

				geometryBase = geometryBase + "/";
			}
		}

		if (options && options.materialBase) {

			materialBase = options.materialBase;

			if (materialBase.charAt(materialBase.length - 1) !== "/") {

				materialBase = materialBase + "/";
			}
		}

		this.downloadModel(geometryBase, materialBase, loaded, callback);
	}.bind(this));
};

// XMLHttpRequest stuff

function getHttpRequest(url, onload, opt_onprogress) {

	var req = new THREE.FileLoader();
	req.load(url, onload, opt_onprogress);
}

function getJsonRequest(url, onjson) {

	getHttpRequest(url, function (e) {

		onjson(JSON.parse(e));
	}, function () {});
}

function addListeners(dom, listeners) {

	// TODO: handle event capture, object binding.

	for (var key in listeners) {

		dom.addEventListener(key, listeners[key]);
	}
}

exports.default = UTF8Loader;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Alex Pletzer
 *
 * Updated on 22.03.2017
 * VTK header is now parsed and used to extract all the compressed data
 * @author Andrii Iudin https://github.com/andreyyudin
 * @author Paul Kibet Korir https://github.com/polarise
 * @author Sriram Somasundharam https://github.com/raamssundar
 */

var VTKLoader = function VTKLoader(manager) {

	this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};

Object.assign(VTKLoader.prototype, THREE.EventDispatcher.prototype, {

	load: function load(url, onLoad, onProgress, onError) {

		var scope = this;

		var loader = new THREE.FileLoader(scope.manager);
		loader.setResponseType('arraybuffer');
		loader.load(url, function (text) {

			onLoad(scope.parse(text));
		}, onProgress, onError);
	},

	parse: function parse(data) {

		function parseASCII(data) {

			// connectivity of the triangles
			var indices = [];

			// triangles vertices
			var positions = [];

			// red, green, blue colors in the range 0 to 1
			var colors = [];

			// normal vector, one per vertex
			var normals = [];

			var result;

			// pattern for reading vertices, 3 floats or integers
			var pat3Floats = /(\-?\d+\.?[\d\-\+e]*)\s+(\-?\d+\.?[\d\-\+e]*)\s+(\-?\d+\.?[\d\-\+e]*)/g;

			// pattern for connectivity, an integer followed by any number of ints
			// the first integer is the number of polygon nodes
			var patConnectivity = /^(\d+)\s+([\s\d]*)/;

			// indicates start of vertex data section
			var patPOINTS = /^POINTS /;

			// indicates start of polygon connectivity section
			var patPOLYGONS = /^POLYGONS /;

			// indicates start of triangle strips section
			var patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /;

			// POINT_DATA number_of_values
			var patPOINT_DATA = /^POINT_DATA[ ]+(\d+)/;

			// CELL_DATA number_of_polys
			var patCELL_DATA = /^CELL_DATA[ ]+(\d+)/;

			// Start of color section
			var patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\w+)[ ]+3/;

			// NORMALS Normals float
			var patNORMALS = /^NORMALS[ ]+(\w+)[ ]+(\w+)/;

			var inPointsSection = false;
			var inPolygonsSection = false;
			var inTriangleStripSection = false;
			var inPointDataSection = false;
			var inCellDataSection = false;
			var inColorSection = false;
			var inNormalsSection = false;

			var lines = data.split('\n');

			for (var i in lines) {

				var line = lines[i];

				if (inPointsSection) {

					// get the vertices
					while ((result = pat3Floats.exec(line)) !== null) {

						var x = parseFloat(result[1]);
						var y = parseFloat(result[2]);
						var z = parseFloat(result[3]);
						positions.push(x, y, z);
					}
				} else if (inPolygonsSection) {

					if ((result = patConnectivity.exec(line)) !== null) {

						// numVertices i0 i1 i2 ...
						var numVertices = parseInt(result[1]);
						var inds = result[2].split(/\s+/);

						if (numVertices >= 3) {

							var i0 = parseInt(inds[0]);
							var i1, i2;
							var k = 1;
							// split the polygon in numVertices - 2 triangles
							for (var j = 0; j < numVertices - 2; ++j) {

								i1 = parseInt(inds[k]);
								i2 = parseInt(inds[k + 1]);
								indices.push(i0, i1, i2);
								k++;
							}
						}
					}
				} else if (inTriangleStripSection) {

					if ((result = patConnectivity.exec(line)) !== null) {

						// numVertices i0 i1 i2 ...
						var numVertices = parseInt(result[1]);
						var inds = result[2].split(/\s+/);

						if (numVertices >= 3) {

							var i0, i1, i2;
							// split the polygon in numVertices - 2 triangles
							for (var j = 0; j < numVertices - 2; j++) {

								if (j % 2 === 1) {

									i0 = parseInt(inds[j]);
									i1 = parseInt(inds[j + 2]);
									i2 = parseInt(inds[j + 1]);
									indices.push(i0, i1, i2);
								} else {

									i0 = parseInt(inds[j]);
									i1 = parseInt(inds[j + 1]);
									i2 = parseInt(inds[j + 2]);
									indices.push(i0, i1, i2);
								}
							}
						}
					}
				} else if (inPointDataSection || inCellDataSection) {

					if (inColorSection) {

						// Get the colors

						while ((result = pat3Floats.exec(line)) !== null) {

							var r = parseFloat(result[1]);
							var g = parseFloat(result[2]);
							var b = parseFloat(result[3]);
							colors.push(r, g, b);
						}
					} else if (inNormalsSection) {

						// Get the normal vectors

						while ((result = pat3Floats.exec(line)) !== null) {

							var nx = parseFloat(result[1]);
							var ny = parseFloat(result[2]);
							var nz = parseFloat(result[3]);
							normals.push(nx, ny, nz);
						}
					}
				}

				if (patPOLYGONS.exec(line) !== null) {

					inPolygonsSection = true;
					inPointsSection = false;
					inTriangleStripSection = false;
				} else if (patPOINTS.exec(line) !== null) {

					inPolygonsSection = false;
					inPointsSection = true;
					inTriangleStripSection = false;
				} else if (patTRIANGLE_STRIPS.exec(line) !== null) {

					inPolygonsSection = false;
					inPointsSection = false;
					inTriangleStripSection = true;
				} else if (patPOINT_DATA.exec(line) !== null) {

					inPointDataSection = true;
					inPointsSection = false;
					inPolygonsSection = false;
					inTriangleStripSection = false;
				} else if (patCELL_DATA.exec(line) !== null) {

					inCellDataSection = true;
					inPointsSection = false;
					inPolygonsSection = false;
					inTriangleStripSection = false;
				} else if (patCOLOR_SCALARS.exec(line) !== null) {

					inColorSection = true;
					inNormalsSection = false;
					inPointsSection = false;
					inPolygonsSection = false;
					inTriangleStripSection = false;
				} else if (patNORMALS.exec(line) !== null) {

					inNormalsSection = true;
					inColorSection = false;
					inPointsSection = false;
					inPolygonsSection = false;
					inTriangleStripSection = false;
				}
			}

			var geometry;
			var stagger = 'point';

			if (colors.length === indices.length) {

				stagger = 'cell';
			}

			if (stagger === 'point') {

				// Nodal. Use BufferGeometry
				geometry = new THREE.BufferGeometry();
				geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));
				geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));

				if (colors.length === positions.length) {

					geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), 3));
				}

				if (normals.length === positions.length) {

					geometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), 3));
				}
			} else {

				// Cell centered colors. The only way to attach a solid color to each triangle
				// is to use Geometry, which is less efficient than BufferGeometry
				geometry = new THREE.Geometry();

				var numTriangles = indices.length / 3;
				var numPoints = positions.length / 3;
				var face;
				var ia, ib, ic;
				var x, y, z;
				var r, g, b;

				for (var j = 0; j < numPoints; ++j) {

					x = positions[3 * j + 0];
					y = positions[3 * j + 1];
					z = positions[3 * j + 2];
					geometry.vertices.push(new THREE.Vector3(x, y, z));
				}

				for (var i = 0; i < numTriangles; ++i) {

					ia = indices[3 * i + 0];
					ib = indices[3 * i + 1];
					ic = indices[3 * i + 2];
					geometry.faces.push(new THREE.Face3(ia, ib, ic));
				}

				if (colors.length === numTriangles * 3) {

					for (var i = 0; i < numTriangles; ++i) {

						face = geometry.faces[i];
						r = colors[3 * i + 0];
						g = colors[3 * i + 1];
						b = colors[3 * i + 2];
						face.color = new THREE.Color().setRGB(r, g, b);
					}
				}
			}

			return geometry;
		}

		function parseBinary(data) {

			var count, pointIndex, i, numberOfPoints, s;
			var buffer = new Uint8Array(data);
			var dataView = new DataView(data);

			// Points and normals, by default, are empty
			var points = [];
			var normals = [];
			var indices = [];

			// Going to make a big array of strings
			var vtk = [];
			var index = 0;

			function findString(buffer, start) {

				var index = start;
				var c = buffer[index];
				var s = [];
				while (c !== 10) {

					s.push(String.fromCharCode(c));
					index++;
					c = buffer[index];
				}

				return { start: start,
					end: index,
					next: index + 1,
					parsedString: s.join('') };
			}

			var state, line;

			while (true) {

				// Get a string
				state = findString(buffer, index);
				line = state.parsedString;

				if (line.indexOf('POINTS') === 0) {

					vtk.push(line);
					// Add the points
					numberOfPoints = parseInt(line.split(' ')[1], 10);

					// Each point is 3 4-byte floats
					count = numberOfPoints * 4 * 3;

					points = new Float32Array(numberOfPoints * 3);

					pointIndex = state.next;
					for (i = 0; i < numberOfPoints; i++) {

						points[3 * i] = dataView.getFloat32(pointIndex, false);
						points[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);
						points[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);
						pointIndex = pointIndex + 12;
					}
					// increment our next pointer
					state.next = state.next + count + 1;
				} else if (line.indexOf('TRIANGLE_STRIPS') === 0) {

					var numberOfStrips = parseInt(line.split(' ')[1], 10);
					var size = parseInt(line.split(' ')[2], 10);
					// 4 byte integers
					count = size * 4;

					indices = new Uint32Array(3 * size - 9 * numberOfStrips);
					var indicesIndex = 0;

					pointIndex = state.next;
					for (i = 0; i < numberOfStrips; i++) {

						// For each strip, read the first value, then record that many more points
						var indexCount = dataView.getInt32(pointIndex, false);
						var strip = [];
						pointIndex += 4;
						for (s = 0; s < indexCount; s++) {

							strip.push(dataView.getInt32(pointIndex, false));
							pointIndex += 4;
						}

						// retrieves the n-2 triangles from the triangle strip
						for (var j = 0; j < indexCount - 2; j++) {

							if (j % 2) {

								indices[indicesIndex++] = strip[j];
								indices[indicesIndex++] = strip[j + 2];
								indices[indicesIndex++] = strip[j + 1];
							} else {

								indices[indicesIndex++] = strip[j];
								indices[indicesIndex++] = strip[j + 1];
								indices[indicesIndex++] = strip[j + 2];
							}
						}
					}
					// increment our next pointer
					state.next = state.next + count + 1;
				} else if (line.indexOf('POLYGONS') === 0) {

					var numberOfStrips = parseInt(line.split(' ')[1], 10);
					var size = parseInt(line.split(' ')[2], 10);
					// 4 byte integers
					count = size * 4;

					indices = new Uint32Array(3 * size - 9 * numberOfStrips);
					var indicesIndex = 0;

					pointIndex = state.next;
					for (i = 0; i < numberOfStrips; i++) {

						// For each strip, read the first value, then record that many more points
						var indexCount = dataView.getInt32(pointIndex, false);
						var strip = [];
						pointIndex += 4;
						for (s = 0; s < indexCount; s++) {

							strip.push(dataView.getInt32(pointIndex, false));
							pointIndex += 4;
						}

						// divide the polygon in n-2 triangle
						for (var j = 1; j < indexCount - 1; j++) {

							indices[indicesIndex++] = strip[0];
							indices[indicesIndex++] = strip[j];
							indices[indicesIndex++] = strip[j + 1];
						}
					}
					// increment our next pointer
					state.next = state.next + count + 1;
				} else if (line.indexOf('POINT_DATA') === 0) {

					numberOfPoints = parseInt(line.split(' ')[1], 10);

					// Grab the next line
					state = findString(buffer, state.next);

					// Now grab the binary data
					count = numberOfPoints * 4 * 3;

					normals = new Float32Array(numberOfPoints * 3);
					pointIndex = state.next;
					for (i = 0; i < numberOfPoints; i++) {

						normals[3 * i] = dataView.getFloat32(pointIndex, false);
						normals[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);
						normals[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);
						pointIndex += 12;
					}

					// Increment past our data
					state.next = state.next + count;
				}

				// Increment index
				index = state.next;

				if (index >= buffer.byteLength) {

					break;
				}
			}

			var geometry = new THREE.BufferGeometry();
			geometry.setIndex(new THREE.BufferAttribute(indices, 1));
			geometry.addAttribute('position', new THREE.BufferAttribute(points, 3));

			if (normals.length === points.length) {

				geometry.addAttribute('normal', new THREE.BufferAttribute(normals, 3));
			}

			return geometry;
		}

		function Float32Concat(first, second) {

			var firstLength = first.length,
			    result = new Float32Array(firstLength + second.length);

			result.set(first);
			result.set(second, firstLength);

			return result;
		}

		function Int32Concat(first, second) {

			var firstLength = first.length,
			    result = new Int32Array(firstLength + second.length);

			result.set(first);
			result.set(second, firstLength);

			return result;
		}

		function parseXML(stringFile) {

			// Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json

			function xmlToJson(xml) {

				// Create the return object
				var obj = {};

				if (xml.nodeType === 1) {
					// element

					// do attributes

					if (xml.attributes) {

						if (xml.attributes.length > 0) {

							obj['attributes'] = {};

							for (var j = 0; j < xml.attributes.length; j++) {

								var attribute = xml.attributes.item(j);
								obj['attributes'][attribute.nodeName] = attribute.nodeValue.trim();
							}
						}
					}
				} else if (xml.nodeType === 3) {
					// text

					obj = xml.nodeValue.trim();
				}

				// do children
				if (xml.hasChildNodes()) {

					for (var i = 0; i < xml.childNodes.length; i++) {

						var item = xml.childNodes.item(i);
						var nodeName = item.nodeName;

						if (typeof obj[nodeName] === 'undefined') {

							var tmp = xmlToJson(item);

							if (tmp !== '') obj[nodeName] = tmp;
						} else {

							if (typeof obj[nodeName].push === 'undefined') {

								var old = obj[nodeName];
								obj[nodeName] = [old];
							}

							var tmp = xmlToJson(item);

							if (tmp !== '') obj[nodeName].push(tmp);
						}
					}
				}

				return obj;
			}

			// Taken from Base64-js
			function Base64toByteArray(b64) {

				var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
				var i;
				var lookup = [];
				var revLookup = [];
				var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
				var len = code.length;

				for (i = 0; i < len; i++) {

					lookup[i] = code[i];
				}

				for (i = 0; i < len; ++i) {

					revLookup[code.charCodeAt(i)] = i;
				}

				revLookup['-'.charCodeAt(0)] = 62;
				revLookup['_'.charCodeAt(0)] = 63;

				var j, l, tmp, placeHolders, arr;
				var len = b64.length;

				if (len % 4 > 0) {

					throw new Error('Invalid string. Length must be a multiple of 4');
				}

				placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
				arr = new Arr(len * 3 / 4 - placeHolders);
				l = placeHolders > 0 ? len - 4 : len;

				var L = 0;

				for (i = 0, j = 0; i < l; i += 4, j += 3) {

					tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
					arr[L++] = (tmp & 0xFF0000) >> 16;
					arr[L++] = (tmp & 0xFF00) >> 8;
					arr[L++] = tmp & 0xFF;
				}

				if (placeHolders === 2) {

					tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
					arr[L++] = tmp & 0xFF;
				} else if (placeHolders === 1) {

					tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
					arr[L++] = tmp >> 8 & 0xFF;
					arr[L++] = tmp & 0xFF;
				}

				return arr;
			}

			function parseDataArray(ele, compressed) {

				var numBytes = 0;

				if (json.attributes.header_type === 'UInt64') {

					numBytes = 8;
				} else if (json.attributes.header_type === 'UInt32') {

					numBytes = 4;
				}

				// Check the format
				if (ele.attributes.format === 'binary' && compressed) {

					var rawData, content, byteData, blocks, cSizeStart, headerSize, padding, dataOffsets, currentOffset;

					if (ele.attributes.type === 'Float32') {

						var txt = new Float32Array();
					} else if (ele.attributes.type === 'Int64') {

						var txt = new Int32Array();
					}

					// VTP data with the header has the following structure:
					// [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]
					//
					// Each token is an integer value whose type is specified by "header_type" at the top of the file (UInt32 if no type specified). The token meanings are:
					// [#blocks] = Number of blocks
					// [#u-size] = Block size before compression
					// [#p-size] = Size of last partial block (zero if it not needed)
					// [#c-size-i] = Size in bytes of block i after compression
					//
					// The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is
					// computed by summing the compressed block sizes from preceding blocks according to the header.

					rawData = ele['#text'];

					byteData = Base64toByteArray(rawData);

					blocks = byteData[0];
					for (var i = 1; i < numBytes - 1; i++) {

						blocks = blocks | byteData[i] << i * numBytes;
					}

					headerSize = (blocks + 3) * numBytes;
					padding = headerSize % 3 > 0 ? 3 - headerSize % 3 : 0;
					headerSize = headerSize + padding;

					dataOffsets = [];
					currentOffset = headerSize;
					dataOffsets.push(currentOffset);

					// Get the blocks sizes after the compression.
					// There are three blocks before c-size-i, so we skip 3*numBytes
					cSizeStart = 3 * numBytes;

					for (var i = 0; i < blocks; i++) {

						var currentBlockSize = byteData[i * numBytes + cSizeStart];

						for (var j = 1; j < numBytes - 1; j++) {

							// Each data point consists of 8 bytes regardless of the header type
							currentBlockSize = currentBlockSize | byteData[i * numBytes + cSizeStart + j] << j * 8;
						}

						currentOffset = currentOffset + currentBlockSize;
						dataOffsets.push(currentOffset);
					}

					for (var i = 0; i < dataOffsets.length - 1; i++) {

						var inflate = new Zlib.Inflate(byteData.slice(dataOffsets[i], dataOffsets[i + 1]), { resize: true, verify: true }); // eslint-disable-line no-undef
						content = inflate.decompress();
						content = content.buffer;

						if (ele.attributes.type === 'Float32') {

							content = new Float32Array(content);
							txt = Float32Concat(txt, content);
						} else if (ele.attributes.type === 'Int64') {

							content = new Int32Array(content);
							txt = Int32Concat(txt, content);
						}
					}

					delete ele['#text'];

					// Get the content and optimize it
					if (ele.attributes.type === 'Float32') {

						if (ele.attributes.format === 'binary') {

							if (!compressed) {

								txt = txt.filter(function (el, idx) {

									if (idx !== 0) return true;
								});
							}
						}
					} else if (ele.attributes.type === 'Int64') {

						if (ele.attributes.format === 'binary') {

							if (!compressed) {

								txt = txt.filter(function (el, idx) {

									if (idx !== 0) return true;
								});
							}

							txt = txt.filter(function (el, idx) {

								if (idx % 2 !== 1) return true;
							});
						}
					}
				} else {

					if (ele.attributes.format === 'binary' && !compressed) {

						var content = Base64toByteArray(ele['#text']);

						//  VTP data for the uncompressed case has the following structure:
						// [#bytes][DATA]
						// where "[#bytes]" is an integer value specifying the number of bytes in the block of data following it.
						content = content.slice(numBytes).buffer;
					} else {

						if (ele['#text']) {

							var content = ele['#text'].split(/\s+/).filter(function (el) {

								if (el !== '') return el;
							});
						} else {

							var content = new Int32Array(0).buffer;
						}
					}

					delete ele['#text'];

					// Get the content and optimize it
					if (ele.attributes.type === 'Float32') {

						var txt = new Float32Array(content);
					} else if (ele.attributes.type === 'Int32') {

						var txt = new Int32Array(content);
					} else if (ele.attributes.type === 'Int64') {

						var txt = new Int32Array(content);

						if (ele.attributes.format === 'binary') {

							txt = txt.filter(function (el, idx) {

								if (idx % 2 !== 1) return true;
							});
						}
					}
				} // endif ( ele.attributes.format === 'binary' && compressed )

				return txt;
			}

			// Main part
			// Get Dom
			var dom = null;

			if (window.DOMParser) {

				try {

					dom = new DOMParser().parseFromString(stringFile, 'text/xml');
				} catch (e) {

					dom = null;
				}
			} else if (window.ActiveXObject) {

				try {

					dom = new ActiveXObject('Microsoft.XMLDOM'); // eslint-disable-line no-undef
					dom.async = false;

					if (!dom.loadXML()) {

						throw new Error(dom.parseError.reason + dom.parseError.srcText);
					}
				} catch (e) {

					dom = null;
				}
			} else {

				throw new Error('Cannot parse xml string!');
			}

			// Get the doc
			var doc = dom.documentElement;
			// Convert to json
			var json = xmlToJson(doc);
			var points = [];
			var normals = [];
			var indices = [];

			if (json.PolyData) {

				var piece = json.PolyData.Piece;
				var compressed = json.attributes.hasOwnProperty('compressor');

				// Can be optimized
				// Loop through the sections
				var sections = ['PointData', 'Points', 'Strips', 'Polys']; // +['CellData', 'Verts', 'Lines'];
				var sectionIndex = 0,
				    numberOfSections = sections.length;

				while (sectionIndex < numberOfSections) {

					var section = piece[sections[sectionIndex]];

					// If it has a DataArray in it

					if (section && section.DataArray) {

						// Depending on the number of DataArrays

						if (Object.prototype.toString.call(section.DataArray) === '[object Array]') {

							var arr = section.DataArray;
						} else {

							var arr = [section.DataArray];
						}

						var dataArrayIndex = 0,
						    numberOfDataArrays = arr.length;

						while (dataArrayIndex < numberOfDataArrays) {

							// Parse the DataArray
							if ('#text' in arr[dataArrayIndex] && arr[dataArrayIndex]['#text'].length > 0) {

								arr[dataArrayIndex].text = parseDataArray(arr[dataArrayIndex], compressed);
							}

							dataArrayIndex++;
						}

						switch (sections[sectionIndex]) {

							// if iti is point data
							case 'PointData':

								var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);
								var normalsName = section.attributes.Normals;

								if (numberOfPoints > 0) {

									for (var i = 0, len = arr.length; i < len; i++) {

										if (normalsName === arr[i].attributes.Name) {

											var components = arr[i].attributes.NumberOfComponents;
											normals = new Float32Array(numberOfPoints * components);
											normals.set(arr[i].text, 0);
										}
									}
								}

								break;

							// if it is points
							case 'Points':

								var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);

								if (numberOfPoints > 0) {

									var components = section.DataArray.attributes.NumberOfComponents;
									points = new Float32Array(numberOfPoints * components);
									points.set(section.DataArray.text, 0);
								}

								break;

							// if it is strips
							case 'Strips':

								var numberOfStrips = parseInt(piece.attributes.NumberOfStrips);

								if (numberOfStrips > 0) {

									var connectivity = new Int32Array(section.DataArray[0].text.length);
									var offset = new Int32Array(section.DataArray[1].text.length);
									connectivity.set(section.DataArray[0].text, 0);
									offset.set(section.DataArray[1].text, 0);

									var size = numberOfStrips + connectivity.length;
									indices = new Uint32Array(3 * size - 9 * numberOfStrips);

									var indicesIndex = 0;

									for (var i = 0, len = numberOfStrips; i < len; i++) {

										var strip = [];

										for (var s = 0, len1 = offset[i], len0 = 0; s < len1 - len0; s++) {

											strip.push(connectivity[s]);

											if (i > 0) len0 = offset[i - 1];
										}

										for (var j = 0, len1 = offset[i], len0 = 0; j < len1 - len0 - 2; j++) {

											if (j % 2) {

												indices[indicesIndex++] = strip[j];
												indices[indicesIndex++] = strip[j + 2];
												indices[indicesIndex++] = strip[j + 1];
											} else {

												indices[indicesIndex++] = strip[j];
												indices[indicesIndex++] = strip[j + 1];
												indices[indicesIndex++] = strip[j + 2];
											}

											if (i > 0) len0 = offset[i - 1];
										}
									}
								}

								break;

							// if it is polys
							case 'Polys':

								var numberOfPolys = parseInt(piece.attributes.NumberOfPolys);

								if (numberOfPolys > 0) {

									var connectivity = new Int32Array(section.DataArray[0].text.length);
									var offset = new Int32Array(section.DataArray[1].text.length);
									connectivity.set(section.DataArray[0].text, 0);
									offset.set(section.DataArray[1].text, 0);

									var size = numberOfPolys + connectivity.length;
									indices = new Uint32Array(3 * size - 9 * numberOfPolys);
									var indicesIndex = 0,
									    connectivityIndex = 0;
									var i = 0,
									    len = numberOfPolys,
									    len0 = 0;

									while (i < len) {

										var poly = [];
										var s = 0,
										    len1 = offset[i];

										while (s < len1 - len0) {

											poly.push(connectivity[connectivityIndex++]);
											s++;
										}

										var j = 1;

										while (j < len1 - len0 - 1) {

											indices[indicesIndex++] = poly[0];
											indices[indicesIndex++] = poly[j];
											indices[indicesIndex++] = poly[j + 1];
											j++;
										}

										i++;
										len0 = offset[i - 1];
									}
								}

								break;

							default:
								break;

						}
					}

					sectionIndex++;
				}

				var geometry = new THREE.BufferGeometry();
				geometry.setIndex(new THREE.BufferAttribute(indices, 1));
				geometry.addAttribute('position', new THREE.BufferAttribute(points, 3));

				if (normals.length === points.length) {

					geometry.addAttribute('normal', new THREE.BufferAttribute(normals, 3));
				}

				return geometry;
			} else {

				// TODO for vtu,vti,and other xml formats

			}
		}

		function getStringFile(data) {

			var stringFile = '';
			var charArray = new Uint8Array(data);
			var i = 0;
			var len = charArray.length;

			while (len--) {

				stringFile += String.fromCharCode(charArray[i++]);
			}

			return stringFile;
		}

		// get the 5 first lines of the files to check if there is the key word binary
		var meta = THREE.LoaderUtils.decodeText(new Uint8Array(data, 0, 250)).split('\n');

		if (meta[0].indexOf('xml') !== -1) {

			return parseXML(getStringFile(data));
		} else if (meta[2].includes('ASCII')) {

			return parseASCII(getStringFile(data));
		} else {

			return parseBinary(data);
		}
	}

});

exports.default = VTKLoader;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// ( function ( global, factory ) {
//
// 	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
// 		typeof define === 'function' && define.amd ? define( factory ) :
// 			( global.THREE = global.THREE || {}, global.THREE.XLoader = factory() );
//
// }( this, ( function () {

'use strict';

var classCallCheck = function classCallCheck(instance, Constructor) {

	if (!(instance instanceof Constructor)) {

		throw new TypeError("Cannot call a class as a function");
	}
};

var createClass = function () {

	function defineProperties(target, props) {

		for (var i = 0; i < props.length; i++) {

			var descriptor = props[i];
			descriptor.enumerable = descriptor.enumerable || false;
			descriptor.configurable = true;
			if ("value" in descriptor) descriptor.writable = true;
			Object.defineProperty(target, descriptor.key, descriptor);
		}
	}

	return function (Constructor, protoProps, staticProps) {

		if (protoProps) defineProperties(Constructor.prototype, protoProps);
		if (staticProps) defineProperties(Constructor, staticProps);
		return Constructor;
	};
}();

var XboneInf = function XboneInf() {

	classCallCheck(this, XboneInf);

	this.boneName = "";
	this.BoneIndex = 0;
	this.Indeces = [];
	this.Weights = [];
	this.initMatrix = null;
	this.OffsetMatrix = null;
};

var XAnimationInfo = function XAnimationInfo() {

	classCallCheck(this, XAnimationInfo);

	this.animeName = "";
	this.boneName = "";
	this.targetBone = null;
	this.keyType = 4;
	this.frameStartLv = 0;
	this.keyFrames = [];
	this.InverseMx = null;
};

var XAnimationObj = function () {

	function XAnimationObj(_flags) {

		classCallCheck(this, XAnimationObj);

		this.fps = 30;
		this.name = 'xanimation';
		this.length = 0;
		this.hierarchy = [];
		this.putFlags = _flags;
		if (this.putFlags.putPos === undefined) {

			this.putFlags.putPos = true;
		}
		if (this.putFlags.putRot === undefined) {

			this.putFlags.putRot = true;
		}
		if (this.putFlags.putScl === undefined) {

			this.putFlags.putScl = true;
		}
	}

	createClass(XAnimationObj, [{
		key: "make",
		value: function make(XAnimationInfoArray) {

			for (var i = 0; i < XAnimationInfoArray.length; i++) {

				this.hierarchy.push(this.makeBonekeys(XAnimationInfoArray[i]));
			}
			this.length = this.hierarchy[0].keys[this.hierarchy[0].keys.length - 1].time;
		}
	}, {
		key: "clone",
		value: function clone() {

			return Object.assign({}, this);
		}
	}, {
		key: "makeBonekeys",
		value: function makeBonekeys(XAnimationInfo) {

			var refObj = {};
			refObj.name = XAnimationInfo.boneName;
			refObj.parent = "";
			refObj.keys = this.keyFrameRefactor(XAnimationInfo);
			refObj.copy = function () {

				return Object.assign({}, this);
			};
			return refObj;
		}
	}, {
		key: "keyFrameRefactor",
		value: function keyFrameRefactor(XAnimationInfo) {

			var keys = [];
			for (var i = 0; i < XAnimationInfo.keyFrames.length; i++) {

				var keyframe = {};
				keyframe.time = XAnimationInfo.keyFrames[i].time * this.fps;
				if (XAnimationInfo.keyFrames[i].pos && this.putFlags.putPos) {

					keyframe.pos = XAnimationInfo.keyFrames[i].pos;
				}
				if (XAnimationInfo.keyFrames[i].rot && this.putFlags.putRot) {

					keyframe.rot = XAnimationInfo.keyFrames[i].rot;
				}
				if (XAnimationInfo.keyFrames[i].scl && this.putFlags.putScl) {

					keyframe.scl = XAnimationInfo.keyFrames[i].scl;
				}
				if (XAnimationInfo.keyFrames[i].matrix) {

					keyframe.matrix = XAnimationInfo.keyFrames[i].matrix;
					if (this.putFlags.putPos) {

						keyframe.pos = new THREE.Vector3().setFromMatrixPosition(keyframe.matrix);
					}
					if (this.putFlags.putRot) {

						keyframe.rot = new THREE.Quaternion().setFromRotationMatrix(keyframe.matrix);
					}
					if (this.putFlags.putScl) {

						keyframe.scl = new THREE.Vector3().setFromMatrixScale(keyframe.matrix);
					}
				}
				keys.push(keyframe);
			}
			return keys;
		}
	}]);
	return XAnimationObj;
}();

var XKeyFrameInfo = function XKeyFrameInfo() {

	classCallCheck(this, XKeyFrameInfo);

	this.index = 0;
	this.Frame = 0;
	this.time = 0.0;
	this.matrix = null;
};

var XLoader = function () {

	function XLoader(manager, texloader) {

		classCallCheck(this, XLoader);

		this.debug = false;
		this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
		this.texloader = texloader !== undefined ? texloader : new THREE.TextureLoader();
		this.url = "";
		this.baseDir = "";
		this._putMatLength = 0;
		this._nowMat = null;
		this._tmpUvArray = [];
		this._facesNormal = [];
		this._nowFrameName = "";
		this.frameHierarchie = [];
		this.Hierarchies = {};
		this.HieStack = [];
		this._currentObject = {};
		this._currentFrame = {};
		this._data = null;
		this.onLoad = null;
		this.IsUvYReverse = true;
		this.Meshes = [];
		this.animations = [];
		this.animTicksPerSecond = 30;
		this._currentGeo = null;
		this._currentAnime = null;
		this._currentAnimeFrames = null;
	}

	createClass(XLoader, [{
		key: '_setArgOption',
		value: function _setArgOption(_arg) {

			var _start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

			if (!_arg) {

				return;
			}
			for (var i = _start; i < _arg.length; i++) {

				switch (i) {

					case 0:
						this.url = _arg[i];
						break;
					case 1:
						this.options = _arg[i];
						break;

				}
			}
			if (this.options === undefined) {

				this.options = {};
			}
		}
	}, {
		key: 'load',
		value: function load(_arg, onLoad, onProgress, onError) {

			var _this = this;

			this._setArgOption(_arg);
			var loader = new THREE.FileLoader(this.manager);
			loader.setResponseType('arraybuffer');
			loader.load(this.url, function (response) {

				_this._parse(response, onLoad);
			}, onProgress, onError);
		}
	}, {
		key: 'fromResponsedData',
		value: function fromResponsedData(_data, _arg, onLoad) {

			this._setArgOption(_arg);
			this._parse(_data, onLoad);
		}
	}, {
		key: '_readLine',
		value: function _readLine(line) {

			var readed = 0;
			while (true) {

				var find = -1;
				find = line.indexOf('//', readed);
				if (find === -1) {

					find = line.indexOf('#', readed);
				}
				if (find > -1 && find < 2) {

					var foundNewLine = -1;
					foundNewLine = line.indexOf("\r\n", readed);
					if (foundNewLine > 0) {

						readed = foundNewLine + 2;
					} else {

						foundNewLine = line.indexOf("\r", readed);
						if (foundNewLine > 0) {

							readed = foundNewLine + 1;
						} else {

							readed = line.indexOf("\n", readed) + 1;
						}
					}
				} else {

					break;
				}
			}
			return line.substr(readed);
		}
	}, {
		key: '_readLine',
		value: function _readLine(line) {

			var readed = 0;
			while (true) {

				var find = -1;
				find = line.indexOf('//', readed);
				if (find === -1) {

					find = line.indexOf('#', readed);
				}
				if (find > -1 && find < 2) {

					var foundNewLine = -1;
					foundNewLine = line.indexOf("\r\n", readed);
					if (foundNewLine > 0) {

						readed = foundNewLine + 2;
					} else {

						foundNewLine = line.indexOf("\r", readed);
						if (foundNewLine > 0) {

							readed = foundNewLine + 1;
						} else {

							readed = line.indexOf("\n", readed) + 1;
						}
					}
				} else {

					break;
				}
			}
			return line.substr(readed);
		}
	}, {
		key: '_isBinary',
		value: function _isBinary(binData) {

			var reader = new DataView(binData);
			var face_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;
			var n_faces = reader.getUint32(80, true);
			var expect = 80 + 32 / 8 + n_faces * face_size;
			if (expect === reader.byteLength) {

				return true;
			}
			var fileLength = reader.byteLength;
			for (var index = 0; index < fileLength; index++) {

				if (reader.getUint8(index, false) > 127) {

					return true;
				}
			}
			return false;
		}
	}, {
		key: 'ensureBinary',
		value: function ensureBinary(buf) {

			if (typeof buf === "string") {

				var array_buffer = new Uint8Array(buf.length);
				for (var i = 0; i < buf.length; i++) {

					array_buffer[i] = buf.charCodeAt(i) & 0xff;
				}
				return array_buffer.buffer || array_buffer;
			} else {

				return buf;
			}
		}
	}, {
		key: 'ensureString',
		value: function ensureString(buf) {

			if (typeof buf !== "string") {

				return THREE.LoaderUtils.decodeText(new Uint8Array(buf));
			} else {

				return buf;
			}
		}
	}, {
		key: '_parse',
		value: function _parse(data, onLoad) {

			var binData = this.ensureBinary(data);
			this._data = this.ensureString(data);
			this.onLoad = onLoad;
			return this._isBinary(binData) ? this._parseBinary(binData) : this._parseASCII();
		}
	}, {
		key: '_parseBinary',
		value: function _parseBinary(data) {

			return this._parseASCII(THREE.LoaderUtils.decodeText(new Uint8Array(data)));
		}
	}, {
		key: '_parseASCII',
		value: function _parseASCII() {

			if (this.url.lastIndexOf("/") > 0) {

				this.baseDir = this.url.substr(0, this.url.lastIndexOf("/") + 1);
			}
			var endRead = 16;
			this.Hierarchies.children = [];
			this._hierarchieParse(this.Hierarchies, endRead);
			this._changeRoot();
			this._currentObject = this.Hierarchies.children.shift();
			this.mainloop();
		}
	}, {
		key: '_hierarchieParse',
		value: function _hierarchieParse(_parent, _end) {

			var endRead = _end;
			while (true) {

				var find1 = this._data.indexOf('{', endRead) + 1;
				var findEnd = this._data.indexOf('}', endRead);
				var findNext = this._data.indexOf('{', find1) + 1;
				if (find1 > 0 && findEnd > find1) {

					var _currentObject = {};
					_currentObject.children = [];
					var nameData = this._readLine(this._data.substr(endRead, find1 - endRead - 1)).trim();
					var word = nameData.split(/ /g);
					if (word.length > 0) {

						_currentObject.type = word[0];
						if (word.length >= 2) {

							_currentObject.name = word[1];
						} else {

							_currentObject.name = word[0] + this.Hierarchies.children.length;
						}
					} else {

						_currentObject.name = nameData;
						_currentObject.type = "";
					}
					if (_currentObject.type === "Animation") {

						_currentObject.data = this._data.substr(findNext, findEnd - findNext).trim();
						var refs = this._hierarchieParse(_currentObject, findEnd + 1);
						endRead = refs.end;
						_currentObject.children = refs.parent.children;
					} else {

						var DataEnder = this._data.lastIndexOf(';', findNext > 0 ? Math.min(findNext, findEnd) : findEnd);
						_currentObject.data = this._data.substr(find1, DataEnder - find1).trim();
						if (findNext <= 0 || findEnd < findNext) {

							endRead = findEnd + 1;
						} else {

							var nextStart = Math.max(DataEnder + 1, find1);
							var _refs = this._hierarchieParse(_currentObject, nextStart);
							endRead = _refs.end;
							_currentObject.children = _refs.parent.children;
						}
					}
					_currentObject.parent = _parent;
					if (_currentObject.type != "template") {

						_parent.children.push(_currentObject);
					}
				} else {

					endRead = find1 === -1 ? this._data.length : findEnd + 1;
					break;
				}
			}
			return {
				parent: _parent,
				end: endRead
			};
		}
	}, {
		key: 'mainloop',
		value: function mainloop() {

			var _this2 = this;

			this.mainProc();
			if (this._currentObject.parent || this._currentObject.children.length > 0 || !this._currentObject.worked) {

				setTimeout(function () {

					_this2.mainloop();
				}, 1);
			} else {

				setTimeout(function () {

					_this2.onLoad({
						models: _this2.Meshes,
						animations: _this2.animations
					});
				}, 1);
			}
		}
	}, {
		key: 'mainProc',
		value: function mainProc() {

			var breakFlag = false;
			while (true) {

				if (!this._currentObject.worked) {

					switch (this._currentObject.type) {

						case "template":
							break;
						case "AnimTicksPerSecond":
							this.animTicksPerSecond = parseInt(this._currentObject.data);
							break;
						case "Frame":
							this._setFrame();
							break;
						case "FrameTransformMatrix":
							this._setFrameTransformMatrix();
							break;
						case "Mesh":
							this._changeRoot();
							this._currentGeo = {};
							this._currentGeo.name = this._currentObject.name.trim();
							this._currentGeo.parentName = this._getParentName(this._currentObject).trim();
							this._currentGeo.VertexSetedBoneCount = [];
							this._currentGeo.Geometry = new THREE.Geometry();
							this._currentGeo.Materials = [];
							this._currentGeo.normalVectors = [];
							this._currentGeo.BoneInfs = [];
							this._currentGeo.baseFrame = this._currentFrame;
							this._makeBoneFrom_CurrentFrame();
							this._readVertexDatas();
							breakFlag = true;
							break;
						case "MeshNormals":
							this._readVertexDatas();
							break;
						case "MeshTextureCoords":
							this._setMeshTextureCoords();
							break;
						case "VertexDuplicationIndices":
							break;
						case "MeshMaterialList":
							this._setMeshMaterialList();
							break;
						case "Material":
							this._setMaterial();
							break;
						case "SkinWeights":
							this._setSkinWeights();
							break;
						case "AnimationSet":
							this._changeRoot();
							this._currentAnime = {};
							this._currentAnime.name = this._currentObject.name.trim();
							this._currentAnime.AnimeFrames = [];
							break;
						case "Animation":
							if (this._currentAnimeFrames) {

								this._currentAnime.AnimeFrames.push(this._currentAnimeFrames);
							}
							this._currentAnimeFrames = new XAnimationInfo();
							this._currentAnimeFrames.boneName = this._currentObject.data.trim();
							break;
						case "AnimationKey":
							this._readAnimationKey();
							breakFlag = true;
							break;

					}
					this._currentObject.worked = true;
				}
				if (this._currentObject.children.length > 0) {

					this._currentObject = this._currentObject.children.shift();
					if (this.debug) {

						console.log('processing ' + this._currentObject.name);
					}
					if (breakFlag) break;
				} else {

					if (this._currentObject.worked) {

						if (this._currentObject.parent && !this._currentObject.parent.parent) {

							this._changeRoot();
						}
					}
					if (this._currentObject.parent) {

						this._currentObject = this._currentObject.parent;
					} else {

						breakFlag = true;
					}
					if (breakFlag) break;
				}
			}
			return;
		}
	}, {
		key: '_changeRoot',
		value: function _changeRoot() {

			if (this._currentGeo != null && this._currentGeo.name) {

				this._makeOutputGeometry();
			}
			this._currentGeo = {};
			if (this._currentAnime != null && this._currentAnime.name) {

				if (this._currentAnimeFrames) {

					this._currentAnime.AnimeFrames.push(this._currentAnimeFrames);
					this._currentAnimeFrames = null;
				}
				this._makeOutputAnimation();
			}
			this._currentAnime = {};
		}
	}, {
		key: '_getParentName',
		value: function _getParentName(_obj) {

			if (_obj.parent) {

				if (_obj.parent.name) {

					return _obj.parent.name;
				} else {

					return this._getParentName(_obj.parent);
				}
			} else {

				return "";
			}
		}
	}, {
		key: '_setFrame',
		value: function _setFrame() {

			this._nowFrameName = this._currentObject.name.trim();
			this._currentFrame = {};
			this._currentFrame.name = this._nowFrameName;
			this._currentFrame.children = [];
			if (this._currentObject.parent && this._currentObject.parent.name) {

				this._currentFrame.parentName = this._currentObject.parent.name;
			}
			this.frameHierarchie.push(this._nowFrameName);
			this.HieStack[this._nowFrameName] = this._currentFrame;
		}
	}, {
		key: '_setFrameTransformMatrix',
		value: function _setFrameTransformMatrix() {

			this._currentFrame.FrameTransformMatrix = new THREE.Matrix4();
			var data = this._currentObject.data.split(",");
			this._ParseMatrixData(this._currentFrame.FrameTransformMatrix, data);
			this._makeBoneFrom_CurrentFrame();
		}
	}, {
		key: '_makeBoneFrom_CurrentFrame',
		value: function _makeBoneFrom_CurrentFrame() {

			if (!this._currentFrame.FrameTransformMatrix) {

				return;
			}
			var b = new THREE.Bone();
			b.name = this._currentFrame.name;
			b.applyMatrix(this._currentFrame.FrameTransformMatrix);
			b.matrixWorld = b.matrix;
			b.FrameTransformMatrix = this._currentFrame.FrameTransformMatrix;
			this._currentFrame.putBone = b;
			if (this._currentFrame.parentName) {

				for (var frame in this.HieStack) {

					if (this.HieStack[frame].name === this._currentFrame.parentName) {

						this.HieStack[frame].putBone.add(this._currentFrame.putBone);
					}
				}
			}
		}
	}, {
		key: '_readVertexDatas',
		value: function _readVertexDatas() {

			var endRead = 0;
			var mode = 0;
			var mode_local = 0;
			var maxLength = 0;
			var nowReadedLine = 0;
			while (true) {

				var changeMode = false;
				if (mode_local === 0) {

					var refO = this._readInt1(endRead);
					endRead = refO.endRead;
					mode_local = 1;
					nowReadedLine = 0;
					maxLength = this._currentObject.data.indexOf(';;', endRead) + 1;
					if (maxLength <= 0) {

						maxLength = this._currentObject.data.length;
					}
				} else {

					var find = 0;
					switch (mode) {

						case 0:
							find = this._currentObject.data.indexOf(',', endRead) + 1;
							break;
						case 1:
							find = this._currentObject.data.indexOf(';,', endRead) + 1;
							break;

					}
					if (find === 0 || find > maxLength) {

						find = maxLength;
						mode_local = 0;
						changeMode = true;
					}
					switch (this._currentObject.type) {

						case "Mesh":
							switch (mode) {

								case 0:
									this._readVertex1(this._currentObject.data.substr(endRead, find - endRead));
									break;
								case 1:
									this._readFace1(this._currentObject.data.substr(endRead, find - endRead));
									break;

							}
							break;
						case "MeshNormals":
							switch (mode) {

								case 0:
									this._readNormalVector1(this._currentObject.data.substr(endRead, find - endRead));
									break;
								case 1:
									this._readNormalFace1(this._currentObject.data.substr(endRead, find - endRead), nowReadedLine);
									break;

							}
							break;

					}
					endRead = find + 1;
					nowReadedLine++;
					if (changeMode) {

						mode++;
					}
				}
				if (endRead >= this._currentObject.data.length) {

					break;
				}
			}
		}
	}, {
		key: '_readInt1',
		value: function _readInt1(start) {

			var find = this._currentObject.data.indexOf(';', start);
			return {
				refI: parseInt(this._currentObject.data.substr(start, find - start)),
				endRead: find + 1
			};
		}
	}, {
		key: '_readVertex1',
		value: function _readVertex1(line) {

			var data = this._readLine(line.trim()).substr(0, line.length - 2).split(";");
			this._currentGeo.Geometry.vertices.push(new THREE.Vector3(parseFloat(data[0]), parseFloat(data[1]), parseFloat(data[2])));
			this._currentGeo.Geometry.skinIndices.push(new THREE.Vector4(0, 0, 0, 0));
			this._currentGeo.Geometry.skinWeights.push(new THREE.Vector4(1, 0, 0, 0));
			this._currentGeo.VertexSetedBoneCount.push(0);
		}
	}, {
		key: '_readFace1',
		value: function _readFace1(line) {

			var data = this._readLine(line.trim()).substr(2, line.length - 4).split(",");
			this._currentGeo.Geometry.faces.push(new THREE.Face3(parseInt(data[0], 10), parseInt(data[1], 10), parseInt(data[2], 10), new THREE.Vector3(1, 1, 1).normalize()));
		}
	}, {
		key: '_readNormalVector1',
		value: function _readNormalVector1(line) {

			var data = this._readLine(line.trim()).substr(0, line.length - 2).split(";");
			this._currentGeo.normalVectors.push(new THREE.Vector3(parseFloat(data[0]), parseFloat(data[1]), parseFloat(data[2])));
		}
	}, {
		key: '_readNormalFace1',
		value: function _readNormalFace1(line, nowReaded) {

			var data = this._readLine(line.trim()).substr(2, line.length - 4).split(",");
			var nowID = parseInt(data[0], 10);
			var v1 = this._currentGeo.normalVectors[nowID];
			nowID = parseInt(data[1], 10);
			var v2 = this._currentGeo.normalVectors[nowID];
			nowID = parseInt(data[2], 10);
			var v3 = this._currentGeo.normalVectors[nowID];
			this._currentGeo.Geometry.faces[nowReaded].vertexNormals = [v1, v2, v3];
		}
	}, {
		key: '_setMeshNormals',
		value: function _setMeshNormals() {

			var endRead = 0;
			var mode = 0;
			var mode_local = 0;
			while (true) {

				switch (mode) {

					case 0:
						if (mode_local === 0) {

							var refO = this._readInt1(0);
							endRead = refO.endRead;
							mode_local = 1;
						} else {

							var find = this._currentObject.data.indexOf(',', endRead) + 1;
							if (find === -1) {

								find = this._currentObject.data.indexOf(';;', endRead) + 1;
								mode = 2;
								mode_local = 0;
							}
							var line = this._currentObject.data.substr(endRead, find - endRead);
							var data = this._readLine(line.trim()).split(";");
							this._currentGeo.normalVectors.push([parseFloat(data[0]), parseFloat(data[1]), parseFloat(data[2])]);
							endRead = find + 1;
						}
						break;

				}
				if (endRead >= this._currentObject.data.length) {

					break;
				}
			}
		}
	}, {
		key: '_setMeshTextureCoords',
		value: function _setMeshTextureCoords() {

			this._tmpUvArray = [];
			this._currentGeo.Geometry.faceVertexUvs = [];
			this._currentGeo.Geometry.faceVertexUvs.push([]);
			var endRead = 0;
			var mode = 0;
			var mode_local = 0;
			while (true) {

				switch (mode) {

					case 0:
						if (mode_local === 0) {

							var refO = this._readInt1(0);
							endRead = refO.endRead;
							mode_local = 1;
						} else {

							var find = this._currentObject.data.indexOf(',', endRead) + 1;
							if (find === 0) {

								find = this._currentObject.data.length;
								mode = 2;
								mode_local = 0;
							}
							var line = this._currentObject.data.substr(endRead, find - endRead);
							var data = this._readLine(line.trim()).split(";");
							if (this.IsUvYReverse) {

								this._tmpUvArray.push(new THREE.Vector2(parseFloat(data[0]), 1 - parseFloat(data[1])));
							} else {

								this._tmpUvArray.push(new THREE.Vector2(parseFloat(data[0]), parseFloat(data[1])));
							}
							endRead = find + 1;
						}
						break;

				}
				if (endRead >= this._currentObject.data.length) {

					break;
				}
			}
			this._currentGeo.Geometry.faceVertexUvs[0] = [];
			for (var m = 0; m < this._currentGeo.Geometry.faces.length; m++) {

				this._currentGeo.Geometry.faceVertexUvs[0][m] = [];
				this._currentGeo.Geometry.faceVertexUvs[0][m].push(this._tmpUvArray[this._currentGeo.Geometry.faces[m].a]);
				this._currentGeo.Geometry.faceVertexUvs[0][m].push(this._tmpUvArray[this._currentGeo.Geometry.faces[m].b]);
				this._currentGeo.Geometry.faceVertexUvs[0][m].push(this._tmpUvArray[this._currentGeo.Geometry.faces[m].c]);
			}
			this._currentGeo.Geometry.uvsNeedUpdate = true;
		}
	}, {
		key: '_setMeshMaterialList',
		value: function _setMeshMaterialList() {

			var endRead = 0;
			var mode = 0;
			var mode_local = 0;
			while (true) {

				if (mode_local < 2) {

					var refO = this._readInt1(endRead);
					endRead = refO.endRead;
					mode_local++;
				} else {

					var find = this._currentObject.data.indexOf(';', endRead);
					if (find === -1) {

						find = this._currentObject.data.length;
						mode = 3;
						mode_local = 0;
					}
					var line = this._currentObject.data.substr(endRead, find - endRead);
					var data = this._readLine(line.trim()).split(",");
					for (var i = 0; i < data.length; i++) {

						this._currentGeo.Geometry.faces[i].materialIndex = parseInt(data[i]);
					}
					endRead = this._currentObject.data.length;
				}
				if (endRead >= this._currentObject.data.length || mode >= 3) {

					break;
				}
			}
		}
	}, {
		key: '_setMaterial',
		value: function _setMaterial() {

			var _nowMat = new THREE.MeshPhongMaterial({
				color: Math.random() * 0xffffff
			});
			_nowMat.side = THREE.FrontSide;
			_nowMat.name = this._currentObject.name;
			var endRead = 0;
			var find = this._currentObject.data.indexOf(';;', endRead);
			var line = this._currentObject.data.substr(endRead, find - endRead);
			var data = this._readLine(line.trim()).split(";");
			_nowMat.color.r = parseFloat(data[0]);
			_nowMat.color.g = parseFloat(data[1]);
			_nowMat.color.b = parseFloat(data[2]);
			endRead = find + 2;
			find = this._currentObject.data.indexOf(';', endRead);
			line = this._currentObject.data.substr(endRead, find - endRead);
			_nowMat.shininess = parseFloat(this._readLine(line));
			endRead = find + 1;
			find = this._currentObject.data.indexOf(';;', endRead);
			line = this._currentObject.data.substr(endRead, find - endRead);
			var data2 = this._readLine(line.trim()).split(";");
			_nowMat.specular.r = parseFloat(data2[0]);
			_nowMat.specular.g = parseFloat(data2[1]);
			_nowMat.specular.b = parseFloat(data2[2]);
			endRead = find + 2;
			find = this._currentObject.data.indexOf(';;', endRead);
			if (find === -1) {

				find = this._currentObject.data.length;
			}
			line = this._currentObject.data.substr(endRead, find - endRead);
			var data3 = this._readLine(line.trim()).split(";");
			_nowMat.emissive.r = parseFloat(data3[0]);
			_nowMat.emissive.g = parseFloat(data3[1]);
			_nowMat.emissive.b = parseFloat(data3[2]);
			var localObject = null;
			while (true) {

				if (this._currentObject.children.length > 0) {

					localObject = this._currentObject.children.shift();
					if (this.debug) {

						console.log('processing ' + localObject.name);
					}
					var fileName = localObject.data.substr(1, localObject.data.length - 2);
					switch (localObject.type) {

						case "TextureFilename":
							_nowMat.map = this.texloader.load(this.baseDir + fileName);
							break;
						case "BumpMapFilename":
							_nowMat.bumpMap = this.texloader.load(this.baseDir + fileName);
							_nowMat.bumpScale = 0.05;
							break;
						case "NormalMapFilename":
							_nowMat.normalMap = this.texloader.load(this.baseDir + fileName);
							_nowMat.normalScale = new THREE.Vector2(2, 2);
							break;
						case "EmissiveMapFilename":
							_nowMat.emissiveMap = this.texloader.load(this.baseDir + fileName);
							break;
						case "LightMapFilename":
							_nowMat.lightMap = this.texloader.load(this.baseDir + fileName);
							break;

					}
				} else {

					break;
				}
			}
			this._currentGeo.Materials.push(_nowMat);
		}
	}, {
		key: '_setSkinWeights',
		value: function _setSkinWeights() {

			var boneInf = new XboneInf();
			var endRead = 0;
			var find = this._currentObject.data.indexOf(';', endRead);
			var line = this._currentObject.data.substr(endRead, find - endRead);
			endRead = find + 1;
			boneInf.boneName = line.substr(1, line.length - 2);
			boneInf.BoneIndex = this._currentGeo.BoneInfs.length;
			find = this._currentObject.data.indexOf(';', endRead);
			endRead = find + 1;
			find = this._currentObject.data.indexOf(';', endRead);
			line = this._currentObject.data.substr(endRead, find - endRead);
			var data = this._readLine(line.trim()).split(",");
			for (var i = 0; i < data.length; i++) {

				boneInf.Indeces.push(parseInt(data[i]));
			}
			endRead = find + 1;
			find = this._currentObject.data.indexOf(';', endRead);
			line = this._currentObject.data.substr(endRead, find - endRead);
			var data2 = this._readLine(line.trim()).split(",");
			for (var _i = 0; _i < data2.length; _i++) {

				boneInf.Weights.push(parseFloat(data2[_i]));
			}
			endRead = find + 1;
			find = this._currentObject.data.indexOf(';', endRead);
			if (find <= 0) {

				find = this._currentObject.data.length;
			}
			line = this._currentObject.data.substr(endRead, find - endRead);
			var data3 = this._readLine(line.trim()).split(",");
			boneInf.OffsetMatrix = new THREE.Matrix4();
			this._ParseMatrixData(boneInf.OffsetMatrix, data3);
			this._currentGeo.BoneInfs.push(boneInf);
		}
	}, {
		key: '_makePutBoneList',
		value: function _makePutBoneList(_RootName, _bones) {

			var putting = false;
			for (var frame in this.HieStack) {

				if (this.HieStack[frame].name === _RootName || putting) {

					putting = true;
					var b = new THREE.Bone();
					b.name = this.HieStack[frame].name;
					b.applyMatrix(this.HieStack[frame].FrameTransformMatrix);
					b.matrixWorld = b.matrix;
					b.FrameTransformMatrix = this.HieStack[frame].FrameTransformMatrix;
					b.pos = new THREE.Vector3().setFromMatrixPosition(b.FrameTransformMatrix).toArray();
					b.rotq = new THREE.Quaternion().setFromRotationMatrix(b.FrameTransformMatrix).toArray();
					b.scl = new THREE.Vector3().setFromMatrixScale(b.FrameTransformMatrix).toArray();
					if (this.HieStack[frame].parentName && this.HieStack[frame].parentName.length > 0) {

						for (var i = 0; i < _bones.length; i++) {

							if (this.HieStack[frame].parentName === _bones[i].name) {

								_bones[i].add(b);
								b.parent = i;
								break;
							}
						}
					}
					_bones.push(b);
				}
			}
		}
	}, {
		key: '_makeOutputGeometry',
		value: function _makeOutputGeometry() {

			this._currentGeo.Geometry.computeBoundingBox();
			this._currentGeo.Geometry.computeBoundingSphere();
			this._currentGeo.Geometry.verticesNeedUpdate = true;
			this._currentGeo.Geometry.normalsNeedUpdate = true;
			this._currentGeo.Geometry.colorsNeedUpdate = true;
			this._currentGeo.Geometry.uvsNeedUpdate = true;
			this._currentGeo.Geometry.groupsNeedUpdate = true;
			var mesh = null;
			if (this._currentGeo.BoneInfs.length > 0) {

				var putBones = [];
				this._makePutBoneList(this._currentGeo.baseFrame.parentName, putBones);
				for (var bi = 0; bi < this._currentGeo.BoneInfs.length; bi++) {

					var boneIndex = 0;
					for (var bb = 0; bb < putBones.length; bb++) {

						if (putBones[bb].name === this._currentGeo.BoneInfs[bi].boneName) {

							boneIndex = bb;
							putBones[bb].OffsetMatrix = new THREE.Matrix4();
							putBones[bb].OffsetMatrix.copy(this._currentGeo.BoneInfs[bi].OffsetMatrix);
							break;
						}
					}
					for (var vi = 0; vi < this._currentGeo.BoneInfs[bi].Indeces.length; vi++) {

						var nowVertexID = this._currentGeo.BoneInfs[bi].Indeces[vi];
						var nowVal = this._currentGeo.BoneInfs[bi].Weights[vi];
						switch (this._currentGeo.VertexSetedBoneCount[nowVertexID]) {

							case 0:
								this._currentGeo.Geometry.skinIndices[nowVertexID].x = boneIndex;
								this._currentGeo.Geometry.skinWeights[nowVertexID].x = nowVal;
								break;
							case 1:
								this._currentGeo.Geometry.skinIndices[nowVertexID].y = boneIndex;
								this._currentGeo.Geometry.skinWeights[nowVertexID].y = nowVal;
								break;
							case 2:
								this._currentGeo.Geometry.skinIndices[nowVertexID].z = boneIndex;
								this._currentGeo.Geometry.skinWeights[nowVertexID].z = nowVal;
								break;
							case 3:
								this._currentGeo.Geometry.skinIndices[nowVertexID].w = boneIndex;
								this._currentGeo.Geometry.skinWeights[nowVertexID].w = nowVal;
								break;

						}
						this._currentGeo.VertexSetedBoneCount[nowVertexID]++;
						if (this._currentGeo.VertexSetedBoneCount[nowVertexID] > 4) {

							console.log('warn! over 4 bone weight! :' + nowVertexID);
						}
					}
				}
				for (var sk = 0; sk < this._currentGeo.Materials.length; sk++) {

					this._currentGeo.Materials[sk].skinning = true;
				}
				var offsetList = [];
				for (var _bi = 0; _bi < putBones.length; _bi++) {

					if (putBones[_bi].OffsetMatrix) {

						offsetList.push(putBones[_bi].OffsetMatrix);
					} else {

						offsetList.push(new THREE.Matrix4());
					}
				}
				var bufferGeometry = new THREE.BufferGeometry().fromGeometry(this._currentGeo.Geometry);
				bufferGeometry.bones = putBones;
				mesh = new THREE.SkinnedMesh(bufferGeometry, this._currentGeo.Materials.length === 1 ? this._currentGeo.Materials[0] : this._currentGeo.Materials);
				mesh.skeleton.boneInverses = offsetList;
			} else {

				var _bufferGeometry = new THREE.BufferGeometry().fromGeometry(this._currentGeo.Geometry);
				mesh = new THREE.Mesh(_bufferGeometry, this._currentGeo.Materials.length === 1 ? this._currentGeo.Materials[0] : this._currentGeo.Materials);
			}
			mesh.name = this._currentGeo.name;
			var worldBaseMx = new THREE.Matrix4();
			var currentMxFrame = this._currentGeo.baseFrame.putBone;
			if (currentMxFrame && currentMxFrame.parent) {

				while (true) {

					currentMxFrame = currentMxFrame.parent;
					if (currentMxFrame) {

						worldBaseMx.multiply(currentMxFrame.FrameTransformMatrix);
					} else {

						break;
					}
				}
				mesh.applyMatrix(worldBaseMx);
			}
			this.Meshes.push(mesh);
		}
	}, {
		key: '_readAnimationKey',
		value: function _readAnimationKey() {

			var endRead = 0;
			var find = this._currentObject.data.indexOf(';', endRead);
			var line = this._currentObject.data.substr(endRead, find - endRead);
			endRead = find + 1;
			var nowKeyType = parseInt(this._readLine(line));
			find = this._currentObject.data.indexOf(';', endRead);
			endRead = find + 1;
			line = this._currentObject.data.substr(endRead);
			var data = this._readLine(line.trim()).split(";;,");
			for (var i = 0; i < data.length; i++) {

				var data2 = data[i].split(";");
				var keyInfo = new XKeyFrameInfo();
				keyInfo.type = nowKeyType;
				keyInfo.Frame = parseInt(data2[0]);
				keyInfo.index = this._currentAnimeFrames.keyFrames.length;
				keyInfo.time = keyInfo.Frame;
				if (nowKeyType != 4) {

					var frameFound = false;
					for (var mm = 0; mm < this._currentAnimeFrames.keyFrames.length; mm++) {

						if (this._currentAnimeFrames.keyFrames[mm].Frame === keyInfo.Frame) {

							keyInfo = this._currentAnimeFrames.keyFrames[mm];
							frameFound = true;
							break;
						}
					}
					var frameValue = data2[2].split(",");
					switch (nowKeyType) {

						case 0:
							keyInfo.rot = new THREE.Quaternion(parseFloat(frameValue[1]), parseFloat(frameValue[2]), parseFloat(frameValue[3]), parseFloat(frameValue[0]) * -1);
							break;
						case 1:
							keyInfo.scl = new THREE.Vector3(parseFloat(frameValue[0]), parseFloat(frameValue[1]), parseFloat(frameValue[2]));
							break;
						case 2:
							keyInfo.pos = new THREE.Vector3(parseFloat(frameValue[0]), parseFloat(frameValue[1]), parseFloat(frameValue[2]));
							break;

					}
					if (!frameFound) {

						this._currentAnimeFrames.keyFrames.push(keyInfo);
					}
				} else {

					keyInfo.matrix = new THREE.Matrix4();
					this._ParseMatrixData(keyInfo.matrix, data2[2].split(","));
					this._currentAnimeFrames.keyFrames.push(keyInfo);
				}
			}
		}
	}, {
		key: '_makeOutputAnimation',
		value: function _makeOutputAnimation() {

			var animationObj = new XAnimationObj(this.options);
			animationObj.fps = this.animTicksPerSecond;
			animationObj.name = this._currentAnime.name;
			animationObj.make(this._currentAnime.AnimeFrames);
			this.animations.push(animationObj);
		}
	}, {
		key: 'assignAnimation',
		value: function assignAnimation(_model, _animation, _isBind) {

			var model = _model;
			var animation = _animation;
			if (!model) {

				model = this.Meshes[0];
			}
			if (!animation) {

				animation = this.animations[0];
			}
			if (!model || !animation) {

				return null;
			}
			var put = {};
			put.fps = animation.fps;
			put.name = animation.name;
			put.length = animation.length;
			put.hierarchy = [];
			for (var b = 0; b < model.skeleton.bones.length; b++) {

				var findAnimation = false;
				for (var i = 0; i < animation.hierarchy.length; i++) {

					if (model.skeleton.bones[b].name === animation.hierarchy[i].name) {

						findAnimation = true;
						var c_key = animation.hierarchy[i].copy();
						c_key.parent = -1;
						if (model.skeleton.bones[b].parent && model.skeleton.bones[b].parent.type === "Bone") {

							for (var bb = 0; bb < put.hierarchy.length; bb++) {

								if (put.hierarchy[bb].name === model.skeleton.bones[b].parent.name) {

									c_key.parent = bb;
									c_key.parentName = model.skeleton.bones[b].parent.name;
								}
							}
						}
						put.hierarchy.push(c_key);
						break;
					}
				}
				if (!findAnimation) {

					var _c_key = animation.hierarchy[0].copy();
					_c_key.name = model.skeleton.bones[b].name;
					_c_key.parent = -1;
					for (var k = 0; k < _c_key.keys.length; k++) {

						if (_c_key.keys[k].pos) {

							_c_key.keys[k].pos.set(0, 0, 0);
						}
						if (_c_key.keys[k].scl) {

							_c_key.keys[k].scl.set(1, 1, 1);
						}
						if (_c_key.keys[k].rot) {

							_c_key.keys[k].rot.set(0, 0, 0, 1);
						}
					}
					put.hierarchy.push(_c_key);
				}
			}
			if (!model.geometry.animations) {

				model.geometry.animations = [];
			}

			model.geometry.animations.push(THREE.AnimationClip.parseAnimation(put, model.skeleton.bones));
			if (!model.animationMixer) {

				model.animationMixer = new THREE.AnimationMixer(model);
			}

			return put;
		}
	}, {
		key: '_ParseMatrixData',
		value: function _ParseMatrixData(targetMatrix, data) {

			targetMatrix.set(parseFloat(data[0]), parseFloat(data[4]), parseFloat(data[8]), parseFloat(data[12]), parseFloat(data[1]), parseFloat(data[5]), parseFloat(data[9]), parseFloat(data[13]), parseFloat(data[2]), parseFloat(data[6]), parseFloat(data[10]), parseFloat(data[14]), parseFloat(data[3]), parseFloat(data[7]), parseFloat(data[11]), parseFloat(data[15]));
		}
	}]);
	return XLoader;
}();

// 	return XLoader;
//
// } ) ) );

exports.default = XLoader;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UnrealBloomPass = exports.TexturePass = exports.TAARenderPass = exports.SSAOPass = exports.SSAARenderPass = exports.SMAAPass = exports.ShaderPass = exports.SavePass = exports.SAOPass = exports.RenderPass = exports.Pass = exports.OutlinePass = exports.MaskPass = exports.HalftonePass = exports.GlitchPass = exports.FilmPass = exports.EffectComposer = exports.DotScreenPass = exports.CubeTexturePass = exports.ClearPass = exports.ClearMaskPass = exports.BokehPass = exports.BloomPass = exports.AdaptiveToneMappingPass = undefined;

var _AdaptiveToneMappingPass = __webpack_require__(91);

var _AdaptiveToneMappingPass2 = _interopRequireDefault(_AdaptiveToneMappingPass);

var _BloomPass = __webpack_require__(92);

var _BloomPass2 = _interopRequireDefault(_BloomPass);

var _BokehPass = __webpack_require__(93);

var _BokehPass2 = _interopRequireDefault(_BokehPass);

var _ClearMaskPass = __webpack_require__(94);

var _ClearMaskPass2 = _interopRequireDefault(_ClearMaskPass);

var _ClearPass = __webpack_require__(95);

var _ClearPass2 = _interopRequireDefault(_ClearPass);

var _CubeTexturePass = __webpack_require__(96);

var _CubeTexturePass2 = _interopRequireDefault(_CubeTexturePass);

var _DotScreenPass = __webpack_require__(97);

var _DotScreenPass2 = _interopRequireDefault(_DotScreenPass);

var _EffectComposer = __webpack_require__(98);

var _EffectComposer2 = _interopRequireDefault(_EffectComposer);

var _FilmPass = __webpack_require__(99);

var _FilmPass2 = _interopRequireDefault(_FilmPass);

var _GlitchPass = __webpack_require__(100);

var _GlitchPass2 = _interopRequireDefault(_GlitchPass);

var _HalftonePass = __webpack_require__(101);

var _HalftonePass2 = _interopRequireDefault(_HalftonePass);

var _MaskPass = __webpack_require__(102);

var _MaskPass2 = _interopRequireDefault(_MaskPass);

var _OutlinePass = __webpack_require__(103);

var _OutlinePass2 = _interopRequireDefault(_OutlinePass);

var _Pass = __webpack_require__(1);

var _Pass2 = _interopRequireDefault(_Pass);

var _RenderPass = __webpack_require__(104);

var _RenderPass2 = _interopRequireDefault(_RenderPass);

var _SAOPass = __webpack_require__(105);

var _SAOPass2 = _interopRequireDefault(_SAOPass);

var _SavePass = __webpack_require__(106);

var _SavePass2 = _interopRequireDefault(_SavePass);

var _ShaderPass = __webpack_require__(3);

var _ShaderPass2 = _interopRequireDefault(_ShaderPass);

var _SMAAPass = __webpack_require__(107);

var _SMAAPass2 = _interopRequireDefault(_SMAAPass);

var _SSAARenderPass = __webpack_require__(24);

var _SSAARenderPass2 = _interopRequireDefault(_SSAARenderPass);

var _SSAOPass = __webpack_require__(108);

var _SSAOPass2 = _interopRequireDefault(_SSAOPass);

var _TAARenderPass = __webpack_require__(109);

var _TAARenderPass2 = _interopRequireDefault(_TAARenderPass);

var _TexturePass = __webpack_require__(110);

var _TexturePass2 = _interopRequireDefault(_TexturePass);

var _UnrealBloomPass = __webpack_require__(111);

var _UnrealBloomPass2 = _interopRequireDefault(_UnrealBloomPass);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.AdaptiveToneMappingPass = _AdaptiveToneMappingPass2.default;
exports.BloomPass = _BloomPass2.default;
exports.BokehPass = _BokehPass2.default;
exports.ClearMaskPass = _ClearMaskPass2.default;
exports.ClearPass = _ClearPass2.default;
exports.CubeTexturePass = _CubeTexturePass2.default;
exports.DotScreenPass = _DotScreenPass2.default;
exports.EffectComposer = _EffectComposer2.default;
exports.FilmPass = _FilmPass2.default;
exports.GlitchPass = _GlitchPass2.default;
exports.HalftonePass = _HalftonePass2.default;
exports.MaskPass = _MaskPass2.default;
exports.OutlinePass = _OutlinePass2.default;
exports.Pass = _Pass2.default;
exports.RenderPass = _RenderPass2.default;
exports.SAOPass = _SAOPass2.default;
exports.SavePass = _SavePass2.default;
exports.ShaderPass = _ShaderPass2.default;
exports.SMAAPass = _SMAAPass2.default;
exports.SSAARenderPass = _SSAARenderPass2.default;
exports.SSAOPass = _SSAOPass2.default;
exports.TAARenderPass = _TAARenderPass2.default;
exports.TexturePass = _TexturePass2.default;
exports.UnrealBloomPass = _UnrealBloomPass2.default;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _Pass = __webpack_require__(1);

var _Pass2 = _interopRequireDefault(_Pass);

var _CopyShader = __webpack_require__(2);

var _CopyShader2 = _interopRequireDefault(_CopyShader);

var _LuminosityShader = __webpack_require__(11);

var _LuminosityShader2 = _interopRequireDefault(_LuminosityShader);

var _ToneMapShader = __webpack_require__(12);

var _ToneMapShader2 = _interopRequireDefault(_ToneMapShader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author miibond
 * Generate a texture that represents the luminosity of the current scene, adapted over time
 * to simulate the optic nerve responding to the amount of light it is receiving.
 * Based on a GDC2007 presentation by Wolfgang Engel titled "Post-Processing Pipeline"
 *
 * Full-screen tone-mapping shader based on http://www.graphics.cornell.edu/~jaf/publications/sig02_paper.pdf
 */

var AdaptiveToneMappingPass = function AdaptiveToneMappingPass(adaptive, resolution) {

	_Pass2.default.call(this);

	this.resolution = resolution !== undefined ? resolution : 256;
	this.needsInit = true;
	this.adaptive = adaptive !== undefined ? !!adaptive : true;

	this.luminanceRT = null;
	this.previousLuminanceRT = null;
	this.currentLuminanceRT = null;

	if (_CopyShader2.default === undefined) console.error("THREE.AdaptiveToneMappingPass relies on THREE.CopyShader");

	var copyShader = _CopyShader2.default;

	this.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);

	this.materialCopy = new THREE.ShaderMaterial({

		uniforms: this.copyUniforms,
		vertexShader: copyShader.vertexShader,
		fragmentShader: copyShader.fragmentShader,
		blending: THREE.NoBlending,
		depthTest: false

	});

	if (_LuminosityShader2.default === undefined) console.error("THREE.AdaptiveToneMappingPass relies on THREE.LuminosityShader");

	this.materialLuminance = new THREE.ShaderMaterial({

		uniforms: THREE.UniformsUtils.clone(_LuminosityShader2.default.uniforms),
		vertexShader: _LuminosityShader2.default.vertexShader,
		fragmentShader: _LuminosityShader2.default.fragmentShader,
		blending: THREE.NoBlending
	});

	this.adaptLuminanceShader = {
		defines: {
			"MIP_LEVEL_1X1": (Math.log(this.resolution) / Math.log(2.0)).toFixed(1)
		},
		uniforms: {
			"lastLum": { value: null },
			"currentLum": { value: null },
			"minLuminance": { value: 0.01 },
			"delta": { value: 0.016 },
			"tau": { value: 1.0 }
		},
		vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join('\n'),
		fragmentShader: ["varying vec2 vUv;", "uniform sampler2D lastLum;", "uniform sampler2D currentLum;", "uniform float minLuminance;", "uniform float delta;", "uniform float tau;", "void main() {", "vec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );", "vec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );", "float fLastLum = max( minLuminance, lastLum.r );", "float fCurrentLum = max( minLuminance, currentLum.r );",

		//The adaption seems to work better in extreme lighting differences
		//if the input luminance is squared.
		"fCurrentLum *= fCurrentLum;",

		// Adapt the luminance using Pattanaik's technique
		"float fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));",
		// "fAdaptedLum = sqrt(fAdaptedLum);",
		"gl_FragColor.r = fAdaptedLum;", "}"].join('\n')
	};

	this.materialAdaptiveLum = new THREE.ShaderMaterial({

		uniforms: THREE.UniformsUtils.clone(this.adaptLuminanceShader.uniforms),
		vertexShader: this.adaptLuminanceShader.vertexShader,
		fragmentShader: this.adaptLuminanceShader.fragmentShader,
		defines: Object.assign({}, this.adaptLuminanceShader.defines),
		blending: THREE.NoBlending
	});

	if (_ToneMapShader2.default === undefined) console.error("THREE.AdaptiveToneMappingPass relies on THREE.ToneMapShader");

	this.materialToneMap = new THREE.ShaderMaterial({

		uniforms: THREE.UniformsUtils.clone(_ToneMapShader2.default.uniforms),
		vertexShader: _ToneMapShader2.default.vertexShader,
		fragmentShader: _ToneMapShader2.default.fragmentShader,
		blending: THREE.NoBlending
	});

	this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
	this.scene = new THREE.Scene();

	this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
	this.quad.frustumCulled = false; // Avoid getting clipped
	this.scene.add(this.quad);
};

AdaptiveToneMappingPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {

	constructor: AdaptiveToneMappingPass,

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		if (this.needsInit) {

			this.reset(renderer);

			this.luminanceRT.texture.type = readBuffer.texture.type;
			this.previousLuminanceRT.texture.type = readBuffer.texture.type;
			this.currentLuminanceRT.texture.type = readBuffer.texture.type;
			this.needsInit = false;
		}

		if (this.adaptive) {

			//Render the luminance of the current scene into a render target with mipmapping enabled
			this.quad.material = this.materialLuminance;
			this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;
			renderer.render(this.scene, this.camera, this.currentLuminanceRT);

			//Use the new luminance values, the previous luminance and the frame delta to
			//adapt the luminance over time.
			this.quad.material = this.materialAdaptiveLum;
			this.materialAdaptiveLum.uniforms.delta.value = delta;
			this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;
			this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;
			renderer.render(this.scene, this.camera, this.luminanceRT);

			//Copy the new adapted luminance value so that it can be used by the next frame.
			this.quad.material = this.materialCopy;
			this.copyUniforms.tDiffuse.value = this.luminanceRT.texture;
			renderer.render(this.scene, this.camera, this.previousLuminanceRT);
		}

		this.quad.material = this.materialToneMap;
		this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;

		if (this.renderToScreen) {

			renderer.render(this.scene, this.camera);
		} else {

			renderer.render(this.scene, this.camera, writeBuffer, this.clear);
		}
	},

	reset: function reset(renderer) {

		// render targets
		if (this.luminanceRT) {

			this.luminanceRT.dispose();
		}
		if (this.currentLuminanceRT) {

			this.currentLuminanceRT.dispose();
		}
		if (this.previousLuminanceRT) {

			this.previousLuminanceRT.dispose();
		}

		var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat }; // was RGB format. changed to RGBA format. see discussion in #8415 / #8450

		this.luminanceRT = new THREE.WebGLRenderTarget(this.resolution, this.resolution, pars);
		this.luminanceRT.texture.name = "AdaptiveToneMappingPass.l";
		this.luminanceRT.texture.generateMipmaps = false;

		this.previousLuminanceRT = new THREE.WebGLRenderTarget(this.resolution, this.resolution, pars);
		this.previousLuminanceRT.texture.name = "AdaptiveToneMappingPass.pl";
		this.previousLuminanceRT.texture.generateMipmaps = false;

		// We only need mipmapping for the current luminosity because we want a down-sampled version to sample in our adaptive shader
		pars.minFilter = THREE.LinearMipMapLinearFilter;
		this.currentLuminanceRT = new THREE.WebGLRenderTarget(this.resolution, this.resolution, pars);
		this.currentLuminanceRT.texture.name = "AdaptiveToneMappingPass.cl";

		if (this.adaptive) {

			this.materialToneMap.defines["ADAPTED_LUMINANCE"] = "";
			this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;
		}
		//Put something in the adaptive luminance texture so that the scene can render initially
		this.quad.material = new THREE.MeshBasicMaterial({ color: 0x777777 });
		this.materialLuminance.needsUpdate = true;
		this.materialAdaptiveLum.needsUpdate = true;
		this.materialToneMap.needsUpdate = true;
		// renderer.render( this.scene, this.camera, this.luminanceRT );
		// renderer.render( this.scene, this.camera, this.previousLuminanceRT );
		// renderer.render( this.scene, this.camera, this.currentLuminanceRT );
	},

	setAdaptive: function setAdaptive(adaptive) {

		if (adaptive) {

			this.adaptive = true;
			this.materialToneMap.defines["ADAPTED_LUMINANCE"] = "";
			this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;
		} else {

			this.adaptive = false;
			delete this.materialToneMap.defines["ADAPTED_LUMINANCE"];
			this.materialToneMap.uniforms.luminanceMap.value = null;
		}
		this.materialToneMap.needsUpdate = true;
	},

	setAdaptionRate: function setAdaptionRate(rate) {

		if (rate) {

			this.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate);
		}
	},

	setMinLuminance: function setMinLuminance(minLum) {

		if (minLum) {

			this.materialToneMap.uniforms.minLuminance.value = minLum;
			this.materialAdaptiveLum.uniforms.minLuminance.value = minLum;
		}
	},

	setMaxLuminance: function setMaxLuminance(maxLum) {

		if (maxLum) {

			this.materialToneMap.uniforms.maxLuminance.value = maxLum;
		}
	},

	setAverageLuminance: function setAverageLuminance(avgLum) {

		if (avgLum) {

			this.materialToneMap.uniforms.averageLuminance.value = avgLum;
		}
	},

	setMiddleGrey: function setMiddleGrey(middleGrey) {

		if (middleGrey) {

			this.materialToneMap.uniforms.middleGrey.value = middleGrey;
		}
	},

	dispose: function dispose() {

		if (this.luminanceRT) {

			this.luminanceRT.dispose();
		}
		if (this.previousLuminanceRT) {

			this.previousLuminanceRT.dispose();
		}
		if (this.currentLuminanceRT) {

			this.currentLuminanceRT.dispose();
		}
		if (this.materialLuminance) {

			this.materialLuminance.dispose();
		}
		if (this.materialAdaptiveLum) {

			this.materialAdaptiveLum.dispose();
		}
		if (this.materialCopy) {

			this.materialCopy.dispose();
		}
		if (this.materialToneMap) {

			this.materialToneMap.dispose();
		}
	}

});

exports.default = AdaptiveToneMappingPass;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _Pass = __webpack_require__(1);

var _Pass2 = _interopRequireDefault(_Pass);

var _CopyShader = __webpack_require__(2);

var _CopyShader2 = _interopRequireDefault(_CopyShader);

var _ConvolutionShader = __webpack_require__(13);

var _ConvolutionShader2 = _interopRequireDefault(_ConvolutionShader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author alteredq / http://alteredqualia.com/
 */

var BloomPass = function BloomPass(strength, kernelSize, sigma, resolution) {

	_Pass2.default.call(this);

	strength = strength !== undefined ? strength : 1;
	kernelSize = kernelSize !== undefined ? kernelSize : 25;
	sigma = sigma !== undefined ? sigma : 4.0;
	resolution = resolution !== undefined ? resolution : 256;

	// render targets

	var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };

	this.renderTargetX = new THREE.WebGLRenderTarget(resolution, resolution, pars);
	this.renderTargetX.texture.name = "BloomPass.x";
	this.renderTargetY = new THREE.WebGLRenderTarget(resolution, resolution, pars);
	this.renderTargetY.texture.name = "BloomPass.y";

	// copy material

	if (_CopyShader2.default === undefined) console.error("THREE.BloomPass relies on THREE.CopyShader");

	var copyShader = _CopyShader2.default;

	this.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);

	this.copyUniforms["opacity"].value = strength;

	this.materialCopy = new THREE.ShaderMaterial({

		uniforms: this.copyUniforms,
		vertexShader: copyShader.vertexShader,
		fragmentShader: copyShader.fragmentShader,
		blending: THREE.AdditiveBlending,
		transparent: true

	});

	// convolution material

	if (_ConvolutionShader2.default === undefined) console.error("THREE.BloomPass relies on THREE.ConvolutionShader");

	var convolutionShader = _ConvolutionShader2.default;

	this.convolutionUniforms = THREE.UniformsUtils.clone(convolutionShader.uniforms);

	this.convolutionUniforms["uImageIncrement"].value = BloomPass.blurX;
	this.convolutionUniforms["cKernel"].value = _ConvolutionShader2.default.buildKernel(sigma);

	this.materialConvolution = new THREE.ShaderMaterial({

		uniforms: this.convolutionUniforms,
		vertexShader: convolutionShader.vertexShader,
		fragmentShader: convolutionShader.fragmentShader,
		defines: {
			"KERNEL_SIZE_FLOAT": kernelSize.toFixed(1),
			"KERNEL_SIZE_INT": kernelSize.toFixed(0)
		}

	});

	this.needsSwap = false;

	this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
	this.scene = new THREE.Scene();

	this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
	this.quad.frustumCulled = false; // Avoid getting clipped
	this.scene.add(this.quad);
};

BloomPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {

	constructor: BloomPass,

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		if (maskActive) renderer.context.disable(renderer.context.STENCIL_TEST);

		// Render quad with blured scene into texture (convolution pass 1)

		this.quad.material = this.materialConvolution;

		this.convolutionUniforms["tDiffuse"].value = readBuffer.texture;
		this.convolutionUniforms["uImageIncrement"].value = BloomPass.blurX;

		renderer.render(this.scene, this.camera, this.renderTargetX, true);

		// Render quad with blured scene into texture (convolution pass 2)

		this.convolutionUniforms["tDiffuse"].value = this.renderTargetX.texture;
		this.convolutionUniforms["uImageIncrement"].value = BloomPass.blurY;

		renderer.render(this.scene, this.camera, this.renderTargetY, true);

		// Render original scene with superimposed blur to texture

		this.quad.material = this.materialCopy;

		this.copyUniforms["tDiffuse"].value = this.renderTargetY.texture;

		if (maskActive) renderer.context.enable(renderer.context.STENCIL_TEST);

		renderer.render(this.scene, this.camera, readBuffer, this.clear);
	}

});

BloomPass.blurX = new THREE.Vector2(0.001953125, 0.0);
BloomPass.blurY = new THREE.Vector2(0.0, 0.001953125);

exports.default = BloomPass;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _global = __webpack_require__(8);

var _global2 = _interopRequireDefault(_global);

var _Pass = __webpack_require__(1);

var _Pass2 = _interopRequireDefault(_Pass);

var _BokehShader = __webpack_require__(14);

var _BokehShader2 = _interopRequireDefault(_BokehShader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var window = _global2.default;

/**
 * Depth-of-field post-process with bokeh shader
 */

var BokehPass = function BokehPass(scene, camera, params) {

	_Pass2.default.call(this);

	this.scene = scene;
	this.camera = camera;

	var focus = params.focus !== undefined ? params.focus : 1.0;
	var aspect = params.aspect !== undefined ? params.aspect : camera.aspect;
	var aperture = params.aperture !== undefined ? params.aperture : 0.025;
	var maxblur = params.maxblur !== undefined ? params.maxblur : 1.0;

	// render targets

	var width = params.width || window.innerWidth || 1;
	var height = params.height || window.innerHeight || 1;

	this.renderTargetColor = new THREE.WebGLRenderTarget(width, height, {
		minFilter: THREE.LinearFilter,
		magFilter: THREE.LinearFilter,
		format: THREE.RGBFormat
	});
	this.renderTargetColor.texture.name = "BokehPass.color";

	this.renderTargetDepth = this.renderTargetColor.clone();
	this.renderTargetDepth.texture.name = "BokehPass.depth";

	// depth material

	this.materialDepth = new THREE.MeshDepthMaterial();
	this.materialDepth.depthPacking = THREE.RGBADepthPacking;
	this.materialDepth.blending = THREE.NoBlending;

	// bokeh material

	if (_BokehShader2.default === undefined) {

		console.error("THREE.BokehPass relies on THREE.BokehShader");
	}

	var bokehShader = _BokehShader2.default;
	var bokehUniforms = THREE.UniformsUtils.clone(bokehShader.uniforms);

	bokehUniforms["tDepth"].value = this.renderTargetDepth.texture;

	bokehUniforms["focus"].value = focus;
	bokehUniforms["aspect"].value = aspect;
	bokehUniforms["aperture"].value = aperture;
	bokehUniforms["maxblur"].value = maxblur;
	bokehUniforms["nearClip"].value = camera.near;
	bokehUniforms["farClip"].value = camera.far;

	this.materialBokeh = new THREE.ShaderMaterial({
		defines: Object.assign({}, bokehShader.defines),
		uniforms: bokehUniforms,
		vertexShader: bokehShader.vertexShader,
		fragmentShader: bokehShader.fragmentShader
	});

	this.uniforms = bokehUniforms;
	this.needsSwap = false;

	this.camera2 = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
	this.scene2 = new THREE.Scene();

	this.quad2 = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
	this.quad2.frustumCulled = false; // Avoid getting clipped
	this.scene2.add(this.quad2);

	this.oldClearColor = new THREE.Color();
	this.oldClearAlpha = 1;
};

BokehPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {

	constructor: BokehPass,

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		this.quad2.material = this.materialBokeh;

		// Render depth into texture

		this.scene.overrideMaterial = this.materialDepth;

		this.oldClearColor.copy(renderer.getClearColor());
		this.oldClearAlpha = renderer.getClearAlpha();
		var oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		renderer.setClearColor(0xffffff);
		renderer.setClearAlpha(1.0);
		renderer.render(this.scene, this.camera, this.renderTargetDepth, true);

		// Render bokeh composite

		this.uniforms["tColor"].value = readBuffer.texture;
		this.uniforms["nearClip"].value = this.camera.near;
		this.uniforms["farClip"].value = this.camera.far;

		if (this.renderToScreen) {

			renderer.render(this.scene2, this.camera2);
		} else {

			renderer.render(this.scene2, this.camera2, writeBuffer, this.clear);
		}

		this.scene.overrideMaterial = null;
		renderer.setClearColor(this.oldClearColor);
		renderer.setClearAlpha(this.oldClearAlpha);
		renderer.autoClear = this.oldAutoClear;
	}

});

exports.default = BokehPass;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Pass = __webpack_require__(1);

var _Pass2 = _interopRequireDefault(_Pass);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @author alteredq / http://alteredqualia.com/
 */

var ClearMaskPass = function ClearMaskPass() {

	_Pass2.default.call(this);

	this.needsSwap = false;
};

ClearMaskPass.prototype = Object.create(_Pass2.default.prototype);

Object.assign(ClearMaskPass.prototype, {

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		renderer.state.buffers.stencil.setTest(false);
	}

});

exports.default = ClearMaskPass;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Pass = __webpack_require__(1);

var _Pass2 = _interopRequireDefault(_Pass);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @author mrdoob / http://mrdoob.com/
 */

var ClearPass = function ClearPass(clearColor, clearAlpha) {

	_Pass2.default.call(this);

	this.needsSwap = false;

	this.clearColor = clearColor !== undefined ? clearColor : 0x000000;
	this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;
};

ClearPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {

	constructor: ClearPass,

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		var oldClearColor, oldClearAlpha;

		if (this.clearColor) {

			oldClearColor = renderer.getClearColor().getHex();
			oldClearAlpha = renderer.getClearAlpha();

			renderer.setClearColor(this.clearColor, this.clearAlpha);
		}

		renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
		renderer.clear();

		if (this.clearColor) {

			renderer.setClearColor(oldClearColor, oldClearAlpha);
		}
	}

});

exports.default = ClearPass;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _Pass = __webpack_require__(1);

var _Pass2 = _interopRequireDefault(_Pass);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author bhouston / http://clara.io/
 */

var CubeTexturePass = function CubeTexturePass(camera, envMap, opacity) {

	_Pass2.default.call(this);

	this.camera = camera;

	this.needsSwap = false;

	this.cubeShader = THREE.ShaderLib['cube'];
	this.cubeMesh = new THREE.Mesh(new THREE.BoxBufferGeometry(10, 10, 10), new THREE.ShaderMaterial({
		uniforms: this.cubeShader.uniforms,
		vertexShader: this.cubeShader.vertexShader,
		fragmentShader: this.cubeShader.fragmentShader,
		depthTest: false,
		depthWrite: false,
		side: THREE.BackSide
	}));

	this.envMap = envMap;
	this.opacity = opacity !== undefined ? opacity : 1.0;

	this.cubeScene = new THREE.Scene();
	this.cubeCamera = new THREE.PerspectiveCamera();
	this.cubeScene.add(this.cubeMesh);
};

CubeTexturePass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {

	constructor: CubeTexturePass,

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		var oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		this.cubeCamera.projectionMatrix.copy(this.camera.projectionMatrix);
		this.cubeCamera.quaternion.setFromRotationMatrix(this.camera.matrixWorld);

		this.cubeMesh.material.uniforms["tCube"].value = this.envMap;
		this.cubeMesh.material.uniforms["opacity"].value = this.opacity;
		this.cubeMesh.material.transparent = this.opacity < 1.0;

		renderer.render(this.cubeScene, this.cubeCamera, this.renderToScreen ? null : readBuffer, this.clear);

		renderer.autoClear = oldAutoClear;
	}

});

exports.default = CubeTexturePass;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _Pass = __webpack_require__(1);

var _Pass2 = _interopRequireDefault(_Pass);

var _DotScreenShader = __webpack_require__(15);

var _DotScreenShader2 = _interopRequireDefault(_DotScreenShader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author alteredq / http://alteredqualia.com/
 */

var DotScreenPass = function DotScreenPass(center, angle, scale) {

	_Pass2.default.call(this);

	if (_DotScreenShader2.default === undefined) console.error("THREE.DotScreenPass relies on THREE.DotScreenShader");

	var shader = _DotScreenShader2.default;

	this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);

	if (center !== undefined) this.uniforms["center"].value.copy(center);
	if (angle !== undefined) this.uniforms["angle"].value = angle;
	if (scale !== undefined) this.uniforms["scale"].value = scale;

	this.material = new THREE.ShaderMaterial({

		uniforms: this.uniforms,
		vertexShader: shader.vertexShader,
		fragmentShader: shader.fragmentShader

	});

	this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
	this.scene = new THREE.Scene();

	this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
	this.quad.frustumCulled = false; // Avoid getting clipped
	this.scene.add(this.quad);
};

DotScreenPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {

	constructor: DotScreenPass,

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		this.uniforms["tDiffuse"].value = readBuffer.texture;
		this.uniforms["tSize"].value.set(readBuffer.width, readBuffer.height);

		this.quad.material = this.material;

		if (this.renderToScreen) {

			renderer.render(this.scene, this.camera);
		} else {

			renderer.render(this.scene, this.camera, writeBuffer, this.clear);
		}
	}

});

exports.default = DotScreenPass;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _CopyShader = __webpack_require__(2);

var _CopyShader2 = _interopRequireDefault(_CopyShader);

var _ShaderPass = __webpack_require__(3);

var _ShaderPass2 = _interopRequireDefault(_ShaderPass);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author alteredq / http://alteredqualia.com/
 */

var EffectComposer = function EffectComposer(renderer, renderTarget) {

	this.renderer = renderer;

	if (renderTarget === undefined) {

		var parameters = {
			minFilter: THREE.LinearFilter,
			magFilter: THREE.LinearFilter,
			format: THREE.RGBAFormat,
			stencilBuffer: false
		};

		var size = renderer.getDrawingBufferSize();
		renderTarget = new THREE.WebGLRenderTarget(size.width, size.height, parameters);
		renderTarget.texture.name = 'EffectComposer.rt1';
	}

	this.renderTarget1 = renderTarget;
	this.renderTarget2 = renderTarget.clone();
	this.renderTarget2.texture.name = 'EffectComposer.rt2';

	this.writeBuffer = this.renderTarget1;
	this.readBuffer = this.renderTarget2;

	this.passes = [];

	// dependencies

	if (_CopyShader2.default === undefined) {

		console.error('THREE.EffectComposer relies on THREE.CopyShader');
	}

	if (_ShaderPass2.default === undefined) {

		console.error('THREE.EffectComposer relies on THREE.ShaderPass');
	}

	this.copyPass = new _ShaderPass2.default(_CopyShader2.default);
};

Object.assign(EffectComposer.prototype, {

	swapBuffers: function swapBuffers() {

		var tmp = this.readBuffer;
		this.readBuffer = this.writeBuffer;
		this.writeBuffer = tmp;
	},

	addPass: function addPass(pass) {

		this.passes.push(pass);

		var size = this.renderer.getDrawingBufferSize();
		pass.setSize(size.width, size.height);
	},

	insertPass: function insertPass(pass, index) {

		this.passes.splice(index, 0, pass);
	},

	render: function render(delta) {

		var maskActive = false;

		var pass,
		    i,
		    il = this.passes.length;

		for (i = 0; i < il; i++) {

			pass = this.passes[i];

			if (pass.enabled === false) continue;

			pass.render(this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive);

			if (pass.needsSwap) {

				if (maskActive) {

					var context = this.renderer.context;

					context.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);

					this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, delta);

					context.stencilFunc(context.EQUAL, 1, 0xffffffff);
				}

				this.swapBuffers();
			}

			if (THREE.MaskPass !== undefined) {

				if (pass instanceof THREE.MaskPass) {

					maskActive = true;
				} else if (pass instanceof THREE.ClearMaskPass) {

					maskActive = false;
				}
			}
		}
	},

	reset: function reset(renderTarget) {

		if (renderTarget === undefined) {

			var size = this.renderer.getDrawingBufferSize();

			renderTarget = this.renderTarget1.clone();
			renderTarget.setSize(size.width, size.height);
		}

		this.renderTarget1.dispose();
		this.renderTarget2.dispose();
		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;
	},

	setSize: function setSize(width, height) {

		this.renderTarget1.setSize(width, height);
		this.renderTarget2.setSize(width, height);

		for (var i = 0; i < this.passes.length; i++) {

			this.passes[i].setSize(width, height);
		}
	}

});

exports.default = EffectComposer;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _Pass = __webpack_require__(1);

var _Pass2 = _interopRequireDefault(_Pass);

var _FilmShader = __webpack_require__(16);

var _FilmShader2 = _interopRequireDefault(_FilmShader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author alteredq / http://alteredqualia.com/
 */

var FilmPass = function FilmPass(noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale) {

	_Pass2.default.call(this);

	if (_FilmShader2.default === undefined) console.error("THREE.FilmPass relies on THREE.FilmShader");

	var shader = _FilmShader2.default;

	this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);

	this.material = new THREE.ShaderMaterial({

		uniforms: this.uniforms,
		vertexShader: shader.vertexShader,
		fragmentShader: shader.fragmentShader

	});

	if (grayscale !== undefined) this.uniforms.grayscale.value = grayscale;
	if (noiseIntensity !== undefined) this.uniforms.nIntensity.value = noiseIntensity;
	if (scanlinesIntensity !== undefined) this.uniforms.sIntensity.value = scanlinesIntensity;
	if (scanlinesCount !== undefined) this.uniforms.sCount.value = scanlinesCount;

	this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
	this.scene = new THREE.Scene();

	this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
	this.quad.frustumCulled = false; // Avoid getting clipped
	this.scene.add(this.quad);
};

FilmPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {

	constructor: FilmPass,

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		this.uniforms["tDiffuse"].value = readBuffer.texture;
		this.uniforms["time"].value += delta;

		this.quad.material = this.material;

		if (this.renderToScreen) {

			renderer.render(this.scene, this.camera);
		} else {

			renderer.render(this.scene, this.camera, writeBuffer, this.clear);
		}
	}

});

exports.default = FilmPass;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _Pass = __webpack_require__(1);

var _Pass2 = _interopRequireDefault(_Pass);

var _DigitalGlitch = __webpack_require__(17);

var _DigitalGlitch2 = _interopRequireDefault(_DigitalGlitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author alteredq / http://alteredqualia.com/
 */

var GlitchPass = function GlitchPass(dt_size) {

	_Pass2.default.call(this);

	if (_DigitalGlitch2.default === undefined) console.error("THREE.GlitchPass relies on THREE.DigitalGlitch");

	var shader = _DigitalGlitch2.default;
	this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);

	if (dt_size == undefined) dt_size = 64;

	this.uniforms["tDisp"].value = this.generateHeightmap(dt_size);

	this.material = new THREE.ShaderMaterial({
		uniforms: this.uniforms,
		vertexShader: shader.vertexShader,
		fragmentShader: shader.fragmentShader
	});

	this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
	this.scene = new THREE.Scene();

	this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
	this.quad.frustumCulled = false; // Avoid getting clipped
	this.scene.add(this.quad);

	this.goWild = false;
	this.curF = 0;
	this.generateTrigger();
};

GlitchPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {

	constructor: GlitchPass,

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		this.uniforms["tDiffuse"].value = readBuffer.texture;
		this.uniforms['seed'].value = Math.random(); //default seeding
		this.uniforms['byp'].value = 0;

		if (this.curF % this.randX == 0 || this.goWild == true) {

			this.uniforms['amount'].value = Math.random() / 30;
			this.uniforms['angle'].value = THREE.Math.randFloat(-Math.PI, Math.PI);
			this.uniforms['seed_x'].value = THREE.Math.randFloat(-1, 1);
			this.uniforms['seed_y'].value = THREE.Math.randFloat(-1, 1);
			this.uniforms['distortion_x'].value = THREE.Math.randFloat(0, 1);
			this.uniforms['distortion_y'].value = THREE.Math.randFloat(0, 1);
			this.curF = 0;
			this.generateTrigger();
		} else if (this.curF % this.randX < this.randX / 5) {

			this.uniforms['amount'].value = Math.random() / 90;
			this.uniforms['angle'].value = THREE.Math.randFloat(-Math.PI, Math.PI);
			this.uniforms['distortion_x'].value = THREE.Math.randFloat(0, 1);
			this.uniforms['distortion_y'].value = THREE.Math.randFloat(0, 1);
			this.uniforms['seed_x'].value = THREE.Math.randFloat(-0.3, 0.3);
			this.uniforms['seed_y'].value = THREE.Math.randFloat(-0.3, 0.3);
		} else if (this.goWild == false) {

			this.uniforms['byp'].value = 1;
		}

		this.curF++;
		this.quad.material = this.material;

		if (this.renderToScreen) {

			renderer.render(this.scene, this.camera);
		} else {

			renderer.render(this.scene, this.camera, writeBuffer, this.clear);
		}
	},

	generateTrigger: function generateTrigger() {

		this.randX = THREE.Math.randInt(120, 240);
	},

	generateHeightmap: function generateHeightmap(dt_size) {

		var data_arr = new Float32Array(dt_size * dt_size * 3);
		var length = dt_size * dt_size;

		for (var i = 0; i < length; i++) {

			var val = THREE.Math.randFloat(0, 1);
			data_arr[i * 3 + 0] = val;
			data_arr[i * 3 + 1] = val;
			data_arr[i * 3 + 2] = val;
		}

		var texture = new THREE.DataTexture(data_arr, dt_size, dt_size, THREE.RGBFormat, THREE.FloatType);
		texture.needsUpdate = true;
		return texture;
	}

});

exports.default = GlitchPass;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _Pass = __webpack_require__(1);

var _Pass2 = _interopRequireDefault(_Pass);

var _HalftoneShader = __webpack_require__(18);

var _HalftoneShader2 = _interopRequireDefault(_HalftoneShader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author meatbags / xavierburrow.com, github/meatbags
 *
 * RGB Halftone pass for three.js effects composer. Requires THREE.HalftoneShader.
 *
 */

var HalftonePass = function HalftonePass(width, height, params) {

  _Pass2.default.call(this);

  if (_HalftoneShader2.default === undefined) {

    console.error('THREE.HalftonePass requires THREE.HalftoneShader');
  }

  this.uniforms = THREE.UniformsUtils.clone(_HalftoneShader2.default.uniforms);
  this.material = new THREE.ShaderMaterial({
    uniforms: this.uniforms,
    fragmentShader: _HalftoneShader2.default.fragmentShader,
    vertexShader: _HalftoneShader2.default.vertexShader
  });

  // set params
  this.uniforms.width.value = width;
  this.uniforms.height.value = height;

  for (var key in params) {

    if (params.hasOwnProperty(key) && this.uniforms.hasOwnProperty(key)) {

      this.uniforms[key].value = params[key];
    }
  }

  this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
  this.scene = new THREE.Scene();
  this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
  this.quad.frustumCulled = false;
  this.scene.add(this.quad);
};

HalftonePass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {

  constructor: HalftonePass,

  render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

    this.material.uniforms["tDiffuse"].value = readBuffer.texture;
    this.quad.material = this.material;

    if (this.renderToScreen) {

      renderer.render(this.scene, this.camera);
    } else {

      renderer.render(this.scene, this.camera, writeBuffer, this.clear);
    }
  },

  setSize: function setSize(width, height) {

    this.uniforms.width.value = width;
    this.uniforms.height.value = height;
  }
});

exports.default = HalftonePass;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Pass = __webpack_require__(1);

var _Pass2 = _interopRequireDefault(_Pass);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @author alteredq / http://alteredqualia.com/
 */

var MaskPass = function MaskPass(scene, camera) {

	_Pass2.default.call(this);

	this.scene = scene;
	this.camera = camera;

	this.clear = true;
	this.needsSwap = false;

	this.inverse = false;
};

MaskPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {

	constructor: MaskPass,

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		var context = renderer.context;
		var state = renderer.state;

		// don't update color or depth

		state.buffers.color.setMask(false);
		state.buffers.depth.setMask(false);

		// lock buffers

		state.buffers.color.setLocked(true);
		state.buffers.depth.setLocked(true);

		// set up stencil

		var writeValue, clearValue;

		if (this.inverse) {

			writeValue = 0;
			clearValue = 1;
		} else {

			writeValue = 1;
			clearValue = 0;
		}

		state.buffers.stencil.setTest(true);
		state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
		state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff);
		state.buffers.stencil.setClear(clearValue);

		// draw into the stencil buffer

		renderer.render(this.scene, this.camera, readBuffer, this.clear);
		renderer.render(this.scene, this.camera, writeBuffer, this.clear);

		// unlock color and depth buffer for subsequent rendering

		state.buffers.color.setLocked(false);
		state.buffers.depth.setLocked(false);

		// only render where stencil is set to 1

		state.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff); // draw if == 1
		state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
	}

});

exports.default = MaskPass;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _Pass = __webpack_require__(1);

var _Pass2 = _interopRequireDefault(_Pass);

var _CopyShader = __webpack_require__(2);

var _CopyShader2 = _interopRequireDefault(_CopyShader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author spidersharma / http://eduperiment.com/
 */

var OutlinePass = function OutlinePass(resolution, scene, camera, selectedObjects) {

	this.renderScene = scene;
	this.renderCamera = camera;
	this.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];
	this.visibleEdgeColor = new THREE.Color(1, 1, 1);
	this.hiddenEdgeColor = new THREE.Color(0.1, 0.04, 0.02);
	this.edgeGlow = 0.0;
	this.usePatternTexture = false;
	this.edgeThickness = 1.0;
	this.edgeStrength = 3.0;
	this.downSampleRatio = 2;
	this.pulsePeriod = 0;

	_Pass2.default.call(this);

	this.resolution = resolution !== undefined ? new THREE.Vector2(resolution.x, resolution.y) : new THREE.Vector2(256, 256);

	var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };

	var resx = Math.round(this.resolution.x / this.downSampleRatio);
	var resy = Math.round(this.resolution.y / this.downSampleRatio);

	this.maskBufferMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
	this.maskBufferMaterial.side = THREE.DoubleSide;
	this.renderTargetMaskBuffer = new THREE.WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);
	this.renderTargetMaskBuffer.texture.name = "OutlinePass.mask";
	this.renderTargetMaskBuffer.texture.generateMipmaps = false;

	this.depthMaterial = new THREE.MeshDepthMaterial();
	this.depthMaterial.side = THREE.DoubleSide;
	this.depthMaterial.depthPacking = THREE.RGBADepthPacking;
	this.depthMaterial.blending = THREE.NoBlending;

	this.prepareMaskMaterial = this.getPrepareMaskMaterial();
	this.prepareMaskMaterial.side = THREE.DoubleSide;
	this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(this.prepareMaskMaterial.fragmentShader, this.renderCamera);

	this.renderTargetDepthBuffer = new THREE.WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);
	this.renderTargetDepthBuffer.texture.name = "OutlinePass.depth";
	this.renderTargetDepthBuffer.texture.generateMipmaps = false;

	this.renderTargetMaskDownSampleBuffer = new THREE.WebGLRenderTarget(resx, resy, pars);
	this.renderTargetMaskDownSampleBuffer.texture.name = "OutlinePass.depthDownSample";
	this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;

	this.renderTargetBlurBuffer1 = new THREE.WebGLRenderTarget(resx, resy, pars);
	this.renderTargetBlurBuffer1.texture.name = "OutlinePass.blur1";
	this.renderTargetBlurBuffer1.texture.generateMipmaps = false;
	this.renderTargetBlurBuffer2 = new THREE.WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);
	this.renderTargetBlurBuffer2.texture.name = "OutlinePass.blur2";
	this.renderTargetBlurBuffer2.texture.generateMipmaps = false;

	this.edgeDetectionMaterial = this.getEdgeDetectionMaterial();
	this.renderTargetEdgeBuffer1 = new THREE.WebGLRenderTarget(resx, resy, pars);
	this.renderTargetEdgeBuffer1.texture.name = "OutlinePass.edge1";
	this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;
	this.renderTargetEdgeBuffer2 = new THREE.WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);
	this.renderTargetEdgeBuffer2.texture.name = "OutlinePass.edge2";
	this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;

	var MAX_EDGE_THICKNESS = 4;
	var MAX_EDGE_GLOW = 4;

	this.separableBlurMaterial1 = this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);
	this.separableBlurMaterial1.uniforms["texSize"].value = new THREE.Vector2(resx, resy);
	this.separableBlurMaterial1.uniforms["kernelRadius"].value = 1;
	this.separableBlurMaterial2 = this.getSeperableBlurMaterial(MAX_EDGE_GLOW);
	this.separableBlurMaterial2.uniforms["texSize"].value = new THREE.Vector2(Math.round(resx / 2), Math.round(resy / 2));
	this.separableBlurMaterial2.uniforms["kernelRadius"].value = MAX_EDGE_GLOW;

	// Overlay material
	this.overlayMaterial = this.getOverlayMaterial();

	// copy material
	if (_CopyShader2.default === undefined) console.error("THREE.OutlinePass relies on THREE.CopyShader");

	var copyShader = _CopyShader2.default;

	this.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);
	this.copyUniforms["opacity"].value = 1.0;

	this.materialCopy = new THREE.ShaderMaterial({
		uniforms: this.copyUniforms,
		vertexShader: copyShader.vertexShader,
		fragmentShader: copyShader.fragmentShader,
		blending: THREE.NoBlending,
		depthTest: false,
		depthWrite: false,
		transparent: true
	});

	this.enabled = true;
	this.needsSwap = false;

	this.oldClearColor = new THREE.Color();
	this.oldClearAlpha = 1;

	this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
	this.scene = new THREE.Scene();

	this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
	this.quad.frustumCulled = false; // Avoid getting clipped
	this.scene.add(this.quad);

	this.tempPulseColor1 = new THREE.Color();
	this.tempPulseColor2 = new THREE.Color();
	this.textureMatrix = new THREE.Matrix4();

	function replaceDepthToViewZ(string, camera) {

		var type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';

		return string.replace(/DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ');
	}
};

OutlinePass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {

	constructor: OutlinePass,

	dispose: function dispose() {

		this.renderTargetMaskBuffer.dispose();
		this.renderTargetDepthBuffer.dispose();
		this.renderTargetMaskDownSampleBuffer.dispose();
		this.renderTargetBlurBuffer1.dispose();
		this.renderTargetBlurBuffer2.dispose();
		this.renderTargetEdgeBuffer1.dispose();
		this.renderTargetEdgeBuffer2.dispose();
	},

	setSize: function setSize(width, height) {

		this.renderTargetMaskBuffer.setSize(width, height);

		var resx = Math.round(width / this.downSampleRatio);
		var resy = Math.round(height / this.downSampleRatio);
		this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);
		this.renderTargetBlurBuffer1.setSize(resx, resy);
		this.renderTargetEdgeBuffer1.setSize(resx, resy);
		this.separableBlurMaterial1.uniforms["texSize"].value = new THREE.Vector2(resx, resy);

		resx = Math.round(resx / 2);
		resy = Math.round(resy / 2);

		this.renderTargetBlurBuffer2.setSize(resx, resy);
		this.renderTargetEdgeBuffer2.setSize(resx, resy);

		this.separableBlurMaterial2.uniforms["texSize"].value = new THREE.Vector2(resx, resy);
	},

	changeVisibilityOfSelectedObjects: function changeVisibilityOfSelectedObjects(bVisible) {

		function gatherSelectedMeshesCallBack(object) {

			if (object.isMesh) {

				if (bVisible) {

					object.visible = object.userData.oldVisible;
					delete object.userData.oldVisible;
				} else {

					object.userData.oldVisible = object.visible;
					object.visible = bVisible;
				}
			}
		}

		for (var i = 0; i < this.selectedObjects.length; i++) {

			var selectedObject = this.selectedObjects[i];
			selectedObject.traverse(gatherSelectedMeshesCallBack);
		}
	},

	changeVisibilityOfNonSelectedObjects: function changeVisibilityOfNonSelectedObjects(bVisible) {

		var selectedMeshes = [];

		function gatherSelectedMeshesCallBack(object) {

			if (object.isMesh) selectedMeshes.push(object);
		}

		for (var i = 0; i < this.selectedObjects.length; i++) {

			var selectedObject = this.selectedObjects[i];
			selectedObject.traverse(gatherSelectedMeshesCallBack);
		}

		function VisibilityChangeCallBack(object) {

			if (object.isMesh || object.isLine || object.isSprite) {

				var bFound = false;

				for (var i = 0; i < selectedMeshes.length; i++) {

					var selectedObjectId = selectedMeshes[i].id;

					if (selectedObjectId === object.id) {

						bFound = true;
						break;
					}
				}

				if (!bFound) {

					var visibility = object.visible;

					if (!bVisible || object.bVisible) object.visible = bVisible;

					object.bVisible = visibility;
				}
			}
		}

		this.renderScene.traverse(VisibilityChangeCallBack);
	},

	updateTextureMatrix: function updateTextureMatrix() {

		this.textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
		this.textureMatrix.multiply(this.renderCamera.projectionMatrix);
		this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);
	},

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		if (this.selectedObjects.length > 0) {

			this.oldClearColor.copy(renderer.getClearColor());
			this.oldClearAlpha = renderer.getClearAlpha();
			var oldAutoClear = renderer.autoClear;

			renderer.autoClear = false;

			if (maskActive) renderer.context.disable(renderer.context.STENCIL_TEST);

			renderer.setClearColor(0xffffff, 1);

			// Make selected objects invisible
			this.changeVisibilityOfSelectedObjects(false);

			var currentBackground = this.renderScene.background;
			this.renderScene.background = null;

			// 1. Draw Non Selected objects in the depth buffer
			this.renderScene.overrideMaterial = this.depthMaterial;
			renderer.render(this.renderScene, this.renderCamera, this.renderTargetDepthBuffer, true);

			// Make selected objects visible
			this.changeVisibilityOfSelectedObjects(true);

			// Update Texture Matrix for Depth compare
			this.updateTextureMatrix();

			// Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects
			this.changeVisibilityOfNonSelectedObjects(false);
			this.renderScene.overrideMaterial = this.prepareMaskMaterial;
			this.prepareMaskMaterial.uniforms["cameraNearFar"].value = new THREE.Vector2(this.renderCamera.near, this.renderCamera.far);
			this.prepareMaskMaterial.uniforms["depthTexture"].value = this.renderTargetDepthBuffer.texture;
			this.prepareMaskMaterial.uniforms["textureMatrix"].value = this.textureMatrix;
			renderer.render(this.renderScene, this.renderCamera, this.renderTargetMaskBuffer, true);
			this.renderScene.overrideMaterial = null;
			this.changeVisibilityOfNonSelectedObjects(true);

			this.renderScene.background = currentBackground;

			// 2. Downsample to Half resolution
			this.quad.material = this.materialCopy;
			this.copyUniforms["tDiffuse"].value = this.renderTargetMaskBuffer.texture;
			renderer.render(this.scene, this.camera, this.renderTargetMaskDownSampleBuffer, true);

			this.tempPulseColor1.copy(this.visibleEdgeColor);
			this.tempPulseColor2.copy(this.hiddenEdgeColor);

			if (this.pulsePeriod > 0) {

				var scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1.0 - 0.25) / 2;
				this.tempPulseColor1.multiplyScalar(scalar);
				this.tempPulseColor2.multiplyScalar(scalar);
			}

			// 3. Apply Edge Detection Pass
			this.quad.material = this.edgeDetectionMaterial;
			this.edgeDetectionMaterial.uniforms["maskTexture"].value = this.renderTargetMaskDownSampleBuffer.texture;
			this.edgeDetectionMaterial.uniforms["texSize"].value = new THREE.Vector2(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);
			this.edgeDetectionMaterial.uniforms["visibleEdgeColor"].value = this.tempPulseColor1;
			this.edgeDetectionMaterial.uniforms["hiddenEdgeColor"].value = this.tempPulseColor2;
			renderer.render(this.scene, this.camera, this.renderTargetEdgeBuffer1, true);

			// 4. Apply Blur on Half res
			this.quad.material = this.separableBlurMaterial1;
			this.separableBlurMaterial1.uniforms["colorTexture"].value = this.renderTargetEdgeBuffer1.texture;
			this.separableBlurMaterial1.uniforms["direction"].value = THREE.OutlinePass.BlurDirectionX;
			this.separableBlurMaterial1.uniforms["kernelRadius"].value = this.edgeThickness;
			renderer.render(this.scene, this.camera, this.renderTargetBlurBuffer1, true);
			this.separableBlurMaterial1.uniforms["colorTexture"].value = this.renderTargetBlurBuffer1.texture;
			this.separableBlurMaterial1.uniforms["direction"].value = THREE.OutlinePass.BlurDirectionY;
			renderer.render(this.scene, this.camera, this.renderTargetEdgeBuffer1, true);

			// Apply Blur on quarter res
			this.quad.material = this.separableBlurMaterial2;
			this.separableBlurMaterial2.uniforms["colorTexture"].value = this.renderTargetEdgeBuffer1.texture;
			this.separableBlurMaterial2.uniforms["direction"].value = THREE.OutlinePass.BlurDirectionX;
			renderer.render(this.scene, this.camera, this.renderTargetBlurBuffer2, true);
			this.separableBlurMaterial2.uniforms["colorTexture"].value = this.renderTargetBlurBuffer2.texture;
			this.separableBlurMaterial2.uniforms["direction"].value = THREE.OutlinePass.BlurDirectionY;
			renderer.render(this.scene, this.camera, this.renderTargetEdgeBuffer2, true);

			// Blend it additively over the input texture
			this.quad.material = this.overlayMaterial;
			this.overlayMaterial.uniforms["maskTexture"].value = this.renderTargetMaskBuffer.texture;
			this.overlayMaterial.uniforms["edgeTexture1"].value = this.renderTargetEdgeBuffer1.texture;
			this.overlayMaterial.uniforms["edgeTexture2"].value = this.renderTargetEdgeBuffer2.texture;
			this.overlayMaterial.uniforms["patternTexture"].value = this.patternTexture;
			this.overlayMaterial.uniforms["edgeStrength"].value = this.edgeStrength;
			this.overlayMaterial.uniforms["edgeGlow"].value = this.edgeGlow;
			this.overlayMaterial.uniforms["usePatternTexture"].value = this.usePatternTexture;

			if (maskActive) renderer.context.enable(renderer.context.STENCIL_TEST);

			renderer.render(this.scene, this.camera, readBuffer, false);

			renderer.setClearColor(this.oldClearColor, this.oldClearAlpha);
			renderer.autoClear = oldAutoClear;
		}

		if (this.renderToScreen) {

			this.quad.material = this.materialCopy;
			this.copyUniforms["tDiffuse"].value = readBuffer.texture;
			renderer.render(this.scene, this.camera);
		}
	},

	getPrepareMaskMaterial: function getPrepareMaskMaterial() {

		return new THREE.ShaderMaterial({

			uniforms: {
				"depthTexture": { value: null },
				"cameraNearFar": { value: new THREE.Vector2(0.5, 0.5) },
				"textureMatrix": { value: new THREE.Matrix4() }
			},

			vertexShader: ['varying vec4 projTexCoord;', 'varying vec4 vPosition;', 'uniform mat4 textureMatrix;', 'void main() {', '	vPosition = modelViewMatrix * vec4( position, 1.0 );', '	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '	projTexCoord = textureMatrix * worldPosition;', '	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\n'),

			fragmentShader: ['#include <packing>', 'varying vec4 vPosition;', 'varying vec4 projTexCoord;', 'uniform sampler2D depthTexture;', 'uniform vec2 cameraNearFar;', 'void main() {', '	float depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));', '	float viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );', '	float depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;', '	gl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);', '}'].join('\n')

		});
	},

	getEdgeDetectionMaterial: function getEdgeDetectionMaterial() {

		return new THREE.ShaderMaterial({

			uniforms: {
				"maskTexture": { value: null },
				"texSize": { value: new THREE.Vector2(0.5, 0.5) },
				"visibleEdgeColor": { value: new THREE.Vector3(1.0, 1.0, 1.0) },
				"hiddenEdgeColor": { value: new THREE.Vector3(1.0, 1.0, 1.0) }
			},

			vertexShader: "varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader: "varying vec2 vUv;\
				uniform sampler2D maskTexture;\
				uniform vec2 texSize;\
				uniform vec3 visibleEdgeColor;\
				uniform vec3 hiddenEdgeColor;\
				\
				void main() {\n\
					vec2 invSize = 1.0 / texSize;\
					vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\
					vec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\
					vec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\
					vec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\
					vec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\
					float diff1 = (c1.r - c2.r)*0.5;\
					float diff2 = (c3.r - c4.r)*0.5;\
					float d = length( vec2(diff1, diff2) );\
					float a1 = min(c1.g, c2.g);\
					float a2 = min(c3.g, c4.g);\
					float visibilityFactor = min(a1, a2);\
					vec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\
					gl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\
				}"
		});
	},

	getSeperableBlurMaterial: function getSeperableBlurMaterial(maxRadius) {

		return new THREE.ShaderMaterial({

			defines: {
				"MAX_RADIUS": maxRadius
			},

			uniforms: {
				"colorTexture": { value: null },
				"texSize": { value: new THREE.Vector2(0.5, 0.5) },
				"direction": { value: new THREE.Vector2(0.5, 0.5) },
				"kernelRadius": { value: 1.0 }
			},

			vertexShader: "varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader: "#include <common>\
				varying vec2 vUv;\
				uniform sampler2D colorTexture;\
				uniform vec2 texSize;\
				uniform vec2 direction;\
				uniform float kernelRadius;\
				\
				float gaussianPdf(in float x, in float sigma) {\
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\
				}\
				void main() {\
					vec2 invSize = 1.0 / texSize;\
					float weightSum = gaussianPdf(0.0, kernelRadius);\
					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\
					vec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\
					vec2 uvOffset = delta;\
					for( int i = 1; i <= MAX_RADIUS; i ++ ) {\
						float w = gaussianPdf(uvOffset.x, kernelRadius);\
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\
						diffuseSum += ((sample1 + sample2) * w);\
						weightSum += (2.0 * w);\
						uvOffset += delta;\
					}\
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);\
				}"
		});
	},

	getOverlayMaterial: function getOverlayMaterial() {

		return new THREE.ShaderMaterial({

			uniforms: {
				"maskTexture": { value: null },
				"edgeTexture1": { value: null },
				"edgeTexture2": { value: null },
				"patternTexture": { value: null },
				"edgeStrength": { value: 1.0 },
				"edgeGlow": { value: 1.0 },
				"usePatternTexture": { value: 0.0 }
			},

			vertexShader: "varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader: "varying vec2 vUv;\
				uniform sampler2D maskTexture;\
				uniform sampler2D edgeTexture1;\
				uniform sampler2D edgeTexture2;\
				uniform sampler2D patternTexture;\
				uniform float edgeStrength;\
				uniform float edgeGlow;\
				uniform bool usePatternTexture;\
				\
				void main() {\
					vec4 edgeValue1 = texture2D(edgeTexture1, vUv);\
					vec4 edgeValue2 = texture2D(edgeTexture2, vUv);\
					vec4 maskColor = texture2D(maskTexture, vUv);\
					vec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\
					float visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\
					vec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\
					vec4 finalColor = edgeStrength * maskColor.r * edgeValue;\
					if(usePatternTexture)\
						finalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\
					gl_FragColor = finalColor;\
				}",
			blending: THREE.AdditiveBlending,
			depthTest: false,
			depthWrite: false,
			transparent: true
		});
	}

});

OutlinePass.BlurDirectionX = new THREE.Vector2(1.0, 0.0);
OutlinePass.BlurDirectionY = new THREE.Vector2(0.0, 1.0);

exports.default = OutlinePass;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Pass = __webpack_require__(1);

var _Pass2 = _interopRequireDefault(_Pass);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @author alteredq / http://alteredqualia.com/
 */

var RenderPass = function RenderPass(scene, camera, overrideMaterial, clearColor, clearAlpha) {

	_Pass2.default.call(this);

	this.scene = scene;
	this.camera = camera;

	this.overrideMaterial = overrideMaterial;

	this.clearColor = clearColor;
	this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;

	this.clear = true;
	this.clearDepth = false;
	this.needsSwap = false;
};

RenderPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {

	constructor: RenderPass,

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		var oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		this.scene.overrideMaterial = this.overrideMaterial;

		var oldClearColor, oldClearAlpha;

		if (this.clearColor) {

			oldClearColor = renderer.getClearColor().getHex();
			oldClearAlpha = renderer.getClearAlpha();

			renderer.setClearColor(this.clearColor, this.clearAlpha);
		}

		if (this.clearDepth) {

			renderer.clearDepth();
		}

		renderer.render(this.scene, this.camera, this.renderToScreen ? null : readBuffer, this.clear);

		if (this.clearColor) {

			renderer.setClearColor(oldClearColor, oldClearAlpha);
		}

		this.scene.overrideMaterial = null;
		renderer.autoClear = oldAutoClear;
	}

});

exports.default = RenderPass;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _Pass = __webpack_require__(1);

var _Pass2 = _interopRequireDefault(_Pass);

var _SAOShader = __webpack_require__(19);

var _SAOShader2 = _interopRequireDefault(_SAOShader);

var _DepthLimitedBlurShader = __webpack_require__(20);

var _DepthLimitedBlurShader2 = _interopRequireDefault(_DepthLimitedBlurShader);

var _CopyShader = __webpack_require__(2);

var _CopyShader2 = _interopRequireDefault(_CopyShader);

var _UnpackDepthRGBAShader = __webpack_require__(21);

var _UnpackDepthRGBAShader2 = _interopRequireDefault(_UnpackDepthRGBAShader);

var _BlurShaderUtils = __webpack_require__(22);

var _BlurShaderUtils2 = _interopRequireDefault(_BlurShaderUtils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author ludobaka / ludobaka.github.io
 * SAO implementation inspired from bhouston previous SAO work
 */

var SAOPass = function SAOPass(scene, camera, depthTexture, useNormals, resolution) {

	_Pass2.default.call(this);

	this.scene = scene;
	this.camera = camera;

	this.clear = true;
	this.needsSwap = false;

	this.supportsDepthTextureExtension = depthTexture !== undefined ? depthTexture : false;
	this.supportsNormalTexture = useNormals !== undefined ? useNormals : false;

	this.oldClearColor = new THREE.Color();
	this.oldClearAlpha = 1;

	this.params = {
		output: 0,
		saoBias: 0.5,
		saoIntensity: 0.18,
		saoScale: 1,
		saoKernelRadius: 100,
		saoMinResolution: 0,
		saoBlur: true,
		saoBlurRadius: 8,
		saoBlurStdDev: 4,
		saoBlurDepthCutoff: 0.01
	};

	this.resolution = resolution !== undefined ? new THREE.Vector2(resolution.x, resolution.y) : new THREE.Vector2(256, 256);

	this.saoRenderTarget = new THREE.WebGLRenderTarget(this.resolution.x, this.resolution.y, {
		minFilter: THREE.LinearFilter,
		magFilter: THREE.LinearFilter,
		format: THREE.RGBAFormat
	});
	this.blurIntermediateRenderTarget = this.saoRenderTarget.clone();
	this.beautyRenderTarget = this.saoRenderTarget.clone();

	this.normalRenderTarget = new THREE.WebGLRenderTarget(this.resolution.x, this.resolution.y, {
		minFilter: THREE.NearestFilter,
		magFilter: THREE.NearestFilter,
		format: THREE.RGBAFormat
	});
	this.depthRenderTarget = this.normalRenderTarget.clone();

	if (this.supportsDepthTextureExtension) {

		var depthTexture = new THREE.DepthTexture();
		depthTexture.type = THREE.UnsignedShortType;
		depthTexture.minFilter = THREE.NearestFilter;
		depthTexture.maxFilter = THREE.NearestFilter;

		this.beautyRenderTarget.depthTexture = depthTexture;
		this.beautyRenderTarget.depthBuffer = true;
	}

	this.depthMaterial = new THREE.MeshDepthMaterial();
	this.depthMaterial.depthPacking = THREE.RGBADepthPacking;
	this.depthMaterial.blending = THREE.NoBlending;

	this.normalMaterial = new THREE.MeshNormalMaterial();
	this.normalMaterial.blending = THREE.NoBlending;

	if (_SAOShader2.default === undefined) {

		console.error('THREE.SAOPass relies on THREE.SAOShader');
	}

	this.saoMaterial = new THREE.ShaderMaterial({
		defines: Object.assign({}, _SAOShader2.default.defines),
		fragmentShader: _SAOShader2.default.fragmentShader,
		vertexShader: _SAOShader2.default.vertexShader,
		uniforms: THREE.UniformsUtils.clone(_SAOShader2.default.uniforms)
	});
	this.saoMaterial.extensions.derivatives = true;
	this.saoMaterial.defines['DEPTH_PACKING'] = this.supportsDepthTextureExtension ? 0 : 1;
	this.saoMaterial.defines['NORMAL_TEXTURE'] = this.supportsNormalTexture ? 1 : 0;
	this.saoMaterial.defines['PERSPECTIVE_CAMERA'] = this.camera.isPerspectiveCamera ? 1 : 0;
	this.saoMaterial.uniforms['tDepth'].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;
	this.saoMaterial.uniforms['tNormal'].value = this.normalRenderTarget.texture;
	this.saoMaterial.uniforms['size'].value.set(this.resolution.x, this.resolution.y);
	this.saoMaterial.uniforms['cameraInverseProjectionMatrix'].value.getInverse(this.camera.projectionMatrix);
	this.saoMaterial.uniforms['cameraProjectionMatrix'].value = this.camera.projectionMatrix;
	this.saoMaterial.blending = THREE.NoBlending;

	if (_DepthLimitedBlurShader2.default === undefined) {

		console.error('THREE.SAOPass relies on THREE.DepthLimitedBlurShader');
	}

	this.vBlurMaterial = new THREE.ShaderMaterial({
		uniforms: THREE.UniformsUtils.clone(_DepthLimitedBlurShader2.default.uniforms),
		defines: Object.assign({}, _DepthLimitedBlurShader2.default.defines),
		vertexShader: _DepthLimitedBlurShader2.default.vertexShader,
		fragmentShader: _DepthLimitedBlurShader2.default.fragmentShader
	});
	this.vBlurMaterial.defines['DEPTH_PACKING'] = this.supportsDepthTextureExtension ? 0 : 1;
	this.vBlurMaterial.defines['PERSPECTIVE_CAMERA'] = this.camera.isPerspectiveCamera ? 1 : 0;
	this.vBlurMaterial.uniforms['tDiffuse'].value = this.saoRenderTarget.texture;
	this.vBlurMaterial.uniforms['tDepth'].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;
	this.vBlurMaterial.uniforms['size'].value.set(this.resolution.x, this.resolution.y);
	this.vBlurMaterial.blending = THREE.NoBlending;

	this.hBlurMaterial = new THREE.ShaderMaterial({
		uniforms: THREE.UniformsUtils.clone(_DepthLimitedBlurShader2.default.uniforms),
		defines: Object.assign({}, _DepthLimitedBlurShader2.default.defines),
		vertexShader: _DepthLimitedBlurShader2.default.vertexShader,
		fragmentShader: _DepthLimitedBlurShader2.default.fragmentShader
	});
	this.hBlurMaterial.defines['DEPTH_PACKING'] = this.supportsDepthTextureExtension ? 0 : 1;
	this.hBlurMaterial.defines['PERSPECTIVE_CAMERA'] = this.camera.isPerspectiveCamera ? 1 : 0;
	this.hBlurMaterial.uniforms['tDiffuse'].value = this.blurIntermediateRenderTarget.texture;
	this.hBlurMaterial.uniforms['tDepth'].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;
	this.hBlurMaterial.uniforms['size'].value.set(this.resolution.x, this.resolution.y);
	this.hBlurMaterial.blending = THREE.NoBlending;

	if (_CopyShader2.default === undefined) {

		console.error('THREE.SAOPass relies on THREE.CopyShader');
	}

	this.materialCopy = new THREE.ShaderMaterial({
		uniforms: THREE.UniformsUtils.clone(_CopyShader2.default.uniforms),
		vertexShader: _CopyShader2.default.vertexShader,
		fragmentShader: _CopyShader2.default.fragmentShader,
		blending: THREE.NoBlending
	});
	this.materialCopy.transparent = true;
	this.materialCopy.depthTest = false;
	this.materialCopy.depthWrite = false;
	this.materialCopy.blending = THREE.CustomBlending;
	this.materialCopy.blendSrc = THREE.DstColorFactor;
	this.materialCopy.blendDst = THREE.ZeroFactor;
	this.materialCopy.blendEquation = THREE.AddEquation;
	this.materialCopy.blendSrcAlpha = THREE.DstAlphaFactor;
	this.materialCopy.blendDstAlpha = THREE.ZeroFactor;
	this.materialCopy.blendEquationAlpha = THREE.AddEquation;

	if (_CopyShader2.default === undefined) {

		console.error('THREE.SAOPass relies on THREE.UnpackDepthRGBAShader');
	}

	this.depthCopy = new THREE.ShaderMaterial({
		uniforms: THREE.UniformsUtils.clone(_UnpackDepthRGBAShader2.default.uniforms),
		vertexShader: _UnpackDepthRGBAShader2.default.vertexShader,
		fragmentShader: _UnpackDepthRGBAShader2.default.fragmentShader,
		blending: THREE.NoBlending
	});

	this.quadCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
	this.quadScene = new THREE.Scene();
	this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
	this.quadScene.add(this.quad);
};

SAOPass.OUTPUT = {
	'Beauty': 1,
	'Default': 0,
	'SAO': 2,
	'Depth': 3,
	'Normal': 4
};

SAOPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {
	constructor: SAOPass,

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		// Rendering readBuffer first when rendering to screen
		if (this.renderToScreen) {

			this.materialCopy.blending = THREE.NoBlending;
			this.materialCopy.uniforms['tDiffuse'].value = readBuffer.texture;
			this.materialCopy.needsUpdate = true;
			this.renderPass(renderer, this.materialCopy, null);
		}

		if (this.params.output === 1) {

			return;
		}

		this.oldClearColor.copy(renderer.getClearColor());
		this.oldClearAlpha = renderer.getClearAlpha();
		var oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		renderer.clearTarget(this.depthRenderTarget);

		this.saoMaterial.uniforms['bias'].value = this.params.saoBias;
		this.saoMaterial.uniforms['intensity'].value = this.params.saoIntensity;
		this.saoMaterial.uniforms['scale'].value = this.params.saoScale;
		this.saoMaterial.uniforms['kernelRadius'].value = this.params.saoKernelRadius;
		this.saoMaterial.uniforms['minResolution'].value = this.params.saoMinResolution;
		this.saoMaterial.uniforms['cameraNear'].value = this.camera.near;
		this.saoMaterial.uniforms['cameraFar'].value = this.camera.far;
		// this.saoMaterial.uniforms['randomSeed'].value = Math.random();

		var depthCutoff = this.params.saoBlurDepthCutoff * (this.camera.far - this.camera.near);
		this.vBlurMaterial.uniforms['depthCutoff'].value = depthCutoff;
		this.hBlurMaterial.uniforms['depthCutoff'].value = depthCutoff;

		this.vBlurMaterial.uniforms['cameraNear'].value = this.camera.near;
		this.vBlurMaterial.uniforms['cameraFar'].value = this.camera.far;
		this.hBlurMaterial.uniforms['cameraNear'].value = this.camera.near;
		this.hBlurMaterial.uniforms['cameraFar'].value = this.camera.far;

		this.params.saoBlurRadius = Math.floor(this.params.saoBlurRadius);
		if (this.prevStdDev !== this.params.saoBlurStdDev || this.prevNumSamples !== this.params.saoBlurRadius) {

			_BlurShaderUtils2.default.configure(this.vBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new THREE.Vector2(0, 1));
			_BlurShaderUtils2.default.configure(this.hBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new THREE.Vector2(1, 0));
			this.prevStdDev = this.params.saoBlurStdDev;
			this.prevNumSamples = this.params.saoBlurRadius;
		}

		// Rendering scene to depth texture
		renderer.setClearColor(0x000000);
		renderer.render(this.scene, this.camera, this.beautyRenderTarget, true);

		// Re-render scene if depth texture extension is not supported
		if (!this.supportsDepthTextureExtension) {

			// Clear rule : far clipping plane in both RGBA and Basic encoding
			this.renderOverride(renderer, this.depthMaterial, this.depthRenderTarget, 0x000000, 1.0);
		}

		if (this.supportsNormalTexture) {

			// Clear rule : default normal is facing the camera
			this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 0x7777ff, 1.0);
		}

		// Rendering SAO texture
		this.renderPass(renderer, this.saoMaterial, this.saoRenderTarget, 0xffffff, 1.0);

		// Blurring SAO texture
		if (this.params.saoBlur) {

			this.renderPass(renderer, this.vBlurMaterial, this.blurIntermediateRenderTarget, 0xffffff, 1.0);
			this.renderPass(renderer, this.hBlurMaterial, this.saoRenderTarget, 0xffffff, 1.0);
		}

		var outputMaterial = this.materialCopy;
		// Setting up SAO rendering
		if (this.params.output === 3) {

			if (this.supportsDepthTextureExtension) {

				this.materialCopy.uniforms['tDiffuse'].value = this.beautyRenderTarget.depthTexture;
				this.materialCopy.needsUpdate = true;
			} else {

				this.depthCopy.uniforms['tDiffuse'].value = this.depthRenderTarget.texture;
				this.depthCopy.needsUpdate = true;
				outputMaterial = this.depthCopy;
			}
		} else if (this.params.output === 4) {

			this.materialCopy.uniforms['tDiffuse'].value = this.normalRenderTarget.texture;
			this.materialCopy.needsUpdate = true;
		} else {

			this.materialCopy.uniforms['tDiffuse'].value = this.saoRenderTarget.texture;
			this.materialCopy.needsUpdate = true;
		}

		// Blending depends on output, only want a CustomBlending when showing SAO
		if (this.params.output === 0) {

			outputMaterial.blending = THREE.CustomBlending;
		} else {

			outputMaterial.blending = THREE.NoBlending;
		}

		// Rendering SAOPass result on top of previous pass
		this.renderPass(renderer, outputMaterial, this.renderToScreen ? null : readBuffer);

		renderer.setClearColor(this.oldClearColor, this.oldClearAlpha);
		renderer.autoClear = oldAutoClear;
	},

	renderPass: function renderPass(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {

		// save original state
		var originalClearColor = renderer.getClearColor();
		var originalClearAlpha = renderer.getClearAlpha();
		var originalAutoClear = renderer.autoClear;

		// setup pass state
		renderer.autoClear = false;
		var clearNeeded = clearColor !== undefined && clearColor !== null;
		if (clearNeeded) {

			renderer.setClearColor(clearColor);
			renderer.setClearAlpha(clearAlpha || 0.0);
		}

		this.quad.material = passMaterial;
		renderer.render(this.quadScene, this.quadCamera, renderTarget, clearNeeded);

		// restore original state
		renderer.autoClear = originalAutoClear;
		renderer.setClearColor(originalClearColor);
		renderer.setClearAlpha(originalClearAlpha);
	},

	renderOverride: function renderOverride(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {

		var originalClearColor = renderer.getClearColor();
		var originalClearAlpha = renderer.getClearAlpha();
		var originalAutoClear = renderer.autoClear;

		renderer.autoClear = false;

		clearColor = overrideMaterial.clearColor || clearColor;
		clearAlpha = overrideMaterial.clearAlpha || clearAlpha;
		var clearNeeded = clearColor !== undefined && clearColor !== null;
		if (clearNeeded) {

			renderer.setClearColor(clearColor);
			renderer.setClearAlpha(clearAlpha || 0.0);
		}

		this.scene.overrideMaterial = overrideMaterial;
		renderer.render(this.scene, this.camera, renderTarget, clearNeeded);
		this.scene.overrideMaterial = null;

		// restore original state
		renderer.autoClear = originalAutoClear;
		renderer.setClearColor(originalClearColor);
		renderer.setClearAlpha(originalClearAlpha);
	},

	setSize: function setSize(width, height) {

		this.beautyRenderTarget.setSize(width, height);
		this.saoRenderTarget.setSize(width, height);
		this.blurIntermediateRenderTarget.setSize(width, height);
		this.normalRenderTarget.setSize(width, height);
		this.depthRenderTarget.setSize(width, height);

		this.saoMaterial.uniforms['size'].value.set(width, height);
		this.saoMaterial.uniforms['cameraInverseProjectionMatrix'].value.getInverse(this.camera.projectionMatrix);
		this.saoMaterial.uniforms['cameraProjectionMatrix'].value = this.camera.projectionMatrix;
		this.saoMaterial.needsUpdate = true;

		this.vBlurMaterial.uniforms['size'].value.set(width, height);
		this.vBlurMaterial.needsUpdate = true;

		this.hBlurMaterial.uniforms['size'].value.set(width, height);
		this.hBlurMaterial.needsUpdate = true;
	}

});

exports.default = SAOPass;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _Pass = __webpack_require__(1);

var _Pass2 = _interopRequireDefault(_Pass);

var _CopyShader = __webpack_require__(2);

var _CopyShader2 = _interopRequireDefault(_CopyShader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author alteredq / http://alteredqualia.com/
 */

var SavePass = function SavePass(renderTarget) {

	_Pass2.default.call(this);

	if (_CopyShader2.default === undefined) console.error("THREE.SavePass relies on THREE.CopyShader");

	var shader = _CopyShader2.default;

	this.textureID = "tDiffuse";

	this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);

	this.material = new THREE.ShaderMaterial({

		uniforms: this.uniforms,
		vertexShader: shader.vertexShader,
		fragmentShader: shader.fragmentShader

	});

	this.renderTarget = renderTarget;

	if (this.renderTarget === undefined) {

		this.renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false });
		this.renderTarget.texture.name = "SavePass.rt";
	}

	this.needsSwap = false;

	this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
	this.scene = new THREE.Scene();

	this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
	this.quad.frustumCulled = false; // Avoid getting clipped
	this.scene.add(this.quad);
};

SavePass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {

	constructor: SavePass,

	render: function render(renderer, writeBuffer, readBuffer) {

		if (this.uniforms[this.textureID]) {

			this.uniforms[this.textureID].value = readBuffer.texture;
		}

		this.quad.material = this.material;

		renderer.render(this.scene, this.camera, this.renderTarget, this.clear);
	}

});

exports.default = SavePass;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _Pass = __webpack_require__(1);

var _Pass2 = _interopRequireDefault(_Pass);

var _SMAAShader = __webpack_require__(23);

var _SMAAShader2 = _interopRequireDefault(_SMAAShader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author mpk / http://polko.me/
 */

var SMAAPass = function SMAAPass(width, height) {

	_Pass2.default.call(this);

	// render targets

	this.edgesRT = new THREE.WebGLRenderTarget(width, height, {
		depthBuffer: false,
		stencilBuffer: false,
		generateMipmaps: false,
		minFilter: THREE.LinearFilter,
		format: THREE.RGBFormat
	});
	this.edgesRT.texture.name = "SMAAPass.edges";

	this.weightsRT = new THREE.WebGLRenderTarget(width, height, {
		depthBuffer: false,
		stencilBuffer: false,
		generateMipmaps: false,
		minFilter: THREE.LinearFilter,
		format: THREE.RGBAFormat
	});
	this.weightsRT.texture.name = "SMAAPass.weights";

	// textures

	var areaTextureImage = new Image();
	areaTextureImage.src = this.getAreaTexture();

	this.areaTexture = new THREE.Texture();
	this.areaTexture.name = "SMAAPass.area";
	this.areaTexture.image = areaTextureImage;
	this.areaTexture.format = THREE.RGBFormat;
	this.areaTexture.minFilter = THREE.LinearFilter;
	this.areaTexture.generateMipmaps = false;
	this.areaTexture.needsUpdate = true;
	this.areaTexture.flipY = false;

	var searchTextureImage = new Image();
	searchTextureImage.src = this.getSearchTexture();

	this.searchTexture = new THREE.Texture();
	this.searchTexture.name = "SMAAPass.search";
	this.searchTexture.image = searchTextureImage;
	this.searchTexture.magFilter = THREE.NearestFilter;
	this.searchTexture.minFilter = THREE.NearestFilter;
	this.searchTexture.generateMipmaps = false;
	this.searchTexture.needsUpdate = true;
	this.searchTexture.flipY = false;

	// materials - pass 1

	if (_SMAAShader2.default === undefined) {
		console.error("THREE.SMAAPass relies on THREE.SMAAShader");
	}

	this.uniformsEdges = THREE.UniformsUtils.clone(_SMAAShader2.default[0].uniforms);

	this.uniformsEdges["resolution"].value.set(1 / width, 1 / height);

	this.materialEdges = new THREE.ShaderMaterial({
		defines: Object.assign({}, _SMAAShader2.default[0].defines),
		uniforms: this.uniformsEdges,
		vertexShader: _SMAAShader2.default[0].vertexShader,
		fragmentShader: _SMAAShader2.default[0].fragmentShader
	});

	// materials - pass 2

	this.uniformsWeights = THREE.UniformsUtils.clone(_SMAAShader2.default[1].uniforms);

	this.uniformsWeights["resolution"].value.set(1 / width, 1 / height);
	this.uniformsWeights["tDiffuse"].value = this.edgesRT.texture;
	this.uniformsWeights["tArea"].value = this.areaTexture;
	this.uniformsWeights["tSearch"].value = this.searchTexture;

	this.materialWeights = new THREE.ShaderMaterial({
		defines: Object.assign({}, _SMAAShader2.default[1].defines),
		uniforms: this.uniformsWeights,
		vertexShader: _SMAAShader2.default[1].vertexShader,
		fragmentShader: _SMAAShader2.default[1].fragmentShader
	});

	// materials - pass 3

	this.uniformsBlend = THREE.UniformsUtils.clone(_SMAAShader2.default[2].uniforms);

	this.uniformsBlend["resolution"].value.set(1 / width, 1 / height);
	this.uniformsBlend["tDiffuse"].value = this.weightsRT.texture;

	this.materialBlend = new THREE.ShaderMaterial({
		uniforms: this.uniformsBlend,
		vertexShader: _SMAAShader2.default[2].vertexShader,
		fragmentShader: _SMAAShader2.default[2].fragmentShader
	});

	this.needsSwap = false;

	this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
	this.scene = new THREE.Scene();

	this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
	this.quad.frustumCulled = false; // Avoid getting clipped
	this.scene.add(this.quad);
};

SMAAPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {

	constructor: SMAAPass,

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		// pass 1

		this.uniformsEdges["tDiffuse"].value = readBuffer.texture;

		this.quad.material = this.materialEdges;

		renderer.render(this.scene, this.camera, this.edgesRT, this.clear);

		// pass 2

		this.quad.material = this.materialWeights;

		renderer.render(this.scene, this.camera, this.weightsRT, this.clear);

		// pass 3

		this.uniformsBlend["tColor"].value = readBuffer.texture;

		this.quad.material = this.materialBlend;

		if (this.renderToScreen) {

			renderer.render(this.scene, this.camera);
		} else {

			renderer.render(this.scene, this.camera, writeBuffer, this.clear);
		}
	},

	setSize: function setSize(width, height) {

		this.edgesRT.setSize(width, height);
		this.weightsRT.setSize(width, height);

		this.materialEdges.uniforms['resolution'].value.set(1 / width, 1 / height);
		this.materialWeights.uniforms['resolution'].value.set(1 / width, 1 / height);
		this.materialBlend.uniforms['resolution'].value.set(1 / width, 1 / height);
	},

	getAreaTexture: function getAreaTexture() {
		return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAIAAACOVPcQAACBeklEQVR42u39W4xlWXrnh/3WWvuciIzMrKxrV8/0rWbY0+SQFKcb4owIkSIFCjY9AC1BT/LYBozRi+EX+cV+8IMsYAaCwRcBwjzMiw2jAWtgwC8WR5Q8mDFHZLNHTarZGrLJJllt1W2qKrsumZWZcTvn7L3W54e1vrXX3vuciLPPORFR1XE2EomorB0nVuz//r71re/y/1eMvb4Cb3N11xV/PP/2v4UBAwJG/7H8urx6/25/Gf8O5hypMQ0EEEQwAqLfoN/Z+97f/SW+/NvcgQk4sGBJK6H7N4PFVL+K+e0N11yNfkKvwUdwdlUAXPHHL38oa15f/i/46Ih6SuMSPmLAYAwyRKn7dfMGH97jaMFBYCJUgotIC2YAdu+LyW9vvubxAP8kAL8H/koAuOKP3+q6+xGnd5kdYCeECnGIJViwGJMAkQKfDvB3WZxjLKGh8VSCCzhwEWBpMc5/kBbjawT4HnwJfhr+pPBIu7uu+OOTo9vsmtQcniMBGkKFd4jDWMSCRUpLjJYNJkM+IRzQ+PQvIeAMTrBS2LEiaiR9b/5PuT6Ap/AcfAFO4Y3dA3DFH7/VS+M8k4baEAQfMI4QfbVDDGIRg7GKaIY52qAjTAgTvGBAPGIIghOCYAUrGFNgzA7Q3QhgCwfwAnwe5vDejgG44o/fbm1C5ZlYQvQDARPAIQGxCWBM+wWl37ZQESb4gImexGMDouhGLx1Cst0Saa4b4AqO4Hk4gxo+3DHAV/nx27p3JziPM2pVgoiia5MdEzCGULprIN7gEEeQ5IQxEBBBQnxhsDb5auGmAAYcHMA9eAAz8PBol8/xij9+C4Djlim4gJjWcwZBhCBgMIIYxGAVIkH3ZtcBuLdtRFMWsPGoY9rN+HoBji9VBYdwD2ZQg4cnO7OSq/z4rU5KKdwVbFAjNojCQzTlCLPFSxtamwh2jMUcEgg2Wm/6XgErIBhBckQtGN3CzbVacERgCnfgLswhnvqf7QyAq/z4rRZm1YglYE3affGITaZsdIe2FmMIpnOCap25I6jt2kCwCW0D1uAD9sZctNGXcQIHCkINDQgc78aCr+zjtw3BU/ijdpw3zhCwcaONwBvdeS2YZKkJNJsMPf2JKEvC28RXxxI0ASJyzQCjCEQrO4Q7sFArEzjZhaFc4cdv+/JFdKULM4px0DfUBI2hIsy06BqLhGTQEVdbfAIZXYMPesq6VoCHICzUyjwInO4Y411//LYLs6TDa9wvg2CC2rElgAnpTBziThxaL22MYhzfkghz6GAs2VHbbdM91VZu1MEEpupMMwKyVTb5ij9+u4VJG/5EgEMMmFF01cFai3isRbKbzb+YaU/MQbAm2XSMoUPAmvZzbuKYRIFApbtlrfFuUGd6vq2hXNnH78ZLh/iFhsQG3T4D1ib7k5CC6vY0DCbtrohgLEIClXiGtl10zc0CnEGIhhatLBva7NP58Tvw0qE8yWhARLQ8h4+AhQSP+I4F5xoU+VilGRJs6wnS7ruti/4KvAY/CfdgqjsMy4pf8fodQO8/gnuX3f/3xi3om1/h7THr+co3x93PP9+FBUfbNUjcjEmhcrkT+8K7ml7V10Jo05mpIEFy1NmCJWx9SIKKt+EjAL4Ez8EBVOB6havuT/rByPvHXK+9zUcfcbb254+9fydJknYnRr1oGfdaiAgpxu1Rx/Rek8KISftx3L+DfsLWAANn8Hvw0/AFeAGO9DFV3c6D+CcWbL8Dj9e7f+T1k8AZv/d7+PXWM/Z+VvdCrIvuAKO09RpEEQJM0Ci6+B4xhTWr4cZNOvhktabw0ta0rSJmqz3Yw5/AKXwenod7cAhTmBSPKf6JBdvH8IP17h95pXqw50/+BFnj88fev4NchyaK47OPhhtI8RFSvAfDSNh0Ck0p2gLxGkib5NJj/JWCr90EWQJvwBzO4AHcgztwAFN1evHPUVGwfXON+0debT1YeGON9Yy9/63X+OguiwmhIhQhD7l4sMqlG3D86Suc3qWZ4rWjI1X7u0Ytw6x3rIMeIOPDprfe2XzNgyj6PahhBjO4C3e6puDgXrdg+/5l948vF3bqwZetZ+z9Rx9zdIY5pInPK4Nk0t+l52xdK2B45Qd87nM8fsD5EfUhIcJcERw4RdqqH7Yde5V7m1vhNmtedkz6EDzUMF/2jJYWbC+4fzzA/Y+/8PPH3j9dcBAPIRP8JLXd5BpAu03aziOL3VVHZzz3CXWDPWd+SH2AnxIqQoTZpo9Ckc6HIrFbAbzNmlcg8Ag8NFDDAhbJvTBZXbC94P7t68EXfv6o+21gUtPETU7bbkLxvNKRFG2+KXzvtObonPP4rBvsgmaKj404DlshFole1Glfh02fE7bYR7dZ82oTewIBGn1Md6CG6YUF26X376oevOLzx95vhUmgblI6LBZwTCDY7vMq0op5WVXgsObOXJ+1x3qaBl9j1FeLxbhU9w1F+Wiba6s1X/TBz1LnUfuYDi4r2C69f1f14BWfP+p+W2GFKuC9phcELMYRRLur9DEZTUdEH+iEqWdaM7X4WOoPGI+ZYD2+wcQ+y+ioHUZ9dTDbArzxmi/bJI9BND0Ynd6lBdve/butBw8+f/T9D3ABa3AG8W3VPX4hBin+bj8dMMmSpp5pg7fJ6xrBFE2WQQEWnV8Qg3FbAWzYfM1rREEnmvkN2o1+acG2d/9u68GDzx91v3mAjb1zkpqT21OipPKO0b9TO5W0nTdOmAQm0TObts3aBKgwARtoPDiCT0gHgwnbArzxmtcLc08HgF1asN0C4Ms/fvD5I+7PhfqyXE/b7RbbrGyRQRT9ARZcwAUmgdoz0ehJ9Fn7QAhUjhDAQSw0bV3T3WbNa59jzmiP6GsWbGXDX2ytjy8+f9T97fiBPq9YeLdBmyuizZHaqXITnXiMUEEVcJ7K4j3BFPurtB4bixW8wTpweL8DC95szWMOqucFYGsWbGU7p3TxxxefP+r+oTVktxY0v5hbq3KiOKYnY8ddJVSBxuMMVffNbxwIOERShst73HZ78DZrHpmJmH3K6sGz0fe3UUj0eyRrSCGTTc+rjVNoGzNSv05srAxUBh8IhqChiQgVNIIBH3AVPnrsnXQZbLTm8ammv8eVXn/vWpaTem5IXRlt+U/LA21zhSb9cye6jcOfCnOwhIAYXAMVTUNV0QhVha9xjgA27ODJbLbmitt3tRN80lqG6N/khgot4ZVlOyO4WNg3OIMzhIZQpUEHieg2im6F91hB3I2tubql6BYNN9Hj5S7G0G2tahslBWKDnOiIvuAEDzakDQKDNFQT6gbn8E2y4BBubM230YIpBnDbMa+y3dx0n1S0BtuG62lCCXwcY0F72T1VRR3t2ONcsmDjbmzNt9RFs2LO2hQNyb022JisaI8rAWuw4HI3FuAIhZdOGIcdjLJvvObqlpqvWTJnnQbyi/1M9O8UxWhBs//H42I0q1Yb/XPGONzcmm+ri172mHKvZBpHkJaNJz6v9jxqiklDj3U4CA2ugpAaYMWqNXsdXbmJNd9egCnJEsphXNM+MnK3m0FCJ5S1kmJpa3DgPVbnQnPGWIDspW9ozbcO4K/9LkfaQO2KHuqlfFXSbdNzcEcwoqNEFE9zcIXu9/6n/ym/BC/C3aJLzEKPuYVlbFnfhZ8kcWxV3dbv4bKl28566wD+8C53aw49lTABp9PWbsB+knfc/Li3eVizf5vv/xmvnPKg5ihwKEwlrcHqucuVcVOxEv8aH37E3ZqpZypUulrHEtIWKUr+txHg+ojZDGlwnqmkGlzcVi1dLiNSJiHjfbRNOPwKpx9TVdTn3K05DBx4psIk4Ei8aCkJahRgffk4YnEXe07T4H2RR1u27E6wfQsBDofUgjFUFnwC2AiVtA+05J2zpiDK2Oa0c5fmAecN1iJzmpqFZxqYBCYhFTCsUNEmUnIcZ6aEA5rQVhEywG6w7HSW02XfOoBlQmjwulOFQAg66SvJblrTEX1YtJ3uG15T/BH1OfOQeuR8g/c0gdpT5fx2SKbs9EfHTKdM8A1GaJRHLVIwhcGyydZsbifAFVKl5EMKNU2Hryo+06BeTgqnxzYjThVySDikbtJPieco75lYfKAJOMEZBTjoITuWHXXZVhcUDIS2hpiXHV9Ku4u44bN5OYLDOkJo8w+xJSMbhBRHEdEs9JZUCkQrPMAvaHyLkxgkEHxiNkx/x2YB0mGsQ8EUWj/stW5YLhtS5SMu+/YBbNPDCkGTUybN8krRLBGPlZkVOA0j+a1+rkyQKWGaPHPLZOkJhioQYnVZ2hS3zVxMtgC46KuRwbJNd9nV2PHgb36F194ecf/Yeu2vAFe5nm/bRBFrnY4BauE8ERmZRFUn0k8hbftiVYSKMEme2dJCJSCGYAlNqh87bXOPdUkGy24P6d1ll21MBqqx48Fvv8ZHH8HZFY7j/uAq1xMJUFqCSUlJPmNbIiNsmwuMs/q9CMtsZsFO6SprzCS1Z7QL8xCQClEelpjTduDMsmWD8S1PT152BtvmIGvUeDA/yRn83u/x0/4qxoPHjx+PXY9pqX9bgMvh/Nz9kpP4pOe1/fYf3axUiMdHLlPpZCNjgtNFAhcHEDxTumNONhHrBduW+vOyY++70WWnPXj98eA4kOt/mj/5E05l9+O4o8ePx67HFqyC+qSSnyselqjZGaVK2TadbFLPWAQ4NBhHqDCCV7OTpo34AlSSylPtIdd2AJZlyzYQrDJ5lcWGNceD80CunPLGGzsfD+7wRb95NevJI5docQ3tgCyr5bGnyaPRlmwNsFELViOOx9loebGNq2moDOKpHLVP5al2cymWHbkfzGXL7kfRl44H9wZy33tvt+PB/Xnf93e+nh5ZlU18wCiRUa9m7kib9LYuOk+hudQNbxwm0AQqbfloimaB2lM5fChex+ylMwuTbfmXQtmWlenZljbdXTLuOxjI/fDDHY4Hjx8/Hrse0zXfPFxbUN1kKqSCCSk50m0Ajtx3ub9XHBKHXESb8iO6E+qGytF4nO0OG3SXzbJlhxBnKtKyl0NwybjvYCD30aMdjgePHz8eu56SVTBbgxJMliQ3Oauwg0QHxXE2Ez/EIReLdQj42Gzb4CLS0YJD9xUx7bsi0vJi5mUbW1QzL0h0PFk17rtiIPfJk52MB48fPx67npJJwyrBa2RCCQRTbGZSPCxTPOiND4G2pYyOQ4h4jINIJh5wFU1NFZt+IsZ59LSnDqBjZ2awbOku+yInunLcd8VA7rNnOxkPHj9+PGY9B0MWJJNozOJmlglvDMXDEozdhQWbgs/U6oBanGzLrdSNNnZFjOkmbi5bNt1lX7JLLhn3vXAg9/h4y/Hg8ePHI9dzQMEkWCgdRfYykYKnkP7D4rIujsujaKPBsB54vE2TS00ccvFY/Tth7JXeq1hz+qgVy04sAJawTsvOknHfCwdyT062HA8eP348Zj0vdoXF4pilKa2BROed+9fyw9rWRXeTFXESMOanvDZfJuJaSXouQdMdDJZtekZcLLvEeK04d8m474UDuaenW44Hjx8/Xns9YYqZpszGWB3AN/4VHw+k7WSFtJ3Qicuqb/NlVmgXWsxh570xg2UwxUw3WfO6B5nOuO8aA7lnZxuPB48fPx6znm1i4bsfcbaptF3zNT78eFPtwi1OaCNOqp1x3zUGcs/PN++AGD1+fMXrSVm2baTtPhPahbPhA71wIHd2bXzRa69nG+3CraTtPivahV/55tXWg8fyRY/9AdsY8VbSdp8V7cKrrgdfM//z6ILQFtJ2nxHtwmuoB4/kf74+gLeRtvvMaBdeSz34+vifx0YG20jbfTa0C6+tHrwe//NmOG0L8EbSdp8R7cLrrQe/996O+ai3ujQOskpTNULa7jOjXXj99eCd8lHvoFiwsbTdZ0a78PrrwTvlo966pLuRtB2fFe3Cm6oHP9kNH/W2FryxtN1nTLvwRurBO+Kj3pWXHidtx2dFu/Bm68Fb81HvykuPlrb7LGkX3mw9eGs+6h1Y8MbSdjegXcguQLjmevDpTQLMxtJ2N6NdyBZu9AbrwVvwUW+LbteULUpCdqm0HTelXbhNPe8G68Gb8lFvVfYfSNuxvrTdTWoXbozAzdaDZzfkorOj1oxVxlIMlpSIlpLrt8D4hrQL17z+c3h6hU/wv4Q/utps4+bm+6P/hIcf0JwQ5oQGPBL0eKPTYEXTW+eL/2DKn73J9BTXYANG57hz1cEMviVf/4tf5b/6C5pTQkMIWoAq7hTpOJjtAM4pxKu5vg5vXeUrtI09/Mo/5H+4z+Mp5xULh7cEm2QbRP2tFIKR7WM3fPf/jZ3SWCqLM2l4NxID5zB72HQXv3jj/8mLR5xXNA5v8EbFQEz7PpRfl1+MB/hlAN65qgDn3wTgH13hK7T59bmP+NIx1SHHU84nLOITt3iVz8mNO+lPrjGAnBFqmioNn1mTyk1ta47R6d4MrX7tjrnjYUpdUbv2rVr6YpVfsGG58AG8Ah9eyUN8CX4WfgV+G8LVWPDGb+Zd4cU584CtqSbMKxauxTg+dyn/LkVgA+IR8KHtejeFKRtTmLLpxN6mYVLjYxwXf5x2VofiZcp/lwKk4wGOpYDnoIZPdg/AAbwMfx0+ge9dgZvYjuqKe4HnGnykYo5TvJbG0Vj12JagRhwKa44H95ShkZa5RyLGGdfYvG7aw1TsF6iapPAS29mNS3NmsTQZCmgTzFwgL3upCTgtBTRwvGMAKrgLn4evwin8+afJRcff+8izUGUM63GOOuAs3tJkw7J4kyoNreqrpO6cYLQeFUd7TTpr5YOTLc9RUUogUOVJQ1GYJaFLAW0oTmKyYS46ZooP4S4EON3xQ5zC8/CX4CnM4c1PE8ApexpoYuzqlP3d4S3OJP8ZDK7cKWNaTlqmgDiiHwl1YsE41w1zT4iRTm3DBqxvOUsbMKKDa/EHxagtnta072ejc3DOIh5ojvh8l3tk1JF/AV6FU6jh3U8HwEazLgdCLYSQ+MYiAI2ltomkzttUb0gGHdSUUgsIYjTzLG3mObX4FBRaYtpDVNZrih9TgTeYOBxsEnN1gOCTM8Bsw/ieMc75w9kuAT6A+/AiHGvN/+Gn4KRkiuzpNNDYhDGFndWRpE6SVfm8U5bxnSgVV2jrg6JCKmneqey8VMFgq2+AM/i4L4RUbfSi27lNXZ7R7W9RTcq/q9fk4Xw3AMQd4I5ifAZz8FcVtm9SAom/dyN4lczJQW/kC42ZrHgcCoIf1oVMKkVItmMBi9cOeNHGLqOZk+QqQmrbc5YmYgxELUUN35z2iohstgfLIFmcMV7s4CFmI74L9+EFmGsi+tGnAOD4Yk9gIpo01Y4cA43BWGygMdr4YZekG3OBIUXXNukvJS8tqa06e+lSDCtnqqMFu6hWHXCF+WaYt64m9QBmNxi7Ioy7D+fa1yHw+FMAcPt7SysFLtoG4PXAk7JOA3aAxBRqUiAdU9Yp5lK3HLSRFtOim0sa8euEt08xvKjYjzeJ2GU7YawexrnKI9tmobInjFXCewpwriY9+RR4aaezFhMhGCppKwom0ChrgFlKzyPKkGlTW1YQrE9HJqu8hKGgMc6hVi5QRq0PZxNfrYNgE64utmRv6KKHRpxf6VDUaOvNP5jCEx5q185My/7RKz69UQu2im5k4/eownpxZxNLwiZ1AZTO2ZjWjkU9uaB2HFn6Q3u0JcsSx/qV9hTEApRzeBLDJQXxYmTnq7bdLa3+uqFrxLJ5w1TehnNHx5ECvCh2g2c3hHH5YsfdaSKddztfjQ6imKFGSyFwlLzxEGPp6r5IevVjk1AMx3wMqi1NxDVjLBiPs9tbsCkIY5we5/ML22zrCScFxnNtzsr9Wcc3CnD+pYO+4VXXiDE0oc/vQQ/fDK3oPESJMYXNmJa/DuloJZkcTpcYE8lIH8Dz8DJMiynNC86Mb2lNaaqP/+L7f2fcE/yP7/Lde8xfgSOdMxvOixZf/9p3+M4hT1+F+zApxg9XfUvYjc8qX2lfOOpK2gNRtB4flpFu9FTKCp2XJRgXnX6olp1zyYjTKJSkGmLE2NjUr1bxFM4AeAAHBUFIeSLqXR+NvH/M9fOnfHzOD2vCSyQJKzfgsCh+yi/Mmc35F2fUrw7miW33W9hBD1vpuUojFphIyvg7aTeoymDkIkeW3XLHmguMzbIAJejN6B5MDrhipE2y6SoFRO/AK/AcHHZHNIfiWrEe/C6cr3f/yOvrQKB+zMM55/GQdLDsR+ifr5Fiuu+/y+M78LzOE5dsNuXC3PYvYWd8NXvphLSkJIasrlD2/HOqQ+RjcRdjKTGWYhhVUm4yxlyiGPuMsZR7sMCHUBeTuNWA7if+ifXgc/hovftHXs/DV+Fvwe+f8shzMiMcweFgBly3//vwJfg5AN4450fn1Hd1Rm1aBLu22Dy3y3H2+OqMemkbGZ4jozcDjJf6596xOLpC0eMTHbKnxLxH27uZ/bMTGs2jOaMOY4m87CfQwF0dw53oa1k80JRuz/XgS+8fX3N9Af4qPIMfzKgCp4H5TDGe9GGeFPzSsZz80SlPTxXjgwJmC45njzgt2vbQ4b4OAdUK4/vWhO8d8v6EE8fMUsfakXbPpFJeLs2ubM/qdm/la3WP91uWhxXHjoWhyRUq2iJ/+5mA73zwIIo+LoZ/SgvIRjAd1IMvvn98PfgOvAJfhhm8scAKVWDuaRaK8aQ9f7vuPDH6Bj47ZXau7rqYJ66mTDwEDU6lLbCjCK0qTXyl5mnDoeNRxanj3FJbaksTk0faXxHxLrssgPkWB9LnA/MFleXcJozzjwsUvUG0X/QCve51qkMDXp9mtcyOy3rwBfdvVJK7D6/ACSzg3RoruIq5UDeESfEmVclDxnniU82vxMLtceD0hGZWzBNPMM/jSPne2OVatiTKUpY5vY7gc0LdUAWeWM5tH+O2I66AOWw9xT2BuyRVLGdoDHUsVRXOo/c+ZdRXvFfnxWyIV4upFLCl9eAL7h8Zv0QH8Ry8pA2cHzQpGesctVA37ZtklBTgHjyvdSeKY/RZw/kJMk0Y25cSNRWSigQtlULPTw+kzuJPeYEkXjQRpoGZobYsLF79pyd1dMRHInbgFTZqNLhDqiIsTNpoex2WLcy0/X6rHcdMMQvFSd5dWA++4P7xv89deACnmr36uGlL69bRCL6BSZsS6c0TU2TKK5gtWCzgAOOwQcurqk9j8whvziZSMLcq5hbuwBEsYjopUBkqw1yYBGpLA97SRElEmx5MCInBY5vgLk94iKqSWmhIGmkJ4Bi9m4L645J68LyY4wsFYBfUg5feP/6gWWm58IEmKQM89hq7KsZNaKtP5TxxrUZZVkNmMJtjbKrGxLNEbHPJxhqy7lAmbC32ZqeF6lTaknRWcYaFpfLUBh/rwaQycCCJmW15Kstv6jRHyJFry2C1ahkkIW0LO75s61+owxK1y3XqweX9m5YLM2DPFeOjn/iiqCKJ+yKXF8t5Yl/kNsqaSCryxPq5xWTFIaP8KSW0RYxqupaUf0RcTNSSdJZGcKYdYA6kdtrtmyBckfKXwqk0pHpUHlwWaffjNRBYFPUDWa8e3Lt/o0R0CdisKDM89cX0pvRHEfM8ca4t0s2Xx4kgo91MPQJ/0c9MQYq0co8MBh7bz1fio0UUHLR4aAIOvOmoYO6kwlEVODSSTliWtOtH6sPkrtctF9ZtJ9GIerBskvhdVS5cFNv9s1BU0AbdUgdK4FG+dRnjFmDTzniRMdZO1QhzMK355vigbdkpz9P6qjUGE5J2qAcXmwJ20cZUiAD0z+pGMx6xkzJkmEf40Hr4qZfVg2XzF9YOyoV5BjzVkUJngKf8lgNYwKECEHrCNDrWZzMlflS3yBhr/InyoUgBc/lKT4pxVrrC6g1YwcceK3BmNxZcAtz3j5EIpqguh9H6wc011YN75cKDLpFDxuwkrPQmUwW4KTbj9mZTwBwLq4aQMUZbHm1rylJ46dzR0dua2n3RYCWZsiHROeywyJGR7mXKlpryyCiouY56sFkBWEnkEB/raeh/Sw4162KeuAxMQpEkzy5alMY5wamMsWKKrtW2WpEWNnReZWONKWjrdsKZarpFjqCslq773PLmEhM448Pc3+FKr1+94vv/rfw4tEcu+lKTBe4kZSdijBrykwv9vbCMPcLQTygBjzVckSLPRVGslqdunwJ4oegtFOYb4SwxNgWLCmD7T9kVjTv5YDgpo0XBmN34Z/rEHp0sgyz7lngsrm4lvMm2Mr1zNOJYJ5cuxuQxwMGJq/TP5emlb8fsQBZviK4t8hFL+zbhtlpwaRSxQRWfeETjuauPsdGxsBVdO7nmP4xvzSoT29pRl7kGqz+k26B3Oy0YNV+SXbbQas1ctC/GarskRdFpKczVAF1ZXnLcpaMuzVe6lZ2g/1ndcvOVgRG3sdUAY1bKD6achijMPdMxV4muKVorSpiDHituH7rSTs7n/4y5DhRXo4FVBN4vO/zbAcxhENzGbHCzU/98Mcx5e7a31kWjw9FCe/zNeYyQjZsWb1uc7U33pN4Mji6hCLhivqfa9Ss6xLg031AgfesA/l99m9fgvnaF9JoE6bYKmkGNK3aPbHB96w3+DnxFm4hs0drLsk7U8kf/N/CvwQNtllna0rjq61sH8L80HAuvwH1tvBy2ChqWSCaYTaGN19sTvlfzFD6n+iKTbvtayfrfe9ueWh6GJFoxLdr7V72a5ZpvHcCPDzma0wTO4EgbLyedxstO81n57LYBOBzyfsOhUKsW1J1BB5vr/tz8RyqOFylQP9Tvst2JALsC5lsH8PyQ40DV4ANzYa4dedNiKNR1s+x2wwbR7q4/4cTxqEk4LWDebfisuo36JXLiWFjOtLrlNWh3K1rRS4xvHcDNlFnNmWBBAl5SWaL3oPOfnvbr5pdjVnEaeBJSYjuLEkyLLsWhKccadmOphZkOPgVdalj2QpSmfOsADhMWE2ZBu4+EEJI4wKTAuCoC4xwQbWXBltpxbjkXJtKxxabo9e7tyhlgb6gNlSbUpMh+l/FaqzVwewGu8BW1Zx7pTpQDJUjb8tsUTW6+GDXbMn3mLbXlXJiGdggxFAoUrtPS3wE4Nk02UZG2OOzlk7fRs7i95QCLo3E0jtrjnM7SR3uS1p4qtS2nJ5OwtQVHgOvArLBFijZUV9QtSl8dAY5d0E0hM0w3HS2DpIeB6m/A1+HfhJcGUq4sOxH+x3f5+VO+Ds9rYNI7zPXOYWPrtf8bYMx6fuOAX5jzNR0PdsuON+X1f7EERxMJJoU6GkTEWBvVolVlb5lh3tKCg6Wx1IbaMDdJ+9sUCc5KC46hKGCk3IVOS4TCqdBNfUs7Kd4iXf2RjnT/LLysJy3XDcHLh/vde3x8DoGvwgsa67vBk91G5Pe/HbOe7xwym0NXbtiuuDkGO2IJDh9oQvJ4cY4vdoqLDuoH9Zl2F/ofsekn8lkuhIlhQcffUtSjytFyp++p6NiE7Rqx/lodgKVoceEp/CP4FfjrquZaTtj2AvH5K/ywpn7M34K/SsoYDAdIN448I1/0/wveW289T1/lX5xBzc8N5IaHr0XMOQdHsIkDuJFifj20pBm5jzwUv9e2FhwRsvhAbalCIuIw3bhJihY3p6nTFFIZgiSYjfTf3aXuOjmeGn4bPoGvwl+CFzTRczBIuHBEeImHc37/lGfwZR0cXzVDOvaKfNHvwe+suZ771K/y/XcBlsoN996JpBhoE2toYxOznNEOS5TJc6Id5GEXLjrWo+LEWGNpPDU4WAwsIRROu+1vM+0oW37z/MBN9kqHnSArwPfgFJ7Cq/Ai3Ie7g7ncmI09v8sjzw9mzOAEXoIHxURueaAce5V80f/DOuuZwHM8vsMb5wBzOFWM7wymTXPAEvm4vcFpZ2ut0VZRjkiP2MlmLd6DIpbGSiHOjdnUHN90hRYmhTnmvhzp1iKDNj+b7t5hi79lWGwQ+HN9RsfFMy0FXbEwhfuczKgCbyxYwBmcFhhvo/7a44v+i3XWcwDP86PzpGQYdWh7csP5dBvZ1jNzdxC8pBGuxqSW5vw40nBpj5JhMwvOzN0RWqERHMr4Lv1kWX84xLR830G3j6yqZ1a8UstTlW+qJPOZ+sZ7xZPKTJLhiNOAFd6tk+jrTH31ncLOxid8+nzRb128HhUcru/y0Wn6iT254YPC6FtVSIMoW2sk727AhvTtrWKZTvgsmckfXYZWeNRXx/3YQ2OUxLDrbHtN11IwrgXT6c8dATDwLniYwxzO4RzuQqTKSC5gAofMZ1QBK3zQ4JWobFbcvJm87FK+6JXrKahLn54m3p+McXzzYtP8VF/QpJuh1OwieElEoI1pRxPS09FBrkq2tWCU59+HdhNtTIqKm8EBrw2RTOEDpG3IKo2Y7mFdLm3ZeVjYwVw11o/oznceMve4CgMfNym/utA/d/ILMR7gpXzRy9eDsgLcgbs8O2Va1L0zzIdwGGemTBuwROHeoMShkUc7P+ISY3KH5ZZeWqO8mFTxQYeXTNuzvvK5FGPdQfuu00DwYFY9dyhctEt+OJDdnucfpmyhzUJzfsJjr29l8S0bXBfwRS9ZT26tmMIdZucch5ZboMz3Nio3nIOsYHCGoDT4kUA9MiXEp9Xsui1S8th/kbWIrMBxDGLodWUQIWcvnXy+9M23xPiSMOiRPqM+YMXkUN3gXFrZJwXGzUaMpJfyRS9ZT0lPe8TpScuRlbMHeUmlaKDoNuy62iWNTWNFYjoxFzuJs8oR+RhRx7O4SVNSXpa0ZJQ0K1LAHDQ+D9IepkMXpcsq5EVCvClBUIzDhDoyKwDw1Lc59GbTeORivugw1IcuaEOaGWdNm+Ps5fQ7/tm0DjMegq3yM3vb5j12qUId5UZD2oxDSEWOZMSqFl/W+5oynWDa/aI04tJRQ2eTXusg86SQVu/nwSYwpW6wLjlqIzwLuxGIvoAvul0PS+ZNz0/akp/pniO/8JDnGyaCkzbhl6YcqmK/69prxPqtpx2+Km9al9sjL+rwMgHw4jE/C8/HQ3m1vBuL1fldbzd8mOueVJ92syqdEY4KJjSCde3mcRw2TA6szxedn+zwhZMps0XrqEsiUjnC1hw0TELC2Ek7uAAdzcheXv1BYLagspxpzSAoZZUsIzIq35MnFQ9DOrlNB30jq3L4pkhccKUAA8/ocvN1Rzx9QyOtERs4CVsJRK/DF71kPYrxYsGsm6RMh4cps5g1DOmM54Ly1ii0Hd3Y/BMk8VWFgBVmhqrkJCPBHAolwZaWzLR9Vb7bcWdX9NyUYE+uB2BKfuaeBUcjDljbYVY4DdtsVWvzRZdWnyUzDpjNl1Du3aloAjVJTNDpcIOVVhrHFF66lLfJL1zJr9PQ2nFJSBaKoDe+sAvLufZVHVzYh7W0h/c6AAZ+7Tvj6q9j68G/cTCS/3n1vLKHZwNi+P+pS0WkZNMBMUl+LDLuiE4omZy71r3UFMwNJV+VJ/GC5ixVUkBStsT4gGKh0Gm4Oy3qvq7Lbmq24nPdDuDR9deR11XzP4vFu3TYzfnIyiSVmgizUYGqkIXNdKTY9pgb9D2Ix5t0+NHkVzCdU03suWkkVZAoCONCn0T35gAeW38de43mf97sMOpSvj4aa1KYUm58USI7Wxxes03bAZdRzk6UtbzMaCQ6IxO0dy7X+XsjoD16hpsBeGz9dfzHj+R/Hp8nCxZRqkEDTaCKCSywjiaoMJ1TITE9eg7Jqnq8HL6gDwiZb0u0V0Rr/rmvqjxKuaLCX7ZWXTvAY+uvm3z8CP7nzVpngqrJpZKwWnCUjIviYVlirlGOzPLI3SMVyp/elvBUjjDkNhrtufFFErQ8pmdSlbK16toBHlt/HV8uHMX/vEGALkV3RJREiSlopxwdMXOZPLZ+ix+kAHpMKIk8UtE1ygtquttwxNhphrIZ1IBzjGF3IIGxGcBj6q8bHJBG8T9vdsoWrTFEuebEZuVxhhClH6P5Zo89OG9fwHNjtNQTpD0TG9PJLEYqvEY6Rlxy+ZZGfL0Aj62/bnQCXp//eeM4KzfQVJbgMQbUjlMFIm6TpcfWlZje7NBSV6IsEVmumWIbjiloUzQX9OzYdo8L1wjw2PrrpimONfmfNyzKklrgnEkSzT5QWYQW40YShyzqsRmMXbvVxKtGuYyMKaU1ugenLDm5Ily4iT14fP11Mx+xJv+zZ3MvnfdFqxU3a1W/FTB4m3Qfsyc1XUcdVhDeUDZXSFHHLQj/Y5jtC7ZqM0CXGwB4bP11i3LhOvzPGygYtiUBiwQV/4wFO0majijGsafHyRLu0yG6q35cL1rOpVxr2s5cM2jJYMCdc10Aj6q/blRpWJ//+dmm5psMl0KA2+AFRx9jMe2WbC4jQxnikd4DU8TwUjRVacgdlhmr3bpddzuJ9zXqr2xnxJfzP29RexdtjDVZqzkqa6PyvcojGrfkXiJ8SEtml/nYskicv0ivlxbqjemwUjMw5evdg8fUX9nOiC/lf94Q2i7MURk9nW1MSj5j8eAyV6y5CN2S6qbnw3vdA1Iwq+XOSCl663udN3IzLnrt+us25cI1+Z83SXQUldqQq0b5XOT17bGpLd6ssN1VMPf8c+jG8L3NeCnMdF+Ra3fRa9dft39/LuZ/3vwHoHrqGmQFafmiQw6eyzMxS05K4bL9uA+SKUQzCnSDkqOGokXyJvbgJ/BHI+qvY69//4rl20NsmK2ou2dTsyIALv/91/8n3P2Aao71WFGi8KKv1fRC5+J67Q/507/E/SOshqN5TsmYIjVt+kcjAx98iz/4SaojbIV1rexE7/C29HcYD/DX4a0rBOF5VTu7omsb11L/AWcVlcVZHSsqGuXLLp9ha8I//w3Mv+T4Ew7nTBsmgapoCrNFObIcN4pf/Ob/mrvHTGqqgAupL8qWjWPS9m/31jAe4DjA+4+uCoQoT/zOzlrNd3qd4SdphFxsUvYwGWbTWtISc3wNOWH+kHBMfc6kpmpwPgHWwqaSUG2ZWWheYOGQGaHB+eQ/kn6b3pOgLV+ODSn94wDvr8Bvb70/LLuiPPEr8OGVWfDmr45PZyccEmsVXZGe1pRNX9SU5+AVQkNTIVPCHF/jGmyDC9j4R9LfWcQvfiETmgMMUCMN1uNCakkweZsowdYobiMSlnKA93u7NzTXlSfe+SVbfnPQXmg9LpYAQxpwEtONyEyaueWM4FPjjyjG3uOaFmBTWDNgBXGEiQpsaWhnAqIijB07Dlsy3fUGeP989xbWkyf+FF2SNEtT1E0f4DYYVlxFlbaSMPIRMk/3iMU5pME2SIWJvjckciebkQuIRRyhUvkHg/iUljG5kzVog5hV7vIlCuBrmlhvgPfNHQM8lCf+FEGsYbMIBC0qC9a0uuy2wLXVbLBaP5kjHokCRxapkQyzI4QEcwgYHRZBp+XEFTqXFuNVzMtjXLJgX4gAid24Hjwc4N3dtVSe+NNiwTrzH4WVUOlDobUqr1FuAgYllc8pmzoVrELRHSIW8ViPxNy4xwjBpyR55I6J220qQTZYR4guvUICJiSpr9gFFle4RcF/OMB7BRiX8sSfhpNSO3lvEZCQfLUVTKT78Ek1LRLhWN+yLyTnp8qWUZ46b6vxdRGXfHVqx3eI75YaLa4iNNiK4NOW7wPW6lhbSOF9/M9qw8e/aoB3d156qTzxp8pXx5BKAsYSTOIIiPkp68GmTq7sZtvyzBQaRLNxIZ+paozHWoLFeExIhRBrWitHCAHrCF7/thhD8JhYz84wg93QRV88wLuLY8zF8sQ36qF1J455bOlgnELfshKVxYOXKVuKx0jaj22sczTQqPqtV/XDgpswmGTWWMSDw3ssyUunLLrVPGjYRsH5ggHeHSWiV8kT33ycFSfMgkoOK8apCye0J6VW6GOYvffgU9RWsukEi2kUV2nl4dOYUzRik9p7bcA4ggdJ53LxKcEe17B1R8eqAd7dOepV8sTXf5lhejoL85hUdhDdknPtKHFhljOT+bdq0hxbm35p2nc8+Ja1Iw+tJykgp0EWuAAZYwMVwac5KzYMslhvgHdHRrxKnvhTYcfKsxTxtTETkjHO7rr3zjoV25lAQHrqpV7bTiy2aXMmUhTBnKS91jhtR3GEoF0oLnWhWNnYgtcc4N0FxlcgT7yz3TgNIKkscx9jtV1ZKpWW+Ub1tc1eOv5ucdgpx+FJy9pgbLE7xDyXb/f+hLHVGeitHOi6A7ybo3sF8sS7w7cgdk0nJaOn3hLj3uyD0Zp5pazFIUXUpuTTU18d1EPkDoX8SkmWTnVIozEdbTcZjoqxhNHf1JrSS/AcvHjZ/SMHhL/7i5z+POsTUh/8BvNfYMTA8n+yU/MlTZxSJDRStqvEuLQKWwDctMTQogUDyQRoTQG5Kc6oQRE1yV1jCA7ri7jdZyK0sYTRjCR0Hnnd+y7nHxNgTULqw+8wj0mQKxpYvhjm9uSUxg+TTy7s2GtLUGcywhXSKZN275GsqlclX90J6bRI1aouxmgL7Q0Nen5ziM80SqMIo8cSOo+8XplT/5DHNWsSUr/6lLN/QQ3rDyzLruEW5enpf7KqZoShEduuSFOV7DLX7Ye+GmXb6/hnNNqKsVXuMDFpb9Y9eH3C6NGEzuOuI3gpMH/I6e+zDiH1fXi15t3vA1czsLws0TGEtmPEJdiiFPwlwKbgLHAFk4P6ZyPdymYYHGE0dutsChQBl2JcBFlrEkY/N5bQeXQ18gjunuMfMfsBlxJSx3niO485fwO4fGD5T/+3fPQqkneWVdwnw/3bMPkW9Wbqg+iC765Zk+xcT98ibKZc2EdgHcLoF8cSOo/Oc8fS+OyEULF4g4sJqXVcmfMfsc7A8v1/yfGXmL9I6Fn5pRwZhsPv0TxFNlAfZCvG+Oohi82UC5f/2IsJo0cTOm9YrDoKhFPEUr/LBYTUNht9zelHXDqwfPCIw4owp3mOcIQcLttWXFe3VZ/j5H3cIc0G6oPbCR+6Y2xF2EC5cGUm6wKC5tGEzhsWqw5hNidUiKX5gFWE1GXh4/Qplw4sVzOmx9QxU78g3EF6wnZlEN4FzJ1QPSLEZz1KfXC7vd8ssGdIbNUYpVx4UapyFUHzJoTOo1McSkeNn1M5MDQfs4qQuhhX5vQZFw8suwWTcyYTgioISk2YdmkhehG4PkE7w51inyAGGaU+uCXADabGzJR1fn3lwkty0asIo8cROm9Vy1g0yDxxtPvHDAmpu+PKnM8Ix1wwsGw91YJqhteaWgjYBmmQiebmSpwKKzE19hx7jkzSWOm66oPbzZ8Yj6kxVSpYjVAuvLzYMCRo3oTQecOOjjgi3NQ4l9K5/hOGhNTdcWVOTrlgYNkEXINbpCkBRyqhp+LdRB3g0OU6rMfW2HPCFFMV9nSp+uB2woepdbLBuJQyaw/ZFysXrlXwHxI0b0LovEkiOpXGA1Ijagf+KUNC6rKNa9bQnLFqYNkEnMc1uJrg2u64ELPBHpkgWbmwKpJoDhMwNbbGzAp7Yg31wS2T5rGtzit59PrKhesWG550CZpHEzpv2NGRaxlNjbMqpmEIzygJqQfjypycs2pg2cS2RY9r8HUqkqdEgKTWtWTKoRvOBPDYBltja2SO0RGjy9UHtxwRjA11ujbKF+ti5cIR9eCnxUg6owidtyoU5tK4NLji5Q3HCtiyF2IqLGYsHViOXTXOYxucDqG0HyttqYAKqYo3KTY1ekyDXRAm2AWh9JmsVh/ccg9WJ2E8YjG201sPq5ULxxX8n3XLXuMInbft2mk80rRGjCGctJ8/GFdmEQ9Ug4FlE1ll1Y7jtiraqm5Fe04VV8lvSVBL8hiPrfFVd8+7QH3Qbu2ipTVi8cvSGivc9cj8yvH11YMHdNSERtuOslM97feYFOPKzGcsI4zW0YGAbTAOaxCnxdfiYUmVWslxiIblCeAYr9VYR1gM7GmoPrilunSxxeT3DN/2eBQ9H11+nk1adn6VK71+5+Jfct4/el10/7KBZfNryUunWSCPxPECk1rdOv1WVSrQmpC+Tl46YD3ikQYcpunSQgzVB2VHFhxHVGKDgMEY5GLlQnP7FMDzw7IacAWnO6sBr12u+XanW2AO0wQ8pknnFhsL7KYIqhkEPmEXFkwaN5KQphbkUmG72wgw7WSm9RiL9QT925hkjiVIIhphFS9HKI6/8QAjlpXqg9W2C0apyaVDwKQwrwLY3j6ADR13ZyUNByQXHQu6RY09Hu6zMqXRaNZGS/KEJs0cJEe9VH1QdvBSJv9h09eiRmy0V2uJcqHcShcdvbSNg5fxkenkVprXM9rDVnX24/y9MVtncvbKY706anNl3ASll9a43UiacVquXGhvq4s2FP62NGKfQLIQYu9q1WmdMfmUrDGt8eDS0cXozH/fjmUH6Jruvm50hBDSaEU/2Ru2LEN/dl006TSc/g7tfJERxGMsgDUEr104pfWH9lQaN+M4KWQjwZbVc2rZVNHsyHal23wZtIs2JJqtIc/WLXXRFCpJkfE9jvWlfFbsNQ9pP5ZBS0zKh4R0aMFj1IjTcTnvi0Zz2rt7NdvQb2mgbju1plsH8MmbnEk7KbK0b+wC2iy3aX3szW8xeZvDwET6hWZYwqTXSSG+wMETKum0Dq/q+x62gt2ua2ppAo309TRk9TPazfV3qL9H8z7uhGqGqxNVg/FKx0HBl9OVUORn8Q8Jx9gFttGQUDr3tzcXX9xGgN0EpzN9mdZ3GATtPhL+CjxFDmkeEU6x56kqZRusLzALXVqkCN7zMEcqwjmywDQ6OhyUe0Xao1Qpyncrg6wKp9XfWDsaZplElvQ/b3sdweeghorwBDlHzgk1JmMc/wiERICVy2VJFdMjFuLQSp3S0W3+sngt2njwNgLssFGVQdJ0tu0KH4ky1LW4yrbkuaA6Iy9oz/qEMMXMMDWyIHhsAyFZc2peV9hc7kiKvfULxCl9iddfRK1f8kk9qvbdOoBtOg7ZkOZ5MsGrSHsokgLXUp9y88smniwWyuFSIRVmjplga3yD8Uij5QS1ZiM4U3Qw5QlSm2bXjFe6jzzBFtpg+/YBbLAWG7OPynNjlCw65fukGNdkJRf7yM1fOxVzbxOJVocFoYIaGwH22mIQkrvu1E2nGuebxIgW9U9TSiukPGU+Lt++c3DJPKhyhEEbXCQLUpae2exiKy6tMPe9mDRBFCEMTWrtwxN8qvuGnt6MoihKWS5NSyBhbH8StXoAz8PLOrRgLtOT/+4vcu+7vDLnqNvztOq7fmd8sMmY9Xzn1zj8Dq8+XVdu2Nv0IIySgEdQo3xVHps3Q5i3fLFsV4aiqzAiBhbgMDEd1uh8qZZ+lwhjkgokkOIv4xNJmyncdfUUzgB4oFMBtiu71Xumpz/P+cfUP+SlwFExwWW62r7b+LSPxqxn/gvMZ5z9C16t15UbNlq+jbGJtco7p8wbYlL4alSyfWdeuu0j7JA3JFNuVAwtst7F7FhWBbPFNKIUORndWtLraFLmMu7KFVDDOzqkeaiN33YAW/r76wR4XDN/yN1z7hejPau06EddkS/6XThfcz1fI/4K736fO48vlxt2PXJYFaeUkFS8U15XE3428xdtn2kc8GQlf1vkIaNRRnOMvLTWrZbElEHeLWi1o0dlKPAh1MVgbbVquPJ5+Cr8LU5/H/+I2QlHIU2ClXM9G8v7Rr7oc/hozfUUgsPnb3D+I+7WF8kNO92GY0SNvuxiE+2Bt8prVJTkzE64sfOstxuwfxUUoyk8VjcTlsqe2qITSFoSj6Epd4KsT6BZOWmtgE3hBfir8IzZDwgV4ZTZvD8VvPHERo8v+vL1DASHTz/i9OlKueHDjK5Rnx/JB1Vb1ioXdBra16dmt7dgik10yA/FwJSVY6XjA3oy4SqM2frqDPPSRMex9qs3XQtoWxMj7/Er8GWYsXgjaVz4OYumP2+9kbxvny/6kvWsEBw+fcb5bInc8APdhpOSs01tEqIkoiZjbAqKMruLbJYddHuHFRIyJcbdEdbl2sVLaySygunutBg96Y2/JjKRCdyHV+AEFtTvIpbKIXOamknYSiB6KV/0JetZITgcjjk5ZdaskBtWO86UF0ap6ozGXJk2WNiRUlCPFir66lzdm/SLSuK7EUdPz8f1z29Skq6F1fXg8+5UVR6bszncP4Tn4KUkkdJ8UFCY1zR1i8RmL/qQL3rlei4THG7OODlnKko4oI01kd3CaM08Ia18kC3GNoVaO9iDh+hWxSyTXFABXoau7Q6q9OxYg/OVEMw6jdbtSrJ9cBcewGmaZmg+bvkUnUUaGr+ZfnMH45Ivevl61hMcXsxYLFTu1hTm2zViCp7u0o5l+2PSUh9bDj6FgYypufBDhqK2+oXkiuHFHR3zfj+9PtA8oR0xnqX8qn+sx3bFODSbbF0X8EUvWQ8jBIcjo5bRmLOljDNtcqNtOe756h3l0VhKa9hDd2l1eqmsnh0MNMT/Cqnx6BInumhLT8luljzQ53RiJeA/0dxe5NK0o2fA1+GLXr6eNQWHNUOJssQaTRlGpLHKL9fD+IrQzTOMZS9fNQD4AnRNVxvTdjC+fJdcDDWQcyB00B0t9BDwTxXgaAfzDZ/DBXzRnfWMFRwuNqocOmX6OKNkY63h5n/fFcB28McVHqnXZVI27K0i4rDLNE9lDKV/rT+udVbD8dFFu2GGZ8mOt0kAXcoX3ZkIWVtw+MNf5NjR2FbivROHmhV1/pj2egv/fMGIOWTIWrV3Av8N9imV9IWml36H6cUjqEWNv9aNc+veb2sH46PRaHSuMBxvtW+twxctq0z+QsHhux8Q7rCY4Ct8lqsx7c6Sy0dl5T89rIeEuZKoVctIk1hNpfavER6yyH1Vvm3MbsUHy4ab4hWr/OZPcsRBphnaV65/ZcdYPNNwsjN/djlf9NqCw9U5ExCPcdhKxUgLSmfROpLp4WSUr8ojdwbncbvCf+a/YzRaEc6QOvXcGO256TXc5Lab9POvB+AWY7PigWYjzhifbovuunzRawsO24ZqQQAqguBtmpmPB7ysXJfyDDaV/aPGillgz1MdQg4u5MYaEtBNNHFjkRlSpd65lp4hd2AVPTfbV7FGpyIOfmNc/XVsPfg7vzaS/3nkvLL593ANLvMuRMGpQIhiF7kUEW9QDpAUbTWYBcbp4WpacHHY1aacqQyjGZS9HI3yCBT9kUZJhVOD+zUDvEH9ddR11fzPcTDQ5TlgB0KwqdXSavk9BC0pKp0WmcuowSw07VXmXC5guzSa4p0UvRw2lbDiYUx0ExJJRzWzi6Gm8cnEkfXXsdcG/M/jAJa0+bmCgdmQ9CYlNlSYZOKixmRsgiFxkrmW4l3KdFKv1DM8tk6WxPYJZhUUzcd8Kdtgrw/gkfXXDT7+avmfVak32qhtkg6NVdUS5wgkru1YzIkSduTW1FDwVWV3JQVJVuieTc0y4iDpFwc7/BvSalvKdQM8sv662cevz/+8sQVnjVAT0W2wLllw1JiMhJRxgDjCjLQsOzSFSgZqx7lAW1JW0e03yAD3asC+GD3NbQhbe+mN5GXH1F83KDOM4n/e5JIuH4NpdQARrFPBVptUNcjj4cVMcFSRTE2NpR1LEYbYMmfWpXgP9KejaPsLUhuvLCsVXznAG9dfx9SR1ud/3hZdCLHb1GMdPqRJgqDmm76mHbvOXDtiO2QPUcKo/TWkQ0i2JFXpBoo7vij1i1Lp3ADAo+qvG3V0rM//vFnnTE4hxd5Ka/Cor5YEdsLVJyKtDgVoHgtW11pWSjolPNMnrlrVj9Fv2Qn60twMwKPqr+N/wvr8z5tZcDsDrv06tkqyzESM85Ycv6XBWA2birlNCXrI6VbD2lx2L0vQO0QVTVVLH4SE67fgsfVXv8n7sz7/85Z7cMtbE6f088wSaR4kCkCm10s6pKbJhfqiUNGLq+0gLWC6eUAZFPnLjwqtKd8EwGvWX59t7iPW4X/eAN1svgRVSY990YZg06BD1ohLMtyFTI4pKTJsS9xREq9EOaPWiO2gpms7397x6nQJkbh+Fz2q/rqRROX6/M8bJrqlVW4l6JEptKeUFuMYUbtCQ7CIttpGc6MY93x1r1vgAnRXvY5cvwWPqb9uWQm+lP95QxdNMeWhOq1x0Db55C7GcUv2ZUuN6n8iKzsvOxibC//Yfs9Na8r2Rlz02vXXDT57FP/zJi66/EJSmsJKa8QxnoqW3VLQ+jZVUtJwJ8PNX1NQCwfNgdhhHD9on7PdRdrdGPF28rJr1F+3LBdeyv+8yYfLoMYet1vX4upNAjVvwOUWnlNXJXlkzk5Il6kqeoiL0C07qno+/CYBXq/+utlnsz7/Mzvy0tmI4zm4ag23PRN3t/CWryoUVJGm+5+K8RJ0V8Hc88/XHUX/HfiAq7t+BH+x6v8t438enWmdJwFA6ZINriLGKv/95f8lT9/FnyA1NMVEvQyaXuu+gz36f/DD73E4pwqpLcvm/o0Vle78n//+L/NPvoefp1pTJye6e4A/D082FERa5/opeH9zpvh13cNm19/4v/LDe5xMWTi8I0Ta0qKlK27AS/v3/r+/x/2GO9K2c7kVMonDpq7//jc5PKCxeNPpFVzaRr01wF8C4Pu76hXuX18H4LduTr79guuFD3n5BHfI+ZRFhY8w29TYhbbLi/bvBdqKE4fUgg1pBKnV3FEaCWOWyA+m3WpORZr/j+9TKJtW8yBTF2/ZEODI9/QavHkVdGFp/Pjn4Q+u5hXapsP5sOH+OXXA1LiKuqJxiMNbhTkbdJTCy4llEt6NnqRT4dhg1V3nbdrm6dYMecA1yTOL4PWTE9L5VzPFlLBCvlG58AhehnN4uHsAYinyJ+AZ/NkVvELbfOBUuOO5syBIEtiqHU1k9XeISX5bsimrkUUhnGDxourN8SgUsCZVtKyGbyGzHXdjOhsAvOAswSRyIBddRdEZWP6GZhNK/yjwew9ehBo+3jEADu7Ay2n8mDc+TS7awUHg0OMzR0LABhqLD4hJEh/BEGyBdGlSJoXYXtr+3HS4ijzVpgi0paWXtdruGTknXBz+11qT1Q2inxaTzQCO46P3lfLpyS4fou2PH/PupwZgCxNhGlj4IvUuWEsTkqMWm6i4xCSMc9N1RDQoCVcuGItJ/MRWefais+3synowi/dESgJjkilnWnBTGvRWmaw8oR15257t7CHmCf8HOn7cwI8+NQBXMBEmAa8PMRemrNCEhLGEhDQKcGZWS319BX9PFBEwGTbRBhLbDcaV3drFcDqk5kCTd2JF1Wp0HraqBx8U0wwBTnbpCadwBA/gTH/CDrcCs93LV8E0YlmmcyQRQnjBa8JESmGUfIjK/7fkaDJpmD2QptFNVJU1bbtIAjjWQizepOKptRjbzR9Kag6xZmMLLjHOtcLT3Tx9o/0EcTT1XN3E45u24AiwEypDJXihKjQxjLprEwcmRKclaDNZCVqr/V8mYWyFADbusiY5hvgFoU2vio49RgJLn5OsReRFN6tabeetiiy0V7KFHT3HyZLx491u95sn4K1QQSPKM9hNT0wMVvAWbzDSVdrKw4zRjZMyJIHkfq1VAVCDl/bUhNKlGq0zGr05+YAceXVPCttVk0oqjVwMPt+BBefx4yPtGVkUsqY3CHDPiCM5ngupUwCdbkpd8kbPrCWHhkmtIKLEetF2499eS1jZlIPGYnlcPXeM2KD9vLS0bW3ktYNqUllpKLn5ZrsxlIzxvDu5eHxzGLctkZLEY4PgSOg2IUVVcUONzUDBEpRaMoXNmUc0tFZrTZquiLyKxrSm3DvIW9Fil+AkhXu5PhEPx9mUNwqypDvZWdKlhIJQY7vn2OsnmBeOWnYZ0m1iwbbw1U60by5om47iHRV6fOgzjMf/DAZrlP40Z7syxpLK0lJ0gqaAK1c2KQKu7tabTXkLFz0sCftuwX++MyNeNn68k5Buq23YQhUh0SNTJa1ioQ0p4nUG2y0XilF1JqODqdImloPS4Bp111DEWT0jJjVv95uX9BBV7eB3bUWcu0acSVM23YZdd8R8UbQUxJ9wdu3oMuhdt929ME+mh6JXJ8di2RxbTi6TbrDquqV4aUKR2iwT6aZbyOwEXN3DUsWr8Hn4EhwNyHuXHh7/pdaUjtR7vnDh/d8c9xD/s5f501eQ1+CuDiCvGhk1AN/4Tf74RfxPwD3toLarR0zNtsnPzmS64KIRk861dMWCU8ArasG9T9H0ZBpsDGnjtAOM2+/LuIb2iIUGXNgl5ZmKD/Tw8TlaAuihaFP5yrw18v4x1898zIdP+DDAX1bM3GAMvPgRP/cJn3zCW013nrhHkrITyvYuwOUkcHuKlRSW5C6rzIdY4ppnF7J8aAJbQepgbJYBjCY9usGXDKQxq7RZfh9eg5d1UHMVATRaD/4BHK93/1iAgYZ/+jqPn8Dn4UExmWrpa3+ZOK6MvM3bjwfzxNWA2dhs8+51XHSPJiaAhGSpWevEs5xHLXcEGFXYiCONySH3fPWq93JIsBiSWvWyc3CAN+EcXoT7rCSANloPPoa31rt/5PUA/gp8Q/jDD3hyrjzlR8VkanfOvB1XPubt17vzxAfdSVbD1pzAnfgyF3ycadOTOTXhpEUoLC1HZyNGW3dtmjeXgr2r56JNmRwdNNWaQVBddd6rh4MhviEB9EFRD/7RGvePvCbwAL4Mx/D6M541hHO4D3e7g6PafdcZVw689z7NGTwo5om7A8sPhccT6qKcl9NJl9aM/9kX+e59Hh1yPqGuCCZxuITcsmNaJ5F7d0q6J3H48TO1/+M57085q2icdu2U+W36Ldllz9Agiv4YGljoEN908EzvDOrBF98/vtJwCC/BF2AG75xxEmjmMIcjxbjoaxqOK3/4hPOZzhMPBpYPG44CM0dTVm1LjLtUWWVz1Bcf8tEx0zs8O2A2YVHRxKYOiy/aOVoAaMu0i7ubu43njjmd4ibMHU1sIDHaQNKrZND/FZYdk54oCXetjq7E7IVl9eAL7t+oHnwXXtLx44czzoRFHBztYVwtH1d+NOMkupZ5MTM+gUmq90X+Bh9zjRlmaQ+m7YMqUL/veemcecAtOJ0yq1JnVlN27di2E0+Klp1tAJ4KRw1eMI7aJjsO3R8kPSI3fUFXnIOfdQe86sIIVtWDL7h//Ok6vj8vwDk08NEcI8zz7OhBy+WwalzZeZ4+0XniRfst9pAJqQHDGLzVQ2pheZnnv1OWhwO43/AgcvAEXEVVpa4db9sGvNK8wjaENHkfFQ4Ci5i7dqnQlPoLQrHXZDvO3BIXZbJOBrOaEbML6sFL798I4FhKihjHMsPjBUZYCMFr6nvaArxqXPn4lCa+cHfSa2cP27g3Z3ziYTRrcbQNGLQmGF3F3cBdzzzX7AILx0IB9rbwn9kx2G1FW3Inic+ZLIsVvKR8Zwfj0l1fkqo8LWY1M3IX14OX3r9RKTIO+d9XzAI8qRPGPn/4NC2n6o4rN8XJ82TOIvuVA8zLKUHRFgBCetlDZlqR1gLKjS39xoE7Bt8UvA6BxuEDjU3tFsEijgA+615tmZkXKqiEENrh41iLDDZNq4pKTWR3LZfnos81LOuNa15cD956vLMsJd1rqYp51gDUQqMYm2XsxnUhD2jg1DM7SeuJxxgrmpfISSXVIJIS5qJJSvJPEQ49DQTVIbYWJ9QWa/E2+c/oPK1drmC7WSfJRNKBO5Yjvcp7Gc3dmmI/Xh1kDTEuiSnWqQf37h+fTMhGnDf6dsS8SQfQWlqqwXXGlc/PEZ/SC5mtzIV0nAshlQdM/LvUtYutrEZ/Y+EAFtq1k28zQhOwLr1AIeANzhF8t9qzTdZf2qRKO6MWE9ohBYwibbOmrFtNmg3mcS+tB28xv2uKd/agYCvOP+GkSc+0lr7RXzyufL7QbkUpjLjEWFLqOIkAGu2B0tNlO9Eau2W1qcOUvVRgKzypKIQZ5KI3q0MLzqTNRYqiZOqmtqloIRlmkBHVpHmRYV6/HixbO6UC47KOFJnoMrVyr7wYz+SlW6GUaghYbY1I6kkxA2W1fSJokUdSh2LQ1GAimRGm0MT+uu57H5l7QgOWxERpO9moLRPgTtquWCfFlGlIjQaRly9odmzMOWY+IBO5tB4sW/0+VWGUh32qYk79EidWKrjWuiLpiVNGFWFRJVktyeXWmbgBBzVl8anPuXyNJlBJOlKLTgAbi/EYHVHxWiDaVR06GnHQNpJcWcK2jJtiCfG2sEHLzuI66sGrMK47nPIInPnu799935aOK2cvmvubrE38ZzZjrELCmXM2hM7UcpXD2oC3+ECVp7xtIuxptJ0jUr3sBmBS47TVxlvJ1Sqb/E0uLdvLj0lLr29ypdd/eMX3f6lrxGlKwKQxEGvw0qHbkbwrF3uHKwVENbIV2wZ13kNEF6zD+x24aLNMfDTCbDPnEikZFyTNttxWBXDaBuM8KtI2rmaMdUY7cXcUPstqTGvBGSrFWIpNMfbdea990bvAOC1YX0qbc6smDS1mPxSJoW4fwEXvjMmhlijDRq6qale6aJEuFGoppYDoBELQzLBuh/mZNx7jkinv0EtnUp50lO9hbNK57lZaMAWuWR5Yo9/kYwcYI0t4gWM47Umnl3YmpeBPqSyNp3K7s2DSAS/39KRuEN2bS4xvowV3dFRMx/VFcp2Yp8w2nTO9hCXtHG1kF1L4KlrJr2wKfyq77R7MKpFKzWlY9UkhYxyHWW6nBWPaudvEAl3CGcNpSXPZ6R9BbBtIl6cHL3gIBi+42CYXqCx1gfGWe7Ap0h3luyXdt1MKy4YUT9xSF01G16YEdWsouW9mgDHd3veyA97H+Ya47ZmEbqMY72oPztCGvK0onL44AvgC49saZKkWRz4veWljE1FHjbRJaWv6ZKKtl875h4CziFCZhG5rx7tefsl0aRT1bMHZjm8dwL/6u7wCRysaQblQoG5yAQN5zpatMNY/+yf8z+GLcH/Qn0iX2W2oEfXP4GvwQHuIL9AYGnaO3zqAX6946nkgqZNnUhx43DIdQtMFeOPrgy/y3Yd85HlJWwjLFkU3kFwq28xPnuPhMWeS+tDLV9Otllq7pQCf3uXJDN9wFDiUTgefHaiYbdfi3b3u8+iY6TnzhgehI1LTe8lcd7s1wJSzKbahCRxKKztTLXstGAiu3a6rPuQs5pk9TWAan5f0BZmGf7Ylxzzk/A7PAs4QPPPAHeFQ2hbFHszlgZuKZsJcUmbDC40sEU403cEjczstOEypa+YxevL4QBC8oRYqWdK6b7sK25tfE+oDZgtOQ2Jg8T41HGcBE6fTWHn4JtHcu9S7uYgU5KSCkl/mcnq+5/YBXOEr6lCUCwOTOM1taOI8mSxx1NsCXBEmLKbMAg5MkwbLmpBaFOPrNSlO2HnLiEqW3tHEwd8AeiQLmn+2gxjC3k6AxREqvKcJbTEzlpLiw4rNZK6oJdidbMMGX9FULKr0AkW+2qDEPBNNm5QAt2Ik2nftNWHetubosHLo2nG4vQA7GkcVCgVCgaDixHqo9UUn1A6OshapaNR/LPRYFV8siT1cCtJE0k/3WtaNSuUZYKPnsVIW0xXWnMUxq5+En4Kvw/MqQmVXnAXj9Z+9zM98zM/Agy7F/qqj2Nh67b8HjFnPP3iBn/tkpdzwEJX/whIcQUXOaikeliCRGUk7tiwF0rItwMEhjkZ309hikFoRAmLTpEXWuHS6y+am/KB/fM50aLEhGnSMwkpxzOov4H0AvgovwJ1iGzDLtJn/9BU+fAINfwUe6FHSLhu83viV/+/HrOePX+STT2B9uWGbrMHHLldRBlhS/CJQmcRxJFqZica01XixAZsYiH1uolZxLrR/SgxVIJjkpQP4PE9sE59LKLr7kltSBogS5tyszzH8Fvw8/AS8rNOg0xUS9fIaHwb+6et8Q/gyvKRjf5OusOzGx8evA/BP4IP11uN/grca5O0lcsPLJ5YjwI4QkJBOHa0WdMZYGxPbh2W2nR9v3WxEWqgp/G3+6VZbRLSAAZ3BhdhAaUL33VUSw9yjEsvbaQ9u4A/gGXwZXoEHOuU1GSj2chf+Mo+f8IcfcAxfIKVmyunRbYQVnoevwgfw3TXXcw++xNuP4fhyueEUNttEduRVaDttddoP0eSxLe2LENk6itYxlrxBNBYrNNKSQmeaLcm9c8UsaB5WyO6675yyQIAWSDpBVoA/gxmcwEvwoDv0m58UE7gHn+fJOa8/Ywan8EKRfjsopF83eCglX/Sfr7OeaRoQfvt1CGvIDccH5BCvw1sWIzRGC/66t0VTcLZQZtm6PlAasbOJ9iwWtUo7biktTSIPxnR24jxP1ZKaqq+2RcXM9OrBAm/AAs7hDJ5bNmGb+KIfwCs8a3jnjBrOFeMjHSCdbKr+2uOLfnOd9eiA8Hvvwwq54VbP2OqwkB48Ytc4YEOiH2vTXqodabfWEOzso4qxdbqD5L6tbtNPECqbhnA708DZH4QOJUXqScmUlks7Ot6FBuZw3n2mEbaUX7kDzxHOOQk8nKWMzAzu6ZZ8sOFw4RK+6PcuXo9tB4SbMz58ApfKDXf3szjNIIbGpD5TKTRxGkEMLjLl+K3wlWXBsCUxIDU+jbOiysESqAy1MGUJpXgwbTWzNOVEziIXZrJ+VIztl1PUBxTSo0dwn2bOmfDRPD3TRTGlfbCJvO9KvuhL1hMHhB9wPuPRLGHcdOWG2xc0U+5bQtAJT0nRTewXL1pgk2+rZAdeWmz3jxAqfNQQdzTlbF8uJ5ecEIWvTkevAHpwz7w78QujlD/Lr491bD8/1vhM2yrUQRrWXNQY4fGilfctMWYjL72UL/qS9eiA8EmN88nbNdour+PBbbAjOjIa4iBhfFg6rxeKdEGcL6p3EWR1Qq2Qkhs2DrnkRnmN9tG2EAqmgPw6hoL7Oza7B+3SCrR9tRftko+Lsf2F/mkTndN2LmzuMcKTuj/mX2+4Va3ki16+nnJY+S7MefpkidxwnV+4wkXH8TKnX0tsYzYp29DOOoSW1nf7nTh2akYiWmcJOuTidSaqESrTYpwjJJNVGQr+rLI7WsqerHW6Kp/oM2pKuV7T1QY9gjqlZp41/WfKpl56FV/0kvXQFRyeQ83xaTu5E8p5dNP3dUF34ihyI3GSpeCsywSh22ZJdWto9winhqifb7VRvgktxp13vyjrS0EjvrRfZ62uyqddSWaWYlwTPAtJZ2oZ3j/Sgi/mi+6vpzesfAcWNA0n8xVyw90GVFGuZjTXEQy+6GfLGLMLL523f5E0OmxVjDoOuRiH91RKU+vtoCtH7TgmvBLvtFXWLW15H9GTdVw8ow4IlRLeHECN9ym1e9K0I+Cbnhgv4Yu+aD2HaQJ80XDqOzSGAV4+4yCqBxrsJAX6ZTIoX36QnvzhhzzMfFW2dZVLOJfo0zbce5OvwXMFaZ81mOnlTVXpDZsQNuoYWveketKb5+6JOOsgX+NTm7H49fUTlx+WLuWL7qxnOFh4BxpmJx0p2gDzA/BUARuS6phR+pUsY7MMboAHx5xNsSVfVZcYSwqCKrqon7zM+8ecCkeS4nm3rINuaWvVNnMRI1IRpxTqx8PZUZ0Br/UEduo3B3hNvmgZfs9gQPj8vIOxd2kndir3awvJ6BLvoUuOfFWNYB0LR1OQJoUySKb9IlOBx74q1+ADC2G6rOdmFdJcD8BkfualA+BdjOOzP9uUhGUEX/TwhZsUduwRr8wNuXKurCixLBgpQI0mDbJr9dIqUuV+92ngkJZ7xduCk2yZKbfWrH1VBiTg9VdzsgRjW3CVXCvAwDd+c1z9dWw9+B+8MJL/eY15ZQ/HqvTwVdsZn5WQsgRRnMaWaecu3jFvMBEmgg+FJFZsnSl0zjB9OqPYaBD7qmoVyImFvzi41usesV0julaAR9dfR15Xzv9sEruRDyk1nb+QaLU67T885GTls6YgcY+UiMa25M/pwGrbCfzkvR3e0jjtuaFtnwuagHTSb5y7boBH119HXhvwP487jJLsLJ4XnUkHX5sLbS61dpiAXRoZSCrFJ+EjpeU3puVfitngYNo6PJrAigKktmwjyQdZpfq30mmtulaAx9Zfx15Xzv+cyeuiBFUs9zq8Kq+XB9a4PVvph3GV4E3y8HENJrN55H1X2p8VyqSKwVusJDKzXOZzplWdzBUFK9e+B4+uv468xvI/b5xtSAkBHQaPvtqWzllVvEOxPbuiE6+j2pvjcKsbvI7txnRErgfH7LdXqjq0IokKzga14GzQ23SSbCQvO6r+Or7SMIr/efOkkqSdMnj9mBx2DRsiY29Uj6+qK9ZrssCKaptR6HKURdwUYeUWA2kPzVKQO8ku2nU3Anhs/XWkBx3F/7wJtCTTTIKftthue1ty9xvNYLY/zo5KSbIuKbXpbEdSyeRyYdAIwKY2neyoc3+k1XUaufYga3T9daMUx/r8z1s10ITknIO0kuoMt+TB8jK0lpayqqjsJ2qtXAYwBU932zinimgmd6mTRDnQfr88q36NAI+tv24E8Pr8zxtasBqx0+xHH9HhlrwsxxNUfKOHQaZBITNf0uccj8GXiVmXAuPEAKSdN/4GLHhs/XWj92dN/uetNuBMnVR+XWDc25JLjo5Mg5IZIq226tmCsip2zZliL213YrTlL2hcFjpCduyim3M7/eB16q/blQsv5X/esDRbtJeabLIosWy3ycavwLhtxdWzbMmHiBTiVjJo6lCLjXZsi7p9PEPnsq6X6wd4bP11i0rD5fzPm/0A6brrIsllenZs0lCJlU4abakR59enZKrKe3BZihbTxlyZ2zl1+g0wvgmA166/bhwDrcn/7Ddz0eWZuJvfSESug6NzZsox3Z04FIxz0mUjMwVOOVTq1CQ0AhdbBGVdjG/CgsfUX7esJl3K/7ytWHRv683praW/8iDOCqWLLhpljDY1ZpzK75QiaZoOTpLKl60auHS/97oBXrv+umU9+FL+5+NtLFgjqVLCdbmj7pY5zPCPLOHNCwXGOcLquOhi8CmCWvbcuO73XmMUPab+ug3A6/A/78Bwe0bcS2+tgHn4J5pyS2WbOck0F51Vq3LcjhLvZ67p1ABbaL2H67bg78BfjKi/jr3+T/ABV3ilLmNXTI2SpvxWBtt6/Z//D0z/FXaGbSBgylzlsEGp+5//xrd4/ae4d8DUUjlslfIYS3t06HZpvfQtvv0N7AHWqtjP2pW08QD/FLy//da38vo8PNlKHf5y37Dxdfe/oj4kVIgFq3koLReSR76W/bx//n9k8jonZxzWTANVwEniDsg87sOSd/z7//PvMp3jQiptGVWFX2caezzAXwfgtzYUvbr0iozs32c3Uge7varH+CNE6cvEYmzbPZ9hMaYDdjK4V2iecf6EcEbdUDVUARda2KzO/JtCuDbNQB/iTeL0EG1JSO1jbXS+nLxtPMDPw1fh5+EPrgSEKE/8Gry5A73ui87AmxwdatyMEBCPNOCSKUeRZ2P6Myb5MRvgCHmA9ywsMifU+AYXcB6Xa5GibUC5TSyerxyh0j6QgLVpdyhfArRTTLqQjwe4HOD9s92D4Ap54odXAPBWLAwB02igG5Kkc+piN4lvODIFGAZgT+EO4Si1s7fjSR7vcQETUkRm9O+MXyo9OYhfe4xt9STQ2pcZRLayCV90b4D3jR0DYAfyxJ+eywg2IL7NTMXna7S/RpQ63JhWEM8U41ZyQGjwsVS0QBrEKLu8xwZsbi4wLcCT+OGidPIOCe1PiSc9Qt+go+vYqB7cG+B9d8cAD+WJPz0Am2gxXgU9IneOqDpAAXOsOltVuMzpdakJXrdPCzXiNVUpCeOos5cxnpQT39G+XVLhs1osQVvJKPZyNq8HDwd4d7pNDuWJPxVX7MSzqUDU6gfadKiNlUFTzLeFHHDlzO4kpa7aiKhBPGKwOqxsBAmYkOIpipyXcQSPlRTf+Tii0U3EJGaZsDER2qoB3h2hu0qe+NNwUooYU8y5mILbJe6OuX+2FTKy7bieTDAemaQyQ0CPthljSWO+xmFDIYiESjM5xKd6Ik5lvLq5GrQ3aCMLvmCA9wowLuWJb9xF59hVVP6O0CrBi3ZjZSNOvRy+I6klNVRJYRBaEzdN+imiUXQ8iVF8fsp+W4JXw7WISW7fDh7lptWkCwZ4d7QTXyBPfJMYK7SijjFppGnlIVJBJBYj7eUwtiP1IBXGI1XCsjNpbjENVpSAJ2hq2LTywEly3hUYazt31J8w2+aiLx3g3fohXixPfOMYm6zCGs9LVo9MoW3MCJE7R5u/WsOIjrqBoHUO0bJE9vxBpbhsd3+Nb4/vtPCZ4oZYCitNeYuC/8UDvDvy0qvkiW/cgqNqRyzqSZa/s0mqNGjtKOoTm14zZpUauiQgVfqtQiZjq7Q27JNaSK5ExRcrGCXO1FJYh6jR6CFqK7bZdQZ4t8g0rSlPfP1RdBtqaa9diqtzJkQ9duSryi2brQXbxDwbRUpFMBHjRj8+Nt7GDKgvph9okW7LX47gu0SpGnnFQ1S1lYldOsC7hYteR574ZuKs7Ei1lBsfdz7IZoxzzCVmmVqaSySzQbBVAWDek+N4jh9E/4VqZrJjPwiv9BC1XcvOWgO8275CVyBPvAtTVlDJfZkaZGU7NpqBogAj/xEHkeAuJihWYCxGN6e8+9JtSegFXF1TrhhLGP1fak3pebgPz192/8gB4d/6WT7+GdYnpH7hH/DJzzFiYPn/vjW0SgNpTNuPIZoAEZv8tlGw4+RLxy+ZjnKa5NdFoC7UaW0aduoYse6+bXg1DLg6UfRYwmhGEjqPvF75U558SANrElK/+MdpXvmqBpaXOa/MTZaa1DOcSiLaw9j0NNNst3c+63c7EKTpkvKHzu6bPbP0RkuHAVcbRY8ijP46MIbQeeT1mhA+5PV/inyDdQipf8LTvMXbwvoDy7IruDNVZKTfV4CTSRUYdybUCnGU7KUTDxLgCknqUm5aAW6/1p6eMsOYsphLzsHrE0Y/P5bQedx1F/4yPHnMB3/IOoTU9+BL8PhtjuFKBpZXnYNJxTuv+2XqolKR2UQgHhS5novuxVySJhBNRF3SoKK1XZbbXjVwWNyOjlqWJjrWJIy+P5bQedyldNScP+HZ61xKSK3jyrz+NiHG1hcOLL/+P+PDF2gOkekKGiNWKgJ+8Z/x8Iv4DdQHzcpZyF4v19I27w9/yPGDFQvmEpKtqv/TLiWMfn4sofMm9eAH8Ao0zzh7h4sJqYtxZd5/D7hkYPneDzl5idlzNHcIB0jVlQ+8ULzw/nc5/ojzl2juE0apD7LRnJxe04dMz2iOCFNtGFpTuXA5AhcTRo8mdN4kz30nVjEC4YTZQy4gpC7GlTlrePKhGsKKgeXpCYeO0MAd/GH7yKQUlXPLOasOH3FnSphjHuDvEu4gB8g66oNbtr6eMbFIA4fIBJkgayoXriw2XEDQPJrQeROAlY6aeYOcMf+IVYTU3XFlZufMHinGywaW3YLpObVBAsbjF4QJMsVUSayjk4voPsHJOQfPWDhCgDnmDl6XIRerD24HsGtw86RMHOLvVSHrKBdeVE26gKB5NKHzaIwLOmrqBWJYZDLhASG16c0Tn+CdRhWDgWXnqRZUTnPIHuMJTfLVpkoYy5CzylHVTGZMTwkGAo2HBlkQplrJX6U+uF1wZz2uwS1SQ12IqWaPuO4baZaEFBdukksJmkcTOm+YJSvoqPFzxFA/YUhIvWxcmSdPWTWwbAKVp6rxTtPFUZfKIwpzm4IoMfaYQLWgmlG5FME2gdBgm+J7J+rtS/XBbaVLsR7bpPQnpMFlo2doWaVceHk9+MkyguZNCJ1He+kuHTWyQAzNM5YSUg/GlTk9ZunAsg1qELVOhUSAK0LABIJHLKbqaEbHZLL1VA3VgqoiOKXYiS+HRyaEKgsfIqX64HYWbLRXy/qWoylIV9gudL1OWBNgBgTNmxA6b4txDT4gi3Ri7xFSLxtXpmmYnzAcWDZgY8d503LFogz5sbonDgkKcxGsWsE1OI+rcQtlgBBCSOKD1mtqYpIU8cTvBmAT0yZe+zUzeY92fYjTtGipXLhuR0ePoHk0ofNWBX+lo8Z7pAZDk8mEw5L7dVyZZoE/pTewbI6SNbiAL5xeygW4xPRuLCGbhcO4RIeTMFYHEJkYyEO9HmJfXMDEj/LaH781wHHZEtqSQ/69UnGpzH7LKIAZEDSPJnTesJTUa+rwTepI9dLJEawYV+ZkRn9g+QirD8vF8Mq0jFQ29js6kCS3E1+jZIhgPNanHdHFqFvPJLHqFwQqbIA4jhDxcNsOCCQLDomaL/dr5lyJaJU6FxPFjO3JOh3kVMcROo8u+C+jo05GjMF3P3/FuDLn5x2M04xXULPwaS6hBYki+MrMdZJSgPHlcB7nCR5bJ9Kr5ACUn9jk5kivdd8tk95SOGrtqu9lr2IhK65ZtEl7ZKrp7DrqwZfRUSN1el7+7NJxZbywOC8neNKTch5vsTEMNsoCCqHBCqIPRjIPkm0BjvFODGtto99rCl+d3wmHkW0FPdpZtC7MMcVtGFQjJLX5bdQ2+x9ypdc313uj8xlsrfuLgWXz1cRhZvJYX0iNVBRcVcmCXZs6aEf3RQF2WI/TcCbKmGU3IOoDJGDdDub0+hYckt6PlGu2BcxmhbTdj/klhccLGJMcqRjMJP1jW2ETqLSWJ/29MAoORluJ+6LPffBZbi5gqi5h6catQpmOT7/OFf5UorRpLzCqcMltBLhwd1are3kztrSzXO0LUbXRQcdLh/RdSZ+swRm819REDrtqzC4es6Gw4JCKlSnjYVpo0xeq33PrADbFLL3RuCmObVmPN+24kfa+AojDuM4umKe2QwCf6EN906HwjujaitDs5o0s1y+k3lgbT2W2i7FJdnwbLXhJUBq/9liTctSmFC/0OqUinb0QddTWamtjbHRFuWJJ6NpqZ8vO3fZJ37Db+2GkaPYLGHs7XTTdiFQJ68SkVJFVmY6McR5UycflNCsccHFaV9FNbR4NttLxw4pQ7wJd066Z0ohVbzihaxHVExd/ay04oxUKWt+AsdiQ9OUyZ2krzN19IZIwafSTFgIBnMV73ADj7V/K8u1MaY2sJp2HWm0f41tqwajEvdHWOJs510MaAqN4aoSiPCXtN2KSi46dUxHdaMquar82O1x5jqhDGvqmoE9LfxcY3zqA7/x3HA67r9ZG4O6Cuxu12/+TP+eLP+I+HErqDDCDVmBDO4larujNe7x8om2rMug0MX0rL1+IWwdwfR+p1TNTyNmVJ85ljWzbWuGv8/C7HD/izjkHNZNYlhZcUOKVzKFUxsxxN/kax+8zPWPSFKw80rJr9Tizyj3o1gEsdwgWGoxPezDdZ1TSENE1dLdNvuKL+I84nxKesZgxXVA1VA1OcL49dFlpFV5yJMhzyCmNQ+a4BqusPJ2bB+xo8V9u3x48VVIEPS/mc3DvAbXyoYr6VgDfh5do5hhHOCXMqBZUPhWYbWZECwVJljLgMUWOCB4MUuMaxGNUQDVI50TQ+S3kFgIcu2qKkNSHVoM0SHsgoZxP2d5HH8B9woOk4x5bPkKtAHucZsdykjxuIpbUrSILgrT8G7G5oCW+K0990o7E3T6AdW4TilH5kDjds+H64kS0mz24grtwlzDHBJqI8YJQExotPvoC4JBq0lEjjQkyBZ8oH2LnRsQ4Hu1QsgDTJbO8fQDnllitkxuVskoiKbRF9VwzMDvxHAdwB7mD9yCplhHFEyUWHx3WtwCbSMMTCUCcEmSGlg4gTXkHpZXWQ7kpznK3EmCHiXInqndkQjunG5kxTKEeGye7jWz9cyMR2mGiFQ15ENRBTbCp+Gh86vAyASdgmJq2MC6hoADQ3GosP0QHbnMHjyBQvQqfhy/BUbeHd5WY/G/9LK/8Ka8Jd7UFeNWEZvzPb458Dn8DGLOe3/wGL/4xP+HXlRt+M1PE2iLhR8t+lfgxsuh7AfO2AOf+owWhSZRYQbd622hbpKWKuU+XuvNzP0OseRDa+mObgDHJUSc/pKx31QdKffQ5OIJpt8GWjlgTwMc/w5MPCR/yl1XC2a2Yut54SvOtMev55Of45BOat9aWG27p2ZVORRvnEk1hqWMVUmqa7S2YtvlIpspuF1pt0syuZS2NV14mUidCSfzQzg+KqvIYCMljIx2YK2AO34fX4GWdu5xcIAb8MzTw+j/lyWM+Dw/gjs4GD6ehNgA48kX/AI7XXM/XAN4WHr+9ntywqoCakCqmKP0rmQrJJEErG2Upg1JObr01lKQy4jskWalKYfJ/EDLMpjNSHFEUAde2fltaDgmrNaWQ9+AAb8I5vKjz3L1n1LriB/BXkG/wwR9y/oRX4LlioHA4LzP2inzRx/DWmutRweFjeP3tNeSGlaE1Fde0OS11yOpmbIp2u/jF1n2RRZviJM0yBT3IZl2HWImKjQOxIyeU325b/qWyU9Moj1o07tS0G7qJDoGHg5m8yeCxMoEH8GU45tnrNM84D2l297DQ9t1YP7jki/7RmutRweEA77/HWXOh3HCxkRgldDQkAjNTMl2Iloc1qN5JfJeeTlyTRzxURTdn1Ixv2uKjs12AbdEWlBtmVdk2k7FFwj07PCZ9XAwW3dG+8xKzNFr4EnwBZpy9Qzhh3jDXebBpYcpuo4fQ44u+fD1dweEnHzI7v0xuuOALRUV8rXpFyfSTQYkhd7IHm07jpyhlkCmI0ALYqPTpUxXS+z4jgDj1Pflvmz5ecuItpIBxyTHpSTGWd9g1ApfD/bvwUhL4nT1EzqgX7cxfCcNmb3mPL/qi9SwTHJ49oj5ZLjccbTG3pRmlYi6JCG0mQrAt1+i2UXTZ2dv9IlQpN5naMYtviaXlTrFpoMsl3bOAFEa8sqPj2WCMrx3Yjx99qFwO59Aw/wgx+HlqNz8oZvA3exRDvuhL1jMQHPaOJ0+XyA3fp1OfM3qObEVdhxjvynxNMXQV4+GJyvOEFqeQBaIbbO7i63rpxCltdZShPFxkjM2FPVkn3TG+Rp9pO3l2RzFegGfxGDHIAh8SteR0C4HopXzRF61nheDw6TFN05Ebvq8M3VKKpGjjO6r7nhudTEGMtYM92HTDaR1FDMXJ1eThsbKfywyoWwrzRSXkc51flG3vIid62h29bIcFbTGhfV+faaB+ohj7dPN0C2e2lC96+XouFByen9AsunLDJZ9z7NExiUc0OuoYW6UZkIyx2YUR2z6/TiRjyKMx5GbbjLHvHuf7YmtKghf34LJfx63Yg8vrvN2zC7lY0x0tvKezo4HmGYDU+Gab6dFL+KI761lDcNifcjLrrr9LWZJctG1FfU1uwhoQE22ObjdfkSzY63CbU5hzs21WeTddH2BaL11Gi7lVdlxP1nkxqhnKhVY6knS3EPgVGg1JpN5cP/hivujOelhXcPj8HC/LyI6MkteVjlolBdMmF3a3DbsuAYhL44dxzthWSN065xxUd55Lmf0wRbOYOqH09/o9WbO2VtFdaMb4qBgtFJoT1SqoN8wPXMoXLb3p1PUEhxfnnLzGzBI0Ku7FxrKsNJj/8bn/H8fPIVOd3rfrklUB/DOeO+nkghgSPzrlPxluCMtOnDL4Yml6dK1r3vsgMxgtPOrMFUZbEUbTdIzii5beq72G4PD0DKnwjmBULUVFmy8t+k7fZ3pKc0Q4UC6jpVRqS9Umv8bxw35flZVOU1X7qkjnhZlsMbk24qQ6Hz7QcuL6sDC0iHHki96Uh2UdvmgZnjIvExy2TeJdMDZNSbdZyAHe/Yd1xsQhHiKzjh7GxQ4yqMPaywPkjMamvqrYpmO7Knad+ZQC5msCuAPWUoxrxVhrGv7a+KLXFhyONdTMrZ7ke23qiO40ZJUyzgYyX5XyL0mV7NiUzEs9mjtbMN0dERqwyAJpigad0B3/zRV7s4PIfXSu6YV/MK7+OrYe/JvfGMn/PHJe2fyUdtnFrKRNpXV0Y2559aWPt/G4BlvjTMtXlVIWCnNyA3YQBDmYIodFz41PvXPSa6rq9lWZawZ4dP115HXV/M/tnFkkrBOdzg6aP4pID+MZnTJ1SuuB6iZlyiox4HT2y3YBtkUKWooacBQUDTpjwaDt5poBHl1/HXltwP887lKKXxNUEyPqpGTyA699UqY/lt9yGdlUKra0fFWS+36iylVWrAyd7Uw0CZM0z7xKTOduznLIjG2Hx8cDPLb+OvK6Bv7n1DYci4CxUuRxrjBc0bb4vD3rN5Zz36ntLb83eVJIB8LiIzCmn6SMPjlX+yNlTjvIGjs+QzHPf60Aj62/jrzG8j9vYMFtm1VoRWCJdmw7z9N0t+c8cxZpPeK4aTRicS25QhrVtUp7U578chk4q04Wx4YoQSjFryUlpcQ1AbxZ/XVMknIU//OGl7Q6z9Zpxi0+3yFhSkjUDpnCIUhLWVX23KQ+L9vKvFKI0ZWFQgkDLvBoylrHNVmaw10zwCPrr5tlodfnf94EWnQ0lFRWy8pW9LbkLsyUVDc2NSTHGDtnD1uMtchjbCeb1mpxFP0YbcClhzdLu6lfO8Bj6q+bdT2sz/+8SZCV7VIxtt0DUn9L7r4cLYWDSXnseEpOGFuty0qbOVlS7NNzs5FOGJUqQpl2Q64/yBpZf90sxbE+//PGdZ02HSipCbmD6NItmQ4Lk5XUrGpDMkhbMm2ZVheNYV+VbUWTcv99+2NyX1VoafSuC+AN6q9bFIMv5X/eagNWXZxEa9JjlMwNWb00akGUkSoepp1/yRuuqHGbUn3UdBSTxBU6SEVklzWRUkPndVvw2PrrpjvxOvzPmwHc0hpmq82npi7GRro8dXp0KXnUQmhZbRL7NEVp1uuZmO45vuzKsHrktS3GLWXODVjw+vXXLYx4Hf7njRPd0i3aoAGX6W29GnaV5YdyDj9TFkakje7GHYzDoObfddHtOSpoi2SmzJHrB3hM/XUDDEbxP2/oosszcRlehWXUvzHv4TpBVktHqwenFo8uLVmy4DKLa5d3RtLrmrM3aMFr1183E4sewf+85VWeg1c5ag276NZrM9IJVNcmLEvDNaV62aq+14IAOGFsBt973Ra8Xv11YzXwNfmft7Jg2oS+XOyoC8/cwzi66Dhmgk38kUmP1CUiYWOX1bpD2zWXt2FCp7uq8703APAa9dfNdscR/M/bZLIyouVxqJfeWvG9Je+JVckHQ9+CI9NWxz+blX/KYYvO5n2tAP/vrlZ7+8/h9y+9qeB/Hnt967e5mevX10rALDWK//FaAT5MXdBXdP0C/BAes792c40H+AiAp1e1oH8HgH94g/Lttx1gp63op1eyoM/Bvw5/G/7xFbqJPcCXnmBiwDPb/YKO4FX4OjyCb289db2/Noqicw4i7N6TVtoz8tNwDH+8x/i6Ae7lmaQVENzJFb3Di/BFeAwz+Is9SjeQySpPqbLFlNmyz47z5a/AF+AYFvDmHqibSXTEzoT4Gc3OALaqAP4KPFUJ6n+1x+rGAM6Zd78bgJ0a8QN4GU614vxwD9e1Amy6CcskNrczLx1JIp6HE5UZD/DBHrFr2oNlgG4Odv226BodoryjGJ9q2T/AR3vQrsOCS0ctXZi3ruLlhpFDJYl4HmYtjQCP9rhdn4suySLKDt6wLcC52h8xPlcjju1fn+yhuw4LZsAGUuo2b4Fx2UwQu77uqRHXGtg92aN3tQCbFexc0uk93vhTXbct6y7MulLycoUljx8ngDMBg1tvJjAazpEmOtxlzclvj1vQf1Tx7QlPDpGpqgtdSKz/d9/hdy1vTfFHSmC9dGDZbLiezz7Ac801HirGZsWjydfZyPvHXL/Y8Mjzg8BxTZiuwKz4Eb8sBE9zznszmjvFwHKPIWUnwhqfVRcd4Ck0K6ate48m1oOfrX3/yOtvAsJ8zsPAM89sjnddmuLuDPjX9Bu/L7x7xpMzFk6nWtyQfPg278Gn4Aekz2ZgOmU9eJ37R14vwE/BL8G3aibCiWMWWDQ0ZtkPMnlcGeAu/Ag+8ZyecU5BPuy2ILD+sQqyZhAKmn7XZd+jIMTN9eBL7x95xVLSX4On8EcNlXDqmBlqS13jG4LpmGbkF/0CnOi3H8ETOIXzmnmtb0a16Tzxj1sUvQCBiXZGDtmB3KAefPH94xcUa/6vwRn80GOFyjEXFpba4A1e8KQfFF+259tx5XS4egYn8fQsLGrqGrHbztr+uByTahWuL1NUGbDpsnrwBfePPwHHIf9X4RnM4Z2ABWdxUBlqQ2PwhuDxoS0vvqB1JzS0P4h2nA/QgTrsJFn+Y3AOjs9JFC07CGWX1oNX3T/yHOzgDjwPn1PM3g9Jk9lZrMEpxnlPmBbjyo2+KFXRU52TJM/2ALcY57RUzjObbjqxVw++4P6RAOf58pcVsw9Daje3htriYrpDOonre3CudSe6bfkTEgHBHuDiyu5MCsc7BHhYDx7ePxLjqigXZsw+ijMHFhuwBmtoTPtOxOrTvYJDnC75dnUbhfwu/ZW9AgYd+peL68HD+0emKquiXHhWjJg/UrkJYzuiaL3E9aI/ytrCvAd4GcYZMCkSQxfUg3v3j8c4e90j5ZTPdvmJJGHnOCI2nHS8081X013pHuBlV1gB2MX1YNmWLHqqGN/TWmG0y6clJWthxNUl48q38Bi8vtMKyzzpFdSDhxZ5WBA5ZLt8Jv3895DduBlgbPYAj8C4B8hO68FDkoh5lydC4FiWvBOVqjYdqjiLv92t8yPDjrDaiHdUD15qkSURSGmXJwOMSxWAXYwr3zaAufJ66l+94vv3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/wHuD9tQd4f+0B3l97gPfXHuD9tQd4f+0B3l97gG8LwP8G/AL8O/A5OCq0Ys2KIdv/qOIXG/4mvFAMF16gZD+2Xvu/B8as5+8bfllWyg0zaNO5bfXj6vfhhwD86/Aq3NfRS9t9WPnhfnvCIw/CT8GLcFTMnpntdF/z9V+PWc/vWoIH+FL3Znv57PitcdGP4R/C34avw5fgRVUInCwbsn1yyA8C8zm/BH8NXoXnVE6wVPjdeCI38kX/3+Ct9dbz1pTmHFRu+Hm4O9Ch3clr99negxfwj+ER/DR8EV6B5+DuQOnTgUw5rnkY+FbNU3gNXh0o/JYTuWOvyBf9FvzX663HH/HejO8LwAl8Hl5YLTd8q7sqA3wbjuExfAFegQdwfyDoSkWY8swzEf6o4Qyewefg+cHNbqMQruSL/u/WWc+E5g7vnnEXgDmcDeSGb/F4cBcCgT+GGRzDU3hZYburAt9TEtHgbM6JoxJ+6NMzzTcf6c2bycv2+KK/f+l6LBzw5IwfqZJhA3M472pWT/ajKxnjv4AFnMEpnBTPND6s2J7qHbPAqcMK74T2mZ4VGB9uJA465It+/eL1WKhYOD7xHOkr1ajK7d0C4+ke4Hy9qXZwpgLr+Znm/uNFw8xQOSy8H9IzjUrd9+BIfenYaylf9FsXr8fBAadnPIEDna8IBcwlxnuA0/Wv6GAWPd7dDIKjMdSWueAsBj4M7TOd06qBbwDwKr7oleuxMOEcTuEZTHWvDYUO7aHqAe0Bbq+HEFRzOz7WVoTDQkVds7A4sIIxfCQdCefFRoIOF/NFL1mPab/nvOakSL/Q1aFtNpUb/nFOVX6gzyg/1nISyDfUhsokIzaBR9Kxm80s5mK+6P56il1jXic7nhQxsxSm3OwBHl4fFdLqi64nDQZvqE2at7cWAp/IVvrN6/BFL1mPhYrGMBfOi4PyjuSGf6wBBh7p/FZTghCNWGgMzlBbrNJoPJX2mW5mwZfyRffXo7OFi5pZcS4qZUrlViptrXtw+GQoyhDPS+ANjcGBNRiLCQDPZPMHuiZfdFpPSTcQwwKYdRNqpkjm7AFeeT0pJzALgo7g8YYGrMHS0iocy+YTm2vyRUvvpXCIpQ5pe666TJrcygnScUf/p0NDs/iAI/nqDHC8TmQT8x3NF91l76oDdQGwu61Z6E0ABv7uO1dbf/37Zlv+Zw/Pbh8f1s4Avur6657/+YYBvur6657/+YYBvur6657/+YYBvur6657/+aYBvuL6657/+VMA8FXWX/f8zzcN8BXXX/f8zzcNMFdbf93zP38KLPiK6697/uebtuArrr/u+Z9vGmCusP6653/+1FjwVdZf9/zPN7oHX339dc//fNMu+irrr3v+50+Bi+Zq6697/uebA/jz8Pudf9ht/fWv517J/XUzAP8C/BAeX9WCDrUpZ3/dEMBxgPcfbtTVvsYV5Yn32u03B3Ac4P3b8I+vxNBKeeL9dRMAlwO83959qGO78sT769oB7g3w/vGVYFzKE++v6wV4OMD7F7tckFkmT7y/rhHgpQO8b+4Y46XyxPvrugBeNcB7BRiX8sT767oAvmCA9woAHsoT76+rBJjLBnh3txOvkifeX1dswZcO8G6N7sXyxPvr6i340gHe3TnqVfLE++uKAb50gHcXLnrX8sR7gNdPRqwzwLu7Y/FO5Yn3AK9jXCMGeHdgxDuVJ75VAI8ljP7PAb3/RfjcZfePHBB+79dpfpH1CanN30d+mT1h9GqAxxJGM5LQeeQ1+Tb+EQJrElLb38VHQ94TRq900aMIo8cSOo+8Dp8QfsB8zpqE1NO3OI9Zrj1h9EV78PqE0WMJnUdeU6E+Jjyk/hbrEFIfeWbvId8H9oTRFwdZaxJGvziW0Hn0gqYB/wyZ0PwRlxJST+BOw9m77Amj14ii1yGM/txYQudN0qDzGe4EqfA/5GJCagsHcPaEPWH0esekSwmjRxM6b5JEcZ4ww50ilvAOFxBSx4yLW+A/YU8YvfY5+ALC6NGEzhtmyZoFZoarwBLeZxUhtY4rc3bKnjB6TKJjFUHzJoTOozF2YBpsjcyxDgzhQ1YRUse8+J4wenwmaylB82hC5w0zoRXUNXaRBmSMQUqiWSWkLsaVqc/ZE0aPTFUuJWgeTei8SfLZQeMxNaZSIzbII4aE1Nmr13P2hNHjc9E9guYNCZ032YlNwESMLcZiLQHkE4aE1BFg0yAR4z1h9AiAGRA0jyZ03tyIxWMajMPWBIsxYJCnlITU5ShiHYdZ94TR4wCmSxg9jtB5KyPGYzymAYexWEMwAPIsAdYdV6aObmNPGD0aYLoEzaMJnTc0Ygs+YDw0GAtqxBjkuP38bMRWCHn73xNGjz75P73WenCEJnhwyVe3AEe8TtKdJcYhBl97wuhNAObK66lvD/9J9NS75v17wuitAN5fe4D31x7g/bUHeH/tAd5fe4D3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/w/toDvAd4f/24ABzZ8o+KLsSLS+Pv/TqTb3P4hKlQrTGh+fbIBT0Axqznnb+L/V2mb3HkN5Mb/nEHeK7d4IcDld6lmDW/iH9E+AH1MdOw/Jlu2T1xNmY98sv4wHnD7D3uNHu54WUuOsBTbQuvBsPT/UfzNxGYzwkP8c+Yz3C+r/i6DcyRL/rZ+utRwWH5PmfvcvYEt9jLDS/bg0/B64DWKrQM8AL8FPwS9beQCe6EMKNZYJol37jBMy35otdaz0Bw2H/C2Smc7+WGB0HWDELBmOByA3r5QONo4V+DpzR/hFS4U8wMW1PXNB4TOqYz9urxRV++ntWCw/U59Ty9ebdWbrgfRS9AYKKN63ZokZVygr8GZ/gfIhZXIXPsAlNjPOLBby5c1eOLvmQ9lwkOy5x6QV1j5TYqpS05JtUgUHUp5toHGsVfn4NX4RnMCe+AxTpwmApTYxqMxwfCeJGjpXzRF61nbcHhUBPqWze9svwcHJ+S6NPscKrEjug78Dx8Lj3T8D4YxGIdxmJcwhi34fzZUr7olevZCw5vkOhoClq5zBPZAnygD/Tl9EzDh6kl3VhsHYcDEb+hCtJSvuiV69kLDm+WycrOTArHmB5/VYyP6jOVjwgGawk2zQOaTcc1L+aLXrKeveDwZqlKrw8U9Y1p66uK8dEzdYwBeUQAY7DbyYNezBfdWQ97weEtAKYQg2xJIkuveAT3dYeLGH+ShrWNwZgN0b2YL7qznr3g8JYAo5bQBziPjx7BPZ0d9RCQp4UZbnFdzBddor4XHN4KYMrB2qHFRIzzcLAHQZ5the5ovui94PCWAPefaYnxIdzRwdHCbuR4B+tbiy96Lzi8E4D7z7S0mEPd+eqO3cT53Z0Y8SV80XvB4Z0ADJi/f7X113f+7p7/+UYBvur6657/+YYBvur6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+VMA8FXWX/f8z58OgK+y/rrnf75RgLna+uue//lTA/CV1V/3/M837aKvvv6653++UQvmauuve/7nTwfAV1N/3fM/fzr24Cuuv+75nz8FFnxl9dc9//MOr/8/glixwRuUfM4AAAAASUVORK5CYII=';
	},

	getSearchTexture: function getSearchTexture() {
		return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII=';
	}

});

exports.default = SMAAPass;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _ShaderPass = __webpack_require__(3);

var _ShaderPass2 = _interopRequireDefault(_ShaderPass);

var _SSAOShader = __webpack_require__(25);

var _SSAOShader2 = _interopRequireDefault(_SSAOShader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

'use strict';

/**
 * Screen-space ambient occlusion pass.
 *
 * Has the following parameters
 *  - radius
 *  	- Ambient occlusion shadow radius (numeric value).
 *  - onlyAO
 *  	- Display only ambient occlusion result (boolean value).
 *  - aoClamp
 *  	- Ambient occlusion clamp (numeric value).
 *  - lumInfluence
 *  	- Pixel luminosity influence in AO calculation (numeric value).
 *
 * To output to screen set renderToScreens true
 *
 * @author alteredq / http://alteredqualia.com/
 * @author tentone
 * @class SSAOPass
 */
var SSAOPass = function SSAOPass(scene, camera, width, height) {

	if (_SSAOShader2.default === undefined) {

		console.warn('THREE.SSAOPass depends on THREE.SSAOShader');
		return new _ShaderPass2.default();
	}

	_ShaderPass2.default.call(this, _SSAOShader2.default);

	this.width = width !== undefined ? width : 512;
	this.height = height !== undefined ? height : 256;

	this.renderToScreen = false;

	this.camera2 = camera;
	this.scene2 = scene;

	//Depth material
	this.depthMaterial = new THREE.MeshDepthMaterial();
	this.depthMaterial.depthPacking = THREE.RGBADepthPacking;
	this.depthMaterial.blending = THREE.NoBlending;

	//Depth render target
	this.depthRenderTarget = new THREE.WebGLRenderTarget(this.width, this.height, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter });
	//this.depthRenderTarget.texture.name = 'SSAOShader.rt';

	//Shader uniforms
	this.uniforms['tDepth'].value = this.depthRenderTarget.texture;
	this.uniforms['size'].value.set(this.width, this.height);
	this.uniforms['cameraNear'].value = this.camera2.near;
	this.uniforms['cameraFar'].value = this.camera2.far;

	this.uniforms['radius'].value = 4;
	this.uniforms['onlyAO'].value = false;
	this.uniforms['aoClamp'].value = 0.25;
	this.uniforms['lumInfluence'].value = 0.7;

	//Setters and getters for uniforms
	var self = this;
	Object.defineProperties(this, {

		radius: {
			get: function get() {
				return this.uniforms['radius'].value;
			},
			set: function set(value) {
				this.uniforms['radius'].value = value;
			}
		},

		onlyAO: {
			get: function get() {
				return this.uniforms['onlyAO'].value;
			},
			set: function set(value) {
				this.uniforms['onlyAO'].value = value;
			}
		},

		aoClamp: {
			get: function get() {
				return this.uniforms['aoClamp'].value;
			},
			set: function set(value) {
				this.uniforms['aoClamp'].value = value;
			}
		},

		lumInfluence: {
			get: function get() {
				return this.uniforms['lumInfluence'].value;
			},
			set: function set(value) {
				this.uniforms['lumInfluence'].value = value;
			}
		}

	});
};

SSAOPass.prototype = Object.create(_ShaderPass2.default.prototype);

/**
 * Render using this pass.
 *
 * @method render
 * @param {WebGLRenderer} renderer
 * @param {WebGLRenderTarget} writeBuffer Buffer to write output.
 * @param {WebGLRenderTarget} readBuffer Input buffer.
 * @param {Number} delta Delta time in milliseconds.
 * @param {Boolean} maskActive Not used in this pass.
 */
SSAOPass.prototype.render = function (renderer, writeBuffer, readBuffer, delta, maskActive) {

	//Render depth into depthRenderTarget
	this.scene2.overrideMaterial = this.depthMaterial;

	renderer.render(this.scene2, this.camera2, this.depthRenderTarget, true);

	this.scene2.overrideMaterial = null;

	//SSAO shaderPass
	_ShaderPass2.default.prototype.render.call(this, renderer, writeBuffer, readBuffer, delta, maskActive);
};

/**
 * Change scene to be renderer by this render pass.
 *
 * @method setScene
 * @param {Scene} scene
 */
SSAOPass.prototype.setScene = function (scene) {

	this.scene2 = scene;
};

/**
 * Set camera used by this render pass.
 *
 * @method setCamera
 * @param {Camera} camera
 */
SSAOPass.prototype.setCamera = function (camera) {

	this.camera2 = camera;

	this.uniforms['cameraNear'].value = this.camera2.near;
	this.uniforms['cameraFar'].value = this.camera2.far;
};

/**
 * Set resolution of this render pass.
 *
 * @method setSize
 * @param {Number} width
 * @param {Number} height
 */
SSAOPass.prototype.setSize = function (width, height) {

	this.width = width;
	this.height = height;

	this.uniforms['size'].value.set(this.width, this.height);
	this.depthRenderTarget.setSize(this.width, this.height);
};

exports.default = SSAOPass;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _SSAARenderPass = __webpack_require__(24);

var _SSAARenderPass2 = _interopRequireDefault(_SSAARenderPass);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 *
 * Temporal Anti-Aliasing Render Pass
 *
 * @author bhouston / http://clara.io/
 *
 * When there is no motion in the scene, the TAA render pass accumulates jittered camera samples across frames to create a high quality anti-aliased result.
 *
 * References:
 *
 * TODO: Add support for motion vector pas so that accumulation of samples across frames can occur on dynamics scenes.
 *
 */

var TAARenderPass = function TAARenderPass(scene, camera, params) {

	if (_SSAARenderPass2.default === undefined) {

		console.error("THREE.TAARenderPass relies on THREE.SSAARenderPass");
	}

	_SSAARenderPass2.default.call(this, scene, camera, params);

	this.sampleLevel = 0;
	this.accumulate = false;
};

TAARenderPass.JitterVectors = _SSAARenderPass2.default.JitterVectors;

TAARenderPass.prototype = Object.assign(Object.create(_SSAARenderPass2.default.prototype), {

	constructor: TAARenderPass,

	render: function render(renderer, writeBuffer, readBuffer, delta) {

		if (!this.accumulate) {

			_SSAARenderPass2.default.prototype.render.call(this, renderer, writeBuffer, readBuffer, delta);

			this.accumulateIndex = -1;
			return;
		}

		var jitterOffsets = TAARenderPass.JitterVectors[5];

		if (!this.sampleRenderTarget) {

			this.sampleRenderTarget = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);
			this.sampleRenderTarget.texture.name = "TAARenderPass.sample";
		}

		if (!this.holdRenderTarget) {

			this.holdRenderTarget = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);
			this.holdRenderTarget.texture.name = "TAARenderPass.hold";
		}

		if (this.accumulate && this.accumulateIndex === -1) {

			_SSAARenderPass2.default.prototype.render.call(this, renderer, this.holdRenderTarget, readBuffer, delta);

			this.accumulateIndex = 0;
		}

		var autoClear = renderer.autoClear;
		renderer.autoClear = false;

		var sampleWeight = 1.0 / jitterOffsets.length;

		if (this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length) {

			this.copyUniforms["opacity"].value = sampleWeight;
			this.copyUniforms["tDiffuse"].value = writeBuffer.texture;

			// render the scene multiple times, each slightly jitter offset from the last and accumulate the results.
			var numSamplesPerFrame = Math.pow(2, this.sampleLevel);
			for (var i = 0; i < numSamplesPerFrame; i++) {

				var j = this.accumulateIndex;
				var jitterOffset = jitterOffsets[j];

				if (this.camera.setViewOffset) {

					this.camera.setViewOffset(readBuffer.width, readBuffer.height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625, // 0.0625 = 1 / 16
					readBuffer.width, readBuffer.height);
				}

				renderer.render(this.scene, this.camera, writeBuffer, true);
				renderer.render(this.scene2, this.camera2, this.sampleRenderTarget, this.accumulateIndex === 0);

				this.accumulateIndex++;

				if (this.accumulateIndex >= jitterOffsets.length) break;
			}

			if (this.camera.clearViewOffset) this.camera.clearViewOffset();
		}

		var accumulationWeight = this.accumulateIndex * sampleWeight;

		if (accumulationWeight > 0) {

			this.copyUniforms["opacity"].value = 1.0;
			this.copyUniforms["tDiffuse"].value = this.sampleRenderTarget.texture;
			renderer.render(this.scene2, this.camera2, writeBuffer, true);
		}

		if (accumulationWeight < 1.0) {

			this.copyUniforms["opacity"].value = 1.0 - accumulationWeight;
			this.copyUniforms["tDiffuse"].value = this.holdRenderTarget.texture;
			renderer.render(this.scene2, this.camera2, writeBuffer, accumulationWeight === 0);
		}

		renderer.autoClear = autoClear;
	}

});

exports.default = TAARenderPass;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _Pass = __webpack_require__(1);

var _Pass2 = _interopRequireDefault(_Pass);

var _CopyShader = __webpack_require__(2);

var _CopyShader2 = _interopRequireDefault(_CopyShader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author alteredq / http://alteredqualia.com/
 */

var TexturePass = function TexturePass(map, opacity) {

	_Pass2.default.call(this);

	if (_CopyShader2.default === undefined) console.error("THREE.TexturePass relies on THREE.CopyShader");

	var shader = _CopyShader2.default;

	this.map = map;
	this.opacity = opacity !== undefined ? opacity : 1.0;

	this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);

	this.material = new THREE.ShaderMaterial({

		uniforms: this.uniforms,
		vertexShader: shader.vertexShader,
		fragmentShader: shader.fragmentShader,
		depthTest: false,
		depthWrite: false

	});

	this.needsSwap = false;

	this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
	this.scene = new THREE.Scene();

	this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
	this.quad.frustumCulled = false; // Avoid getting clipped
	this.scene.add(this.quad);
};

TexturePass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {

	constructor: TexturePass,

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		var oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		this.quad.material = this.material;

		this.uniforms["opacity"].value = this.opacity;
		this.uniforms["tDiffuse"].value = this.map;
		this.material.transparent = this.opacity < 1.0;

		renderer.render(this.scene, this.camera, this.renderToScreen ? null : readBuffer, this.clear);

		renderer.autoClear = oldAutoClear;
	}

});

exports.default = TexturePass;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

var _Pass = __webpack_require__(1);

var _Pass2 = _interopRequireDefault(_Pass);

var _CopyShader = __webpack_require__(2);

var _CopyShader2 = _interopRequireDefault(_CopyShader);

var _LuminosityHighPassShader = __webpack_require__(26);

var _LuminosityHighPassShader2 = _interopRequireDefault(_LuminosityHighPassShader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author spidersharma / http://eduperiment.com/
 *
 * Inspired from Unreal Engine
 * https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/
 */
var UnrealBloomPass = function UnrealBloomPass(resolution, strength, radius, threshold) {

	_Pass2.default.call(this);

	this.strength = strength !== undefined ? strength : 1;
	this.radius = radius;
	this.threshold = threshold;
	this.resolution = resolution !== undefined ? new THREE.Vector2(resolution.x, resolution.y) : new THREE.Vector2(256, 256);

	// render targets
	var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };
	this.renderTargetsHorizontal = [];
	this.renderTargetsVertical = [];
	this.nMips = 5;
	var resx = Math.round(this.resolution.x / 2);
	var resy = Math.round(this.resolution.y / 2);

	this.renderTargetBright = new THREE.WebGLRenderTarget(resx, resy, pars);
	this.renderTargetBright.texture.name = "UnrealBloomPass.bright";
	this.renderTargetBright.texture.generateMipmaps = false;

	for (var i = 0; i < this.nMips; i++) {

		var renderTarget = new THREE.WebGLRenderTarget(resx, resy, pars);

		renderTarget.texture.name = "UnrealBloomPass.h" + i;
		renderTarget.texture.generateMipmaps = false;

		this.renderTargetsHorizontal.push(renderTarget);

		var renderTarget = new THREE.WebGLRenderTarget(resx, resy, pars);

		renderTarget.texture.name = "UnrealBloomPass.v" + i;
		renderTarget.texture.generateMipmaps = false;

		this.renderTargetsVertical.push(renderTarget);

		resx = Math.round(resx / 2);

		resy = Math.round(resy / 2);
	}

	// luminosity high pass material

	if (_LuminosityHighPassShader2.default === undefined) console.error("THREE.UnrealBloomPass relies on THREE.LuminosityHighPassShader");

	var highPassShader = _LuminosityHighPassShader2.default;
	this.highPassUniforms = THREE.UniformsUtils.clone(highPassShader.uniforms);

	this.highPassUniforms["luminosityThreshold"].value = threshold;
	this.highPassUniforms["smoothWidth"].value = 0.01;

	this.materialHighPassFilter = new THREE.ShaderMaterial({
		uniforms: this.highPassUniforms,
		vertexShader: highPassShader.vertexShader,
		fragmentShader: highPassShader.fragmentShader,
		defines: {}
	});

	// Gaussian Blur Materials
	this.separableBlurMaterials = [];
	var kernelSizeArray = [3, 5, 7, 9, 11];
	var resx = Math.round(this.resolution.x / 2);
	var resy = Math.round(this.resolution.y / 2);

	for (var i = 0; i < this.nMips; i++) {

		this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));

		this.separableBlurMaterials[i].uniforms["texSize"].value = new THREE.Vector2(resx, resy);

		resx = Math.round(resx / 2);

		resy = Math.round(resy / 2);
	}

	// Composite material
	this.compositeMaterial = this.getCompositeMaterial(this.nMips);
	this.compositeMaterial.uniforms["blurTexture1"].value = this.renderTargetsVertical[0].texture;
	this.compositeMaterial.uniforms["blurTexture2"].value = this.renderTargetsVertical[1].texture;
	this.compositeMaterial.uniforms["blurTexture3"].value = this.renderTargetsVertical[2].texture;
	this.compositeMaterial.uniforms["blurTexture4"].value = this.renderTargetsVertical[3].texture;
	this.compositeMaterial.uniforms["blurTexture5"].value = this.renderTargetsVertical[4].texture;
	this.compositeMaterial.uniforms["bloomStrength"].value = strength;
	this.compositeMaterial.uniforms["bloomRadius"].value = 0.1;
	this.compositeMaterial.needsUpdate = true;

	var bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];
	this.compositeMaterial.uniforms["bloomFactors"].value = bloomFactors;
	this.bloomTintColors = [new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1)];
	this.compositeMaterial.uniforms["bloomTintColors"].value = this.bloomTintColors;

	// copy material
	if (_CopyShader2.default === undefined) {

		console.error("THREE.BloomPass relies on THREE.CopyShader");
	}

	var copyShader = _CopyShader2.default;

	this.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);
	this.copyUniforms["opacity"].value = 1.0;

	this.materialCopy = new THREE.ShaderMaterial({
		uniforms: this.copyUniforms,
		vertexShader: copyShader.vertexShader,
		fragmentShader: copyShader.fragmentShader,
		blending: THREE.AdditiveBlending,
		depthTest: false,
		depthWrite: false,
		transparent: true
	});

	this.enabled = true;
	this.needsSwap = false;

	this.oldClearColor = new THREE.Color();
	this.oldClearAlpha = 1;

	this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
	this.scene = new THREE.Scene();

	this.basic = new THREE.MeshBasicMaterial();

	this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
	this.quad.frustumCulled = false; // Avoid getting clipped
	this.scene.add(this.quad);
};

UnrealBloomPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {

	constructor: UnrealBloomPass,

	dispose: function dispose() {

		for (var i = 0; i < this.renderTargetsHorizontal.length; i++) {

			this.renderTargetsHorizontal[i].dispose();
		}

		for (var i = 0; i < this.renderTargetsVertical.length; i++) {

			this.renderTargetsVertical[i].dispose();
		}

		this.renderTargetBright.dispose();
	},

	setSize: function setSize(width, height) {

		var resx = Math.round(width / 2);
		var resy = Math.round(height / 2);

		this.renderTargetBright.setSize(resx, resy);

		for (var i = 0; i < this.nMips; i++) {

			this.renderTargetsHorizontal[i].setSize(resx, resy);
			this.renderTargetsVertical[i].setSize(resx, resy);

			this.separableBlurMaterials[i].uniforms["texSize"].value = new THREE.Vector2(resx, resy);

			resx = Math.round(resx / 2);
			resy = Math.round(resy / 2);
		}
	},

	render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {

		this.oldClearColor.copy(renderer.getClearColor());
		this.oldClearAlpha = renderer.getClearAlpha();
		var oldAutoClear = renderer.autoClear;
		renderer.autoClear = false;

		renderer.setClearColor(new THREE.Color(0, 0, 0), 0);

		if (maskActive) renderer.context.disable(renderer.context.STENCIL_TEST);

		// Render input to screen

		if (this.renderToScreen) {

			this.quad.material = this.basic;
			this.basic.map = readBuffer.texture;

			renderer.render(this.scene, this.camera, undefined, true);
		}

		// 1. Extract Bright Areas

		this.highPassUniforms["tDiffuse"].value = readBuffer.texture;
		this.highPassUniforms["luminosityThreshold"].value = this.threshold;
		this.quad.material = this.materialHighPassFilter;

		renderer.render(this.scene, this.camera, this.renderTargetBright, true);

		// 2. Blur All the mips progressively

		var inputRenderTarget = this.renderTargetBright;

		for (var i = 0; i < this.nMips; i++) {

			this.quad.material = this.separableBlurMaterials[i];

			this.separableBlurMaterials[i].uniforms["colorTexture"].value = inputRenderTarget.texture;
			this.separableBlurMaterials[i].uniforms["direction"].value = THREE.UnrealBloomPass.BlurDirectionX;
			renderer.render(this.scene, this.camera, this.renderTargetsHorizontal[i], true);

			this.separableBlurMaterials[i].uniforms["colorTexture"].value = this.renderTargetsHorizontal[i].texture;
			this.separableBlurMaterials[i].uniforms["direction"].value = THREE.UnrealBloomPass.BlurDirectionY;
			renderer.render(this.scene, this.camera, this.renderTargetsVertical[i], true);

			inputRenderTarget = this.renderTargetsVertical[i];
		}

		// Composite All the mips

		this.quad.material = this.compositeMaterial;
		this.compositeMaterial.uniforms["bloomStrength"].value = this.strength;
		this.compositeMaterial.uniforms["bloomRadius"].value = this.radius;
		this.compositeMaterial.uniforms["bloomTintColors"].value = this.bloomTintColors;

		renderer.render(this.scene, this.camera, this.renderTargetsHorizontal[0], true);

		// Blend it additively over the input texture

		this.quad.material = this.materialCopy;
		this.copyUniforms["tDiffuse"].value = this.renderTargetsHorizontal[0].texture;

		if (maskActive) renderer.context.enable(renderer.context.STENCIL_TEST);

		if (this.renderToScreen) {

			renderer.render(this.scene, this.camera, undefined, false);
		} else {

			renderer.render(this.scene, this.camera, readBuffer, false);
		}

		// Restore renderer settings

		renderer.setClearColor(this.oldClearColor, this.oldClearAlpha);
		renderer.autoClear = oldAutoClear;
	},

	getSeperableBlurMaterial: function getSeperableBlurMaterial(kernelRadius) {

		return new THREE.ShaderMaterial({

			defines: {
				"KERNEL_RADIUS": kernelRadius,
				"SIGMA": kernelRadius
			},

			uniforms: {
				"colorTexture": { value: null },
				"texSize": { value: new THREE.Vector2(0.5, 0.5) },
				"direction": { value: new THREE.Vector2(0.5, 0.5) }
			},

			vertexShader: "varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader: "#include <common>\
				varying vec2 vUv;\n\
				uniform sampler2D colorTexture;\n\
				uniform vec2 texSize;\
				uniform vec2 direction;\
				\
				float gaussianPdf(in float x, in float sigma) {\
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\
				}\
				void main() {\n\
					vec2 invSize = 1.0 / texSize;\
					float fSigma = float(SIGMA);\
					float weightSum = gaussianPdf(0.0, fSigma);\
					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {\
						float x = float(i);\
						float w = gaussianPdf(x, fSigma);\
						vec2 uvOffset = direction * invSize * x;\
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\
						diffuseSum += (sample1 + sample2) * w;\
						weightSum += 2.0 * w;\
					}\
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\
				}"
		});
	},

	getCompositeMaterial: function getCompositeMaterial(nMips) {

		return new THREE.ShaderMaterial({

			defines: {
				"NUM_MIPS": nMips
			},

			uniforms: {
				"blurTexture1": { value: null },
				"blurTexture2": { value: null },
				"blurTexture3": { value: null },
				"blurTexture4": { value: null },
				"blurTexture5": { value: null },
				"dirtTexture": { value: null },
				"bloomStrength": { value: 1.0 },
				"bloomFactors": { value: null },
				"bloomTintColors": { value: null },
				"bloomRadius": { value: 0.0 }
			},

			vertexShader: "varying vec2 vUv;\n\
				void main() {\n\
					vUv = uv;\n\
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
				}",

			fragmentShader: "varying vec2 vUv;\
				uniform sampler2D blurTexture1;\
				uniform sampler2D blurTexture2;\
				uniform sampler2D blurTexture3;\
				uniform sampler2D blurTexture4;\
				uniform sampler2D blurTexture5;\
				uniform sampler2D dirtTexture;\
				uniform float bloomStrength;\
				uniform float bloomRadius;\
				uniform float bloomFactors[NUM_MIPS];\
				uniform vec3 bloomTintColors[NUM_MIPS];\
				\
				float lerpBloomFactor(const in float factor) { \
					float mirrorFactor = 1.2 - factor;\
					return mix(factor, mirrorFactor, bloomRadius);\
				}\
				\
				void main() {\
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \
													 lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \
													 lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \
													 lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \
													 lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\
				}"
		});
	}

});

UnrealBloomPass.BlurDirectionX = new THREE.Vector2(1.0, 0.0);
UnrealBloomPass.BlurDirectionY = new THREE.Vector2(0.0, 1.0);

exports.default = UnrealBloomPass;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WaterRefractionShader = exports.VignetteShader = exports.VerticalTiltShiftShader = exports.VerticalBlurShader = exports.UnpackDepthRGBAShader = exports.TriangleBlurShader = exports.ToneMapShader = exports.TechnicolorShader = exports.SSAOShader = exports.SobelOperatorShader = exports.SMAAShader = exports.SepiaShader = exports.SAOShader = exports.RGBShiftShader = exports.PixelShader = exports.ParallaxShader = exports.NormalMapShader = exports.MirrorShader = exports.LuminosityShader = exports.LuminosityHighPassShader = exports.KaleidoShader = exports.HueSaturationShader = exports.HorizontalTiltShiftShader = exports.HorizontalBlurShader = exports.HalftoneShader = exports.GammaCorrectionShader = exports.FXAAShader = exports.FresnelShader = exports.FreiChenShader = exports.FocusShader = exports.FilmShader = exports.DotScreenShader = exports.DOFMipMapShader = exports.DigitalGlitch = exports.DepthLimitedBlurShader = exports.CopyShader = exports.ConvolutionShader = exports.ColorifyShader = exports.ColorCorrectionShader = exports.BrightnessContrastShader = exports.BokehShader2 = exports.BokehShader = exports.BlurShaderUtils = exports.BlendShader = exports.BleachBypassShader = exports.BasicShader = undefined;

var _BasicShader = __webpack_require__(113);

var _BasicShader2 = _interopRequireDefault(_BasicShader);

var _BleachBypassShader = __webpack_require__(114);

var _BleachBypassShader2 = _interopRequireDefault(_BleachBypassShader);

var _BlendShader = __webpack_require__(115);

var _BlendShader2 = _interopRequireDefault(_BlendShader);

var _BlurShaderUtils = __webpack_require__(22);

var _BlurShaderUtils2 = _interopRequireDefault(_BlurShaderUtils);

var _BokehShader = __webpack_require__(14);

var _BokehShader2 = _interopRequireDefault(_BokehShader);

var _BokehShader3 = __webpack_require__(116);

var _BokehShader4 = _interopRequireDefault(_BokehShader3);

var _BrightnessContrastShader = __webpack_require__(117);

var _BrightnessContrastShader2 = _interopRequireDefault(_BrightnessContrastShader);

var _ColorCorrectionShader = __webpack_require__(118);

var _ColorCorrectionShader2 = _interopRequireDefault(_ColorCorrectionShader);

var _ColorifyShader = __webpack_require__(119);

var _ColorifyShader2 = _interopRequireDefault(_ColorifyShader);

var _ConvolutionShader = __webpack_require__(13);

var _ConvolutionShader2 = _interopRequireDefault(_ConvolutionShader);

var _CopyShader = __webpack_require__(2);

var _CopyShader2 = _interopRequireDefault(_CopyShader);

var _DepthLimitedBlurShader = __webpack_require__(20);

var _DepthLimitedBlurShader2 = _interopRequireDefault(_DepthLimitedBlurShader);

var _DigitalGlitch = __webpack_require__(17);

var _DigitalGlitch2 = _interopRequireDefault(_DigitalGlitch);

var _DOFMipMapShader = __webpack_require__(120);

var _DOFMipMapShader2 = _interopRequireDefault(_DOFMipMapShader);

var _DotScreenShader = __webpack_require__(15);

var _DotScreenShader2 = _interopRequireDefault(_DotScreenShader);

var _FilmShader = __webpack_require__(16);

var _FilmShader2 = _interopRequireDefault(_FilmShader);

var _FocusShader = __webpack_require__(121);

var _FocusShader2 = _interopRequireDefault(_FocusShader);

var _FreiChenShader = __webpack_require__(122);

var _FreiChenShader2 = _interopRequireDefault(_FreiChenShader);

var _FresnelShader = __webpack_require__(123);

var _FresnelShader2 = _interopRequireDefault(_FresnelShader);

var _FXAAShader = __webpack_require__(124);

var _FXAAShader2 = _interopRequireDefault(_FXAAShader);

var _GammaCorrectionShader = __webpack_require__(125);

var _GammaCorrectionShader2 = _interopRequireDefault(_GammaCorrectionShader);

var _HalftoneShader = __webpack_require__(18);

var _HalftoneShader2 = _interopRequireDefault(_HalftoneShader);

var _HorizontalBlurShader = __webpack_require__(126);

var _HorizontalBlurShader2 = _interopRequireDefault(_HorizontalBlurShader);

var _HorizontalTiltShiftShader = __webpack_require__(127);

var _HorizontalTiltShiftShader2 = _interopRequireDefault(_HorizontalTiltShiftShader);

var _HueSaturationShader = __webpack_require__(128);

var _HueSaturationShader2 = _interopRequireDefault(_HueSaturationShader);

var _KaleidoShader = __webpack_require__(129);

var _KaleidoShader2 = _interopRequireDefault(_KaleidoShader);

var _LuminosityHighPassShader = __webpack_require__(26);

var _LuminosityHighPassShader2 = _interopRequireDefault(_LuminosityHighPassShader);

var _LuminosityShader = __webpack_require__(11);

var _LuminosityShader2 = _interopRequireDefault(_LuminosityShader);

var _MirrorShader = __webpack_require__(130);

var _MirrorShader2 = _interopRequireDefault(_MirrorShader);

var _NormalMapShader = __webpack_require__(131);

var _NormalMapShader2 = _interopRequireDefault(_NormalMapShader);

var _OceanShaders = __webpack_require__(132);

var _OceanShaders2 = _interopRequireDefault(_OceanShaders);

var _ParallaxShader = __webpack_require__(133);

var _ParallaxShader2 = _interopRequireDefault(_ParallaxShader);

var _PixelShader = __webpack_require__(134);

var _PixelShader2 = _interopRequireDefault(_PixelShader);

var _RGBShiftShader = __webpack_require__(135);

var _RGBShiftShader2 = _interopRequireDefault(_RGBShiftShader);

var _SAOShader = __webpack_require__(19);

var _SAOShader2 = _interopRequireDefault(_SAOShader);

var _SepiaShader = __webpack_require__(136);

var _SepiaShader2 = _interopRequireDefault(_SepiaShader);

var _SMAAShader = __webpack_require__(23);

var _SMAAShader2 = _interopRequireDefault(_SMAAShader);

var _SobelOperatorShader = __webpack_require__(137);

var _SobelOperatorShader2 = _interopRequireDefault(_SobelOperatorShader);

var _SSAOShader = __webpack_require__(25);

var _SSAOShader2 = _interopRequireDefault(_SSAOShader);

var _TechnicolorShader = __webpack_require__(138);

var _TechnicolorShader2 = _interopRequireDefault(_TechnicolorShader);

var _ToneMapShader = __webpack_require__(12);

var _ToneMapShader2 = _interopRequireDefault(_ToneMapShader);

var _TriangleBlurShader = __webpack_require__(139);

var _TriangleBlurShader2 = _interopRequireDefault(_TriangleBlurShader);

var _UnpackDepthRGBAShader = __webpack_require__(21);

var _UnpackDepthRGBAShader2 = _interopRequireDefault(_UnpackDepthRGBAShader);

var _VerticalBlurShader = __webpack_require__(140);

var _VerticalBlurShader2 = _interopRequireDefault(_VerticalBlurShader);

var _VerticalTiltShiftShader = __webpack_require__(141);

var _VerticalTiltShiftShader2 = _interopRequireDefault(_VerticalTiltShiftShader);

var _VignetteShader = __webpack_require__(142);

var _VignetteShader2 = _interopRequireDefault(_VignetteShader);

var _WaterRefractionShader = __webpack_require__(143);

var _WaterRefractionShader2 = _interopRequireDefault(_WaterRefractionShader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.BasicShader = _BasicShader2.default;
exports.BleachBypassShader = _BleachBypassShader2.default;
exports.BlendShader = _BlendShader2.default;
exports.BlurShaderUtils = _BlurShaderUtils2.default;
exports.BokehShader = _BokehShader2.default;
exports.BokehShader2 = _BokehShader4.default;
exports.BrightnessContrastShader = _BrightnessContrastShader2.default;
exports.ColorCorrectionShader = _ColorCorrectionShader2.default;
exports.ColorifyShader = _ColorifyShader2.default;
exports.ConvolutionShader = _ConvolutionShader2.default;
exports.CopyShader = _CopyShader2.default;
exports.DepthLimitedBlurShader = _DepthLimitedBlurShader2.default;
exports.DigitalGlitch = _DigitalGlitch2.default;
exports.DOFMipMapShader = _DOFMipMapShader2.default;
exports.DotScreenShader = _DotScreenShader2.default;
exports.FilmShader = _FilmShader2.default;
exports.FocusShader = _FocusShader2.default;
exports.FreiChenShader = _FreiChenShader2.default;
exports.FresnelShader = _FresnelShader2.default;
exports.FXAAShader = _FXAAShader2.default;
exports.GammaCorrectionShader = _GammaCorrectionShader2.default;
exports.HalftoneShader = _HalftoneShader2.default;
exports.HorizontalBlurShader = _HorizontalBlurShader2.default;
exports.HorizontalTiltShiftShader = _HorizontalTiltShiftShader2.default;
exports.HueSaturationShader = _HueSaturationShader2.default;
exports.KaleidoShader = _KaleidoShader2.default;
exports.LuminosityHighPassShader = _LuminosityHighPassShader2.default;
exports.LuminosityShader = _LuminosityShader2.default;
exports.MirrorShader = _MirrorShader2.default;
exports.NormalMapShader = _NormalMapShader2.default;
exports.ParallaxShader = _ParallaxShader2.default;
exports.PixelShader = _PixelShader2.default;
exports.RGBShiftShader = _RGBShiftShader2.default;
exports.SAOShader = _SAOShader2.default;
exports.SepiaShader = _SepiaShader2.default;
exports.SMAAShader = _SMAAShader2.default;
exports.SobelOperatorShader = _SobelOperatorShader2.default;
exports.SSAOShader = _SSAOShader2.default;
exports.TechnicolorShader = _TechnicolorShader2.default;
exports.ToneMapShader = _ToneMapShader2.default;
exports.TriangleBlurShader = _TriangleBlurShader2.default;
exports.UnpackDepthRGBAShader = _UnpackDepthRGBAShader2.default;
exports.VerticalBlurShader = _VerticalBlurShader2.default;
exports.VerticalTiltShiftShader = _VerticalTiltShiftShader2.default;
exports.VignetteShader = _VignetteShader2.default;
exports.WaterRefractionShader = _WaterRefractionShader2.default;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author mrdoob / http://www.mrdoob.com
 *
 * Simple test shader
 */

var BasicShader = {

	uniforms: {},

	vertexShader: ["void main() {", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["void main() {", "gl_FragColor = vec4( 1.0, 0.0, 0.0, 0.5 );", "}"].join("\n")

};

exports.default = BasicShader;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Bleach bypass shader [http://en.wikipedia.org/wiki/Bleach_bypass]
 * - based on Nvidia example
 * http://developer.download.nvidia.com/shaderlibrary/webpages/shader_library.html#post_bleach_bypass
 */

var BleachBypassShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"opacity": { value: 1.0 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 base = texture2D( tDiffuse, vUv );", "vec3 lumCoeff = vec3( 0.25, 0.65, 0.1 );", "float lum = dot( lumCoeff, base.rgb );", "vec3 blend = vec3( lum );", "float L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );", "vec3 result1 = 2.0 * base.rgb * blend;", "vec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );", "vec3 newColor = mix( result1, result2, L );", "float A2 = opacity * base.a;", "vec3 mixRGB = A2 * newColor.rgb;", "mixRGB += ( ( 1.0 - A2 ) * base.rgb );", "gl_FragColor = vec4( mixRGB, base.a );", "}"].join("\n")

};

exports.default = BleachBypassShader;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Blend two textures
 */

var BlendShader = {

	uniforms: {

		"tDiffuse1": { value: null },
		"tDiffuse2": { value: null },
		"mixRatio": { value: 0.5 },
		"opacity": { value: 1.0 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform float opacity;", "uniform float mixRatio;", "uniform sampler2D tDiffuse1;", "uniform sampler2D tDiffuse2;", "varying vec2 vUv;", "void main() {", "vec4 texel1 = texture2D( tDiffuse1, vUv );", "vec4 texel2 = texture2D( tDiffuse2, vUv );", "gl_FragColor = opacity * mix( texel1, texel2, mixRatio );", "}"].join("\n")

};

exports.default = BlendShader;

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author zz85 / https://github.com/zz85 | twitter.com/blurspline
 *
 * Depth-of-field shader with bokeh
 * ported from GLSL shader by Martins Upitis
 * http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)
 *
 * Requires #define RINGS and SAMPLES integers
 */

var BokehShader2 = {

	uniforms: {

		"textureWidth": { value: 1.0 },
		"textureHeight": { value: 1.0 },

		"focalDepth": { value: 1.0 },
		"focalLength": { value: 24.0 },
		"fstop": { value: 0.9 },

		"tColor": { value: null },
		"tDepth": { value: null },

		"maxblur": { value: 1.0 },

		"showFocus": { value: 0 },
		"manualdof": { value: 0 },
		"vignetting": { value: 0 },
		"depthblur": { value: 0 },

		"threshold": { value: 0.5 },
		"gain": { value: 2.0 },
		"bias": { value: 0.5 },
		"fringe": { value: 0.7 },

		"znear": { value: 0.1 },
		"zfar": { value: 100 },

		"noise": { value: 1 },
		"dithering": { value: 0.0001 },
		"pentagon": { value: 0 },

		"shaderFocus": { value: 1 },
		"focusCoords": { value: new THREE.Vector2() }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["#include <common>", "#include <packing>", "varying vec2 vUv;", "uniform sampler2D tColor;", "uniform sampler2D tDepth;", "uniform float textureWidth;", "uniform float textureHeight;", "uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below", "uniform float focalLength; //focal length in mm", "uniform float fstop; //f-stop value", "uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)", "/*", "make sure that these two values are the same for your camera, otherwise distances will be wrong.", "*/", "uniform float znear; // camera clipping start", "uniform float zfar; // camera clipping end", "//------------------------------------------", "//user variables", "const int samples = SAMPLES; //samples on the first ring", "const int rings = RINGS; //ring count", "const int maxringsamples = rings * samples;", "uniform bool manualdof; // manual dof calculation", "float ndofstart = 1.0; // near dof blur start", "float ndofdist = 2.0; // near dof blur falloff distance", "float fdofstart = 1.0; // far dof blur start", "float fdofdist = 3.0; // far dof blur falloff distance", "float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)", "uniform bool vignetting; // use optical lens vignetting", "float vignout = 1.3; // vignetting outer border", "float vignin = 0.0; // vignetting inner border", "float vignfade = 22.0; // f-stops till vignete fades", "uniform bool shaderFocus;", "// disable if you use external focalDepth value", "uniform vec2 focusCoords;", "// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)", "// if center of screen use vec2(0.5, 0.5);", "uniform float maxblur;", "//clamp value of max blur (0.0 = no blur, 1.0 default)", "uniform float threshold; // highlight threshold;", "uniform float gain; // highlight gain;", "uniform float bias; // bokeh edge bias", "uniform float fringe; // bokeh chromatic aberration / fringing", "uniform bool noise; //use noise instead of pattern for sample dithering", "uniform float dithering;", "uniform bool depthblur; // blur the depth buffer", "float dbsize = 1.25; // depth blur size", "/*", "next part is experimental", "not looking good with small sample and ring count", "looks okay starting from samples = 4, rings = 4", "*/", "uniform bool pentagon; //use pentagon as bokeh shape?", "float feather = 0.4; //pentagon shape feather", "//------------------------------------------", "float getDepth( const in vec2 screenPosition ) {", "	#if DEPTH_PACKING == 1", "	return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );", "	#else", "	return texture2D( tDepth, screenPosition ).x;", "	#endif", "}", "float penta(vec2 coords) {", "//pentagonal shape", "float scale = float(rings) - 1.3;", "vec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);", "vec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);", "vec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);", "vec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);", "vec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);", "vec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);", "vec4  one = vec4( 1.0 );", "vec4 P = vec4((coords),vec2(scale, scale));", "vec4 dist = vec4(0.0);", "float inorout = -4.0;", "dist.x = dot( P, HS0 );", "dist.y = dot( P, HS1 );", "dist.z = dot( P, HS2 );", "dist.w = dot( P, HS3 );", "dist = smoothstep( -feather, feather, dist );", "inorout += dot( dist, one );", "dist.x = dot( P, HS4 );", "dist.y = HS5.w - abs( P.z );", "dist = smoothstep( -feather, feather, dist );", "inorout += dist.x;", "return clamp( inorout, 0.0, 1.0 );", "}", "float bdepth(vec2 coords) {", "// Depth buffer blur", "float d = 0.0;", "float kernel[9];", "vec2 offset[9];", "vec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;", "offset[0] = vec2(-wh.x,-wh.y);", "offset[1] = vec2( 0.0, -wh.y);", "offset[2] = vec2( wh.x -wh.y);", "offset[3] = vec2(-wh.x,  0.0);", "offset[4] = vec2( 0.0,   0.0);", "offset[5] = vec2( wh.x,  0.0);", "offset[6] = vec2(-wh.x, wh.y);", "offset[7] = vec2( 0.0,  wh.y);", "offset[8] = vec2( wh.x, wh.y);", "kernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;", "kernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;", "kernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;", "for( int i=0; i<9; i++ ) {", "float tmp = getDepth( coords + offset[ i ] );", "d += tmp * kernel[i];", "}", "return d;", "}", "vec3 color(vec2 coords,float blur) {", "//processing the sample", "vec3 col = vec3(0.0);", "vec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);", "col.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;", "col.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;", "col.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;", "vec3 lumcoeff = vec3(0.299,0.587,0.114);", "float lum = dot(col.rgb, lumcoeff);", "float thresh = max((lum-threshold)*gain, 0.0);", "return col+mix(vec3(0.0),col,thresh*blur);", "}", "vec3 debugFocus(vec3 col, float blur, float depth) {", "float edge = 0.002*depth; //distance based edge smoothing", "float m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);", "float e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);", "col = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);", "col = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);", "return col;", "}", "float linearize(float depth) {", "return -zfar * znear / (depth * (zfar - znear) - zfar);", "}", "float vignette() {", "float dist = distance(vUv.xy, vec2(0.5,0.5));", "dist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);", "return clamp(dist,0.0,1.0);", "}", "float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {", "float rings2 = float(rings);", "float step = PI*2.0 / float(ringsamples);", "float pw = cos(j*step)*i;", "float ph = sin(j*step)*i;", "float p = 1.0;", "if (pentagon) {", "p = penta(vec2(pw,ph));", "}", "col += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;", "return 1.0 * mix(1.0, i /rings2, bias) * p;", "}", "void main() {", "//scene depth calculation", "float depth = linearize( getDepth( vUv.xy ) );", "// Blur depth?", "if (depthblur) {", "depth = linearize(bdepth(vUv.xy));", "}", "//focal plane calculation", "float fDepth = focalDepth;", "if (shaderFocus) {", "fDepth = linearize( getDepth( focusCoords ) );", "}", "// dof blur factor calculation", "float blur = 0.0;", "if (manualdof) {", "float a = depth-fDepth; // Focal plane", "float b = (a-fdofstart)/fdofdist; // Far DoF", "float c = (-a-ndofstart)/ndofdist; // Near Dof", "blur = (a>0.0) ? b : c;", "} else {", "float f = focalLength; // focal length in mm", "float d = fDepth*1000.0; // focal plane in mm", "float o = depth*1000.0; // depth in mm", "float a = (o*f)/(o-f);", "float b = (d*f)/(d-f);", "float c = (d-f)/(d*fstop*CoC);", "blur = abs(a-b)*c;", "}", "blur = clamp(blur,0.0,1.0);", "// calculation of pattern for dithering", "vec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;", "// getting blur x and y step factor", "float w = (1.0/textureWidth)*blur*maxblur+noise.x;", "float h = (1.0/textureHeight)*blur*maxblur+noise.y;", "// calculation of final color", "vec3 col = vec3(0.0);", "if(blur < 0.05) {", "//some optimization thingy", "col = texture2D(tColor, vUv.xy).rgb;", "} else {", "col = texture2D(tColor, vUv.xy).rgb;", "float s = 1.0;", "int ringsamples;", "for (int i = 1; i <= rings; i++) {", "/*unboxstart*/", "ringsamples = i * samples;", "for (int j = 0 ; j < maxringsamples ; j++) {", "if (j >= ringsamples) break;", "s += gather(float(i), float(j), ringsamples, col, w, h, blur);", "}", "/*unboxend*/", "}", "col /= s; //divide by sample count", "}", "if (showFocus) {", "col = debugFocus(col, blur, depth);", "}", "if (vignetting) {", "col *= vignette();", "}", "gl_FragColor.rgb = col;", "gl_FragColor.a = 1.0;", "} "].join("\n")

};

exports.default = BokehShader2;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author tapio / http://tapio.github.com/
 *
 * Brightness and contrast adjustment
 * https://github.com/evanw/glfx.js
 * brightness: -1 to 1 (-1 is solid black, 0 is no change, and 1 is solid white)
 * contrast: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)
 */

var BrightnessContrastShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"brightness": { value: 0 },
		"contrast": { value: 0 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float brightness;", "uniform float contrast;", "varying vec2 vUv;", "void main() {", "gl_FragColor = texture2D( tDiffuse, vUv );", "gl_FragColor.rgb += brightness;", "if (contrast > 0.0) {", "gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) / (1.0 - contrast) + 0.5;", "} else {", "gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) * (1.0 + contrast) + 0.5;", "}", "}"].join("\n")

};

exports.default = BrightnessContrastShader;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Color correction
 */

var ColorCorrectionShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"powRGB": { value: new THREE.Vector3(2, 2, 2) },
		"mulRGB": { value: new THREE.Vector3(1, 1, 1) },
		"addRGB": { value: new THREE.Vector3(0, 0, 0) }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform sampler2D tDiffuse;", "uniform vec3 powRGB;", "uniform vec3 mulRGB;", "uniform vec3 addRGB;", "varying vec2 vUv;", "void main() {", "gl_FragColor = texture2D( tDiffuse, vUv );", "gl_FragColor.rgb = mulRGB * pow( ( gl_FragColor.rgb + addRGB ), powRGB );", "}"].join("\n")

};

exports.default = ColorCorrectionShader;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Colorify shader
 */

var ColorifyShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"color": { value: new THREE.Color(0xffffff) }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform vec3 color;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "vec3 luma = vec3( 0.299, 0.587, 0.114 );", "float v = dot( texel.xyz, luma );", "gl_FragColor = vec4( v * color, texel.w );", "}"].join("\n")

};

exports.default = ColorifyShader;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Depth-of-field shader using mipmaps
 * - from Matt Handley @applmak
 * - requires power-of-2 sized render target with enabled mipmaps
 */

var DOFMipMapShader = {

	uniforms: {

		"tColor": { value: null },
		"tDepth": { value: null },
		"focus": { value: 1.0 },
		"maxblur": { value: 1.0 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform float focus;", "uniform float maxblur;", "uniform sampler2D tColor;", "uniform sampler2D tDepth;", "varying vec2 vUv;", "void main() {", "vec4 depth = texture2D( tDepth, vUv );", "float factor = depth.x - focus;", "vec4 col = texture2D( tColor, vUv, 2.0 * maxblur * abs( focus - depth.x ) );", "gl_FragColor = col;", "gl_FragColor.a = 1.0;", "}"].join("\n")

};

exports.default = DOFMipMapShader;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Focus shader
 * based on PaintEffect postprocess from ro.me
 * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js
 */

var FocusShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"screenWidth": { value: 1024 },
		"screenHeight": { value: 1024 },
		"sampleDistance": { value: 0.94 },
		"waveFactor": { value: 0.00125 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform float screenWidth;", "uniform float screenHeight;", "uniform float sampleDistance;", "uniform float waveFactor;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 color, org, tmp, add;", "float sample_dist, f;", "vec2 vin;", "vec2 uv = vUv;", "add = color = org = texture2D( tDiffuse, uv );", "vin = ( uv - vec2( 0.5 ) ) * vec2( 1.4 );", "sample_dist = dot( vin, vin ) * 2.0;", "f = ( waveFactor * 100.0 + sample_dist ) * sampleDistance * 4.0;", "vec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2( f );", "add += tmp = texture2D( tDiffuse, uv + vec2( 0.111964, 0.993712 ) * sampleSize );", "if( tmp.b < color.b ) color = tmp;", "add += tmp = texture2D( tDiffuse, uv + vec2( 0.846724, 0.532032 ) * sampleSize );", "if( tmp.b < color.b ) color = tmp;", "add += tmp = texture2D( tDiffuse, uv + vec2( 0.943883, -0.330279 ) * sampleSize );", "if( tmp.b < color.b ) color = tmp;", "add += tmp = texture2D( tDiffuse, uv + vec2( 0.330279, -0.943883 ) * sampleSize );", "if( tmp.b < color.b ) color = tmp;", "add += tmp = texture2D( tDiffuse, uv + vec2( -0.532032, -0.846724 ) * sampleSize );", "if( tmp.b < color.b ) color = tmp;", "add += tmp = texture2D( tDiffuse, uv + vec2( -0.993712, -0.111964 ) * sampleSize );", "if( tmp.b < color.b ) color = tmp;", "add += tmp = texture2D( tDiffuse, uv + vec2( -0.707107, 0.707107 ) * sampleSize );", "if( tmp.b < color.b ) color = tmp;", "color = color * vec4( 2.0 ) - ( add / vec4( 8.0 ) );", "color = color + ( add / vec4( 8.0 ) - color ) * ( vec4( 1.0 ) - vec4( sample_dist * 0.5 ) );", "gl_FragColor = vec4( color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, 1.0 );", "}"].join("\n")
};

exports.default = FocusShader;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author zz85 / https://github.com/zz85 | https://www.lab4games.net/zz85/blog
 *
 * Edge Detection Shader using Frei-Chen filter
 * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector
 *
 * aspect: vec2 of (1/width, 1/height)
 */

var FreiChenShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"aspect": { value: new THREE.Vector2(512, 512) }
	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform sampler2D tDiffuse;", "varying vec2 vUv;", "uniform vec2 aspect;", "vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);", "mat3 G[9];",

	// hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45

	"const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );", "const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );", "const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );", "const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );", "const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );", "const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );", "const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );", "const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );", "const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );", "void main(void)", "{", "G[0] = g0,", "G[1] = g1,", "G[2] = g2,", "G[3] = g3,", "G[4] = g4,", "G[5] = g5,", "G[6] = g6,", "G[7] = g7,", "G[8] = g8;", "mat3 I;", "float cnv[9];", "vec3 sample;",

	/* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */
	"for (float i=0.0; i<3.0; i++) {", "for (float j=0.0; j<3.0; j++) {", "sample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;", "I[int(i)][int(j)] = length(sample);", "}", "}",

	/* calculate the convolution values for all the masks */
	"for (int i=0; i<9; i++) {", "float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);", "cnv[i] = dp3 * dp3;", "}", "float M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);", "float S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);", "gl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);", "}"].join("\n")
};

exports.default = FreiChenShader;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Based on Nvidia Cg tutorial
 */

var FresnelShader = {

	uniforms: {

		"mRefractionRatio": { value: 1.02 },
		"mFresnelBias": { value: 0.1 },
		"mFresnelPower": { value: 2.0 },
		"mFresnelScale": { value: 1.0 },
		"tCube": { value: null }

	},

	vertexShader: ["uniform float mRefractionRatio;", "uniform float mFresnelBias;", "uniform float mFresnelScale;", "uniform float mFresnelPower;", "varying vec3 vReflect;", "varying vec3 vRefract[3];", "varying float vReflectionFactor;", "void main() {", "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "vec4 worldPosition = modelMatrix * vec4( position, 1.0 );", "vec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );", "vec3 I = worldPosition.xyz - cameraPosition;", "vReflect = reflect( I, worldNormal );", "vRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );", "vRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );", "vRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );", "vReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );", "gl_Position = projectionMatrix * mvPosition;", "}"].join("\n"),

	fragmentShader: ["uniform samplerCube tCube;", "varying vec3 vReflect;", "varying vec3 vRefract[3];", "varying float vReflectionFactor;", "void main() {", "vec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );", "vec4 refractedColor = vec4( 1.0 );", "refractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;", "refractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;", "refractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;", "gl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );", "}"].join("\n")

};

exports.default = FresnelShader;

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author alteredq / http://alteredqualia.com/
 * @author davidedc / http://www.sketchpatch.net/
 *
 * NVIDIA FXAA by Timothy Lottes
 * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html
 * - WebGL port by @supereggbert
 * http://www.glge.org/demos/fxaa/
 */

var FXAAShader = {

  uniforms: {

    "tDiffuse": { value: null },
    "resolution": { value: new THREE.Vector2(1 / 1024, 1 / 512) }

  },

  vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

  fragmentShader: ["precision highp float;", "", "uniform sampler2D tDiffuse;", "", "uniform vec2 resolution;", "", "varying vec2 vUv;", "", "// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)", "", "//----------------------------------------------------------------------------------", "// File:        es3-kepler\FXAA\assets\shaders/FXAA_DefaultES.frag", "// SDK Version: v3.00", "// Email:       gameworks@nvidia.com", "// Site:        http://developer.nvidia.com/", "//", "// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.", "//", "// Redistribution and use in source and binary forms, with or without", "// modification, are permitted provided that the following conditions", "// are met:", "//  * Redistributions of source code must retain the above copyright", "//    notice, this list of conditions and the following disclaimer.", "//  * Redistributions in binary form must reproduce the above copyright", "//    notice, this list of conditions and the following disclaimer in the", "//    documentation and/or other materials provided with the distribution.", "//  * Neither the name of NVIDIA CORPORATION nor the names of its", "//    contributors may be used to endorse or promote products derived", "//    from this software without specific prior written permission.", "//", "// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY", "// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", "// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR", "// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR", "// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,", "// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,", "// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR", "// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY", "// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT", "// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE", "// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.", "//", "//----------------------------------------------------------------------------------", "", "#define FXAA_PC 1", "#define FXAA_GLSL_100 1", "#define FXAA_QUALITY_PRESET 12", "", "#define FXAA_GREEN_AS_LUMA 1", "", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_PC_CONSOLE", "    //", "    // The console algorithm for PC is included", "    // for developers targeting really low spec machines.", "    // Likely better to just run FXAA_PC, and use a really low preset.", "    //", "    #define FXAA_PC_CONSOLE 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_GLSL_120", "    #define FXAA_GLSL_120 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_GLSL_130", "    #define FXAA_GLSL_130 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_HLSL_3", "    #define FXAA_HLSL_3 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_HLSL_4", "    #define FXAA_HLSL_4 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_HLSL_5", "    #define FXAA_HLSL_5 0", "#endif", "/*==========================================================================*/", "#ifndef FXAA_GREEN_AS_LUMA", "    //", "    // For those using non-linear color,", "    // and either not able to get luma in alpha, or not wanting to,", "    // this enables FXAA to run using green as a proxy for luma.", "    // So with this enabled, no need to pack luma in alpha.", "    //", "    // This will turn off AA on anything which lacks some amount of green.", "    // Pure red and blue or combination of only R and B, will get no AA.", "    //", "    // Might want to lower the settings for both,", "    //    fxaaConsoleEdgeThresholdMin", "    //    fxaaQualityEdgeThresholdMin", "    // In order to insure AA does not get turned off on colors", "    // which contain a minor amount of green.", "    //", "    // 1 = On.", "    // 0 = Off.", "    //", "    #define FXAA_GREEN_AS_LUMA 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_EARLY_EXIT", "    //", "    // Controls algorithm's early exit path.", "    // On PS3 turning this ON adds 2 cycles to the shader.", "    // On 360 turning this OFF adds 10ths of a millisecond to the shader.", "    // Turning this off on console will result in a more blurry image.", "    // So this defaults to on.", "    //", "    // 1 = On.", "    // 0 = Off.", "    //", "    #define FXAA_EARLY_EXIT 1", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_DISCARD", "    //", "    // Only valid for PC OpenGL currently.", "    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.", "    //", "    // 1 = Use discard on pixels which don't need AA.", "    //     For APIs which enable concurrent TEX+ROP from same surface.", "    // 0 = Return unchanged color on pixels which don't need AA.", "    //", "    #define FXAA_DISCARD 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_FAST_PIXEL_OFFSET", "    //", "    // Used for GLSL 120 only.", "    //", "    // 1 = GL API supports fast pixel offsets", "    // 0 = do not use fast pixel offsets", "    //", "    #ifdef GL_EXT_gpu_shader4", "        #define FXAA_FAST_PIXEL_OFFSET 1", "    #endif", "    #ifdef GL_NV_gpu_shader5", "        #define FXAA_FAST_PIXEL_OFFSET 1", "    #endif", "    #ifdef GL_ARB_gpu_shader5", "        #define FXAA_FAST_PIXEL_OFFSET 1", "    #endif", "    #ifndef FXAA_FAST_PIXEL_OFFSET", "        #define FXAA_FAST_PIXEL_OFFSET 0", "    #endif", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_GATHER4_ALPHA", "    //", "    // 1 = API supports gather4 on alpha channel.", "    // 0 = API does not support gather4 on alpha channel.", "    //", "    #if (FXAA_HLSL_5 == 1)", "        #define FXAA_GATHER4_ALPHA 1", "    #endif", "    #ifdef GL_ARB_gpu_shader5", "        #define FXAA_GATHER4_ALPHA 1", "    #endif", "    #ifdef GL_NV_gpu_shader5", "        #define FXAA_GATHER4_ALPHA 1", "    #endif", "    #ifndef FXAA_GATHER4_ALPHA", "        #define FXAA_GATHER4_ALPHA 0", "    #endif", "#endif", "", "", "/*============================================================================", "                        FXAA QUALITY - TUNING KNOBS", "------------------------------------------------------------------------------", "NOTE the other tuning knobs are now in the shader function inputs!", "============================================================================*/", "#ifndef FXAA_QUALITY_PRESET", "    //", "    // Choose the quality preset.", "    // This needs to be compiled into the shader as it effects code.", "    // Best option to include multiple presets is to", "    // in each shader define the preset, then include this file.", "    //", "    // OPTIONS", "    // -----------------------------------------------------------------------", "    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)", "    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)", "    // 39       - no dither, very expensive", "    //", "    // NOTES", "    // -----------------------------------------------------------------------", "    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)", "    // 13 = about same speed as FXAA 3.9 and better than 12", "    // 23 = closest to FXAA 3.9 visually and performance wise", "    //  _ = the lowest digit is directly related to performance", "    // _  = the highest digit is directly related to style", "    //", "    #define FXAA_QUALITY_PRESET 12", "#endif", "", "", "/*============================================================================", "", "                           FXAA QUALITY - PRESETS", "", "============================================================================*/", "", "/*============================================================================", "                     FXAA QUALITY - MEDIUM DITHER PRESETS", "============================================================================*/", "#if (FXAA_QUALITY_PRESET == 10)", "    #define FXAA_QUALITY_PS 3", "    #define FXAA_QUALITY_P0 1.5", "    #define FXAA_QUALITY_P1 3.0", "    #define FXAA_QUALITY_P2 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 11)", "    #define FXAA_QUALITY_PS 4", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 3.0", "    #define FXAA_QUALITY_P3 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 12)", "    #define FXAA_QUALITY_PS 5", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 4.0", "    #define FXAA_QUALITY_P4 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 13)", "    #define FXAA_QUALITY_PS 6", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 4.0", "    #define FXAA_QUALITY_P5 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 14)", "    #define FXAA_QUALITY_PS 7", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 4.0", "    #define FXAA_QUALITY_P6 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 15)", "    #define FXAA_QUALITY_PS 8", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 4.0", "    #define FXAA_QUALITY_P7 12.0", "#endif", "", "/*============================================================================", "                     FXAA QUALITY - LOW DITHER PRESETS", "============================================================================*/", "#if (FXAA_QUALITY_PRESET == 20)", "    #define FXAA_QUALITY_PS 3", "    #define FXAA_QUALITY_P0 1.5", "    #define FXAA_QUALITY_P1 2.0", "    #define FXAA_QUALITY_P2 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 21)", "    #define FXAA_QUALITY_PS 4", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 22)", "    #define FXAA_QUALITY_PS 5", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 23)", "    #define FXAA_QUALITY_PS 6", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 24)", "    #define FXAA_QUALITY_PS 7", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 3.0", "    #define FXAA_QUALITY_P6 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 25)", "    #define FXAA_QUALITY_PS 8", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 4.0", "    #define FXAA_QUALITY_P7 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 26)", "    #define FXAA_QUALITY_PS 9", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 4.0", "    #define FXAA_QUALITY_P8 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 27)", "    #define FXAA_QUALITY_PS 10", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 4.0", "    #define FXAA_QUALITY_P9 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 28)", "    #define FXAA_QUALITY_PS 11", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 2.0", "    #define FXAA_QUALITY_P9 4.0", "    #define FXAA_QUALITY_P10 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 29)", "    #define FXAA_QUALITY_PS 12", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 2.0", "    #define FXAA_QUALITY_P9 2.0", "    #define FXAA_QUALITY_P10 4.0", "    #define FXAA_QUALITY_P11 8.0", "#endif", "", "/*============================================================================", "                     FXAA QUALITY - EXTREME QUALITY", "============================================================================*/", "#if (FXAA_QUALITY_PRESET == 39)", "    #define FXAA_QUALITY_PS 12", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.0", "    #define FXAA_QUALITY_P2 1.0", "    #define FXAA_QUALITY_P3 1.0", "    #define FXAA_QUALITY_P4 1.0", "    #define FXAA_QUALITY_P5 1.5", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 2.0", "    #define FXAA_QUALITY_P9 2.0", "    #define FXAA_QUALITY_P10 4.0", "    #define FXAA_QUALITY_P11 8.0", "#endif", "", "", "", "/*============================================================================", "", "                                API PORTING", "", "============================================================================*/", "#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)", "    #define FxaaBool bool", "    #define FxaaDiscard discard", "    #define FxaaFloat float", "    #define FxaaFloat2 vec2", "    #define FxaaFloat3 vec3", "    #define FxaaFloat4 vec4", "    #define FxaaHalf float", "    #define FxaaHalf2 vec2", "    #define FxaaHalf3 vec3", "    #define FxaaHalf4 vec4", "    #define FxaaInt2 ivec2", "    #define FxaaSat(x) clamp(x, 0.0, 1.0)", "    #define FxaaTex sampler2D", "#else", "    #define FxaaBool bool", "    #define FxaaDiscard clip(-1)", "    #define FxaaFloat float", "    #define FxaaFloat2 float2", "    #define FxaaFloat3 float3", "    #define FxaaFloat4 float4", "    #define FxaaHalf half", "    #define FxaaHalf2 half2", "    #define FxaaHalf3 half3", "    #define FxaaHalf4 half4", "    #define FxaaSat(x) saturate(x)", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_GLSL_100 == 1)", "  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)", "  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_GLSL_120 == 1)", "    // Requires,", "    //  #version 120", "    // And at least,", "    //  #extension GL_EXT_gpu_shader4 : enable", "    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)", "    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)", "    #if (FXAA_FAST_PIXEL_OFFSET == 1)", "        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)", "    #else", "        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)", "    #endif", "    #if (FXAA_GATHER4_ALPHA == 1)", "        // use #extension GL_ARB_gpu_shader5 : enable", "        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)", "        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)", "        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)", "        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)", "    #endif", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_GLSL_130 == 1)", "    // Requires \"#version 130\" or better", "    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)", "    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)", "    #if (FXAA_GATHER4_ALPHA == 1)", "        // use #extension GL_ARB_gpu_shader5 : enable", "        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)", "        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)", "        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)", "        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)", "    #endif", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_HLSL_3 == 1)", "    #define FxaaInt2 float2", "    #define FxaaTex sampler2D", "    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))", "    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_HLSL_4 == 1)", "    #define FxaaInt2 int2", "    struct FxaaTex { SamplerState smpl; Texture2D tex; };", "    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)", "    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_HLSL_5 == 1)", "    #define FxaaInt2 int2", "    struct FxaaTex { SamplerState smpl; Texture2D tex; };", "    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)", "    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)", "    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)", "    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)", "    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)", "    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)", "#endif", "", "", "/*============================================================================", "                   GREEN AS LUMA OPTION SUPPORT FUNCTION", "============================================================================*/", "#if (FXAA_GREEN_AS_LUMA == 0)", "    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }", "#else", "    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }", "#endif", "", "", "", "", "/*============================================================================", "", "                             FXAA3 QUALITY - PC", "", "============================================================================*/", "#if (FXAA_PC == 1)", "/*--------------------------------------------------------------------------*/", "FxaaFloat4 FxaaPixelShader(", "    //", "    // Use noperspective interpolation here (turn off perspective interpolation).", "    // {xy} = center of pixel", "    FxaaFloat2 pos,", "    //", "    // Used only for FXAA Console, and not used on the 360 version.", "    // Use noperspective interpolation here (turn off perspective interpolation).", "    // {xy_} = upper left of pixel", "    // {_zw} = lower right of pixel", "    FxaaFloat4 fxaaConsolePosPos,", "    //", "    // Input color texture.", "    // {rgb_} = color in linear or perceptual color space", "    // if (FXAA_GREEN_AS_LUMA == 0)", "    //     {__a} = luma in perceptual color space (not linear)", "    FxaaTex tex,", "    //", "    // Only used on the optimized 360 version of FXAA Console.", "    // For everything but 360, just use the same input here as for \"tex\".", "    // For 360, same texture, just alias with a 2nd sampler.", "    // This sampler needs to have an exponent bias of -1.", "    FxaaTex fxaaConsole360TexExpBiasNegOne,", "    //", "    // Only used on the optimized 360 version of FXAA Console.", "    // For everything but 360, just use the same input here as for \"tex\".", "    // For 360, same texture, just alias with a 3nd sampler.", "    // This sampler needs to have an exponent bias of -2.", "    FxaaTex fxaaConsole360TexExpBiasNegTwo,", "    //", "    // Only used on FXAA Quality.", "    // This must be from a constant/uniform.", "    // {x_} = 1.0/screenWidthInPixels", "    // {_y} = 1.0/screenHeightInPixels", "    FxaaFloat2 fxaaQualityRcpFrame,", "    //", "    // Only used on FXAA Console.", "    // This must be from a constant/uniform.", "    // This effects sub-pixel AA quality and inversely sharpness.", "    //   Where N ranges between,", "    //     N = 0.50 (default)", "    //     N = 0.33 (sharper)", "    // {x__} = -N/screenWidthInPixels", "    // {_y_} = -N/screenHeightInPixels", "    // {_z_} =  N/screenWidthInPixels", "    // {__w} =  N/screenHeightInPixels", "    FxaaFloat4 fxaaConsoleRcpFrameOpt,", "    //", "    // Only used on FXAA Console.", "    // Not used on 360, but used on PS3 and PC.", "    // This must be from a constant/uniform.", "    // {x__} = -2.0/screenWidthInPixels", "    // {_y_} = -2.0/screenHeightInPixels", "    // {_z_} =  2.0/screenWidthInPixels", "    // {__w} =  2.0/screenHeightInPixels", "    FxaaFloat4 fxaaConsoleRcpFrameOpt2,", "    //", "    // Only used on FXAA Console.", "    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.", "    // This must be from a constant/uniform.", "    // {x__} =  8.0/screenWidthInPixels", "    // {_y_} =  8.0/screenHeightInPixels", "    // {_z_} = -4.0/screenWidthInPixels", "    // {__w} = -4.0/screenHeightInPixels", "    FxaaFloat4 fxaaConsole360RcpFrameOpt2,", "    //", "    // Only used on FXAA Quality.", "    // This used to be the FXAA_QUALITY_SUBPIX define.", "    // It is here now to allow easier tuning.", "    // Choose the amount of sub-pixel aliasing removal.", "    // This can effect sharpness.", "    //   1.00 - upper limit (softer)", "    //   0.75 - default amount of filtering", "    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)", "    //   0.25 - almost off", "    //   0.00 - completely off", "    FxaaFloat fxaaQualitySubpix,", "    //", "    // Only used on FXAA Quality.", "    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.", "    // It is here now to allow easier tuning.", "    // The minimum amount of local contrast required to apply algorithm.", "    //   0.333 - too little (faster)", "    //   0.250 - low quality", "    //   0.166 - default", "    //   0.125 - high quality", "    //   0.063 - overkill (slower)", "    FxaaFloat fxaaQualityEdgeThreshold,", "    //", "    // Only used on FXAA Quality.", "    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.", "    // It is here now to allow easier tuning.", "    // Trims the algorithm from processing darks.", "    //   0.0833 - upper limit (default, the start of visible unfiltered edges)", "    //   0.0625 - high quality (faster)", "    //   0.0312 - visible limit (slower)", "    // Special notes when using FXAA_GREEN_AS_LUMA,", "    //   Likely want to set this to zero.", "    //   As colors that are mostly not-green", "    //   will appear very dark in the green channel!", "    //   Tune by looking at mostly non-green content,", "    //   then start at zero and increase until aliasing is a problem.", "    FxaaFloat fxaaQualityEdgeThresholdMin,", "    //", "    // Only used on FXAA Console.", "    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.", "    // It is here now to allow easier tuning.", "    // This does not effect PS3, as this needs to be compiled in.", "    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.", "    //   Due to the PS3 being ALU bound,", "    //   there are only three safe values here: 2 and 4 and 8.", "    //   These options use the shaders ability to a free *|/ by 2|4|8.", "    // For all other platforms can be a non-power of two.", "    //   8.0 is sharper (default!!!)", "    //   4.0 is softer", "    //   2.0 is really soft (good only for vector graphics inputs)", "    FxaaFloat fxaaConsoleEdgeSharpness,", "    //", "    // Only used on FXAA Console.", "    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.", "    // It is here now to allow easier tuning.", "    // This does not effect PS3, as this needs to be compiled in.", "    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.", "    //   Due to the PS3 being ALU bound,", "    //   there are only two safe values here: 1/4 and 1/8.", "    //   These options use the shaders ability to a free *|/ by 2|4|8.", "    // The console setting has a different mapping than the quality setting.", "    // Other platforms can use other values.", "    //   0.125 leaves less aliasing, but is softer (default!!!)", "    //   0.25 leaves more aliasing, and is sharper", "    FxaaFloat fxaaConsoleEdgeThreshold,", "    //", "    // Only used on FXAA Console.", "    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.", "    // It is here now to allow easier tuning.", "    // Trims the algorithm from processing darks.", "    // The console setting has a different mapping than the quality setting.", "    // This only applies when FXAA_EARLY_EXIT is 1.", "    // This does not apply to PS3,", "    // PS3 was simplified to avoid more shader instructions.", "    //   0.06 - faster but more aliasing in darks", "    //   0.05 - default", "    //   0.04 - slower and less aliasing in darks", "    // Special notes when using FXAA_GREEN_AS_LUMA,", "    //   Likely want to set this to zero.", "    //   As colors that are mostly not-green", "    //   will appear very dark in the green channel!", "    //   Tune by looking at mostly non-green content,", "    //   then start at zero and increase until aliasing is a problem.", "    FxaaFloat fxaaConsoleEdgeThresholdMin,", "    //", "    // Extra constants for 360 FXAA Console only.", "    // Use zeros or anything else for other platforms.", "    // These must be in physical constant registers and NOT immedates.", "    // Immedates will result in compiler un-optimizing.", "    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)", "    FxaaFloat4 fxaaConsole360ConstDir", ") {", "/*--------------------------------------------------------------------------*/", "    FxaaFloat2 posM;", "    posM.x = pos.x;", "    posM.y = pos.y;", "    #if (FXAA_GATHER4_ALPHA == 1)", "        #if (FXAA_DISCARD == 0)", "            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);", "            #if (FXAA_GREEN_AS_LUMA == 0)", "                #define lumaM rgbyM.w", "            #else", "                #define lumaM rgbyM.y", "            #endif", "        #endif", "        #if (FXAA_GREEN_AS_LUMA == 0)", "            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);", "            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));", "        #else", "            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);", "            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));", "        #endif", "        #if (FXAA_DISCARD == 1)", "            #define lumaM luma4A.w", "        #endif", "        #define lumaE luma4A.z", "        #define lumaS luma4A.x", "        #define lumaSE luma4A.y", "        #define lumaNW luma4B.w", "        #define lumaN luma4B.z", "        #define lumaW luma4B.x", "    #else", "        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);", "        #if (FXAA_GREEN_AS_LUMA == 0)", "            #define lumaM rgbyM.w", "        #else", "            #define lumaM rgbyM.y", "        #endif", "        #if (FXAA_GLSL_100 == 1)", "          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));", "        #else", "          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));", "        #endif", "    #endif", "/*--------------------------------------------------------------------------*/", "    FxaaFloat maxSM = max(lumaS, lumaM);", "    FxaaFloat minSM = min(lumaS, lumaM);", "    FxaaFloat maxESM = max(lumaE, maxSM);", "    FxaaFloat minESM = min(lumaE, minSM);", "    FxaaFloat maxWN = max(lumaN, lumaW);", "    FxaaFloat minWN = min(lumaN, lumaW);", "    FxaaFloat rangeMax = max(maxWN, maxESM);", "    FxaaFloat rangeMin = min(minWN, minESM);", "    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;", "    FxaaFloat range = rangeMax - rangeMin;", "    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);", "    FxaaBool earlyExit = range < rangeMaxClamped;", "/*--------------------------------------------------------------------------*/", "    if(earlyExit)", "        #if (FXAA_DISCARD == 1)", "            FxaaDiscard;", "        #else", "            return rgbyM;", "        #endif", "/*--------------------------------------------------------------------------*/", "    #if (FXAA_GATHER4_ALPHA == 0)", "        #if (FXAA_GLSL_100 == 1)", "          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));", "        #else", "          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));", "        #endif", "    #else", "        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));", "        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));", "    #endif", "/*--------------------------------------------------------------------------*/", "    FxaaFloat lumaNS = lumaN + lumaS;", "    FxaaFloat lumaWE = lumaW + lumaE;", "    FxaaFloat subpixRcpRange = 1.0/range;", "    FxaaFloat subpixNSWE = lumaNS + lumaWE;", "    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;", "    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat lumaNESE = lumaNE + lumaSE;", "    FxaaFloat lumaNWNE = lumaNW + lumaNE;", "    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;", "    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat lumaNWSW = lumaNW + lumaSW;", "    FxaaFloat lumaSWSE = lumaSW + lumaSE;", "    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);", "    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);", "    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;", "    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;", "    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;", "    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;", "    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;", "    FxaaBool horzSpan = edgeHorz >= edgeVert;", "    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;", "/*--------------------------------------------------------------------------*/", "    if(!horzSpan) lumaN = lumaW;", "    if(!horzSpan) lumaS = lumaE;", "    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;", "    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat gradientN = lumaN - lumaM;", "    FxaaFloat gradientS = lumaS - lumaM;", "    FxaaFloat lumaNN = lumaN + lumaM;", "    FxaaFloat lumaSS = lumaS + lumaM;", "    FxaaBool pairN = abs(gradientN) >= abs(gradientS);", "    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));", "    if(pairN) lengthSign = -lengthSign;", "    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);", "/*--------------------------------------------------------------------------*/", "    FxaaFloat2 posB;", "    posB.x = posM.x;", "    posB.y = posM.y;", "    FxaaFloat2 offNP;", "    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;", "    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;", "    if(!horzSpan) posB.x += lengthSign * 0.5;", "    if( horzSpan) posB.y += lengthSign * 0.5;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat2 posN;", "    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;", "    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;", "    FxaaFloat2 posP;", "    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;", "    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;", "    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;", "    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));", "    FxaaFloat subpixE = subpixC * subpixC;", "    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));", "/*--------------------------------------------------------------------------*/", "    if(!pairN) lumaNN = lumaSS;", "    FxaaFloat gradientScaled = gradient * 1.0/4.0;", "    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;", "    FxaaFloat subpixF = subpixD * subpixE;", "    FxaaBool lumaMLTZero = lumaMM < 0.0;", "/*--------------------------------------------------------------------------*/", "    lumaEndN -= lumaNN * 0.5;", "    lumaEndP -= lumaNN * 0.5;", "    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;", "    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;", "    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;", "    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;", "    FxaaBool doneNP = (!doneN) || (!doneP);", "    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;", "    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;", "/*--------------------------------------------------------------------------*/", "    if(doneNP) {", "        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "        doneN = abs(lumaEndN) >= gradientScaled;", "        doneP = abs(lumaEndP) >= gradientScaled;", "        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;", "        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;", "        doneNP = (!doneN) || (!doneP);", "        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;", "        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;", "/*--------------------------------------------------------------------------*/", "        #if (FXAA_QUALITY_PS > 3)", "        if(doneNP) {", "            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "            doneN = abs(lumaEndN) >= gradientScaled;", "            doneP = abs(lumaEndP) >= gradientScaled;", "            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;", "            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;", "            doneNP = (!doneN) || (!doneP);", "            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;", "            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;", "/*--------------------------------------------------------------------------*/", "            #if (FXAA_QUALITY_PS > 4)", "            if(doneNP) {", "                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                doneN = abs(lumaEndN) >= gradientScaled;", "                doneP = abs(lumaEndP) >= gradientScaled;", "                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;", "                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;", "                doneNP = (!doneN) || (!doneP);", "                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;", "                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;", "/*--------------------------------------------------------------------------*/", "                #if (FXAA_QUALITY_PS > 5)", "                if(doneNP) {", "                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                    doneN = abs(lumaEndN) >= gradientScaled;", "                    doneP = abs(lumaEndP) >= gradientScaled;", "                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;", "                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;", "                    doneNP = (!doneN) || (!doneP);", "                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;", "                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;", "/*--------------------------------------------------------------------------*/", "                    #if (FXAA_QUALITY_PS > 6)", "                    if(doneNP) {", "                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                        doneN = abs(lumaEndN) >= gradientScaled;", "                        doneP = abs(lumaEndP) >= gradientScaled;", "                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;", "                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;", "                        doneNP = (!doneN) || (!doneP);", "                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;", "                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;", "/*--------------------------------------------------------------------------*/", "                        #if (FXAA_QUALITY_PS > 7)", "                        if(doneNP) {", "                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                            doneN = abs(lumaEndN) >= gradientScaled;", "                            doneP = abs(lumaEndP) >= gradientScaled;", "                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;", "                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;", "                            doneNP = (!doneN) || (!doneP);", "                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;", "                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;", "/*--------------------------------------------------------------------------*/", "    #if (FXAA_QUALITY_PS > 8)", "    if(doneNP) {", "        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "        doneN = abs(lumaEndN) >= gradientScaled;", "        doneP = abs(lumaEndP) >= gradientScaled;", "        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;", "        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;", "        doneNP = (!doneN) || (!doneP);", "        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;", "        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;", "/*--------------------------------------------------------------------------*/", "        #if (FXAA_QUALITY_PS > 9)", "        if(doneNP) {", "            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "            doneN = abs(lumaEndN) >= gradientScaled;", "            doneP = abs(lumaEndP) >= gradientScaled;", "            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;", "            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;", "            doneNP = (!doneN) || (!doneP);", "            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;", "            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;", "/*--------------------------------------------------------------------------*/", "            #if (FXAA_QUALITY_PS > 10)", "            if(doneNP) {", "                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                doneN = abs(lumaEndN) >= gradientScaled;", "                doneP = abs(lumaEndP) >= gradientScaled;", "                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;", "                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;", "                doneNP = (!doneN) || (!doneP);", "                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;", "                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;", "/*--------------------------------------------------------------------------*/", "                #if (FXAA_QUALITY_PS > 11)", "                if(doneNP) {", "                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                    doneN = abs(lumaEndN) >= gradientScaled;", "                    doneP = abs(lumaEndP) >= gradientScaled;", "                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;", "                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;", "                    doneNP = (!doneN) || (!doneP);", "                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;", "                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;", "/*--------------------------------------------------------------------------*/", "                    #if (FXAA_QUALITY_PS > 12)", "                    if(doneNP) {", "                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                        doneN = abs(lumaEndN) >= gradientScaled;", "                        doneP = abs(lumaEndP) >= gradientScaled;", "                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;", "                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;", "                        doneNP = (!doneN) || (!doneP);", "                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;", "                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;", "/*--------------------------------------------------------------------------*/", "                    }", "                    #endif", "/*--------------------------------------------------------------------------*/", "                }", "                #endif", "/*--------------------------------------------------------------------------*/", "            }", "            #endif", "/*--------------------------------------------------------------------------*/", "        }", "        #endif", "/*--------------------------------------------------------------------------*/", "    }", "    #endif", "/*--------------------------------------------------------------------------*/", "                        }", "                        #endif", "/*--------------------------------------------------------------------------*/", "                    }", "                    #endif", "/*--------------------------------------------------------------------------*/", "                }", "                #endif", "/*--------------------------------------------------------------------------*/", "            }", "            #endif", "/*--------------------------------------------------------------------------*/", "        }", "        #endif", "/*--------------------------------------------------------------------------*/", "    }", "/*--------------------------------------------------------------------------*/", "    FxaaFloat dstN = posM.x - posN.x;", "    FxaaFloat dstP = posP.x - posM.x;", "    if(!horzSpan) dstN = posM.y - posN.y;", "    if(!horzSpan) dstP = posP.y - posM.y;", "/*--------------------------------------------------------------------------*/", "    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;", "    FxaaFloat spanLength = (dstP + dstN);", "    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;", "    FxaaFloat spanLengthRcp = 1.0/spanLength;", "/*--------------------------------------------------------------------------*/", "    FxaaBool directionN = dstN < dstP;", "    FxaaFloat dst = min(dstN, dstP);", "    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;", "    FxaaFloat subpixG = subpixF * subpixF;", "    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;", "    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;", "    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);", "    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;", "    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;", "    #if (FXAA_DISCARD == 1)", "        return FxaaTexTop(tex, posM);", "    #else", "        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);", "    #endif", "}", "/*==========================================================================*/", "#endif", "", "void main() {", "  gl_FragColor = FxaaPixelShader(", "    vUv,", "    vec4(0.0),", "    tDiffuse,", "    tDiffuse,", "    tDiffuse,", "    resolution,", "    vec4(0.0),", "    vec4(0.0),", "    vec4(0.0),", "    0.75,", "    0.166,", "    0.0833,", "    0.0,", "    0.0,", "    0.0,", "    vec4(0.0)", "  );", "", "  // TODO avoid querying texture twice for same texel", "  gl_FragColor.a = texture2D(tDiffuse, vUv).a;", "}"].join("\n")

};

exports.default = FXAAShader;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * Gamma Correction Shader
 * http://en.wikipedia.org/wiki/gamma_correction
 */

var GammaCorrectionShader = {

	uniforms: {

		"tDiffuse": { value: null }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );", "gl_FragColor = LinearToGamma( tex, float( GAMMA_FACTOR ) );", "}"].join("\n")

};

exports.default = GammaCorrectionShader;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Two pass Gaussian blur filter (horizontal and vertical blur shaders)
 * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/
 *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html
 *
 * - 9 samples per pass
 * - standard deviation 2.7
 * - "h" and "v" parameters should be set to "1 / width" and "1 / height"
 */

var HorizontalBlurShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"h": { value: 1.0 / 512.0 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float h;", "varying vec2 vUv;", "void main() {", "vec4 sum = vec4( 0.0 );", "sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;", "sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;", "sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;", "sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;", "gl_FragColor = sum;", "}"].join("\n")

};

exports.default = HorizontalBlurShader;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position
 *
 * - 9 samples per pass
 * - standard deviation 2.7
 * - "h" and "v" parameters should be set to "1 / width" and "1 / height"
 * - "r" parameter control where "focused" horizontal line lies
 */

var HorizontalTiltShiftShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"h": { value: 1.0 / 512.0 },
		"r": { value: 0.35 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float h;", "uniform float r;", "varying vec2 vUv;", "void main() {", "vec4 sum = vec4( 0.0 );", "float hh = h * abs( r - vUv.y );", "sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * hh, vUv.y ) ) * 0.051;", "sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * hh, vUv.y ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * hh, vUv.y ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * hh, vUv.y ) ) * 0.1531;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;", "sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * hh, vUv.y ) ) * 0.1531;", "sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * hh, vUv.y ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * hh, vUv.y ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * hh, vUv.y ) ) * 0.051;", "gl_FragColor = sum;", "}"].join("\n")

};

exports.default = HorizontalTiltShiftShader;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author tapio / http://tapio.github.com/
 *
 * Hue and saturation adjustment
 * https://github.com/evanw/glfx.js
 * hue: -1 to 1 (-1 is 180 degrees in the negative direction, 0 is no change, etc.
 * saturation: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)
 */

var HueSaturationShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"hue": { value: 0 },
		"saturation": { value: 0 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float hue;", "uniform float saturation;", "varying vec2 vUv;", "void main() {", "gl_FragColor = texture2D( tDiffuse, vUv );",

	// hue
	"float angle = hue * 3.14159265;", "float s = sin(angle), c = cos(angle);", "vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;", "float len = length(gl_FragColor.rgb);", "gl_FragColor.rgb = vec3(", "dot(gl_FragColor.rgb, weights.xyz),", "dot(gl_FragColor.rgb, weights.zxy),", "dot(gl_FragColor.rgb, weights.yzx)", ");",

	// saturation
	"float average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;", "if (saturation > 0.0) {", "gl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));", "} else {", "gl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);", "}", "}"].join("\n")

};

exports.default = HueSaturationShader;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author felixturner / http://airtight.cc/
 *
 * Kaleidoscope Shader
 * Radial reflection around center point
 * Ported from: http://pixelshaders.com/editor/
 * by Toby Schachman / http://tobyschachman.com/
 *
 * sides: number of reflections
 * angle: initial angle in radians
 */

var KaleidoShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"sides": { value: 6.0 },
		"angle": { value: 0.0 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float sides;", "uniform float angle;", "varying vec2 vUv;", "void main() {", "vec2 p = vUv - 0.5;", "float r = length(p);", "float a = atan(p.y, p.x) + angle;", "float tau = 2. * 3.1416 ;", "a = mod(a, tau/sides);", "a = abs(a - tau/sides/2.) ;", "p = r * vec2(cos(a), sin(a));", "vec4 color = texture2D(tDiffuse, p + 0.5);", "gl_FragColor = color;", "}"].join("\n")

};

exports.default = KaleidoShader;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author felixturner / http://airtight.cc/
 *
 * Mirror Shader
 * Copies half the input to the other half
 *
 * side: side of input to mirror (0 = left, 1 = right, 2 = top, 3 = bottom)
 */

var MirrorShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"side": { value: 1 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform sampler2D tDiffuse;", "uniform int side;", "varying vec2 vUv;", "void main() {", "vec2 p = vUv;", "if (side == 0){", "if (p.x > 0.5) p.x = 1.0 - p.x;", "}else if (side == 1){", "if (p.x < 0.5) p.x = 1.0 - p.x;", "}else if (side == 2){", "if (p.y < 0.5) p.y = 1.0 - p.y;", "}else if (side == 3){", "if (p.y > 0.5) p.y = 1.0 - p.y;", "} ", "vec4 color = texture2D(tDiffuse, p);", "gl_FragColor = color;", "}"].join("\n")

};

exports.default = MirrorShader;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Normal map shader
 * - compute normals from heightmap
 */

var NormalMapShader = {

	uniforms: {

		"heightMap": { value: null },
		"resolution": { value: new THREE.Vector2(512, 512) },
		"scale": { value: new THREE.Vector2(1, 1) },
		"height": { value: 0.05 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform float height;", "uniform vec2 resolution;", "uniform sampler2D heightMap;", "varying vec2 vUv;", "void main() {", "float val = texture2D( heightMap, vUv ).x;", "float valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;", "float valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;", "gl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );", "}"].join("\n")

};

exports.default = NormalMapShader;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// TODO to ES6

// Author: Aleksandr Albert
// Website: www.routter.co.tt

// Description: A deep water ocean shader set
// based on an implementation of a Tessendorf Waves
// originally presented by David Li ( www.david.li/waves )

// The general method is to apply shaders to simulation Framebuffers
// and then sample these framebuffers when rendering the ocean mesh

// The set uses 7 shaders:

// -- Simulation shaders
// [1] ocean_sim_vertex         -> Vertex shader used to set up a 2x2 simulation plane centered at (0,0)
// [2] ocean_subtransform       -> Fragment shader used to subtransform the mesh (generates the displacement map)
// [3] ocean_initial_spectrum   -> Fragment shader used to set intitial wave frequency at a texel coordinate
// [4] ocean_phase              -> Fragment shader used to set wave phase at a texel coordinate
// [5] ocean_spectrum           -> Fragment shader used to set current wave frequency at a texel coordinate
// [6] ocean_normal             -> Fragment shader used to set face normals at a texel coordinate

// -- Rendering Shader
// [7] ocean_main               -> Vertex and Fragment shader used to create the final render


THREE.ShaderLib['ocean_sim_vertex'] = {
	vertexShader: ['varying vec2 vUV;', 'void main (void) {', 'vUV = position.xy * 0.5 + 0.5;', 'gl_Position = vec4(position, 1.0 );', '}'].join('\n')
};
THREE.ShaderLib['ocean_subtransform'] = {
	uniforms: {
		"u_input": { value: null },
		"u_transformSize": { value: 512.0 },
		"u_subtransformSize": { value: 250.0 }
	},
	fragmentShader: [
	//GPU FFT using a Stockham formulation

	'precision highp float;', '#include <common>', 'uniform sampler2D u_input;', 'uniform float u_transformSize;', 'uniform float u_subtransformSize;', 'varying vec2 vUV;', 'vec2 multiplyComplex (vec2 a, vec2 b) {', 'return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);', '}', 'void main (void) {', '#ifdef HORIZONTAL', 'float index = vUV.x * u_transformSize - 0.5;', '#else', 'float index = vUV.y * u_transformSize - 0.5;', '#endif', 'float evenIndex = floor(index / u_subtransformSize) * (u_subtransformSize * 0.5) + mod(index, u_subtransformSize * 0.5);',

	//transform two complex sequences simultaneously
	'#ifdef HORIZONTAL', 'vec4 even = texture2D(u_input, vec2(evenIndex + 0.5, gl_FragCoord.y) / u_transformSize).rgba;', 'vec4 odd = texture2D(u_input, vec2(evenIndex + u_transformSize * 0.5 + 0.5, gl_FragCoord.y) / u_transformSize).rgba;', '#else', 'vec4 even = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + 0.5) / u_transformSize).rgba;', 'vec4 odd = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + u_transformSize * 0.5 + 0.5) / u_transformSize).rgba;', '#endif', 'float twiddleArgument = -2.0 * PI * (index / u_subtransformSize);', 'vec2 twiddle = vec2(cos(twiddleArgument), sin(twiddleArgument));', 'vec2 outputA = even.xy + multiplyComplex(twiddle, odd.xy);', 'vec2 outputB = even.zw + multiplyComplex(twiddle, odd.zw);', 'gl_FragColor = vec4(outputA, outputB);', '}'].join('\n')
};
THREE.ShaderLib['ocean_initial_spectrum'] = {
	uniforms: {
		"u_wind": { value: new THREE.Vector2(10.0, 10.0) },
		"u_resolution": { value: 512.0 },
		"u_size": { value: 250.0 }
	},
	fragmentShader: ['precision highp float;', '#include <common>', 'const float G = 9.81;', 'const float KM = 370.0;', 'const float CM = 0.23;', 'uniform vec2 u_wind;', 'uniform float u_resolution;', 'uniform float u_size;', 'float omega (float k) {', 'return sqrt(G * k * (1.0 + pow2(k / KM)));', '}', 'float tanh (float x) {', 'return (1.0 - exp(-2.0 * x)) / (1.0 + exp(-2.0 * x));', '}', 'void main (void) {', 'vec2 coordinates = gl_FragCoord.xy - 0.5;', 'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;', 'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;', 'vec2 K = (2.0 * PI * vec2(n, m)) / u_size;', 'float k = length(K);', 'float l_wind = length(u_wind);', 'float Omega = 0.84;', 'float kp = G * pow2(Omega / l_wind);', 'float c = omega(k) / k;', 'float cp = omega(kp) / kp;', 'float Lpm = exp(-1.25 * pow2(kp / k));', 'float gamma = 1.7;', 'float sigma = 0.08 * (1.0 + 4.0 * pow(Omega, -3.0));', 'float Gamma = exp(-pow2(sqrt(k / kp) - 1.0) / 2.0 * pow2(sigma));', 'float Jp = pow(gamma, Gamma);', 'float Fp = Lpm * Jp * exp(-Omega / sqrt(10.0) * (sqrt(k / kp) - 1.0));', 'float alphap = 0.006 * sqrt(Omega);', 'float Bl = 0.5 * alphap * cp / c * Fp;', 'float z0 = 0.000037 * pow2(l_wind) / G * pow(l_wind / cp, 0.9);', 'float uStar = 0.41 * l_wind / log(10.0 / z0);', 'float alpham = 0.01 * ((uStar < CM) ? (1.0 + log(uStar / CM)) : (1.0 + 3.0 * log(uStar / CM)));', 'float Fm = exp(-0.25 * pow2(k / KM - 1.0));', 'float Bh = 0.5 * alpham * CM / c * Fm * Lpm;', 'float a0 = log(2.0) / 4.0;', 'float am = 0.13 * uStar / CM;', 'float Delta = tanh(a0 + 4.0 * pow(c / cp, 2.5) + am * pow(CM / c, 2.5));', 'float cosPhi = dot(normalize(u_wind), normalize(K));', 'float S = (1.0 / (2.0 * PI)) * pow(k, -4.0) * (Bl + Bh) * (1.0 + Delta * (2.0 * cosPhi * cosPhi - 1.0));', 'float dk = 2.0 * PI / u_size;', 'float h = sqrt(S / 2.0) * dk;', 'if (K.x == 0.0 && K.y == 0.0) {', 'h = 0.0;', //no DC term
	'}', 'gl_FragColor = vec4(h, 0.0, 0.0, 0.0);', '}'].join('\n')
};
THREE.ShaderLib['ocean_phase'] = {
	uniforms: {
		"u_phases": { value: null },
		"u_deltaTime": { value: null },
		"u_resolution": { value: null },
		"u_size": { value: null }
	},
	fragmentShader: ['precision highp float;', '#include <common>', 'const float G = 9.81;', 'const float KM = 370.0;', 'varying vec2 vUV;', 'uniform sampler2D u_phases;', 'uniform float u_deltaTime;', 'uniform float u_resolution;', 'uniform float u_size;', 'float omega (float k) {', 'return sqrt(G * k * (1.0 + k * k / KM * KM));', '}', 'void main (void) {', 'float deltaTime = 1.0 / 60.0;', 'vec2 coordinates = gl_FragCoord.xy - 0.5;', 'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;', 'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;', 'vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;', 'float phase = texture2D(u_phases, vUV).r;', 'float deltaPhase = omega(length(waveVector)) * u_deltaTime;', 'phase = mod(phase + deltaPhase, 2.0 * PI);', 'gl_FragColor = vec4(phase, 0.0, 0.0, 0.0);', '}'].join('\n')
};
THREE.ShaderLib['ocean_spectrum'] = {
	uniforms: {
		"u_size": { value: null },
		"u_resolution": { value: null },
		"u_choppiness": { value: null },
		"u_phases": { value: null },
		"u_initialSpectrum": { value: null }
	},
	fragmentShader: ['precision highp float;', '#include <common>', 'const float G = 9.81;', 'const float KM = 370.0;', 'varying vec2 vUV;', 'uniform float u_size;', 'uniform float u_resolution;', 'uniform float u_choppiness;', 'uniform sampler2D u_phases;', 'uniform sampler2D u_initialSpectrum;', 'vec2 multiplyComplex (vec2 a, vec2 b) {', 'return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);', '}', 'vec2 multiplyByI (vec2 z) {', 'return vec2(-z[1], z[0]);', '}', 'float omega (float k) {', 'return sqrt(G * k * (1.0 + k * k / KM * KM));', '}', 'void main (void) {', 'vec2 coordinates = gl_FragCoord.xy - 0.5;', 'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;', 'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;', 'vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;', 'float phase = texture2D(u_phases, vUV).r;', 'vec2 phaseVector = vec2(cos(phase), sin(phase));', 'vec2 h0 = texture2D(u_initialSpectrum, vUV).rg;', 'vec2 h0Star = texture2D(u_initialSpectrum, vec2(1.0 - vUV + 1.0 / u_resolution)).rg;', 'h0Star.y *= -1.0;', 'vec2 h = multiplyComplex(h0, phaseVector) + multiplyComplex(h0Star, vec2(phaseVector.x, -phaseVector.y));', 'vec2 hX = -multiplyByI(h * (waveVector.x / length(waveVector))) * u_choppiness;', 'vec2 hZ = -multiplyByI(h * (waveVector.y / length(waveVector))) * u_choppiness;',

	//no DC term
	'if (waveVector.x == 0.0 && waveVector.y == 0.0) {', 'h = vec2(0.0);', 'hX = vec2(0.0);', 'hZ = vec2(0.0);', '}', 'gl_FragColor = vec4(hX + multiplyByI(h), hZ);', '}'].join('\n')
};
THREE.ShaderLib['ocean_normals'] = {
	uniforms: {
		"u_displacementMap": { value: null },
		"u_resolution": { value: null },
		"u_size": { value: null }
	},
	fragmentShader: ['precision highp float;', 'varying vec2 vUV;', 'uniform sampler2D u_displacementMap;', 'uniform float u_resolution;', 'uniform float u_size;', 'void main (void) {', 'float texel = 1.0 / u_resolution;', 'float texelSize = u_size / u_resolution;', 'vec3 center = texture2D(u_displacementMap, vUV).rgb;', 'vec3 right = vec3(texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(texel, 0.0)).rgb - center;', 'vec3 left = vec3(-texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(-texel, 0.0)).rgb - center;', 'vec3 top = vec3(0.0, 0.0, -texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, -texel)).rgb - center;', 'vec3 bottom = vec3(0.0, 0.0, texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, texel)).rgb - center;', 'vec3 topRight = cross(right, top);', 'vec3 topLeft = cross(top, left);', 'vec3 bottomLeft = cross(left, bottom);', 'vec3 bottomRight = cross(bottom, right);', 'gl_FragColor = vec4(normalize(topRight + topLeft + bottomLeft + bottomRight), 1.0);', '}'].join('\n')
};
THREE.ShaderLib['ocean_main'] = {
	uniforms: {
		"u_displacementMap": { value: null },
		"u_normalMap": { value: null },
		"u_geometrySize": { value: null },
		"u_size": { value: null },
		"u_projectionMatrix": { value: null },
		"u_viewMatrix": { value: null },
		"u_cameraPosition": { value: null },
		"u_skyColor": { value: null },
		"u_oceanColor": { value: null },
		"u_sunDirection": { value: null },
		"u_exposure": { value: null }
	},
	vertexShader: ['precision highp float;', 'varying vec3 vPos;', 'varying vec2 vUV;', 'uniform mat4 u_projectionMatrix;', 'uniform mat4 u_viewMatrix;', 'uniform float u_size;', 'uniform float u_geometrySize;', 'uniform sampler2D u_displacementMap;', 'void main (void) {', 'vec3 newPos = position + texture2D(u_displacementMap, uv).rgb * (u_geometrySize / u_size);', 'vPos = newPos;', 'vUV = uv;', 'gl_Position = u_projectionMatrix * u_viewMatrix * vec4(newPos, 1.0);', '}'].join('\n'),
	fragmentShader: ['precision highp float;', 'varying vec3 vPos;', 'varying vec2 vUV;', 'uniform sampler2D u_displacementMap;', 'uniform sampler2D u_normalMap;', 'uniform vec3 u_cameraPosition;', 'uniform vec3 u_oceanColor;', 'uniform vec3 u_skyColor;', 'uniform vec3 u_sunDirection;', 'uniform float u_exposure;', 'vec3 hdr (vec3 color, float exposure) {', 'return 1.0 - exp(-color * exposure);', '}', 'void main (void) {', 'vec3 normal = texture2D(u_normalMap, vUV).rgb;', 'vec3 view = normalize(u_cameraPosition - vPos);', 'float fresnel = 0.02 + 0.98 * pow(1.0 - dot(normal, view), 5.0);', 'vec3 sky = fresnel * u_skyColor;', 'float diffuse = clamp(dot(normal, normalize(u_sunDirection)), 0.0, 1.0);', 'vec3 water = (1.0 - fresnel) * u_oceanColor * u_skyColor * diffuse;', 'vec3 color = sky + water;', 'gl_FragColor = vec4(hdr(color, u_exposure), 1.0);', '}'].join('\n')
};

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
// Parallax Occlusion shaders from
//    http://sunandblackcat.com/tipFullView.php?topicid=28
// No tangent-space transforms logic based on
//   http://mmikkelsen3d.blogspot.sk/2012/02/parallaxpoc-mapping-and-no-tangent.html

var ParallaxShader = {
	// Ordered from fastest to best quality.
	modes: {
		none: 'NO_PARALLAX',
		basic: 'USE_BASIC_PARALLAX',
		steep: 'USE_STEEP_PARALLAX',
		occlusion: 'USE_OCLUSION_PARALLAX', // a.k.a. POM
		relief: 'USE_RELIEF_PARALLAX'
	},

	uniforms: {
		"bumpMap": { value: null },
		"map": { value: null },
		"parallaxScale": { value: null },
		"parallaxMinLayers": { value: null },
		"parallaxMaxLayers": { value: null }
	},

	vertexShader: ["varying vec2 vUv;", "varying vec3 vViewPosition;", "varying vec3 vNormal;", "void main() {", "vUv = uv;", "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "vViewPosition = -mvPosition.xyz;", "vNormal = normalize( normalMatrix * normal );", "gl_Position = projectionMatrix * mvPosition;", "}"].join("\n"),

	fragmentShader: ["uniform sampler2D bumpMap;", "uniform sampler2D map;", "uniform float parallaxScale;", "uniform float parallaxMinLayers;", "uniform float parallaxMaxLayers;", "varying vec2 vUv;", "varying vec3 vViewPosition;", "varying vec3 vNormal;", "#ifdef USE_BASIC_PARALLAX", "vec2 parallaxMap( in vec3 V ) {", "float initialHeight = texture2D( bumpMap, vUv ).r;",

	// No Offset Limitting: messy, floating output at grazing angles.
	//"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;",

	// Offset Limiting
	"vec2 texCoordOffset = parallaxScale * V.xy * initialHeight;", "return vUv - texCoordOffset;", "}", "#else", "vec2 parallaxMap( in vec3 V ) {",

	// Determine number of layers from angle between V and N
	"float numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );", "float layerHeight = 1.0 / numLayers;", "float currentLayerHeight = 0.0;",
	// Shift of texture coordinates for each iteration
	"vec2 dtex = parallaxScale * V.xy / V.z / numLayers;", "vec2 currentTextureCoords = vUv;", "float heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;",

	// while ( heightFromTexture > currentLayerHeight )
	// Infinite loops are not well supported. Do a "large" finite
	// loop, but not too large, as it slows down some compilers.
	"for ( int i = 0; i < 30; i += 1 ) {", "if ( heightFromTexture <= currentLayerHeight ) {", "break;", "}", "currentLayerHeight += layerHeight;",
	// Shift texture coordinates along vector V
	"currentTextureCoords -= dtex;", "heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;", "}", "#ifdef USE_STEEP_PARALLAX", "return currentTextureCoords;", "#elif defined( USE_RELIEF_PARALLAX )", "vec2 deltaTexCoord = dtex / 2.0;", "float deltaHeight = layerHeight / 2.0;",

	// Return to the mid point of previous layer
	"currentTextureCoords += deltaTexCoord;", "currentLayerHeight -= deltaHeight;",

	// Binary search to increase precision of Steep Parallax Mapping
	"const int numSearches = 5;", "for ( int i = 0; i < numSearches; i += 1 ) {", "deltaTexCoord /= 2.0;", "deltaHeight /= 2.0;", "heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;",
	// Shift along or against vector V
	"if( heightFromTexture > currentLayerHeight ) {", // Below the surface

	"currentTextureCoords -= deltaTexCoord;", "currentLayerHeight += deltaHeight;", "} else {", // above the surface

	"currentTextureCoords += deltaTexCoord;", "currentLayerHeight -= deltaHeight;", "}", "}", "return currentTextureCoords;", "#elif defined( USE_OCLUSION_PARALLAX )", "vec2 prevTCoords = currentTextureCoords + dtex;",

	// Heights for linear interpolation
	"float nextH = heightFromTexture - currentLayerHeight;", "float prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;",

	// Proportions for linear interpolation
	"float weight = nextH / ( nextH - prevH );",

	// Interpolation of texture coordinates
	"return prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );", "#else", // NO_PARALLAX

	"return vUv;", "#endif", "}", "#endif", "vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {", "vec2 texDx = dFdx( vUv );", "vec2 texDy = dFdy( vUv );", "vec3 vSigmaX = dFdx( surfPosition );", "vec3 vSigmaY = dFdy( surfPosition );", "vec3 vR1 = cross( vSigmaY, surfNormal );", "vec3 vR2 = cross( surfNormal, vSigmaX );", "float fDet = dot( vSigmaX, vR1 );", "vec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );", "vec3 vProjVtex;", "vProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;", "vProjVtex.z = dot( surfNormal, viewPosition );", "return parallaxMap( vProjVtex );", "}", "void main() {", "vec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );", "gl_FragColor = texture2D( map, mapUv );", "}"].join("\n")

};

exports.default = ParallaxShader;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author wongbryan / http://wongbryan.github.io
 *
 * Pixelation shader
 */

var PixelShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"resolution": { value: null },
		"pixelSize": { value: 1. }

	},

	vertexShader: ["varying highp vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float pixelSize;", "uniform vec2 resolution;", "varying highp vec2 vUv;", "void main(){", "vec2 dxy = pixelSize / resolution;", "vec2 coord = dxy * floor( vUv / dxy );", "gl_FragColor = texture2D(tDiffuse, coord);", "}"].join("\n")
};

exports.default = PixelShader;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author felixturner / http://airtight.cc/
 *
 * RGB Shift Shader
 * Shifts red and blue channels from center in opposite directions
 * Ported from http://kriss.cx/tom/2009/05/rgb-shift/
 * by Tom Butterworth / http://kriss.cx/tom/
 *
 * amount: shift distance (1 is width of input)
 * angle: shift angle in radians
 */

var RGBShiftShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"amount": { value: 0.005 },
		"angle": { value: 0.0 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float amount;", "uniform float angle;", "varying vec2 vUv;", "void main() {", "vec2 offset = amount * vec2( cos(angle), sin(angle));", "vec4 cr = texture2D(tDiffuse, vUv + offset);", "vec4 cga = texture2D(tDiffuse, vUv);", "vec4 cb = texture2D(tDiffuse, vUv - offset);", "gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);", "}"].join("\n")

};

exports.default = RGBShiftShader;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Sepia tone shader
 * based on glfx.js sepia shader
 * https://github.com/evanw/glfx.js
 */

var SepiaShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"amount": { value: 1.0 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform float amount;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 color = texture2D( tDiffuse, vUv );", "vec3 c = color.rgb;", "color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );", "color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );", "color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );", "gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );", "}"].join("\n")

};

exports.default = SepiaShader;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Sobel Edge Detection (see https://youtu.be/uihBwtPIBxM)
 *
 * As mentioned in the video the Sobel operator expects a grayscale image as input.
 *
 */

var SobelOperatorShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"resolution": { value: new THREE.Vector2() }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform sampler2D tDiffuse;", "uniform vec2 resolution;", "varying vec2 vUv;", "void main() {", "vec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );",

	// kernel definition (in glsl matrices are filled in column-major order)

	"const mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 );", // x direction kernel
	"const mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 );", // y direction kernel

	// fetch the 3x3 neighbourhood of a fragment

	// first column

	"float tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;", "float tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;", "float tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;",

	// second column

	"float tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;", "float tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;", "float tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;",

	// third column

	"float tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;", "float tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;", "float tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;",

	// gradient value in x direction

	"float valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 + ", "Gx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 + ", "Gx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2; ",

	// gradient value in y direction

	"float valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 + ", "Gy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 + ", "Gy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2; ",

	// magnitute of the total gradient

	"float G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );", "gl_FragColor = vec4( vec3( G ), 1 );", "}"].join("\n")

};

exports.default = SobelOperatorShader;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author flimshaw / http://charliehoey.com
 *
 * Technicolor Shader
 * Simulates the look of the two-strip technicolor process popular in early 20th century films.
 * More historical info here: http://www.widescreenmuseum.com/oldcolor/technicolor1.htm
 * Demo here: http://charliehoey.com/technicolor_shader/shader_test.html
 */

var TechnicolorShader = {

	uniforms: {

		"tDiffuse": { value: null }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );", "vec4 newTex = vec4(tex.r, (tex.g + tex.b) * .5, (tex.g + tex.b) * .5, 1.0);", "gl_FragColor = newTex;", "}"].join("\n")

};

exports.default = TechnicolorShader;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(0);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Triangle blur shader
 * based on glfx.js triangle blur shader
 * https://github.com/evanw/glfx.js
 *
 * A basic blur filter, which convolves the image with a
 * pyramid filter. The pyramid filter is separable and is applied as two
 * perpendicular triangle filters.
 */

var TriangleBlurShader = {

	uniforms: {

		"texture": { value: null },
		"delta": { value: new THREE.Vector2(1, 1) }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["#include <common>", "#define ITERATIONS 10.0", "uniform sampler2D texture;", "uniform vec2 delta;", "varying vec2 vUv;", "void main() {", "vec4 color = vec4( 0.0 );", "float total = 0.0;",

	// randomize the lookup values to hide the fixed number of samples

	"float offset = rand( vUv );", "for ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {", "float percent = ( t + offset - 0.5 ) / ITERATIONS;", "float weight = 1.0 - abs( percent );", "color += texture2D( texture, vUv + delta * percent ) * weight;", "total += weight;", "}", "gl_FragColor = color / total;", "}"].join("\n")

};

exports.default = TriangleBlurShader;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Two pass Gaussian blur filter (horizontal and vertical blur shaders)
 * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/
 *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html
 *
 * - 9 samples per pass
 * - standard deviation 2.7
 * - "h" and "v" parameters should be set to "1 / width" and "1 / height"
 */

var VerticalBlurShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"v": { value: 1.0 / 512.0 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float v;", "varying vec2 vUv;", "void main() {", "vec4 sum = vec4( 0.0 );", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;", "gl_FragColor = sum;", "}"].join("\n")

};

exports.default = VerticalBlurShader;

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position
 *
 * - 9 samples per pass
 * - standard deviation 2.7
 * - "h" and "v" parameters should be set to "1 / width" and "1 / height"
 * - "r" parameter control where "focused" horizontal line lies
 */

var VerticalTiltShiftShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"v": { value: 1.0 / 512.0 },
		"r": { value: 0.35 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float v;", "uniform float r;", "varying vec2 vUv;", "void main() {", "vec4 sum = vec4( 0.0 );", "float vv = v * abs( r - vUv.y );", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * vv ) ) * 0.051;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * vv ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * vv ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * vv ) ) * 0.1531;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * vv ) ) * 0.1531;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * vv ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * vv ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * vv ) ) * 0.051;", "gl_FragColor = sum;", "}"].join("\n")

};

exports.default = VerticalTiltShiftShader;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Vignette shader
 * based on PaintEffect postprocess from ro.me
 * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js
 */

var VignetteShader = {

	uniforms: {

		"tDiffuse": { value: null },
		"offset": { value: 1.0 },
		"darkness": { value: 1.0 }

	},

	vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),

	fragmentShader: ["uniform float offset;", "uniform float darkness;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {",

	// Eskil's vignette

	"vec4 texel = texture2D( tDiffuse, vUv );", "vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );", "gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );",

	/*
 // alternative version from glfx.js
 // this one makes more "dusty" look (as opposed to "burned")
 	"vec4 color = texture2D( tDiffuse, vUv );",
 "float dist = distance( vUv, vec2( 0.5 ) );",
 "color.rgb *= smoothstep( 0.8, offset * 0.799, dist *( darkness + offset ) );",
 "gl_FragColor = color;",
 */

	"}"].join("\n")

};

exports.default = VignetteShader;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/**
 * @author Mugen87 / https://github.com/Mugen87
 *
 */

var WaterRefractionShader = {

	uniforms: {

		'color': {
			type: 'c',
			value: null
		},

		'time': {
			type: 'f',
			value: 0
		},

		'tDiffuse': {
			type: 't',
			value: null
		},

		'tDudv': {
			type: 't',
			value: null
		},

		'textureMatrix': {
			type: 'm4',
			value: null
		}

	},

	vertexShader: ['uniform mat4 textureMatrix;', 'varying vec2 vUv;', 'varying vec4 vUvRefraction;', 'void main() {', '	vUv = uv;', '	vUvRefraction = textureMatrix * vec4( position, 1.0 );', '	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\n'),

	fragmentShader: ['uniform vec3 color;', 'uniform float time;', 'uniform sampler2D tDiffuse;', 'uniform sampler2D tDudv;', 'varying vec2 vUv;', 'varying vec4 vUvRefraction;', 'float blendOverlay( float base, float blend ) {', '	return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );', '}', 'vec3 blendOverlay( vec3 base, vec3 blend ) {', '	return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ),blendOverlay( base.b, blend.b ) );', '}', 'void main() {', ' float waveStrength = 0.1;', ' float waveSpeed = 0.03;',

	// simple distortion (ripple) via dudv map (see https://www.youtube.com/watch?v=6B7IF6GOu7s)

	'	vec2 distortedUv = texture2D( tDudv, vec2( vUv.x + time * waveSpeed, vUv.y ) ).rg * waveStrength;', '	distortedUv = vUv.xy + vec2( distortedUv.x, distortedUv.y + time * waveSpeed );', '	vec2 distortion = ( texture2D( tDudv, distortedUv ).rg * 2.0 - 1.0 ) * waveStrength;',

	// new uv coords

	' vec4 uv = vec4( vUvRefraction );', ' uv.xy += distortion;', '	vec4 base = texture2DProj( tDiffuse, uv );', '	gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );', '}'].join('\n')
};

exports.default = WaterRefractionShader;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Volume = undefined;

var _Volume = __webpack_require__(10);

var _Volume2 = _interopRequireDefault(_Volume);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.Volume = _Volume2.default;

/***/ })
/******/ ])));